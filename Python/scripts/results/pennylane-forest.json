[
    {
        "functionName": "test_identity_expectation",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that identity expectation value (i.e. the trace) is 1\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-qvm', shots=shots)\nO1 = qml.expval(qml.Identity(wires=[0]))\nO2 = qml.expval(qml.Identity(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0]), qml.RX(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])], [O1, O2], dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\nself.assertAllAlmostEqual(res, np.array([1, 1]), delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_pauliz_expectation",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that PauliZ expectation value is correct\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-qvm', shots=shots)\nO1 = qml.expval(qml.PauliZ(wires=[0]))\nO2 = qml.expval(qml.PauliZ(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0]), qml.RX(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\nself.assertAllAlmostEqual(res, np.array([np.cos(theta), np.cos(theta) * np.\n    cos(phi)]), delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_paulix_expectation",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that PauliX expectation value is correct\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-qvm', shots=shots)\nO1 = qml.expval(qml.PauliX(wires=[0]))\nO2 = qml.expval(qml.PauliX(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RY(theta, wires=[0]), qml.RY(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\nself.assertAllAlmostEqual(res, np.array([np.sin(theta) * np.sin(phi), np.\n    sin(phi)]), delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_pauliy_expectation",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that PauliY expectation value is correct\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-qvm', shots=shots)\nO1 = qml.expval(qml.PauliY(wires=[0]))\nO2 = qml.expval(qml.PauliY(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0]), qml.RX(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\nself.assertAllAlmostEqual(res, np.array([0, -np.cos(theta) * np.sin(phi)]),\n    delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_hadamard_expectation",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that Hadamard expectation value is correct\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-qvm', shots=shots)\nO1 = qml.expval(qml.Hadamard(wires=[0]))\nO2 = qml.expval(qml.Hadamard(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RY(theta, wires=[0]), qml.RY(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\nexpected = np.array([np.sin(theta) * np.sin(phi) + np.cos(theta), np.cos(\n    theta) * np.cos(phi) + np.sin(phi)]) / np.sqrt(2)\nself.assertAllAlmostEqual(res, expected, delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_hermitian_expectation",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that arbitrary Hermitian expectation values are correct.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-qvm', shots=shots)\nO1 = qml.expval(qml.Hermitian(H, wires=[0]))\nO2 = qml.expval(qml.Hermitian(H, wires=[1]))\ncircuit_graph = CircuitGraph([qml.RY(theta, wires=[0]), qml.RY(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\na = H[0, 0]\nre_b = H[0, 1].real\nd = H[1, 1]\nev1 = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d\n    ) / 2\nev2 = ((a - d) * np.cos(theta) * np.cos(phi) + 2 * re_b * np.sin(phi) + a + d\n    ) / 2\nexpected = np.array([ev1, ev2])\nself.assertAllAlmostEqual(res, expected, delta=4 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_multi_qubit_hermitian_expectation",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that arbitrary multi-qubit Hermitian expectation values are correct\"\"\"\ntheta = 0.432\nphi = 0.123\nA = np.array([[-6, 2 + 1.0j, -3, -5 + 2.0j], [2 - 1.0j, 0, 2 - 1.0j, -5 + \n    4.0j], [-3, 2 + 1.0j, 0, -4 + 3.0j], [-5 - 2.0j, -5 - 4.0j, -4 - 3.0j, -6]]\n    )\ndev = plf.QVMDevice(device='2q-qvm', shots=10 * shots)\nO1 = qml.expval(qml.Hermitian(A, wires=[0, 1]))\ncircuit_graph = CircuitGraph([qml.RY(theta, wires=[0]), qml.RY(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1)])\nexpected = 0.5 * (6 * np.cos(theta) * np.sin(phi) - np.sin(theta) * (8 * np\n    .sin(phi) + 7 * np.cos(phi) + 3) - 2 * np.sin(phi) - 6 * np.cos(phi) - 6)\nself.assertAllAlmostEqual(res, expected, delta=5 / np.sqrt(shots))\n",
        "CUT_1": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_var",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for variance calculation\"\"\"\ndev = plf.QVMDevice(device='2q-qvm', shots=shots)\nphi = 0.543\ntheta = 0.6543\nO1 = qml.var(qml.PauliZ(wires=[0]))\ncircuit_graph = CircuitGraph([qml.RX(phi, wires=[0]), qml.RY(theta, wires=[\n    0])] + [O1], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nvar = np.array([dev.var(O1)])\nexpected = 0.25 * (3 - np.cos(2 * theta) - 2 * np.cos(theta) ** 2 * np.cos(\n    2 * phi))\nself.assertAlmostEqual(var, expected, delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_var_hermitian",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for variance calculation using an arbitrary Hermitian observable\"\"\"\ndev = plf.QVMDevice(device='2q-qvm', shots=100 * shots)\nphi = 0.543\ntheta = 0.6543\nA = np.array([[4, -1 + 6.0j], [-1 - 6.0j, 2]])\nO1 = qml.var(qml.Hermitian(A, wires=[0]))\ncircuit_graph = CircuitGraph([qml.RX(phi, wires=[0]), qml.RY(theta, wires=[\n    0])] + [O1], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nvar = np.array([dev.var(O1)])\nexpected = 0.5 * (2 * np.sin(2 * theta) * np.cos(phi) ** 2 + 24 * np.sin(\n    phi) * np.cos(phi) * (np.sin(theta) - np.cos(theta)) + 35 * np.cos(2 *\n    phi) + 39)\nself.assertAlmostEqual(var, expected, delta=0.3)\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_apply",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the application of gates\"\"\"\ndev = plf.QVMDevice(device='3q-qvm', shots=shots)\ntry:\n    op = getattr(qml.ops, gate)\nexcept AttributeError:\n    op = getattr(plf, gate)\nw = list(range(op.num_wires))\nobs = qml.expval(qml.PauliZ(0))\nif op.par_domain == 'A':\n    if gate == 'QubitUnitary':\n        p = np.array(U)\n        w = [0]\n        state = apply_unitary(U, 3)\n    elif gate == 'BasisState':\n        p = np.array([1, 1, 1])\n        state = np.array([0, 0, 0, 0, 0, 0, 0, 1])\n        w = list(range(dev.num_wires))\n    circuit_graph = CircuitGraph([op(p, wires=w)] + [obs], {}, dev.wires)\nelse:\n    p = [0.432423, 2, 0.324][:op.num_params]\n    fn = test_operation_map[gate]\n    if callable(fn):\n        O = fn(*p)\n    else:\n        O = fn\n    state = apply_unitary(O, 3)\n    if p:\n        circuit_graph = CircuitGraph([op(*p, wires=w)] + [obs], {}, dev.wires)\n    else:\n        circuit_graph = CircuitGraph([op(wires=w)] + [obs], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = dev.expval(obs)\nexpected = np.vdot(state, np.kron(np.kron(Z, I), I) @ state)\nself.assertAllAlmostEqual(res, expected, delta=3 / np.sqrt(shots))\npytest.mark.parametrize('gate', plf.QVMDevice._operation_map)",
        "CUT_1": "\"\"\"Return the matrix associated with the controlled operation.\n\n    Args:\n        op (np.array): Array representing the operation\n                       that should be controlled\n\n    Returns:\n        np.array: Array representing the controlled operations. If the input\n        array has shape (N, N) the output shape is (2*N, 2*N).\n    \"\"\"\nreturn _direct_sum(np.eye(op.shape[0], dtype=op.dtype), op)\n",
        "CUT_2": "\"\"\"Return the matrix associated with the controlled operation.\n\n    Args:\n        op (np.array): Array representing the operation\n                       that should be controlled\n\n    Returns:\n        np.array: Array representing the controlled operations. If the input\n        array has shape (N, N) the output shape is (2*N, 2*N).\n    \"\"\"\nreturn _direct_sum(np.eye(op.shape[0], dtype=op.dtype), op)\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "\"\"\"Determine if the given gate was defined in the pyquil Program.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate that shall be checked\n\n        Returns:\n            bool: True if the gate is defined, False otherwise\n        \"\"\"\nreturn gate.name in self._defined_gate_names\n"
    },
    {
        "functionName": "test_sample_values",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests if the samples returned by sample have\n        the correct values\n        \"\"\"\ndev = plf.QVMDevice(device='1q-qvm', shots=10)\nO1 = qml.expval(qml.PauliZ(wires=[0]))\ncircuit_graph = CircuitGraph([qml.RX(1.5708, wires=[0])] + [O1], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\ns1 = dev.sample(O1)\nself.assertAllAlmostEqual(s1 ** 2, 1, delta=tol)\nself.assertAllAlmostEqual(s1, 1 - 2 * dev._samples[:, (0)], delta=tol)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_sample_values_hermitian",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests if the samples of a Hermitian observable returned by sample have\n        the correct values\n        \"\"\"\ntheta = 0.543\nshots = 1000000\nA = np.array([[1, 2.0j], [-2.0j, 0]])\ndev = plf.QVMDevice(device='1q-qvm', shots=shots)\nO1 = qml.sample(qml.Hermitian(A, wires=[0]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0])] + [O1], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\ns1 = dev.sample(O1)\neigvals = np.linalg.eigvalsh(A)\nassert np.allclose(sorted(list(set(s1))), sorted(eigvals), atol=tol, rtol=0)\nassert np.allclose(np.mean(s1), 2 * np.sin(theta) + 0.5 * np.cos(theta) + \n    0.5, atol=0.1, rtol=0)\nassert np.allclose(np.var(s1), 0.25 * (np.sin(theta) - 4 * np.cos(theta)) **\n    2, atol=0.1, rtol=0)\n",
        "CUT_1": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_2": "\"\"\"\n        Like assertAlmostEqual, but works with arrays. All the corresponding elements have to be almost equal.\n        \"\"\"\nif isinstance(first, tuple):\n    if np.all([np.all(first[idx] == second[idx]) for idx, _ in enumerate(\n        first)]):\n        return\n    if np.all([(np.all(np.abs(first[idx] - second[idx])) <= delta) for idx,\n        _ in enumerate(first)]):\n        return\nelse:\n    if np.all(first == second):\n        return\n    if np.all(np.abs(first - second) <= delta):\n        return\nassert False, '{} != {} within {} delta'.format(first, second, delta)\n",
        "CUT_3": "\"\"\"Return the direct sums of two arrays.\n\n    Args:\n        A (np.array): The first array (upper left array)\n        B (np.array): The second array (lower right array)\n\n    Returns:\n        np.array: The direct sum of the two input arrays\n    \"\"\"\nsum_matrix = np.zeros(np.add(A.shape, B.shape), dtype=A.dtype)\nsum_matrix[:A.shape[0], :A.shape[1]] = A\nsum_matrix[A.shape[0]:, A.shape[1]:] = B\nreturn sum_matrix\n",
        "CUT_4": "\"\"\"Return the direct sums of two arrays.\n\n    Args:\n        A (np.array): The first array (upper left array)\n        B (np.array): The second array (lower right array)\n\n    Returns:\n        np.array: The direct sum of the two input arrays\n    \"\"\"\nsum_matrix = np.zeros(np.add(A.shape, B.shape), dtype=A.dtype)\nsum_matrix[:A.shape[0], :A.shape[1]] = A\nsum_matrix[A.shape[0]:, A.shape[1]:] = B\nreturn sum_matrix\n",
        "CUT_5": "\"\"\"Applies a unitary to the first wire of a register in the ground state\n\n        Args:\n            mat (array): unitary matrix\n            num_wires (n): number of wires in the register\n        \"\"\"\nN = mat.shape[0]\ninit_state = np.zeros(N)\ninit_state[0] = 1\nresult = mat @ init_state\nfor _ in range(num_wires - int(np.log2(N))):\n    result = np.kron(result, np.array([1, 0]))\nreturn result\n"
    },
    {
        "functionName": "test_sample_values_hermitian_multi_qubit",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests if the samples of a multi-qubit Hermitian observable returned by sample have\n        the correct values\n        \"\"\"\ntheta = 0.543\nshots = 100000\nA = np.array([[1, 2.0j, 1 - 2.0j, 0.5j], [-2.0j, 0, 3 + 4.0j, 1], [1 + 2.0j,\n    3 - 4.0j, 0.75, 1.5 - 2.0j], [-0.5j, 1, 1.5 + 2.0j, -1]])\ndev = plf.QVMDevice(device='2q-qvm', shots=shots)\nO1 = qml.sample(qml.Hermitian(A, wires=[0, 1]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0]), qml.RY(2 * theta,\n    wires=[1]), qml.CNOT(wires=[0, 1])] + [O1], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\ns1 = dev.sample(O1)\neigvals = np.linalg.eigvalsh(A)\nassert np.allclose(sorted(list(set(s1))), sorted(eigvals), atol=tol, rtol=0)\nexpected = (88 * np.sin(theta) + 24 * np.sin(2 * theta) - 40 * np.sin(3 *\n    theta) + 5 * np.cos(theta) - 6 * np.cos(2 * theta) + 27 * np.cos(3 *\n    theta) + 6) / 32\nassert np.allclose(np.mean(s1), expected, atol=0.1, rtol=0)\n",
        "CUT_1": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_wires_argument",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wires argument gets processed correctly.\"\"\"\ndev_no_wires = plf.QVMDevice(device='2q-qvm', shots=5)\nassert dev_no_wires.wires == Wires(range(2))\nwith pytest.raises(ValueError, match='Device has a fixed number of'):\n    plf.QVMDevice(device='2q-qvm', shots=5, wires=1000)\ndev_iterable_wires = plf.QVMDevice(device='2q-qvm', shots=5, wires=range(2))\nassert dev_iterable_wires.wires == Wires(range(2))\nwith pytest.raises(ValueError, match='Device has a fixed number of'):\n    plf.QVMDevice(device='2q-qvm', shots=5, wires=range(1000))\n",
        "CUT_1": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_2": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_3": "try:\n    qvm = QVMConnection(random_seed=52)\n    qvm.run(Program(Id(0)), [])\n    return qvm\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires QVM connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_raise_error_if_shots_is_not_positive",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that instantiating a QVMDevice if the number of shots is not a postivie\n        integer raises an error\"\"\"\nwith pytest.raises(ValueError, match=\n    'Number of shots must be a positive integer.'):\n    dev = plf.QVMDevice(device='2q-qvm', shots=shots)\npytest.mark.parametrize('shots', list(range(0, -10, -1)))",
        "CUT_1": "\"\"\"default shots\"\"\"\nreturn QVM_SHOTS\npytest.fixture",
        "CUT_2": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_3": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n"
    },
    {
        "functionName": "test_raise_error_if_analytic_true",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that instantiating a QVMDevice in analytic=True mode raises an error\"\"\"\nwith pytest.raises(ValueError, match=\n    'QVM device cannot be run in analytic=True mode.'):\n    dev = plf.QVMDevice(device='2q-qvm', shots=shots, analytic=True)\n",
        "CUT_1": "super().__init__(wires, shots, analytic=analytic)\nself.analytic = analytic\nself.reset()\n",
        "CUT_2": "super().__init__(wires, shots, analytic=analytic)\nself.analytic = analytic\nself.reset()\n",
        "CUT_3": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "try:\n    qvm = QVMConnection(random_seed=52)\n    qvm.run(Program(Id(0)), [])\n    return qvm\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires QVM connection: {}'.format(e))\npytest.fixture(scope='session')"
    },
    {
        "functionName": "test_timeout_set_correctly",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the timeout attrbiute for the QuantumComputer stored by the QVMDevice\n        is set correctly when passing a value as keyword argument\"\"\"\ndev = plf.QVMDevice(device=device, shots=shots, timeout=100)\nassert dev.qc.compiler.client.timeout == 100\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_2": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_3": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n"
    },
    {
        "functionName": "test_timeout_default",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the timeout attrbiute for the QuantumComputer stored by the QVMDevice\n        is set correctly when passing a value as keyword argument\"\"\"\ndev = plf.QVMDevice(device=device, shots=shots)\nqc = pyquil.get_qc(device, as_qvm=True)\nassert dev.qc.compiler.client.timeout == qc.compiler.client.timeout\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_2": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_3": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n"
    },
    {
        "functionName": "test_compiled_program_stored",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that QVM device stores the latest compiled program.\"\"\"\ndev = qml.device('forest.qvm', device='2q-qvm')\ndev.compiled_program is None\ntheta = 0.432\nphi = 0.123\nO1 = qml.expval(qml.Identity(wires=[0]))\nO2 = qml.expval(qml.Identity(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0]), qml.RX(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])], [O1, O2], dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev.generate_samples()\ndev.compiled_program is not None\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_stored_compiled_program_correct",
        "className": "TestQVMBasic",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that QVM device stores the latest compiled program.\"\"\"\ndev = qml.device('forest.qvm', device='2q-qvm')\ndev.compiled_program is None\ntheta = 0.432\nO1 = qml.expval(qml.PauliZ(wires=[0]))\ncircuit_graph = CircuitGraph([qml.RZ(theta, wires=[0]), qml.CZ(wires=[0, 1]\n    )], [O1], dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev.generate_samples()\ndev.compiled_program.program == compiled_program\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_compiled_program_was_stored_in_dict",
        "className": "TestParametricCompilation",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that QVM device stores the compiled program correctly in a dictionary\"\"\"\ndev = qml.device('forest.qvm', device='2q-qvm')\ntheta = 0.432\nphi = 0.123\nO1 = qml.expval(qml.Identity(wires=[0]))\nO2 = qml.expval(qml.Identity(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0]), qml.RX(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])], [O1, O2], dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._circuit_hash = circuit_graph.hash\ncall_history = []\nwith monkeypatch.context() as m:\n    m.setattr(QuantumComputer, 'compile', lambda self, prog: call_history.\n        append(prog))\n    m.setattr(QuantumComputer, 'run', lambda self, **kwargs: None)\n    dev.generate_samples()\nassert dev.circuit_hash in dev._compiled_program_dict\nassert len(dev._compiled_program_dict.items()) == 1\nassert len(call_history) == 1\nfor i in range(6):\n    with monkeypatch.context() as m:\n        m.setattr(QuantumComputer, 'compile', lambda self, prog:\n            call_history.append(prog))\n        m.setattr(QuantumComputer, 'run', lambda self, **kwargs: None)\n        dev.generate_samples()\n    assert dev.circuit_hash in dev._compiled_program_dict\n    assert len(dev._compiled_program_dict.items()) == 1\n    assert len(call_history) == 1\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_circuit_hash_none_no_compiled_program_was_stored_in_dict",
        "className": "TestParametricCompilation",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that QVM device does not store the compiled program in a dictionary if the\n        _circuit_hash attribute is None\"\"\"\ndev = qml.device('forest.qvm', device='2q-qvm')\ntheta = 0.432\nphi = 0.123\nO1 = qml.expval(qml.Identity(wires=[0]))\nO2 = qml.expval(qml.Identity(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0]), qml.RX(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])], [O1, O2], dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._circuit_hash = None\ncall_history = []\nwith monkeypatch.context() as m:\n    m.setattr(QuantumComputer, 'compile', lambda self, prog: call_history.\n        append(prog))\n    m.setattr(QuantumComputer, 'run', lambda self, **kwargs: None)\n    dev.generate_samples()\nassert dev.circuit_hash is None\nassert len(dev._compiled_program_dict.items()) == 0\nassert len(call_history) == 1\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_parametric_compilation_with_numeric_and_symbolic_queue",
        "className": "TestParametricCompilation",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests that a program containing numeric and symbolic variables as well is only compiled once.\"\"\"\nVariable.positional_arg_values = {}\ndev = qml.device('forest.qvm', device='2q-qvm', timeout=100)\ndev._circuit_hash = None\nnumber_of_runs = 10\nfirst = True\ncall_history = []\nfor run_idx in range(number_of_runs):\n    Variable.positional_arg_values[1] = 0.232 * run_idx\n    Variable.positional_arg_values[2] = 0.8764 * run_idx\n    circuit_graph = CircuitGraph(queue, observable_queue, dev.wires)\n    dev.apply(circuit_graph.operations, rotations=circuit_graph.\n        diagonalizing_gates)\n    if first:\n        dev._circuit_hash = circuit_graph.hash\n        first = False\n    else:\n        assert dev._circuit_hash == circuit_graph.hash\n    with monkeypatch.context() as m:\n        m.setattr(QuantumComputer, 'compile', lambda self, prog:\n            call_history.append(prog))\n        m.setattr(QuantumComputer, 'run', lambda self, **kwargs: None)\n        dev.generate_samples()\nassert len(dev._compiled_program_dict.items()) == 1\nassert len(call_history) == 1\npytest.mark.parametrize('queue, observable_queue', multiple_symbolic_queue)",
        "CUT_1": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_2": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_3": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_4": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_5": "\"\"\"Replaces unittest TestCase.assertTrue\"\"\"\nassert first\n"
    },
    {
        "functionName": "test_apply_basis_state_raises_an_error_if_not_first",
        "className": "TestParametricCompilation",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that there is an error raised when the BasisState is not\n        applied as the first operation.\"\"\"\ndev = qml.device('forest.qvm', device='3q-qvm', parametric_compilation=True)\noperation = qml.BasisState(np.array([1, 0, 0]), wires=list(range(3)))\nqueue = [qml.PauliX(0), operation]\nwith pytest.raises(qml.DeviceError, match=\n    'Operation {} cannot be used after other Operations have already been applied'\n    .format(operation.name)):\n    dev.apply(queue)\n",
        "CUT_1": "rotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    par = operation.parameters\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_2": "rotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    par = operation.parameters\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_3": "\"\"\"Applies a parametric program by applying parametric\n        operation with symbolic parameters.\n        \"\"\"\nrotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    par = []\n    for param in operation.data:\n        if isinstance(param, Variable):\n            parameter_string = 'theta' + str(param.idx)\n            if parameter_string not in self._parameter_reference_map:\n                current_ref = self.prog.declare(parameter_string, 'REAL')\n                self._parameter_reference_map[parameter_string] = current_ref\n            self._parameter_map[parameter_string] = [param.val]\n            par.append(self._parameter_reference_map[parameter_string])\n        else:\n            par.append(param)\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_4": "\"\"\"Applies a parametric program by applying parametric\n        operation with symbolic parameters.\n        \"\"\"\nrotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    par = []\n    for param in operation.data:\n        if isinstance(param, Variable):\n            parameter_string = 'theta' + str(param.idx)\n            if parameter_string not in self._parameter_reference_map:\n                current_ref = self.prog.declare(parameter_string, 'REAL')\n                self._parameter_reference_map[parameter_string] = current_ref\n            self._parameter_map[parameter_string] = [param.val]\n            par.append(self._parameter_reference_map[parameter_string])\n        else:\n            par.append(param)\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_5": "\"\"\"Apply the circuit rotations.\n\n        This method serves as an auxiliary method to :meth:`~.ForestDevice.apply`.\n\n        Args:\n            rotations (List[pennylane.Operation]): operations that rotate into the\n                measurement basis\n\n        Returns:\n            pyquil.Program: the pyquil Program that specifies the corresponding rotations\n        \"\"\"\nrotation_operations = Program()\nfor operation in rotations:\n    device_wires = self.map_wires(operation.wires)\n    par = operation.parameters\n    rotation_operations += self._operation_map[operation.name](*par, *\n        device_wires.labels)\nreturn rotation_operations\n"
    },
    {
        "functionName": "test_apply_qubitstatesvector_raises_an_error_if_not_first",
        "className": "TestParametricCompilation",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that there is an error raised when the QubitStateVector is not\n        applied as the first operation.\"\"\"\ndev = qml.device('forest.qvm', device='2q-qvm', parametric_compilation=True)\noperation = qml.QubitStateVector(np.array([1, 0]), wires=list(range(2)))\nqueue = [qml.PauliX(0), operation]\nwith pytest.raises(qml.DeviceError, match=\n    'Operation {} cannot be used after other Operations have already been applied'\n    .format(operation.name)):\n    dev.apply(queue)\n",
        "CUT_1": "rotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    par = operation.parameters\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_2": "rotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    par = operation.parameters\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_3": "\"\"\"Applies a parametric program by applying parametric\n        operation with symbolic parameters.\n        \"\"\"\nrotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    par = []\n    for param in operation.data:\n        if isinstance(param, Variable):\n            parameter_string = 'theta' + str(param.idx)\n            if parameter_string not in self._parameter_reference_map:\n                current_ref = self.prog.declare(parameter_string, 'REAL')\n                self._parameter_reference_map[parameter_string] = current_ref\n            self._parameter_map[parameter_string] = [param.val]\n            par.append(self._parameter_reference_map[parameter_string])\n        else:\n            par.append(param)\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_4": "\"\"\"Applies a parametric program by applying parametric\n        operation with symbolic parameters.\n        \"\"\"\nrotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    par = []\n    for param in operation.data:\n        if isinstance(param, Variable):\n            parameter_string = 'theta' + str(param.idx)\n            if parameter_string not in self._parameter_reference_map:\n                current_ref = self.prog.declare(parameter_string, 'REAL')\n                self._parameter_reference_map[parameter_string] = current_ref\n            self._parameter_map[parameter_string] = [param.val]\n            par.append(self._parameter_reference_map[parameter_string])\n        else:\n            par.append(param)\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_5": "\"\"\"Apply the circuit rotations.\n\n        This method serves as an auxiliary method to :meth:`~.ForestDevice.apply`.\n\n        Args:\n            rotations (List[pennylane.Operation]): operations that rotate into the\n                measurement basis\n\n        Returns:\n            pyquil.Program: the pyquil Program that specifies the corresponding rotations\n        \"\"\"\nrotation_operations = Program()\nfor operation in rotations:\n    device_wires = self.map_wires(operation.wires)\n    par = operation.parameters\n    rotation_operations += self._operation_map[operation.name](*par, *\n        device_wires.labels)\nreturn rotation_operations\n"
    },
    {
        "functionName": "test_load_qvm_device",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the QVM device loads correctly\"\"\"\ndev = qml.device('forest.qvm', device='2q-qvm')\nself.assertEqual(dev.num_wires, 2)\nself.assertEqual(dev.shots, 1000)\nself.assertEqual(dev.short_name, 'forest.qvm')\n",
        "CUT_1": "try:\n    qvm = QVMConnection(random_seed=52)\n    qvm.run(Program(Id(0)), [])\n    return qvm\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires QVM connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_2": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_3": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "\"\"\"Replaces unittest TestCase.assertEqual\"\"\"\nassert first == second\n"
    },
    {
        "functionName": "test_load_qvm_device_from_topology",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the QVM device, from an input topology, loads correctly\"\"\"\ntopology = nx.complete_graph(2)\ndev = qml.device('forest.qvm', device=topology)\nself.assertEqual(dev.num_wires, 2)\nself.assertEqual(dev.shots, 1000)\nself.assertEqual(dev.short_name, 'forest.qvm')\n",
        "CUT_1": "try:\n    qvm = QVMConnection(random_seed=52)\n    qvm.run(Program(Id(0)), [])\n    return qvm\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires QVM connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_2": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_3": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_4": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_5": "\"\"\"Replaces unittest TestCase.assertEqual\"\"\"\nassert first == second\n"
    },
    {
        "functionName": "test_load_virtual_qpu_device",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the QPU simulators load correctly\"\"\"\nqml.device('forest.qvm', device=np.random.choice(TEST_QPU_LATTICES))\n",
        "CUT_1": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_2": "try:\n    qvm = QVMConnection(random_seed=52)\n    qvm.run(Program(Id(0)), [])\n    return qvm\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires QVM connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_3": "\"\"\"Resets the device after the previous run.\n\n        Note:\n            The ``_compiled_program`` and the ``_compiled_program_dict`` attributes are\n            not reset such that these can be used upon multiple device execution.\n        \"\"\"\nsuper().reset()\nif self.parametric_compilation:\n    self._parameter_map = {}\n    self._parameter_reference_map = {}\n",
        "CUT_4": "\"\"\"Resets the device after the previous run.\n\n        Note:\n            The ``_compiled_program`` and the ``_compiled_program_dict`` attributes are\n            not reset such that these can be used upon multiple device execution.\n        \"\"\"\nsuper().reset()\nif self.parametric_compilation:\n    self._parameter_map = {}\n    self._parameter_reference_map = {}\n",
        "CUT_5": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n"
    },
    {
        "functionName": "test_qvm_args",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the QVM plugin requires correct arguments\"\"\"\nwith pytest.raises(TypeError, match='missing 1 required positional argument'):\n    qml.device('forest.qvm')\nwith pytest.raises(ValueError, match=\n    'Number of shots must be a positive integer'):\n    qml.device('forest.qvm', '2q-qvm', shots=0)\n",
        "CUT_1": "try:\n    qvm = QVMConnection(random_seed=52)\n    qvm.run(Program(Id(0)), [])\n    return qvm\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires QVM connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_2": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_3": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "\"\"\"default shots\"\"\"\nreturn QVM_SHOTS\npytest.fixture"
    },
    {
        "functionName": "test_qubit_unitary",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an arbitrary unitary operation works\"\"\"\ndev1 = qml.device('forest.qvm', device='3q-qvm', shots=shots)\ndev2 = qml.device('forest.qvm', device='9q-square-qvm', shots=shots)\ndef circuit():\n    \"\"\"Reference QNode\"\"\"\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.QubitUnitary(U2, wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\ncircuit1 = qml.QNode(circuit, dev1)\ncircuit2 = qml.QNode(circuit, dev2)\nout_state = U2 @ np.array([1, 0, 0, 1]) / np.sqrt(2)\nobs = np.kron(np.array([[1, 0], [0, -1]]), I)\nself.assertAllAlmostEqual(circuit1(), np.vdot(out_state, obs @ out_state),\n    delta=3 / np.sqrt(shots))\nself.assertAllAlmostEqual(circuit2(), np.vdot(out_state, obs @ out_state),\n    delta=3 / np.sqrt(shots))\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_one_qubit_wavefunction_circuit",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction plugin provides correct result for simple circuit.\n\n        As the results coming from the qvm are stochastic, a constraint of 2 out of 5 runs was added.\n        \"\"\"\nshots = 100000\ndev = qml.device('forest.qvm', device=device, shots=QVM_SHOTS)\na = 0.543\nb = 0.123\nc = 0.987\n@qml.qnode(dev)\ndef circuit(x, y, z):\n    \"\"\"Reference QNode\"\"\"\n    qml.BasisState(np.array([1]), wires=0)\n    qml.Hadamard(wires=0)\n    qml.Rot(x, y, z, wires=0)\n    return qml.expval(qml.PauliZ(0))\nself.assertAlmostEqual(circuit(a, b, c), np.cos(a) * np.sin(b), delta=3 /\n    np.sqrt(shots))\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_2q_gate",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the two qubit gate with the PauliZ observable works correctly.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndev = qml.device('forest.qvm', device=device, shots=QVM_SHOTS)\n@qml.qnode(dev)\ndef circuit():\n    qml.RY(np.pi / 2, wires=[0])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.Identity(1))\nassert np.allclose(circuit(), 0.0, atol=0.02)\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_2q_gate_pauliz_identity_tensor",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the PauliZ tensor Identity observable works correctly.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndev = qml.device('forest.qvm', device=device, shots=QVM_SHOTS)\n@qml.qnode(dev)\ndef circuit():\n    qml.RY(np.pi / 2, wires=[0])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.Identity(1))\nassert np.allclose(circuit(), 0.0, atol=0.02)\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_2q_gate_pauliz_pauliz_tensor",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the PauliZ tensor PauliZ observable works correctly.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndev = qml.device('forest.qvm', device=device, shots=QVM_SHOTS)\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(0)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\nassert np.allclose(circuit(), 1.0, atol=0.02)\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_compiled_program_was_stored",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that QVM device stores the compiled program correctly\"\"\"\ndev = qml.device('forest.qvm', device=device, timeout=100)\nassert len(dev._compiled_program_dict.items()) == 0\ndef circuit(params, wires):\n    qml.Hadamard(0)\n    qml.CNOT(wires=[0, 1])\nobs = [qml.PauliZ(0) @ qml.PauliZ(1)]\nobs_list = obs * 6\nqnodes = qml.map(circuit, obs_list, dev)\nqnodes([])\nassert dev.circuit_hash in dev._compiled_program_dict\nassert len(dev._compiled_program_dict.items()) == 1\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_compiled_program_was_stored_mutable_qnode_with_if_statement",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that QVM device stores the compiled program when the QNode is mutated correctly\"\"\"\ndev = qml.device('forest.qvm', device=device, timeout=100)\nassert len(dev._compiled_program_dict.items()) == 0\ndef circuit(params, wires, statement=None):\n    if statement:\n        qml.Hadamard(0)\n    qml.CNOT(wires=[0, 1])\nobs = [qml.PauliZ(0) @ qml.PauliZ(1)]\nobs_list = obs * 6\nqnodes = qml.map(circuit, obs_list, dev)\nfor idx, stmt in enumerate(statements):\n    qnodes[idx]([], statement=stmt)\n    assert dev.circuit_hash in dev._compiled_program_dict\nnumber_of_true = sum(statements)\nlength = 1 if number_of_true == 6 or number_of_true == 0 else 2\nassert len(dev._compiled_program_dict.items()) == length\npytest.mark.parametrize('statements', [[True, True, True, True, True, True],\n    [True, False, True, False, True, False], [True, False, False, False,\n    True, False], [False, False, False, False, False, True], [True, False,\n    False, False, False, False], [False, False, False, False, False, False]])pytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_2": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_3": "\"\"\"Determine if the given gate was defined in the pyquil Program.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate that shall be checked\n\n        Returns:\n            bool: True if the gate is defined, False otherwise\n        \"\"\"\nreturn gate.name in self._defined_gate_names\n",
        "CUT_4": "\"\"\"Determine if the given gate was defined in the pyquil Program.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate that shall be checked\n\n        Returns:\n            bool: True if the gate is defined, False otherwise\n        \"\"\"\nreturn gate.name in self._defined_gate_names\n",
        "CUT_5": "\"\"\"Determine if a gate is controlled.\n\n    Args:\n        gate (pyquil.quil.Gate): The gate that should be checked\n\n    Returns:\n        bool: True if the gate is controlled, False otherwise\n    \"\"\"\nreturn 'CONTROLLED' in gate.modifiers\n"
    },
    {
        "functionName": "test_compiled_program_was_stored_mutable_qnode_with_loop",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that QVM device stores the compiled program when the QNode is\n        mutated correctly\"\"\"\ndev = qml.device('forest.qvm', device=device, timeout=80)\nassert len(dev._compiled_program_dict.items()) == 0\ndef circuit(params, wires, rounds=1):\n    for i in range(rounds):\n        qml.Hadamard(0)\n        qml.CNOT(wires=[0, 1])\nobs = [qml.PauliZ(0) @ qml.PauliZ(1)]\nobs_list = obs * 6\nqnodes = qml.map(circuit, obs_list, dev)\nfor idx, qnode in enumerate(qnodes):\n    qnode([], rounds=idx)\n    assert dev.circuit_hash in dev._compiled_program_dict\nassert len(dev._compiled_program_dict.items()) == len(qnodes)\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_compiled_program_was_used",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that QVM device used the compiled program correctly, after it was stored\"\"\"\ndev = qml.device('forest.qvm', device=device, timeout=100)\nnumber_of_qnodes = 6\nobs = [qml.PauliZ(0) @ qml.PauliZ(1)]\nobs_list = obs * number_of_qnodes\nqnodes = qml.map(qml.templates.StronglyEntanglingLayers, obs_list, dev)\nparams = qml.init.strong_ent_layers_normal(n_layers=4, n_wires=dev.num_wires)\nqnodes[0](params)\ncall_history = []\nwith monkeypatch.context() as m:\n    m.setattr(QuantumComputer, 'compile', lambda self, prog: call_history.\n        append(prog))\n    for i in range(1, number_of_qnodes):\n        qnodes[i](params)\nresults = qnodes(params)\nassert len(call_history) == 0\nassert dev.circuit_hash in dev._compiled_program_dict\nassert len(dev._compiled_program_dict.items()) == 1\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "try:\n    qvm = QVMConnection(random_seed=52)\n    qvm.run(Program(Id(0)), [])\n    return qvm\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires QVM connection: {}'.format(e))\npytest.fixture(scope='session')"
    },
    {
        "functionName": "test_compiled_program_was_correct_compared_with_default_qubit",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that QVM device stores the compiled program correctly by comparing it with default.qubit.\n\n        As the results coming from the qvm are stochastic, a constraint of 1 out of 5 runs was added.\n        \"\"\"\nnumber_of_qnodes = 6\nobs = [qml.PauliZ(0) @ qml.PauliZ(1)]\nobs_list = obs * number_of_qnodes\ndev = qml.device('forest.qvm', device=device, timeout=100)\nparams = qml.init.strong_ent_layers_normal(n_layers=4, n_wires=dev.num_wires)\nqnodes = qml.map(qml.templates.StronglyEntanglingLayers, obs_list, dev)\nresults = qnodes(params)\ndev2 = qml.device('default.qubit', wires=dev.num_wires)\nqnodes2 = qml.map(qml.templates.StronglyEntanglingLayers, obs_list, dev2)\nresults2 = qnodes2(params)\nassert np.allclose(results, results2, atol=0.02, rtol=0)\nassert dev.circuit_hash in dev._compiled_program_dict\nassert len(dev._compiled_program_dict.items()) == 1\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_2q_gate_pauliz_pauliz_tensor_parametric_compilation_off",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the PauliZ tensor PauliZ observable works correctly, when parametric compilation\n        was turned off.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndev = qml.device('forest.qvm', device=device, shots=QVM_SHOTS,\n    parametric_compilation=False)\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(0)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\nassert np.allclose(circuit(), 1.0, atol=0.02)\npytest.mark.parametrize('device', ['2q-qvm', np.random.choice(\n    TEST_QPU_LATTICES)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "circuit",
        "className": null,
        "fileName": "/tests/test_qvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Reference QNode\"\"\"\nqml.Hadamard(wires=0)\nqml.CNOT(wires=[0, 1])\nqml.QubitUnitary(U2, wires=[0, 1])\nreturn qml.expval(qml.PauliZ(0))\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_identity_expectation",
        "className": "TestPyQVMBasic",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that identity expectation value (i.e. the trace) is 1\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-pyqvm', shots=shots)\nO1 = qml.expval(qml.Identity(wires=[0]))\nO2 = qml.expval(qml.Identity(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0]), qml.RX(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\nself.assertAllAlmostEqual(res, np.array([1, 1]), delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_pauliz_expectation",
        "className": "TestPyQVMBasic",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that PauliZ expectation value is correct\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-pyqvm', shots=shots)\nO1 = qml.expval(qml.PauliZ(wires=[0]))\nO2 = qml.expval(qml.PauliZ(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0]), qml.RX(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\nself.assertAllAlmostEqual(res, np.array([np.cos(theta), np.cos(theta) * np.\n    cos(phi)]), delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_paulix_expectation",
        "className": "TestPyQVMBasic",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that PauliX expectation value is correct\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-pyqvm', shots=shots)\nO1 = qml.expval(qml.PauliX(wires=[0]))\nO2 = qml.expval(qml.PauliX(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RY(theta, wires=[0]), qml.RY(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\nself.assertAllAlmostEqual(res, np.array([np.sin(theta) * np.sin(phi), np.\n    sin(phi)]), delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_pauliy_expectation",
        "className": "TestPyQVMBasic",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that PauliY expectation value is correct\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-pyqvm', shots=shots)\nO1 = qml.expval(qml.PauliY(wires=[0]))\nO2 = qml.expval(qml.PauliY(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RX(theta, wires=[0]), qml.RX(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\nself.assertAllAlmostEqual(res, np.array([0, -np.cos(theta) * np.sin(phi)]),\n    delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_hadamard_expectation",
        "className": "TestPyQVMBasic",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that Hadamard expectation value is correct\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-pyqvm', shots=shots)\nO1 = qml.expval(qml.Hadamard(wires=[0]))\nO2 = qml.expval(qml.Hadamard(wires=[1]))\ncircuit_graph = CircuitGraph([qml.RY(theta, wires=[0]), qml.RY(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\nexpected = np.array([np.sin(theta) * np.sin(phi) + np.cos(theta), np.cos(\n    theta) * np.cos(phi) + np.sin(phi)]) / np.sqrt(2)\nself.assertAllAlmostEqual(res, expected, delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_hermitian_expectation",
        "className": "TestPyQVMBasic",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that arbitrary Hermitian expectation values are correct\"\"\"\ntheta = 0.432\nphi = 0.123\ndev = plf.QVMDevice(device='2q-pyqvm', shots=5 * shots)\nO1 = qml.expval(qml.Hermitian(H, wires=[0]))\nO2 = qml.expval(qml.Hermitian(H, wires=[1]))\ncircuit_graph = CircuitGraph([qml.RY(theta, wires=[0]), qml.RY(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1, O2], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1), dev.expval(O2)])\na = H[0, 0]\nre_b = H[0, 1].real\nd = H[1, 1]\nev1 = ((a - d) * np.cos(theta) + 2 * re_b * np.sin(theta) * np.sin(phi) + a + d\n    ) / 2\nev2 = ((a - d) * np.cos(theta) * np.cos(phi) + 2 * re_b * np.sin(phi) + a + d\n    ) / 2\nexpected = np.array([ev1, ev2])\nself.assertAllAlmostEqual(res, expected, delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_multi_qubit_hermitian_expectation",
        "className": "TestPyQVMBasic",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that arbitrary multi-qubit Hermitian expectation values are correct\"\"\"\ntheta = np.random.random()\nphi = np.random.random()\nA = np.array([[-6, 2 + 1.0j, -3, -5 + 2.0j], [2 - 1.0j, 0, 2 - 1.0j, -5 + \n    4.0j], [-3, 2 + 1.0j, 0, -4 + 3.0j], [-5 - 2.0j, -5 - 4.0j, -4 - 3.0j, -6]]\n    )\ndev = plf.QVMDevice(device='2q-pyqvm', shots=10 * shots)\nO1 = qml.expval(qml.Hermitian(A, wires=[0, 1]))\ncircuit_graph = CircuitGraph([qml.RY(theta, wires=[0]), qml.RY(phi, wires=[\n    1]), qml.CNOT(wires=[0, 1])] + [O1], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = np.array([dev.expval(O1)])\nexpected = 0.5 * (6 * np.cos(theta) * np.sin(phi) - np.sin(theta) * (8 * np\n    .sin(phi) + 7 * np.cos(phi) + 3) - 2 * np.sin(phi) - 6 * np.cos(phi) - 6)\nself.assertAllAlmostEqual(res, expected, delta=6 / np.sqrt(shots))\n",
        "CUT_1": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_var",
        "className": "TestPyQVMBasic",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for variance calculation\"\"\"\ndev = plf.QVMDevice(device='2q-pyqvm', shots=shots)\nphi = 0.543\ntheta = 0.6543\nO1 = qml.var(qml.PauliZ(wires=[0]))\ncircuit_graph = CircuitGraph([qml.RX(phi, wires=[0]), qml.RY(theta, wires=[\n    0])] + [O1], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nvar = np.array([dev.var(O1)])\nexpected = 0.25 * (3 - np.cos(2 * theta) - 2 * np.cos(theta) ** 2 * np.cos(\n    2 * phi))\nself.assertAlmostEqual(var, expected, delta=3 / np.sqrt(shots))\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_var_hermitian",
        "className": "TestPyQVMBasic",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for variance calculation using an arbitrary Hermitian observable\"\"\"\ndev = plf.QVMDevice(device='2q-pyqvm', shots=100 * shots)\nphi = 0.543\ntheta = 0.6543\nA = np.array([[4, -1 + 6.0j], [-1 - 6.0j, 2]])\nO1 = qml.var(qml.Hermitian(A, wires=[0]))\ncircuit_graph = CircuitGraph([qml.RX(phi, wires=[0]), qml.RY(theta, wires=[\n    0])] + [O1], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nvar = np.array([dev.var(O1)])\nexpected = 0.5 * (2 * np.sin(2 * theta) * np.cos(phi) ** 2 + 24 * np.sin(\n    phi) * np.cos(phi) * (np.sin(theta) - np.cos(theta)) + 35 * np.cos(2 *\n    phi) + 39)\nself.assertAlmostEqual(var, expected, delta=0.3)\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_apply",
        "className": "TestPyQVMBasic",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the application of gates\"\"\"\ndev = plf.QVMDevice(device='3q-pyqvm', shots=shots)\ntry:\n    op = getattr(qml.ops, gate)\nexcept AttributeError:\n    op = getattr(plf, gate)\nw = list(range(op.num_wires))\nobs = qml.expval(qml.PauliZ(0))\nif op.par_domain == 'A':\n    if gate == 'QubitUnitary':\n        p = np.array(U)\n        w = [0]\n        state = apply_unitary(U, 3)\n    elif gate == 'BasisState':\n        p = np.array([1, 1, 1])\n        state = np.array([0, 0, 0, 0, 0, 0, 0, 1])\n        w = list(range(dev.num_wires))\n    circuit_graph = CircuitGraph([op(p, wires=w)] + [obs], {}, dev.wires)\nelse:\n    p = [0.432423, 2, 0.324][:op.num_params]\n    fn = test_operation_map[gate]\n    if callable(fn):\n        O = fn(*p)\n    else:\n        O = fn\n    state = apply_unitary(O, 3)\n    if p:\n        circuit_graph = CircuitGraph([op(*p, wires=w)] + [obs], {}, dev.wires)\n    else:\n        circuit_graph = CircuitGraph([op(wires=w)] + [obs], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\nres = dev.expval(obs)\nexpected = np.vdot(state, np.kron(np.kron(Z, I), I) @ state)\nself.assertAllAlmostEqual(res, expected, delta=3 / np.sqrt(shots))\npytest.mark.parametrize('gate', plf.QVMDevice._operation_map)",
        "CUT_1": "\"\"\"Return the matrix associated with the controlled operation.\n\n    Args:\n        op (np.array): Array representing the operation\n                       that should be controlled\n\n    Returns:\n        np.array: Array representing the controlled operations. If the input\n        array has shape (N, N) the output shape is (2*N, 2*N).\n    \"\"\"\nreturn _direct_sum(np.eye(op.shape[0], dtype=op.dtype), op)\n",
        "CUT_2": "\"\"\"Return the matrix associated with the controlled operation.\n\n    Args:\n        op (np.array): Array representing the operation\n                       that should be controlled\n\n    Returns:\n        np.array: Array representing the controlled operations. If the input\n        array has shape (N, N) the output shape is (2*N, 2*N).\n    \"\"\"\nreturn _direct_sum(np.eye(op.shape[0], dtype=op.dtype), op)\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "\"\"\"Determine if the given gate was defined in the pyquil Program.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate that shall be checked\n\n        Returns:\n            bool: True if the gate is defined, False otherwise\n        \"\"\"\nreturn gate.name in self._defined_gate_names\n"
    },
    {
        "functionName": "test_qubit_unitary",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an arbitrary unitary operation works\"\"\"\ndev1 = qml.device('forest.qvm', device='3q-pyqvm', shots=shots)\ndev2 = qml.device('forest.qvm', device='9q-square-pyqvm', shots=shots)\ndef circuit():\n    \"\"\"Reference QNode\"\"\"\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.QubitUnitary(U2, wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\ncircuit1 = qml.QNode(circuit, dev1)\ncircuit2 = qml.QNode(circuit, dev2)\nout_state = U2 @ np.array([1, 0, 0, 1]) / np.sqrt(2)\nobs = np.kron(np.array([[1, 0], [0, -1]]), I)\nself.assertAllAlmostEqual(circuit1(), np.vdot(out_state, obs @ out_state),\n    delta=3 / np.sqrt(shots))\nself.assertAllAlmostEqual(circuit2(), np.vdot(out_state, obs @ out_state),\n    delta=3 / np.sqrt(shots))\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_one_qubit_wavefunction_circuit",
        "className": "TestQVMIntegration",
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction plugin provides correct result for simple circuit.\"\"\"\nshots = 10000\ndev = qml.device('forest.qvm', device=device, shots=shots)\na = 0.543\nb = 0.123\nc = 0.987\n@qml.qnode(dev)\ndef circuit(x, y, z):\n    \"\"\"Reference QNode\"\"\"\n    qml.BasisState(np.array([1]), wires=0)\n    qml.Hadamard(wires=0)\n    qml.Rot(x, y, z, wires=0)\n    return qml.expval(qml.PauliZ(0))\nself.assertAlmostEqual(circuit(a, b, c), np.cos(a) * np.sin(b), delta=5 /\n    np.sqrt(shots))\npytest.mark.parametrize('device', ['2q-pyqvm'])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit",
        "className": null,
        "fileName": "/tests/test_pyqvm.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Reference QNode\"\"\"\nqml.Hadamard(wires=0)\nqml.CNOT(wires=[0, 1])\nqml.QubitUnitary(U2, wires=[0, 1])\nreturn qml.expval(qml.PauliZ(0))\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_load_qpu_device",
        "className": "TestQPUIntegration",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the QPU device loads correctly\"\"\"\ndevice = TEST_QPU_LATTICES[0]\ndev = qml.device('forest.qpu', device=device, load_qc=False)\nqc = pyquil.get_qc(device)\nnum_wires = len(qc.qubits())\nself.assertEqual(dev.num_wires, num_wires)\nself.assertEqual(dev.shots, 1000)\nself.assertEqual(dev.short_name, 'forest.qpu')\n",
        "CUT_1": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_2": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_3": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_4": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_5": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')"
    },
    {
        "functionName": "test_load_virtual_qpu_device",
        "className": "TestQPUIntegration",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the QPU simulators load correctly\"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\nqml.device('forest.qpu', device=device, load_qc=False)\n",
        "CUT_1": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_2": "\"\"\"Resets the device after the previous run.\n\n        Note:\n            The ``_compiled_program`` and the ``_compiled_program_dict`` attributes are\n            not reset such that these can be used upon multiple device execution.\n        \"\"\"\nsuper().reset()\nif self.parametric_compilation:\n    self._parameter_map = {}\n    self._parameter_reference_map = {}\n",
        "CUT_3": "\"\"\"Resets the device after the previous run.\n\n        Note:\n            The ``_compiled_program`` and the ``_compiled_program_dict`` attributes are\n            not reset such that these can be used upon multiple device execution.\n        \"\"\"\nsuper().reset()\nif self.parametric_compilation:\n    self._parameter_map = {}\n    self._parameter_reference_map = {}\n",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n"
    },
    {
        "functionName": "test_qpu_args",
        "className": "TestQPUIntegration",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the QPU plugin requires correct arguments\"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\nwith pytest.raises(TypeError, match='missing 1 required positional argument'):\n    qml.device('forest.qpu')\nwith pytest.raises(ValueError, match=\n    'Number of shots must be a positive integer'):\n    qml.device('forest.qpu', device=device, shots=0)\nwith pytest.raises(ValueError, match=\n    'Readout error cannot be set on the physical QPU'):\n    qml.device('forest.qpu', device=device, load_qc=True, readout_error=[\n        0.9, 0.75])\ndev_no_wires = qml.device('forest.qpu', device=device, shots=5, load_qc=False)\nassert dev_no_wires.wires == Wires(range(4))\nwith pytest.raises(ValueError, match='Device has a fixed number of'):\n    qml.device('forest.qpu', device=device, shots=5, wires=100, load_qc=False)\ndev_iterable_wires = qml.device('forest.qpu', device=device, shots=5, wires\n    =range(4), load_qc=False)\nassert dev_iterable_wires.wires == Wires(range(4))\nwith pytest.raises(ValueError, match='Device has a fixed number of'):\n    qml.device('forest.qpu', device=device, shots=5, wires=range(100),\n        load_qc=False)\n",
        "CUT_1": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_2": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_3": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_4": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_5": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n"
    },
    {
        "functionName": "test_tensor_expval_parametric_compilation",
        "className": "TestQPUIntegration",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the QPU expval method for Tensor observables made up of a single observable when parametric compilation is\n        turned on.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\np = np.pi / 8\ndev = qml.device('forest.qpu', device=device, shots=10000, load_qc=False,\n    parametric_compilation=True)\ndev_1 = qml.device('forest.qpu', device=device, shots=10000, load_qc=False,\n    parametric_compilation=True)\ndef template(param):\n    qml.BasisState(np.array([0, 0, 1, 1]), wires=list(range(4)))\n    qml.RY(param, wires=[2])\n    qml.CNOT(wires=[2, 3])\n@qml.qnode(dev)\ndef circuit_tensor(param):\n    template(param)\n    return qml.expval(Tensor(obs))\n@qml.qnode(dev_1)\ndef circuit_obs(param):\n    template(param)\n    return qml.expval(obs)\nres = circuit_tensor(p)\nexp = circuit_obs(p)\nassert np.allclose(res, exp, atol=0.02)\npytest.mark.parametrize('obs', [qml.PauliX(0), qml.PauliZ(0), qml.PauliY(0),\n    qml.Hadamard(0), qml.Identity(0)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_tensor_expval_operator_estimation",
        "className": "TestQPUIntegration",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the QPU expval method for Tensor observables made up of a single observable when parametric compilation is\n        turned off allowing operator estimation.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\np = np.pi / 7\ndev = qml.device('forest.qpu', device=device, shots=2000, load_qc=False,\n    parametric_compilation=False)\ndev_1 = qml.device('forest.qpu', device=device, shots=2000, load_qc=False,\n    parametric_compilation=False)\ndef template(param):\n    qml.BasisState(np.array([0, 0, 1, 1]), wires=list(range(4)))\n    qml.RY(param, wires=[2])\n    qml.CNOT(wires=[2, 3])\n@qml.qnode(dev)\ndef circuit_tensor(param):\n    template(param)\n    return qml.expval(Tensor(obs))\n@qml.qnode(dev_1)\ndef circuit_obs(param):\n    template(param)\n    return qml.expval(obs)\nres = circuit_tensor(p)\nexp = circuit_obs(p)\nassert np.allclose(res, exp, atol=0.02)\npytest.mark.parametrize('obs', [qml.PauliX(0), qml.PauliZ(0), qml.PauliY(0),\n    qml.Hadamard(0), qml.Identity(0)])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "template",
        "className": null,
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "qml.BasisState(np.array([0, 0, 1, 1]), wires=list(range(4)))\nqml.RY(param, wires=[2])\nqml.CNOT(wires=[2, 3])\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit_tensor",
        "className": null,
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "template(param)\nreturn qml.expval(Tensor(obs))\nqml.qnode(dev)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit_obs",
        "className": null,
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "template(param)\nreturn qml.expval(obs)\nqml.qnode(dev_1)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_warnings_raised_parametric_compilation_and_operator_estimation",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a warning is raised if parameter compilation and operator estimation are both turned on.\"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\nwith pytest.warns(Warning, match='Operator estimation is being turned off.'):\n    dev = qml.device('forest.qpu', device=device, shots=1000, load_qc=False,\n        parametric_compilation=True)\n",
        "CUT_1": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_2": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_3": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n"
    },
    {
        "functionName": "test_no_readout_correction",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the QPU plugin with no readout correction\"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev_qpu = qml.device('forest.qpu', device=device, load_qc=False,\n    readout_error=[0.9, 0.75], symmetrize_readout=None, calibrate_readout=\n    None, parametric_compilation=False)\nqubit = 0\n@qml.qnode(dev_qpu)\ndef circuit_Xpl():\n    qml.RY(np.pi / 2, wires=qubit)\n    return qml.expval(qml.PauliX(qubit))\n@qml.qnode(dev_qpu)\ndef circuit_Xmi():\n    qml.RY(-np.pi / 2, wires=qubit)\n    return qml.expval(qml.PauliX(qubit))\n@qml.qnode(dev_qpu)\ndef circuit_Ypl():\n    qml.RX(-np.pi / 2, wires=qubit)\n    return qml.expval(qml.PauliY(qubit))\n@qml.qnode(dev_qpu)\ndef circuit_Ymi():\n    qml.RX(np.pi / 2, wires=qubit)\n    return qml.expval(qml.PauliY(qubit))\n@qml.qnode(dev_qpu)\ndef circuit_Zpl():\n    qml.RX(0.0, wires=qubit)\n    return qml.expval(qml.PauliZ(qubit))\n@qml.qnode(dev_qpu)\ndef circuit_Zmi():\n    qml.RX(np.pi, wires=qubit)\n    return qml.expval(qml.PauliZ(qubit))\nnum_expts = 10\nresults_unavged = np.zeros((num_expts, 6))\nfor i in range(num_expts):\n    results_unavged[(i), :] = [circuit_Xpl(), circuit_Ypl(), circuit_Zpl(),\n        circuit_Xmi(), circuit_Ymi(), circuit_Zmi()]\nresults = np.mean(results_unavged, axis=0)\nassert np.allclose(results[:3], 0.8, atol=0.02)\nassert np.allclose(results[3:], -0.5, atol=0.02)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_readout_correction",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the QPU plugin with readout correction\"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev_qpu = qml.device('forest.qpu', device=device, load_qc=False,\n    readout_error=[0.9, 0.75], symmetrize_readout='exhaustive',\n    calibrate_readout='plus-eig', timeout=100)\nqubit = 0\n@qml.qnode(dev_qpu)\ndef circuit_Xpl():\n    qml.RY(np.pi / 2, wires=qubit)\n    return qml.expval(qml.PauliX(qubit))\n@qml.qnode(dev_qpu)\ndef circuit_Xmi():\n    qml.RY(-np.pi / 2, wires=qubit)\n    return qml.expval(qml.PauliX(qubit))\n@qml.qnode(dev_qpu)\ndef circuit_Ypl():\n    qml.RX(-np.pi / 2, wires=qubit)\n    return qml.expval(qml.PauliY(qubit))\n@qml.qnode(dev_qpu)\ndef circuit_Ymi():\n    qml.RX(np.pi / 2, wires=qubit)\n    return qml.expval(qml.PauliY(qubit))\n@qml.qnode(dev_qpu)\ndef circuit_Zpl():\n    qml.RX(0.0, wires=qubit)\n    return qml.expval(qml.PauliZ(qubit))\n@qml.qnode(dev_qpu)\ndef circuit_Zmi():\n    qml.RX(np.pi, wires=qubit)\n    return qml.expval(qml.PauliZ(qubit))\nnum_expts = 10\nresults_unavged = np.zeros((num_expts, 6))\nfor i in range(num_expts):\n    results_unavged[(i), :] = [circuit_Xpl(), circuit_Ypl(), circuit_Zpl(),\n        circuit_Xmi(), circuit_Ymi(), circuit_Zmi()]\nresults = np.mean(results_unavged, axis=0)\nassert np.allclose(results[:3], 1.0, atol=0.02)\nassert np.allclose(results[3:], -1.0, atol=0.02)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_multi_qub_no_readout_errors",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the QPU plugin with no readout errors or correction\"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev_qpu = qml.device('forest.qpu', device=device, load_qc=False,\n    symmetrize_readout=None, calibrate_readout=None)\n@qml.qnode(dev_qpu)\ndef circuit():\n    qml.RY(np.pi / 2, wires=0)\n    qml.RY(np.pi / 3, wires=1)\n    return qml.expval(qml.PauliX(0) @ qml.PauliZ(1))\nnum_expts = 50\nresult = 0.0\nfor _ in range(num_expts):\n    result += circuit()\nresult /= num_expts\nassert np.isclose(result, 0.5, atol=0.02)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "\"\"\"Applies a unitary to the first wire of a register in the ground state\n\n        Args:\n            mat (array): unitary matrix\n            num_wires (n): number of wires in the register\n        \"\"\"\nN = mat.shape[0]\ninit_state = np.zeros(N)\ninit_state[0] = 1\nresult = mat @ init_state\nfor _ in range(num_wires - int(np.log2(N))):\n    result = np.kron(result, np.array([1, 0]))\nreturn result\n"
    },
    {
        "functionName": "test_multi_qub_readout_errors",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the QPU plugin with readout errors\"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev_qpu = qml.device('forest.qpu', device=device, load_qc=False, shots=\n    10000, readout_error=[0.9, 0.75], symmetrize_readout=None,\n    calibrate_readout=None, parametric_compilation=False)\n@qml.qnode(dev_qpu)\ndef circuit():\n    qml.RY(np.pi / 2, wires=0)\n    qml.RY(np.pi / 3, wires=1)\n    return qml.expval(qml.PauliX(0) @ qml.PauliZ(1))\nresult = circuit()\nassert np.isclose(result, 0.38, atol=0.02)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_multi_qub_readout_correction",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the QPU plugin with readout errors and correction\"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev_qpu = qml.device('forest.qpu', device=device, load_qc=False, shots=\n    10000, readout_error=[0.9, 0.75], symmetrize_readout='exhaustive',\n    calibrate_readout='plus-eig', parametric_compilation=False)\n@qml.qnode(dev_qpu)\ndef circuit():\n    qml.RY(np.pi / 2, wires=0)\n    qml.RY(np.pi / 3, wires=1)\n    return qml.expval(qml.PauliX(0) @ qml.PauliZ(1))\nresult = circuit()\nassert np.isclose(result, 0.5, atol=0.03)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_2q_gate",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the two qubit gate with the PauliZ observable works correctly.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev_qpu = qml.device('forest.qpu', device=device, load_qc=False,\n    readout_error=[0.9, 0.75], symmetrize_readout='exhaustive',\n    calibrate_readout='plus-eig', shots=QVM_SHOTS)\n@qml.qnode(dev_qpu)\ndef circuit():\n    qml.RY(np.pi / 2, wires=[0])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\nassert np.allclose(circuit(), 0.0, atol=0.02)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_2q_gate_pauliz_identity_tensor",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the PauliZ tensor Identity observable works correctly.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev_qpu = qml.device('forest.qpu', device=device, load_qc=False,\n    readout_error=[0.9, 0.75], symmetrize_readout='exhaustive',\n    calibrate_readout='plus-eig', shots=QVM_SHOTS)\n@qml.qnode(dev_qpu)\ndef circuit():\n    qml.RY(np.pi / 2, wires=[0])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.Identity(1))\nassert np.allclose(circuit(), 0.0, atol=0.02)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_2q_gate_pauliz_pauliz_tensor",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the PauliZ tensor PauliZ observable works correctly.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev_qpu = qml.device('forest.qpu', device=device, load_qc=False,\n    readout_error=[0.9, 0.75], symmetrize_readout='exhaustive',\n    calibrate_readout='plus-eig', shots=QVM_SHOTS)\n@qml.qnode(dev_qpu)\ndef circuit(x):\n    qml.RY(x, wires=[0])\n    qml.Hadamard(wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.Identity(1))\nassert np.allclose(circuit(a), np.cos(a), atol=0.02)\nassert np.allclose(circuit(a), np.cos(a), atol=0.02)\npytest.mark.parametrize('a', np.linspace(-0.5, 2, 6))",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_2q_circuit_pauliz_pauliz_tensor",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the PauliZ tensor PauliZ observable works correctly, when parametric compilation\n        is turned off.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev_qpu = qml.device('forest.qpu', device=device, load_qc=False,\n    readout_error=[0.9, 0.75], symmetrize_readout='exhaustive',\n    calibrate_readout='plus-eig', shots=QVM_SHOTS)\n@qml.qnode(dev_qpu)\ndef circuit(x, y):\n    qml.RY(x, wires=[0])\n    qml.RY(y, wires=[1])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\nanalytic_value = np.cos(a / 2) ** 2 * np.cos(b / 2) ** 2 + np.cos(b / 2\n    ) ** 2 * np.sin(a / 2) ** 2 - np.cos(a / 2) ** 2 * np.sin(b / 2\n    ) ** 2 - np.sin(a / 2) ** 2 * np.sin(b / 2) ** 2\nassert np.allclose(circuit(a, b), analytic_value, atol=0.02)\nassert np.allclose(circuit(a, b), analytic_value, atol=0.02)\npytest.mark.parametrize('a', np.linspace(-np.pi / 2, 0, 3))pytest.mark.parametrize('b', np.linspace(0, np.pi / 2, 3))",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_2q_gate_pauliz_pauliz_tensor_parametric_compilation_off",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the PauliZ tensor PauliZ observable works correctly, when parametric compilation\n        is turned off.\n\n        As the results coming from the qvm are stochastic, a constraint of 3 out of 5 runs was added.\n        \"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev_qpu = qml.device('forest.qpu', device=device, load_qc=False,\n    readout_error=[0.9, 0.75], symmetrize_readout='exhaustive',\n    calibrate_readout='plus-eig', shots=QVM_SHOTS // 20,\n    parametric_compilation=False)\n@qml.qnode(dev_qpu)\ndef circuit(x, y):\n    qml.RY(x, wires=[0])\n    qml.RY(y, wires=[1])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\nanalytic_value = np.cos(a / 2) ** 2 * np.cos(b / 2) ** 2 + np.cos(b / 2\n    ) ** 2 * np.sin(a / 2) ** 2 - np.cos(a / 2) ** 2 * np.sin(b / 2\n    ) ** 2 - np.sin(a / 2) ** 2 * np.sin(b / 2) ** 2\nexpt = np.mean([circuit(a, b) for _ in range(20)])\ntheory = analytic_value\nassert np.allclose(expt, theory, atol=0.02)\npytest.mark.parametrize('a', np.linspace(-np.pi / 2, 0, 3))pytest.mark.parametrize('b', np.linspace(0, np.pi / 2, 3))",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_timeout_set_correctly",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the timeout attrbiute for the QuantumComputer stored by the QVMDevice\n        is set correctly when passing a value as keyword argument\"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev = plf.QVMDevice(device=device, shots=shots, timeout=100)\nassert dev.qc.compiler.client.timeout == 100\n",
        "CUT_1": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_2": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_3": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')"
    },
    {
        "functionName": "test_timeout_default",
        "className": "TestQPUBasic",
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the timeout attrbiute for the QuantumComputer stored by the QVMDevice\n        is set to default when no specific value is being passed.\"\"\"\ndevice = np.random.choice(TEST_QPU_LATTICES)\ndev = plf.QVMDevice(device=device, shots=shots)\nqc = pyquil.get_qc(device, as_qvm=True)\nassert dev.qc.compiler.client.timeout == qc.compiler.client.timeout\n",
        "CUT_1": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_2": "if readout_error is not None and load_qc:\n    raise ValueError('Readout error cannot be set on the physical QPU')\nself.readout_error = readout_error\nself._eigs = {}\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nif kwargs.get('parametric_compilation', False):\n    warnings.warn(\n        'Parametric compilation is currently not supported with operatorestimation. Operator estimation is being turned off.'\n        )\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\ntimeout = kwargs.pop('timeout', None)\nif shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nself.connection = super()._get_connection(**kwargs)\nif load_qc:\n    self.qc = get_qc(device, as_qvm=False, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.quilc_client.timeout = timeout\nelse:\n    self.qc = get_qc(device, as_qvm=True, connection=self.connection)\n    if timeout is not None:\n        self.qc.compiler.client.timeout = timeout\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper(QVMDevice, self).__init__(wires, shots, **kwargs)\nself.active_reset = active_reset\nself.symmetrize_readout = symmetrize_readout\nself.calibrate_readout = calibrate_readout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\n",
        "CUT_3": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')"
    },
    {
        "functionName": "circuit_Xpl",
        "className": null,
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "qml.RY(np.pi / 2, wires=qubit)\nreturn qml.expval(qml.PauliX(qubit))\nqml.qnode(dev_qpu)",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit_Xmi",
        "className": null,
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "qml.RY(-np.pi / 2, wires=qubit)\nreturn qml.expval(qml.PauliX(qubit))\nqml.qnode(dev_qpu)",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit_Ypl",
        "className": null,
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "qml.RX(-np.pi / 2, wires=qubit)\nreturn qml.expval(qml.PauliY(qubit))\nqml.qnode(dev_qpu)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit_Ymi",
        "className": null,
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "qml.RX(np.pi / 2, wires=qubit)\nreturn qml.expval(qml.PauliY(qubit))\nqml.qnode(dev_qpu)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit_Zpl",
        "className": null,
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "qml.RX(0.0, wires=qubit)\nreturn qml.expval(qml.PauliZ(qubit))\nqml.qnode(dev_qpu)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit_Zmi",
        "className": null,
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "qml.RX(np.pi, wires=qubit)\nreturn qml.expval(qml.PauliZ(qubit))\nqml.qnode(dev_qpu)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit",
        "className": null,
        "fileName": "/tests/test_qpu.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "qml.RY(np.pi / 2, wires=0)\nqml.RY(np.pi / 3, wires=1)\nreturn qml.expval(qml.PauliX(0) @ qml.PauliZ(1))\nqml.qnode(dev_qpu)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_expand_state",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a multi-qubit state is correctly expanded for a N-qubit device\"\"\"\ndev = plf.WavefunctionDevice(wires=3)\ndev._state = np.array([0, 1, 1, 0]) / np.sqrt(2)\ndev._active_wires = Wires([0, 2])\ndev.expand_state()\nself.assertAllEqual(dev._state, np.array([0, 1, 0, 0, 1, 0, 0, 0]) / np.sqrt(2)\n    )\ndev._state = np.array([0, 1, 1, 0, 0, 1, 1, 0]) / 2\ndev._active_wires = Wires([0, 1, 2])\ndev.expand_state()\nself.assertAllEqual(dev._state, np.array([0, 1, 1, 0, 0, 1, 1, 0]) / 2)\n",
        "CUT_1": "super().apply(operations, **kwargs)\nself._state = self.qc.wavefunction(self.prog).amplitudes\nself._state = self._state.reshape([2] * len(self._active_wires)).T.flatten()\nself.expand_state()\n",
        "CUT_2": "super().apply(operations, **kwargs)\nself._state = self.qc.wavefunction(self.prog).amplitudes\nself._state = self._state.reshape([2] * len(self._active_wires)).T.flatten()\nself.expand_state()\n",
        "CUT_3": "\"\"\"Return the direct sums of two arrays.\n\n    Args:\n        A (np.array): The first array (upper left array)\n        B (np.array): The second array (lower right array)\n\n    Returns:\n        np.array: The direct sum of the two input arrays\n    \"\"\"\nsum_matrix = np.zeros(np.add(A.shape, B.shape), dtype=A.dtype)\nsum_matrix[:A.shape[0], :A.shape[1]] = A\nsum_matrix[A.shape[0]:, A.shape[1]:] = B\nreturn sum_matrix\n",
        "CUT_4": "\"\"\"Return the direct sums of two arrays.\n\n    Args:\n        A (np.array): The first array (upper left array)\n        B (np.array): The second array (lower right array)\n\n    Returns:\n        np.array: The direct sum of the two input arrays\n    \"\"\"\nsum_matrix = np.zeros(np.add(A.shape, B.shape), dtype=A.dtype)\nsum_matrix[:A.shape[0], :A.shape[1]] = A\nsum_matrix[A.shape[0]:, A.shape[1]:] = B\nreturn sum_matrix\n",
        "CUT_5": "self.prog = Program()\nself._active_wires = Wires([])\nself._state = None\n"
    },
    {
        "functionName": "test_var",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for variance calculation\"\"\"\ndev = plf.WavefunctionDevice(wires=2)\nphi = 0.543\ntheta = 0.6543\ncircuit_operations = [qml.RX(phi, wires=[0]), qml.RY(theta, wires=[0])]\nO = qml.var(qml.PauliZ(wires=[0]))\nobservables = [O]\ncircuit_graph = qml.CircuitGraph(circuit_operations + observables, {}, dev.\n    wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\nvar = dev.var(qml.PauliZ(0))\nexpected = 0.25 * (3 - np.cos(2 * theta) - 2 * np.cos(theta) ** 2 * np.cos(\n    2 * phi))\nself.assertAlmostEqual(var, expected, delta=tol)\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_var_hermitian",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for variance calculation using an arbitrary Hermitian observable\"\"\"\ndev = plf.WavefunctionDevice(wires=2)\nphi = 0.543\ntheta = 0.6543\nH = np.array([[4, -1 + 6.0j], [-1 - 6.0j, 2]])\ncircuit_operations = [qml.RX(phi, wires=[0]), qml.RY(theta, wires=[0])]\nO = qml.var(qml.Hermitian(H, wires=[0]))\nobservables = [O]\ncircuit_graph = qml.CircuitGraph(circuit_operations + observables, {}, dev.\n    wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\nvar = dev.var(qml.Hermitian(H, wires=[0]))\nexpected = 0.5 * (2 * np.sin(2 * theta) * np.cos(phi) ** 2 + 24 * np.sin(\n    phi) * np.cos(phi) * (np.sin(theta) - np.cos(theta)) + 35 * np.cos(2 *\n    phi) + 39)\nself.assertAlmostEqual(var, expected, delta=tol)\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_apply",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the application of gates to a state\"\"\"\ndev = plf.WavefunctionDevice(wires=3)\ntry:\n    op = getattr(qml.ops, gate)\nexcept AttributeError:\n    op = getattr(plf, gate)\nw = list(range(op.num_wires))\nobs = qml.expval(qml.PauliZ(0))\nif op.par_domain == 'A':\n    if gate == 'QubitUnitary':\n        p = np.array(U)\n        w = [0]\n        state = apply_unitary(U, 3)\n    elif gate == 'BasisState':\n        p = np.array([1, 1, 1])\n        state = np.array([0, 0, 0, 0, 0, 0, 0, 1])\n        w = list(range(dev.num_wires))\n    circuit_graph = qml.CircuitGraph([op(p, wires=w)] + [obs], {}, dev.wires)\nelse:\n    p = [0.432423, 2, 0.324][:op.num_params]\n    fn = test_operation_map[gate]\n    if callable(fn):\n        O = fn(*p)\n    else:\n        O = fn\n    state = apply_unitary(O, 3)\n    if p:\n        circuit_graph = qml.CircuitGraph([op(*p, wires=w)] + [obs], {}, dev\n            .wires)\n    else:\n        circuit_graph = qml.CircuitGraph([op(wires=w)] + [obs], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\nres = dev.expval(obs)\nself.assertAllAlmostEqual(dev._state, state, delta=tol)\npytest.mark.parametrize('gate', plf.WavefunctionDevice._operation_map)",
        "CUT_1": "\"\"\"Return the matrix associated with the controlled operation.\n\n    Args:\n        op (np.array): Array representing the operation\n                       that should be controlled\n\n    Returns:\n        np.array: Array representing the controlled operations. If the input\n        array has shape (N, N) the output shape is (2*N, 2*N).\n    \"\"\"\nreturn _direct_sum(np.eye(op.shape[0], dtype=op.dtype), op)\n",
        "CUT_2": "\"\"\"Return the matrix associated with the controlled operation.\n\n    Args:\n        op (np.array): Array representing the operation\n                       that should be controlled\n\n    Returns:\n        np.array: Array representing the controlled operations. If the input\n        array has shape (N, N) the output shape is (2*N, 2*N).\n    \"\"\"\nreturn _direct_sum(np.eye(op.shape[0], dtype=op.dtype), op)\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_sample_values",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests if the samples returned by sample have\n        the correct values\n        \"\"\"\ndev = plf.WavefunctionDevice(wires=1, shots=10)\ntheta = 1.5708\ncircuit_operations = [qml.RX(theta, wires=[0])]\nO = qml.sample(qml.PauliZ(0))\nobservables = [O]\ncircuit_graph = qml.CircuitGraph(circuit_operations + observables, {}, dev.\n    wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\ns1 = dev.sample(O)\nself.assertAllAlmostEqual(s1 ** 2, 1, delta=tol)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_sample_values_hermitian",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests if the samples of a Hermitian observable returned by sample have\n        the correct values\n        \"\"\"\ndev = plf.WavefunctionDevice(wires=1, shots=1000000)\ntheta = 0.543\nA = np.array([[1, 2.0j], [-2.0j, 0]])\ncircuit_operations = [qml.RX(theta, wires=[0])]\nO = qml.sample(qml.Hermitian(A, wires=[0]))\nobservables = [O]\ncircuit_graph = qml.CircuitGraph(circuit_operations + observables, {}, dev.\n    wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\ns1 = dev.sample(O)\neigvals = np.linalg.eigvalsh(A)\nassert np.allclose(sorted(list(set(s1))), sorted(eigvals), atol=tol, rtol=0)\nassert np.allclose(np.mean(s1), 2 * np.sin(theta) + 0.5 * np.cos(theta) + \n    0.5, atol=0.1, rtol=0)\nassert np.allclose(np.var(s1), 0.25 * (np.sin(theta) - 4 * np.cos(theta)) **\n    2, atol=0.1, rtol=0)\n",
        "CUT_1": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "\"\"\"\n        Like assertAlmostEqual, but works with arrays. All the corresponding elements have to be almost equal.\n        \"\"\"\nif isinstance(first, tuple):\n    if np.all([np.all(first[idx] == second[idx]) for idx, _ in enumerate(\n        first)]):\n        return\n    if np.all([(np.all(np.abs(first[idx] - second[idx])) <= delta) for idx,\n        _ in enumerate(first)]):\n        return\nelse:\n    if np.all(first == second):\n        return\n    if np.all(np.abs(first - second) <= delta):\n        return\nassert False, '{} != {} within {} delta'.format(first, second, delta)\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_sample_values_hermitian_multi_qubit",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests if the samples of a multi-qubit Hermitian observable returned by sample have\n        the correct values\n        \"\"\"\nshots = 1000000\ndev = plf.WavefunctionDevice(wires=2, shots=shots)\ntheta = 0.543\nA = np.array([[1, 2.0j, 1 - 2.0j, 0.5j], [-2.0j, 0, 3 + 4.0j, 1], [1 + 2.0j,\n    3 - 4.0j, 0.75, 1.5 - 2.0j], [-0.5j, 1, 1.5 + 2.0j, -1]])\ncircuit_operations = [qml.RX(theta, wires=[0]), qml.RY(2 * theta, wires=[1]\n    ), qml.CNOT(wires=[0, 1])]\nO = qml.sample(qml.Hermitian(A, wires=[0, 1]))\nobservables = [O]\ncircuit_graph = qml.CircuitGraph(circuit_operations + observables, {}, dev.\n    wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\ns1 = dev.sample(O)\neigvals = np.linalg.eigvalsh(A)\nassert np.allclose(sorted(list(set(s1))), sorted(eigvals), atol=tol, rtol=0)\nexpected = (88 * np.sin(theta) + 24 * np.sin(2 * theta) - 40 * np.sin(3 *\n    theta) + 5 * np.cos(theta) - 6 * np.cos(2 * theta) + 27 * np.cos(3 *\n    theta) + 6) / 32\nassert np.allclose(np.mean(s1), expected, atol=0.1, rtol=0)\n",
        "CUT_1": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_load_wavefunction_device",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction device loads correctly\"\"\"\ndev = qml.device('forest.wavefunction', wires=2)\nself.assertEqual(dev.num_wires, 2)\nself.assertEqual(dev.shots, 1000)\nself.assertEqual(dev.short_name, 'forest.wavefunction')\n",
        "CUT_1": "\"\"\"Replaces unittest TestCase.assertEqual\"\"\"\nassert first == second\n",
        "CUT_2": "super().apply(operations, **kwargs)\nself._state = self.qc.wavefunction(self.prog).amplitudes\nself._state = self._state.reshape([2] * len(self._active_wires)).T.flatten()\nself.expand_state()\n",
        "CUT_3": "super().apply(operations, **kwargs)\nself._state = self.qc.wavefunction(self.prog).amplitudes\nself._state = self._state.reshape([2] * len(self._active_wires)).T.flatten()\nself.expand_state()\n",
        "CUT_4": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_5": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n"
    },
    {
        "functionName": "test_program_property",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the program property works as expected\"\"\"\ndev = qml.device('forest.wavefunction', wires=2)\n@qml.qnode(dev)\ndef circuit():\n    \"\"\"Test QNode\"\"\"\n    qml.Hadamard(wires=0)\n    qml.PauliY(wires=0)\n    return qml.expval(qml.PauliX(0))\nself.assertEqual(len(dev.program), 0)\ncircuit()\nself.assertEqual(len(dev.program), 2 + 1)\nself.assertEqual(str(dev.program), 'H 0\\nY 0\\nH 0\\n')\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_wavefunction_args",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction plugin requires correct arguments\"\"\"\nwith pytest.raises(TypeError, match=\n    \"missing 1 required positional argument: 'wires'\"):\n    qml.device('forest.wavefunction')\n",
        "CUT_1": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_2": "try:\n    qvm = QVMConnection(random_seed=52)\n    qvm.run(Program(Id(0)), [])\n    return qvm\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires QVM connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_hermitian_expectation",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an arbitrary Hermitian expectation value works\"\"\"\ndev = qml.device('forest.wavefunction', wires=1)\n@qml.qnode(dev)\ndef circuit():\n    \"\"\"Test QNode\"\"\"\n    qml.Hadamard(wires=0)\n    qml.PauliY(wires=0)\n    return qml.expval(qml.Hermitian(H, 0))\nout_state = 1.0j * np.array([-1, 1]) / np.sqrt(2)\nself.assertAllAlmostEqual(circuit(), np.vdot(out_state, H @ out_state),\n    delta=tol)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_qubit_unitary",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an arbitrary unitary operation works\"\"\"\ndev = qml.device('forest.wavefunction', wires=3)\n@qml.qnode(dev)\ndef circuit():\n    \"\"\"Test QNode\"\"\"\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.QubitUnitary(U2, wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\nout_state = U2 @ np.array([1, 0, 0, 1]) / np.sqrt(2)\nobs = np.kron(np.array([[1, 0], [0, -1]]), I)\nself.assertAllAlmostEqual(circuit(), np.vdot(out_state, obs @ out_state),\n    delta=tol)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_invalid_qubit_unitary",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an invalid unitary operation is not allowed\"\"\"\ndev = qml.device('forest.wavefunction', wires=3)\ndev.shots = 1\ndef circuit(Umat):\n    \"\"\"Test QNode\"\"\"\n    qml.QubitUnitary(Umat, wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\ncircuit1 = qml.QNode(circuit, dev)\nwith pytest.raises(ValueError, match='must be a square matrix'):\n    circuit1(np.array([[0, 1]]))\ncircuit1 = qml.QNode(circuit, dev)\nwith pytest.raises(ValueError, match='must be unitary'):\n    circuit1(np.array([[1, 1], [1, 1]]))\ncircuit1 = qml.QNode(circuit, dev)\nwith pytest.raises(ValueError, match='must be 2\\\\^Nx2\\\\^N'):\n    circuit1(U)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_one_qubit_wavefunction_circuit",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction plugin provides correct result for simple circuit\"\"\"\ndev = qml.device('forest.wavefunction', wires=1)\na = 0.543\nb = 0.123\nc = 0.987\n@qml.qnode(dev)\ndef circuit(x, y, z):\n    \"\"\"Test QNode\"\"\"\n    qml.BasisState(np.array([1]), wires=0)\n    qml.Hadamard(wires=0)\n    qml.Rot(x, y, z, wires=0)\n    return qml.expval(qml.PauliZ(0))\nself.assertAlmostEqual(circuit(a, b, c), np.cos(a) * np.sin(b), delta=tol)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_two_qubit_wavefunction_circuit",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction plugin provides correct result for simple 2-qubit circuit,\n        even when the number of wires > number of qubits.\"\"\"\ndev = qml.device('forest.wavefunction', wires=3)\na = 0.543\nb = 0.123\nc = 0.987\ntheta = 0.6423\n@qml.qnode(dev)\ndef circuit(w, x, y, z):\n    \"\"\"Test QNode\"\"\"\n    qml.BasisState(np.array([0, 1]), wires=[0, 1])\n    qml.Hadamard(wires=1)\n    plf.CPHASE(w, 1, wires=[0, 1])\n    qml.Rot(x, y, z, wires=0)\n    plf.CPHASE(w, 3, wires=[0, 1])\n    plf.CPHASE(w, 0, wires=[0, 1])\n    return qml.expval(qml.PauliY(1))\nself.assertAlmostEqual(circuit(theta, a, b, c), -np.sin(b / 2) ** 2 * np.\n    sin(2 * theta), delta=tol)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_nonzero_shots",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction plugin provides correct result for high shot number\"\"\"\nshots = 10 ** 2\ndev = qml.device('forest.wavefunction', wires=1, shots=shots)\na = 0.543\nb = 0.123\nc = 0.987\n@qml.qnode(dev)\ndef circuit(x, y, z):\n    \"\"\"Test QNode\"\"\"\n    qml.BasisState(np.array([1]), wires=0)\n    qml.Hadamard(wires=0)\n    qml.Rot(x, y, z, wires=0)\n    return qml.expval(qml.PauliZ(0))\nruns = []\nfor _ in range(100):\n    runs.append(circuit(a, b, c))\nexpected_var = np.sqrt(1 / shots)\nself.assertAlmostEqual(np.mean(runs), np.cos(a) * np.sin(b), delta=expected_var\n    )\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit",
        "className": null,
        "fileName": "/tests/test_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test QNode\"\"\"\nqml.Hadamard(wires=0)\nqml.PauliY(wires=0)\nreturn qml.expval(qml.PauliX(0))\nqml.qnode(dev)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_incorrect_matrix_size",
        "className": "TestMatVecProduct",
        "fileName": "/tests/test_device.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an exception is raised if the input matrix is\n        applied to the incorrect number of wires\"\"\"\nwires = 3\ndev = ForestDevice(wires=wires, shots=1)\nvec = np.random.random([2 ** wires])\nwith pytest.raises(ValueError, match='specify a 8 x 8 matrix for 3 wires'):\n    res = dev.mat_vec_product(U2, vec, device_wire_labels=[0, 1, 2])\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "\"\"\"Build the map that assigns wires to qubits.\n\n        Args:\n            wires (Sequence[int]): The wires that should be assigned to the qubits\n\n        Raises:\n            qml.DeviceError: When the number of given wires does not match the number of qubits in the pyquil Program\n\n        Returns:\n            Dict[int, int]: The map that assigns wires to qubits\n        \"\"\"\nif len(wires) != len(self.qubits):\n    raise qml.DeviceError(\n        'The number of given wires does not match the number of qubits in the PyQuil Program. '\n         + '{} wires were given, Program has {} qubits'.format(len(wires),\n        len(self.qubits)))\nself._qubit_to_wire_map = dict(zip(self.qubits, wires))\nreturn self._qubit_to_wire_map\n"
    },
    {
        "functionName": "test_full_system",
        "className": "TestMatVecProduct",
        "fileName": "/tests/test_device.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that matrix-vector multiplication\n        over the entire subsystem agrees with standard\n        dense matrix multiplication\"\"\"\nwires = 3\ndev = ForestDevice(wires=wires, shots=1)\nvec = np.random.random([2 ** wires])\nmat = np.kron(U2, H)\nres = dev.mat_vec_product(mat, vec, device_wire_labels=[0, 1, 2])\nexpected = mat @ vec\nassert np.allclose(res, expected, atol=tol, rtol=0)\n",
        "CUT_1": "\"\"\"Apply multiplication of a matrix to subsystems of the quantum state.\n\n        Args:\n            mat (array): matrix to multiply\n            vec (array): state vector to multiply\n            device_wire_labels (Sequence[int]): labels of device subsystems\n\n        Returns:\n            array: output vector after applying ``mat`` to input ``vec`` on specified subsystems\n        \"\"\"\nnum_wires = len(device_wire_labels)\nif mat.shape != (2 ** num_wires, 2 ** num_wires):\n    raise ValueError(\n        f'Please specify a {(2 ** num_wires)} x {(2 ** num_wires)} matrix for {num_wires} wires.'\n        )\nmat = np.reshape(mat, [2] * len(device_wire_labels) * 2)\nvec = np.reshape(vec, [2] * self.num_wires)\naxes = np.arange(len(device_wire_labels), 2 * len(device_wire_labels)\n    ), device_wire_labels\ntdot = np.tensordot(mat, vec, axes=axes)\nunused_idxs = [idx for idx in range(self.num_wires) if idx not in\n    device_wire_labels]\nperm = device_wire_labels + unused_idxs\ninv_perm = np.argsort(perm)\nstate_multi_index = np.transpose(tdot, inv_perm)\nreturn np.reshape(state_multi_index, 2 ** self.num_wires)\n",
        "CUT_2": "\"\"\"Apply multiplication of a matrix to subsystems of the quantum state.\n\n        Args:\n            mat (array): matrix to multiply\n            vec (array): state vector to multiply\n            device_wire_labels (Sequence[int]): labels of device subsystems\n\n        Returns:\n            array: output vector after applying ``mat`` to input ``vec`` on specified subsystems\n        \"\"\"\nnum_wires = len(device_wire_labels)\nif mat.shape != (2 ** num_wires, 2 ** num_wires):\n    raise ValueError(\n        f'Please specify a {(2 ** num_wires)} x {(2 ** num_wires)} matrix for {num_wires} wires.'\n        )\nmat = np.reshape(mat, [2] * len(device_wire_labels) * 2)\nvec = np.reshape(vec, [2] * self.num_wires)\naxes = np.arange(len(device_wire_labels), 2 * len(device_wire_labels)\n    ), device_wire_labels\ntdot = np.tensordot(mat, vec, axes=axes)\nunused_idxs = [idx for idx in range(self.num_wires) if idx not in\n    device_wire_labels]\nperm = device_wire_labels + unused_idxs\ninv_perm = np.argsort(perm)\nstate_multi_index = np.transpose(tdot, inv_perm)\nreturn np.reshape(state_multi_index, 2 ** self.num_wires)\n",
        "CUT_3": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_4": "\"\"\"Applies a unitary to the first wire of a register in the ground state\n\n        Args:\n            mat (array): unitary matrix\n            num_wires (n): number of wires in the register\n        \"\"\"\nN = mat.shape[0]\ninit_state = np.zeros(N)\ninit_state[0] = 1\nresult = mat @ init_state\nfor _ in range(num_wires - int(np.log2(N))):\n    result = np.kron(result, np.array([1, 0]))\nreturn result\n",
        "CUT_5": "\"\"\"Apply a unitary operation to the ground state.\"\"\"\ndef _apply_unitary(mat, num_wires):\n    \"\"\"Applies a unitary to the first wire of a register in the ground state\n\n        Args:\n            mat (array): unitary matrix\n            num_wires (n): number of wires in the register\n        \"\"\"\n    N = mat.shape[0]\n    init_state = np.zeros(N)\n    init_state[0] = 1\n    result = mat @ init_state\n    for _ in range(num_wires - int(np.log2(N))):\n        result = np.kron(result, np.array([1, 0]))\n    return result\nreturn _apply_unitary\npytest.fixture"
    },
    {
        "functionName": "test_permutation_full_system",
        "className": "TestMatVecProduct",
        "fileName": "/tests/test_device.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that matrix-vector multiplication\n        over a permutation of the system agrees with standard\n        dense matrix multiplication\"\"\"\nwires = 2\ndev = ForestDevice(wires=wires, shots=1)\nvec = np.random.random([2 ** wires])\nres = dev.mat_vec_product(U2, vec, device_wire_labels=[1, 0])\nperm = np.array([0, 2, 1, 3])\nexpected = U2[:, (perm)][perm] @ vec\nassert np.allclose(res, expected, atol=tol, rtol=0)\n",
        "CUT_1": "\"\"\"Apply multiplication of a matrix to subsystems of the quantum state.\n\n        Args:\n            mat (array): matrix to multiply\n            vec (array): state vector to multiply\n            device_wire_labels (Sequence[int]): labels of device subsystems\n\n        Returns:\n            array: output vector after applying ``mat`` to input ``vec`` on specified subsystems\n        \"\"\"\nnum_wires = len(device_wire_labels)\nif mat.shape != (2 ** num_wires, 2 ** num_wires):\n    raise ValueError(\n        f'Please specify a {(2 ** num_wires)} x {(2 ** num_wires)} matrix for {num_wires} wires.'\n        )\nmat = np.reshape(mat, [2] * len(device_wire_labels) * 2)\nvec = np.reshape(vec, [2] * self.num_wires)\naxes = np.arange(len(device_wire_labels), 2 * len(device_wire_labels)\n    ), device_wire_labels\ntdot = np.tensordot(mat, vec, axes=axes)\nunused_idxs = [idx for idx in range(self.num_wires) if idx not in\n    device_wire_labels]\nperm = device_wire_labels + unused_idxs\ninv_perm = np.argsort(perm)\nstate_multi_index = np.transpose(tdot, inv_perm)\nreturn np.reshape(state_multi_index, 2 ** self.num_wires)\n",
        "CUT_2": "\"\"\"Apply multiplication of a matrix to subsystems of the quantum state.\n\n        Args:\n            mat (array): matrix to multiply\n            vec (array): state vector to multiply\n            device_wire_labels (Sequence[int]): labels of device subsystems\n\n        Returns:\n            array: output vector after applying ``mat`` to input ``vec`` on specified subsystems\n        \"\"\"\nnum_wires = len(device_wire_labels)\nif mat.shape != (2 ** num_wires, 2 ** num_wires):\n    raise ValueError(\n        f'Please specify a {(2 ** num_wires)} x {(2 ** num_wires)} matrix for {num_wires} wires.'\n        )\nmat = np.reshape(mat, [2] * len(device_wire_labels) * 2)\nvec = np.reshape(vec, [2] * self.num_wires)\naxes = np.arange(len(device_wire_labels), 2 * len(device_wire_labels)\n    ), device_wire_labels\ntdot = np.tensordot(mat, vec, axes=axes)\nunused_idxs = [idx for idx in range(self.num_wires) if idx not in\n    device_wire_labels]\nperm = device_wire_labels + unused_idxs\ninv_perm = np.argsort(perm)\nstate_multi_index = np.transpose(tdot, inv_perm)\nreturn np.reshape(state_multi_index, 2 ** self.num_wires)\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "self.matrix = matrix\n"
    },
    {
        "functionName": "test_consecutive_subsystem",
        "className": "TestMatVecProduct",
        "fileName": "/tests/test_device.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that matrix-vector multiplication\n        over a consecutive subset of the system agrees with standard\n        dense matrix multiplication\"\"\"\nwires = 3\ndev = ForestDevice(wires=wires, shots=1)\nvec = np.random.random([2 ** wires])\nres = dev.mat_vec_product(U2, vec, device_wire_labels=[1, 2])\nexpected = np.kron(I, U2) @ vec\nassert np.allclose(res, expected, atol=tol, rtol=0)\n",
        "CUT_1": "\"\"\"Apply multiplication of a matrix to subsystems of the quantum state.\n\n        Args:\n            mat (array): matrix to multiply\n            vec (array): state vector to multiply\n            device_wire_labels (Sequence[int]): labels of device subsystems\n\n        Returns:\n            array: output vector after applying ``mat`` to input ``vec`` on specified subsystems\n        \"\"\"\nnum_wires = len(device_wire_labels)\nif mat.shape != (2 ** num_wires, 2 ** num_wires):\n    raise ValueError(\n        f'Please specify a {(2 ** num_wires)} x {(2 ** num_wires)} matrix for {num_wires} wires.'\n        )\nmat = np.reshape(mat, [2] * len(device_wire_labels) * 2)\nvec = np.reshape(vec, [2] * self.num_wires)\naxes = np.arange(len(device_wire_labels), 2 * len(device_wire_labels)\n    ), device_wire_labels\ntdot = np.tensordot(mat, vec, axes=axes)\nunused_idxs = [idx for idx in range(self.num_wires) if idx not in\n    device_wire_labels]\nperm = device_wire_labels + unused_idxs\ninv_perm = np.argsort(perm)\nstate_multi_index = np.transpose(tdot, inv_perm)\nreturn np.reshape(state_multi_index, 2 ** self.num_wires)\n",
        "CUT_2": "\"\"\"Apply multiplication of a matrix to subsystems of the quantum state.\n\n        Args:\n            mat (array): matrix to multiply\n            vec (array): state vector to multiply\n            device_wire_labels (Sequence[int]): labels of device subsystems\n\n        Returns:\n            array: output vector after applying ``mat`` to input ``vec`` on specified subsystems\n        \"\"\"\nnum_wires = len(device_wire_labels)\nif mat.shape != (2 ** num_wires, 2 ** num_wires):\n    raise ValueError(\n        f'Please specify a {(2 ** num_wires)} x {(2 ** num_wires)} matrix for {num_wires} wires.'\n        )\nmat = np.reshape(mat, [2] * len(device_wire_labels) * 2)\nvec = np.reshape(vec, [2] * self.num_wires)\naxes = np.arange(len(device_wire_labels), 2 * len(device_wire_labels)\n    ), device_wire_labels\ntdot = np.tensordot(mat, vec, axes=axes)\nunused_idxs = [idx for idx in range(self.num_wires) if idx not in\n    device_wire_labels]\nperm = device_wire_labels + unused_idxs\ninv_perm = np.argsort(perm)\nstate_multi_index = np.transpose(tdot, inv_perm)\nreturn np.reshape(state_multi_index, 2 ** self.num_wires)\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "self.matrix = matrix\n"
    },
    {
        "functionName": "test_non_consecutive_subsystem",
        "className": "TestMatVecProduct",
        "fileName": "/tests/test_device.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that matrix-vector multiplication\n        over a non-consecutive subset of the system agrees with standard\n        dense matrix multiplication\"\"\"\nwires = 3\ndev = ForestDevice(wires=wires, shots=1)\nvec = np.random.random([2 ** wires])\nres = dev.mat_vec_product(U2, vec, device_wire_labels=[2, 0])\nperm = np.array([0, 4, 1, 5, 2, 6, 3, 7])\nexpected = np.kron(U2, I)[:, (perm)][perm] @ vec\nassert np.allclose(res, expected, atol=tol, rtol=0)\n",
        "CUT_1": "\"\"\"Apply multiplication of a matrix to subsystems of the quantum state.\n\n        Args:\n            mat (array): matrix to multiply\n            vec (array): state vector to multiply\n            device_wire_labels (Sequence[int]): labels of device subsystems\n\n        Returns:\n            array: output vector after applying ``mat`` to input ``vec`` on specified subsystems\n        \"\"\"\nnum_wires = len(device_wire_labels)\nif mat.shape != (2 ** num_wires, 2 ** num_wires):\n    raise ValueError(\n        f'Please specify a {(2 ** num_wires)} x {(2 ** num_wires)} matrix for {num_wires} wires.'\n        )\nmat = np.reshape(mat, [2] * len(device_wire_labels) * 2)\nvec = np.reshape(vec, [2] * self.num_wires)\naxes = np.arange(len(device_wire_labels), 2 * len(device_wire_labels)\n    ), device_wire_labels\ntdot = np.tensordot(mat, vec, axes=axes)\nunused_idxs = [idx for idx in range(self.num_wires) if idx not in\n    device_wire_labels]\nperm = device_wire_labels + unused_idxs\ninv_perm = np.argsort(perm)\nstate_multi_index = np.transpose(tdot, inv_perm)\nreturn np.reshape(state_multi_index, 2 ** self.num_wires)\n",
        "CUT_2": "\"\"\"Apply multiplication of a matrix to subsystems of the quantum state.\n\n        Args:\n            mat (array): matrix to multiply\n            vec (array): state vector to multiply\n            device_wire_labels (Sequence[int]): labels of device subsystems\n\n        Returns:\n            array: output vector after applying ``mat`` to input ``vec`` on specified subsystems\n        \"\"\"\nnum_wires = len(device_wire_labels)\nif mat.shape != (2 ** num_wires, 2 ** num_wires):\n    raise ValueError(\n        f'Please specify a {(2 ** num_wires)} x {(2 ** num_wires)} matrix for {num_wires} wires.'\n        )\nmat = np.reshape(mat, [2] * len(device_wire_labels) * 2)\nvec = np.reshape(vec, [2] * self.num_wires)\naxes = np.arange(len(device_wire_labels), 2 * len(device_wire_labels)\n    ), device_wire_labels\ntdot = np.tensordot(mat, vec, axes=axes)\nunused_idxs = [idx for idx in range(self.num_wires) if idx not in\n    device_wire_labels]\nperm = device_wire_labels + unused_idxs\ninv_perm = np.argsort(perm)\nstate_multi_index = np.transpose(tdot, inv_perm)\nreturn np.reshape(state_multi_index, 2 ** self.num_wires)\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "self.matrix = matrix\n"
    },
    {
        "functionName": "test_apply_basis_state_raises_an_error_if_not_first",
        "className": "TestMatVecProduct",
        "fileName": "/tests/test_device.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that there is an error raised when the BasisState is not\n        applied as the first operation.\"\"\"\nwires = 3\ndev = ForestDevice(wires=wires, shots=1)\noperation = qml.BasisState(np.array([1, 0, 0]), wires=list(range(wires)))\nqueue = [qml.PauliX(0), operation]\nwith pytest.raises(qml.DeviceError, match=\n    'Operation {} cannot be used after other Operations have already been applied'\n    .format(operation.name)):\n    dev.apply(queue)\n",
        "CUT_1": "rotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    par = operation.parameters\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_2": "rotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    par = operation.parameters\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_apply_qubitstatesvector_raises_an_error_if_not_first",
        "className": "TestMatVecProduct",
        "fileName": "/tests/test_device.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that there is an error raised when the QubitStateVector is not\n        applied as the first operation.\"\"\"\nwires = 1\ndev = ForestDevice(wires=wires, shots=1)\noperation = qml.QubitStateVector(np.array([1, 0]), wires=list(range(wires)))\nqueue = [qml.PauliX(0), operation]\nwith pytest.raises(qml.DeviceError, match=\n    'Operation {} cannot be used after other Operations have already been applied'\n    .format(operation.name)):\n    dev.apply(queue)\n",
        "CUT_1": "rotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    par = operation.parameters\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_2": "rotations = kwargs.get('rotations', [])\nself._active_wires = ForestDevice.active_wires(operations + rotations)\nfor i, operation in enumerate(operations):\n    device_wires = self.map_wires(operation.wires)\n    par = operation.parameters\n    if i > 0 and operation.name in ('QubitStateVector', 'BasisState'):\n        raise DeviceError(\n            'Operation {} cannot be used after other Operations have already been applied on a {} device.'\n            .format(operation.name, self.short_name))\n    self.prog += self._operation_map[operation.name](*par, *device_wires.labels\n        )\nself.prog += self.apply_rotations(rotations)\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_cphase_decomposition",
        "className": "TestDecompositions",
        "fileName": "/tests/test_ops.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the decomposition of CPHASE is correct.\"\"\"\nexpected_diagonal = np.array([1, 1, 1, 1], dtype=complex)\nexpected_diagonal[q] = np.exp(1.0j * phi)\nexpected_matrix = np.diag(expected_diagonal)\ndecomposition = CPHASE.decomposition(phi, q, wires=[0, 1])\ncalculated_matrix = np.eye(4, dtype=complex)\ndefault_qubit = qml.device('default.qubit', wires=2)\nfor gate in decomposition:\n    gate_matrix = gate.matrix\n    if gate.num_wires == 1:\n        if gate.wires[0] == Wires(0):\n            gate_matrix = np.kron(gate_matrix, np.eye(2, dtype=complex))\n        elif gate.wires[0] == Wires(1):\n            gate_matrix = np.kron(np.eye(2, dtype=complex), gate_matrix)\n    calculated_matrix = gate_matrix @ calculated_matrix\nassert np.allclose(expected_matrix, calculated_matrix, atol=tol, rtol=0)\npytest.mark.parametrize('phi', np.linspace(-np.pi, np.pi, num=10))pytest.mark.parametrize('q', [0, 1, 2, 3])",
        "CUT_1": "\"\"\"Resolve the matrix of the given pyquil gate.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate whose matrix should be resolved\n\n        Returns:\n            np.array: The matrix of the given gate\n        \"\"\"\ngate_matrix = self._matrix_dictionary[gate.name]\nfor i, modifier in enumerate(gate.modifiers):\n    if modifier == 'CONTROLLED':\n        gate_matrix = _controlled_matrix(gate_matrix)\nreturn gate_matrix\n",
        "CUT_2": "\"\"\"Resolve the matrix of the given pyquil gate.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate whose matrix should be resolved\n\n        Returns:\n            np.array: The matrix of the given gate\n        \"\"\"\ngate_matrix = self._matrix_dictionary[gate.name]\nfor i, modifier in enumerate(gate.modifiers):\n    if modifier == 'CONTROLLED':\n        gate_matrix = _controlled_matrix(gate_matrix)\nreturn gate_matrix\n",
        "CUT_3": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_4": "\"\"\"Return the matrix associated with the controlled operation.\n\n    Args:\n        op (np.array): Array representing the operation\n                       that should be controlled\n\n    Returns:\n        np.array: Array representing the controlled operations. If the input\n        array has shape (N, N) the output shape is (2*N, 2*N).\n    \"\"\"\nreturn _direct_sum(np.eye(op.shape[0], dtype=op.dtype), op)\n",
        "CUT_5": "\"\"\"Return the matrix associated with the controlled operation.\n\n    Args:\n        op (np.array): Array representing the operation\n                       that should be controlled\n\n    Returns:\n        np.array: Array representing the controlled operations. If the input\n        array has shape (N, N) the output shape is (2*N, 2*N).\n    \"\"\"\nreturn _direct_sum(np.eye(op.shape[0], dtype=op.dtype), op)\n"
    },
    {
        "functionName": "test_pswap_decomposition",
        "className": "TestDecompositions",
        "fileName": "/tests/test_ops.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the decomposition of PSWAP is correct.\"\"\"\nexpected_matrix = np.diag([1, np.exp(1.0j * phi), np.exp(1.0j * phi), 1])\nexpected_matrix = expected_matrix[:, ([0, 2, 1, 3])]\ndecomposition = PSWAP.decomposition(phi, wires=[0, 1])\ncalculated_matrix = np.eye(4, dtype=complex)\ndefault_qubit = qml.device('default.qubit', wires=2)\nfor gate in decomposition:\n    gate_matrix = gate.matrix\n    if gate.num_wires == 1:\n        if gate.wires[0] == Wires(0):\n            gate_matrix = np.kron(gate_matrix, np.eye(2, dtype=complex))\n        elif gate.wires[0] == Wires(1):\n            gate_matrix = np.kron(np.eye(2, dtype=complex), gate_matrix)\n    calculated_matrix = gate_matrix @ calculated_matrix\nassert np.allclose(expected_matrix, calculated_matrix, atol=tol, rtol=0)\npytest.mark.parametrize('phi', np.linspace(-np.pi, np.pi, num=10))",
        "CUT_1": "\"\"\"Resolve the matrix of the given pyquil gate.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate whose matrix should be resolved\n\n        Returns:\n            np.array: The matrix of the given gate\n        \"\"\"\ngate_matrix = self._matrix_dictionary[gate.name]\nfor i, modifier in enumerate(gate.modifiers):\n    if modifier == 'CONTROLLED':\n        gate_matrix = _controlled_matrix(gate_matrix)\nreturn gate_matrix\n",
        "CUT_2": "\"\"\"Resolve the matrix of the given pyquil gate.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate whose matrix should be resolved\n\n        Returns:\n            np.array: The matrix of the given gate\n        \"\"\"\ngate_matrix = self._matrix_dictionary[gate.name]\nfor i, modifier in enumerate(gate.modifiers):\n    if modifier == 'CONTROLLED':\n        gate_matrix = _controlled_matrix(gate_matrix)\nreturn gate_matrix\n",
        "CUT_3": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_4": "\"\"\"Maps the two-qubit controlled phase gate to the equivalent pyQuil command.\n\n    Args:\n        phi (float): the controlled phase angle\n        q (int): an integer between 0 and 3 that corresponds to a state\n            :math:`\\\\{00, 01, 10, 11\\\\}` on which the conditional phase\n            gets applied\n        wires (list): list of wires the CPHASE gate acts on\n\n    Returns:\n        pyquil.operation: the corresponding pyQuil operation\n    \"\"\"\nif q == 0:\n    return CPHASE00(phi, *wires)\nif q == 1:\n    return CPHASE01(phi, *wires)\nif q == 2:\n    return CPHASE10(phi, *wires)\nreturn CPHASE(phi, *wires)\n",
        "CUT_5": "\"\"\"Maps the two-qubit controlled phase gate to the equivalent pyQuil command.\n\n    Args:\n        phi (float): the controlled phase angle\n        q (int): an integer between 0 and 3 that corresponds to a state\n            :math:`\\\\{00, 01, 10, 11\\\\}` on which the conditional phase\n            gets applied\n        wires (list): list of wires the CPHASE gate acts on\n\n    Returns:\n        pyquil.operation: the corresponding pyQuil operation\n    \"\"\"\nif q == 0:\n    return CPHASE00(phi, *wires)\nif q == 1:\n    return CPHASE01(phi, *wires)\nif q == 2:\n    return CPHASE10(phi, *wires)\nreturn CPHASE(phi, *wires)\n"
    },
    {
        "functionName": "test_iswap_decomposition",
        "className": "TestDecompositions",
        "fileName": "/tests/test_ops.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the decomposition of ISWAP is correct.\"\"\"\nexpected_matrix = np.diag([1, 1.0j, 1.0j, 1])\nexpected_matrix = expected_matrix[:, ([0, 2, 1, 3])]\ndecomposition = ISWAP.decomposition(wires=[0, 1])\ncalculated_matrix = np.eye(4, dtype=complex)\ndefault_qubit = qml.device('default.qubit', wires=2)\nfor gate in decomposition:\n    gate_matrix = gate.matrix\n    if gate.num_wires == 1:\n        if gate.wires[0] == Wires(0):\n            gate_matrix = np.kron(gate_matrix, np.eye(2, dtype=complex))\n        elif gate.wires[0] == Wires(1):\n            gate_matrix = np.kron(np.eye(2, dtype=complex), gate_matrix)\n    calculated_matrix = gate_matrix @ calculated_matrix\nassert np.allclose(expected_matrix, calculated_matrix, atol=tol, rtol=0)\n",
        "CUT_1": "\"\"\"Resolve the matrix of the given pyquil gate.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate whose matrix should be resolved\n\n        Returns:\n            np.array: The matrix of the given gate\n        \"\"\"\ngate_matrix = self._matrix_dictionary[gate.name]\nfor i, modifier in enumerate(gate.modifiers):\n    if modifier == 'CONTROLLED':\n        gate_matrix = _controlled_matrix(gate_matrix)\nreturn gate_matrix\n",
        "CUT_2": "\"\"\"Resolve the matrix of the given pyquil gate.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate whose matrix should be resolved\n\n        Returns:\n            np.array: The matrix of the given gate\n        \"\"\"\ngate_matrix = self._matrix_dictionary[gate.name]\nfor i, modifier in enumerate(gate.modifiers):\n    if modifier == 'CONTROLLED':\n        gate_matrix = _controlled_matrix(gate_matrix)\nreturn gate_matrix\n",
        "CUT_3": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_4": "\"\"\"Determine if the given gate was defined in the pyquil Program.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate that shall be checked\n\n        Returns:\n            bool: True if the gate is defined, False otherwise\n        \"\"\"\nreturn gate.name in self._defined_gate_names\n",
        "CUT_5": "\"\"\"Determine if the given gate was defined in the pyquil Program.\n\n        Args:\n            gate (pyquil.quil.Gate): The gate that shall be checked\n\n        Returns:\n            bool: True if the gate is defined, False otherwise\n        \"\"\"\nreturn gate.name in self._defined_gate_names\n"
    },
    {
        "functionName": "test_convert_operation",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that single pyquil gates are properly converted.\"\"\"\nprogram = pyquil.Program()\nprogram += pyquil_operation\nwith OperationRecorder() as rec:\n    loader = load_program(program)\n    loader(wires=range(len(loader.defined_qubits)))\nassert rec.queue[0].name == expected_pl_operation.name\nassert rec.queue[0].wires == expected_pl_operation.wires\nassert rec.queue[0].data == expected_pl_operation.data\npytest.mark.parametrize('pyquil_operation,expected_pl_operation', [(g.I(0),\n    qml.Identity(wires=[0])), (g.H(0), qml.Hadamard(0)), (g.H(0).dagger(),\n    qml.Hadamard(0).inv()), (g.H(0).dagger().dagger(), qml.Hadamard(0).inv(\n    ).inv()), (g.S(0), qml.S(wires=[0])), (g.S(0).dagger(), qml.S(wires=[0]\n    ).inv()), (g.S(0).dagger().dagger(), qml.S(wires=[0]).inv().inv()), (g.\n    T(0), qml.T(wires=[0])), (g.T(0).dagger(), qml.T(wires=[0]).inv()), (g.\n    T(0).dagger().dagger(), qml.T(wires=[0]).inv().inv()), (g.X(0), qml.\n    PauliX(0)), (g.X(0).dagger(), qml.PauliX(0).inv()), (g.X(0).dagger().\n    dagger(), qml.PauliX(0).inv().inv()), (g.X(0).controlled(1), qml.CNOT(\n    wires=[1, 0])), (g.X(0).controlled(1).dagger(), qml.CNOT(wires=[1, 0]).\n    inv()), (g.X(0).controlled(1).dagger().dagger(), qml.CNOT(wires=[1, 0])\n    .inv().inv()), (g.X(0).controlled(1).controlled(2), plf.ops.CCNOT(wires\n    =[2, 1, 0])), (g.X(0).controlled(1).controlled(2).dagger(), plf.ops.\n    CCNOT(wires=[2, 1, 0]).inv()), (g.X(0).controlled(1).controlled(2).\n    dagger().dagger(), plf.ops.CCNOT(wires=[2, 1, 0]).inv().inv()), (g.Y(0),\n    qml.PauliY(0)), (g.Y(0).dagger(), qml.PauliY(0).inv()), (g.Y(0).dagger(\n    ).dagger(), qml.PauliY(0).inv().inv()), (g.Z(0), qml.PauliZ(0)), (g.Z(0\n    ).dagger(), qml.PauliZ(0).inv()), (g.Z(0).dagger().dagger(), qml.PauliZ\n    (0).inv().inv()), (g.Z(0).controlled(1), qml.CZ(wires=[1, 0])), (g.Z(0)\n    .controlled(1).dagger(), qml.CZ(wires=[1, 0]).inv()), (g.Z(0).\n    controlled(1).dagger().dagger(), qml.CZ(wires=[1, 0]).inv().inv()), (g.\n    CNOT(0, 1), qml.CNOT(wires=[0, 1])), (g.CNOT(0, 1).dagger(), qml.CNOT(\n    wires=[0, 1]).inv()), (g.CNOT(0, 1).dagger().dagger(), qml.CNOT(wires=[\n    0, 1]).inv().inv()), (g.CNOT(0, 1).controlled(2), plf.ops.CCNOT(wires=[\n    2, 0, 1])), (g.CNOT(0, 1).controlled(2).dagger(), plf.ops.CCNOT(wires=[\n    2, 0, 1]).inv()), (g.CNOT(0, 1).controlled(2).dagger().dagger(), plf.\n    ops.CCNOT(wires=[2, 0, 1]).inv().inv()), (g.SWAP(0, 1), qml.SWAP(wires=\n    [0, 1])), (g.SWAP(0, 1).dagger(), qml.SWAP(wires=[0, 1]).inv()), (g.\n    SWAP(0, 1).dagger().dagger(), qml.SWAP(wires=[0, 1]).inv().inv()), (g.\n    SWAP(0, 1).controlled(2), qml.CSWAP(wires=[2, 0, 1])), (g.SWAP(0, 1).\n    controlled(2).dagger(), qml.CSWAP(wires=[2, 0, 1]).inv()), (g.SWAP(0, 1\n    ).controlled(2).dagger().dagger(), qml.CSWAP(wires=[2, 0, 1]).inv().inv\n    ()), (g.ISWAP(0, 1), plf.ops.ISWAP(wires=[0, 1])), (g.ISWAP(0, 1).\n    dagger(), plf.ops.ISWAP(wires=[0, 1]).inv()), (g.ISWAP(0, 1).dagger().\n    dagger(), plf.ops.ISWAP(wires=[0, 1]).inv().inv()), (g.PSWAP(0.3, 0, 1),\n    plf.ops.PSWAP(0.3, wires=[0, 1])), (g.PSWAP(0.3, 0, 1).dagger(), plf.\n    ops.PSWAP(0.3, wires=[0, 1]).inv()), (g.PSWAP(0.3, 0, 1).dagger().\n    dagger(), plf.ops.PSWAP(0.3, wires=[0, 1]).inv().inv()), (g.CZ(0, 1),\n    qml.CZ(wires=[0, 1])), (g.CZ(0, 1).dagger(), qml.CZ(wires=[0, 1]).inv()\n    ), (g.CZ(0, 1).dagger().dagger(), qml.CZ(wires=[0, 1]).inv().inv()), (g\n    .PHASE(0.3, 0), qml.PhaseShift(0.3, wires=[0])), (g.PHASE(0.3, 0).\n    dagger(), qml.PhaseShift(0.3, wires=[0]).inv()), (g.PHASE(0.3, 0).\n    dagger().dagger(), qml.PhaseShift(0.3, wires=[0]).inv().inv()), (g.\n    PHASE(0.3, 0).controlled(1), plf.ops.CPHASE(0.3, 3, wires=[1, 0])), (g.\n    PHASE(0.3, 0).controlled(1).dagger(), plf.ops.CPHASE(0.3, 3, wires=[1, \n    0]).inv()), (g.PHASE(0.3, 0).controlled(1).dagger().dagger(), plf.ops.\n    CPHASE(0.3, 3, wires=[1, 0]).inv().inv()), (g.RX(0.3, 0), qml.RX(0.3,\n    wires=[0])), (g.RX(0.3, 0).dagger(), qml.RX(0.3, wires=[0]).inv()), (g.\n    RX(0.3, 0).dagger().dagger(), qml.RX(0.3, wires=[0]).inv().inv()), (g.\n    RX(0.3, 0).controlled(1), qml.CRX(0.3, wires=[1, 0])), (g.RX(0.3, 0).\n    controlled(1).dagger(), qml.CRX(0.3, wires=[1, 0]).inv()), (g.RX(0.3, 0\n    ).controlled(1).dagger().dagger(), qml.CRX(0.3, wires=[1, 0]).inv().inv\n    ()), (g.RY(0.3, 0), qml.RY(0.3, wires=[0])), (g.RY(0.3, 0).dagger(),\n    qml.RY(0.3, wires=[0]).inv()), (g.RY(0.3, 0).dagger().dagger(), qml.RY(\n    0.3, wires=[0]).inv().inv()), (g.RY(0.3, 0).controlled(1), qml.CRY(0.3,\n    wires=[1, 0])), (g.RY(0.3, 0).controlled(1).dagger(), qml.CRY(0.3,\n    wires=[1, 0]).inv()), (g.RY(0.3, 0).controlled(1).dagger().dagger(),\n    qml.CRY(0.3, wires=[1, 0]).inv().inv()), (g.RZ(0.3, 0), qml.RZ(0.3,\n    wires=[0])), (g.RZ(0.3, 0).dagger(), qml.RZ(0.3, wires=[0]).inv()), (g.\n    RZ(0.3, 0).dagger().dagger(), qml.RZ(0.3, wires=[0]).inv().inv()), (g.\n    RZ(0.3, 0).controlled(1), qml.CRZ(0.3, wires=[1, 0])), (g.RZ(0.3, 0).\n    controlled(1).dagger(), qml.CRZ(0.3, wires=[1, 0]).inv()), (g.RZ(0.3, 0\n    ).controlled(1).dagger().dagger(), qml.CRZ(0.3, wires=[1, 0]).inv().inv\n    ()), (g.CPHASE(0.3, 0, 1), plf.ops.CPHASE(0.3, 3, wires=[0, 1])), (g.\n    CPHASE(0.3, 0, 1).dagger(), plf.ops.CPHASE(0.3, 3, wires=[0, 1]).inv()),\n    (g.CPHASE(0.3, 0, 1).dagger().dagger(), plf.ops.CPHASE(0.3, 3, wires=[0,\n    1]).inv().inv()), (g.CPHASE00(0.3, 0, 1), plf.ops.CPHASE(0.3, 0, wires=\n    [0, 1])), (g.CPHASE00(0.3, 0, 1).dagger(), plf.ops.CPHASE(0.3, 0, wires\n    =[0, 1]).inv()), (g.CPHASE00(0.3, 0, 1).dagger().dagger(), plf.ops.\n    CPHASE(0.3, 0, wires=[0, 1]).inv().inv()), (g.CPHASE01(0.3, 0, 1), plf.\n    ops.CPHASE(0.3, 1, wires=[0, 1])), (g.CPHASE01(0.3, 0, 1).dagger(), plf\n    .ops.CPHASE(0.3, 1, wires=[0, 1]).inv()), (g.CPHASE01(0.3, 0, 1).dagger\n    ().dagger(), plf.ops.CPHASE(0.3, 1, wires=[0, 1]).inv().inv()), (g.\n    CPHASE10(0.3, 0, 1), plf.ops.CPHASE(0.3, 2, wires=[0, 1])), (g.CPHASE10\n    (0.3, 0, 1).dagger(), plf.ops.CPHASE(0.3, 2, wires=[0, 1]).inv()), (g.\n    CPHASE10(0.3, 0, 1).dagger().dagger(), plf.ops.CPHASE(0.3, 2, wires=[0,\n    1]).inv().inv()), (g.CSWAP(0, 1, 2), qml.CSWAP(wires=[0, 1, 2])), (g.\n    CSWAP(0, 1, 2).dagger(), qml.CSWAP(wires=[0, 1, 2]).inv()), (g.CSWAP(0,\n    1, 2).dagger().dagger(), qml.CSWAP(wires=[0, 1, 2]).inv().inv()), (g.\n    CCNOT(0, 1, 2), plf.ops.CCNOT(wires=[0, 1, 2])), (g.CCNOT(0, 1, 2).\n    dagger(), plf.ops.CCNOT(wires=[0, 1, 2]).inv()), (g.CCNOT(0, 1, 2).\n    dagger().dagger(), plf.ops.CCNOT(wires=[0, 1, 2]).inv().inv())])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_simple_program",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a simple program is properly converted.\"\"\"\nprogram = pyquil.Program()\nprogram += g.H(0)\nprogram += g.RZ(0.34, 1)\nprogram += g.CNOT(0, 3)\nprogram += g.H(2)\nprogram += g.H(7)\nprogram += g.X(7)\nprogram += g.Y(1)\nprogram += g.RZ(0.34, 1)\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(5))\nexpected_queue = [qml.Hadamard(0), qml.RZ(0.34, wires=[1]), qml.CNOT(wires=\n    [0, 3]), qml.Hadamard(2), qml.Hadamard(4), qml.PauliX(4), qml.PauliY(1),\n    qml.RZ(0.34, wires=[1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_simple_program_with_parameters",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a simple program with parameters is properly converted.\"\"\"\nprogram = pyquil.Program()\nalpha = program.declare('alpha', 'REAL')\nbeta = program.declare('beta', 'REAL')\ngamma = program.declare('gamma', 'REAL')\nprogram += g.H(0)\nprogram += g.CNOT(0, 1)\nprogram += g.RX(alpha, 1)\nprogram += g.RZ(beta, 1)\nprogram += g.RX(gamma, 1)\nprogram += g.CNOT(0, 1)\nprogram += g.H(0)\na, b, c = 0.1, 0.2, 0.3\nparameter_map = {'alpha': a, 'beta': b, 'gamma': c}\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(2), parameter_map=parameter_map)\nexpected_queue = [qml.Hadamard(0), qml.CNOT(wires=[0, 1]), qml.RX(0.1,\n    wires=[1]), qml.RZ(0.2, wires=[1]), qml.RX(0.3, wires=[1]), qml.CNOT(\n    wires=[0, 1]), qml.Hadamard(0)]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_parameter_not_given_error",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the correct error is raised if a parameter is not given.\"\"\"\nprogram = pyquil.Program()\nalpha = program.declare('alpha', 'REAL')\nbeta = program.declare('beta', 'REAL')\nprogram += g.H(0)\nprogram += g.CNOT(0, 1)\nprogram += g.RX(alpha, 1)\nprogram += g.RZ(beta, 1)\na = 0.1\nparameter_map = {'alpha': a}\nwith pytest.raises(qml.DeviceError, match=\n    'The PyQuil program defines a variable .* that is not present in the given variable map'\n    ):\n    load_program(program)(wires=range(2), parameter_map=parameter_map)\n",
        "CUT_1": "\"\"\"Check that all variables of the program are defined.\n\n        Only variables used in measurements need not be defined.\n\n        Args:\n            parameter_map (Dict[str, object]): Map that assigns values to variables\n\n        Raises:\n            qml.DeviceError: When not all variables are defined in the variable map\n        \"\"\"\nfor declaration in self._declarations:\n    if not declaration.name in parameter_map:\n        if not declaration.name in self._measurement_variable_names:\n            raise qml.DeviceError((\n                'The PyQuil program defines a variable {} that is not present in the given variable map. '\n                 + 'Instruction: {}').format(declaration.name, declaration))\n",
        "CUT_2": "\"\"\"Check that all variables of the program are defined.\n\n        Only variables used in measurements need not be defined.\n\n        Args:\n            parameter_map (Dict[str, object]): Map that assigns values to variables\n\n        Raises:\n            qml.DeviceError: When not all variables are defined in the variable map\n        \"\"\"\nfor declaration in self._declarations:\n    if not declaration.name in parameter_map:\n        if not declaration.name in self._measurement_variable_names:\n            raise qml.DeviceError((\n                'The PyQuil program defines a variable {} that is not present in the given variable map. '\n                 + 'Instruction: {}').format(declaration.name, declaration))\n",
        "CUT_3": "\"\"\"Load a pyquil.Program instance as a PennyLane template.\n\n    During loading, gates are converted to PennyLane gates as far as possible. If\n    the gates are not supported they are replaced with QubitUnitary instances. The\n    import ignores all statements that are not declarations or gates (e.g. pragmas,\n    classical control flow and measurements).\n\n    Every variable that is present in the Program and that is not used as the target\n    register of a measurement has to be provided in the ``parameter_map`` of the template.\n\n    Args:\n        program (pyquil.Program): The program that should be loaded\n\n    Returns:\n        ProgramLoader: a ProgramLoader instance that can be called like a template\n    \"\"\"\nreturn ProgramLoader(program)\n",
        "CUT_4": "\"\"\"Load a pyquil.Program instance as a PennyLane template.\n\n    During loading, gates are converted to PennyLane gates as far as possible. If\n    the gates are not supported they are replaced with QubitUnitary instances. The\n    import ignores all statements that are not declarations or gates (e.g. pragmas,\n    classical control flow and measurements).\n\n    Every variable that is present in the Program and that is not used as the target\n    register of a measurement has to be provided in the ``parameter_map`` of the template.\n\n    Args:\n        program (pyquil.Program): The program that should be loaded\n\n    Returns:\n        ProgramLoader: a ProgramLoader instance that can be called like a template\n    \"\"\"\nreturn ProgramLoader(program)\n",
        "CUT_5": "\"\"\"Returns the latest program that was compiled for running.\n\n        If parametric compilation is turned on, this will be a parametric program.\n\n        The pyquil.ExecutableDesignator.program attribute stores the pyquil.Program\n        instance. If no program was compiled yet, this property returns None.\n\n        Returns:\n            Union[None, pyquil.ExecutableDesignator]: the latest compiled program\n        \"\"\"\nreturn self._compiled_program\nproperty"
    },
    {
        "functionName": "test_convert_simple_program_with_parameters_mixed_keys",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a parametrized program is properly converted when\n        the variable map contains mixed key types.\"\"\"\nprogram = pyquil.Program()\nalpha = program.declare('alpha', 'REAL')\nbeta = program.declare('beta', 'REAL')\ngamma = program.declare('gamma', 'REAL')\ndelta = program.declare('delta', 'REAL')\nprogram += g.H(0)\nprogram += g.CNOT(0, 1)\nprogram += g.RX(alpha, 1)\nprogram += g.RZ(beta, 1)\nprogram += g.RX(gamma, 1)\nprogram += g.CNOT(0, 1)\nprogram += g.RZ(delta, 0)\nprogram += g.H(0)\na, b, c, d = 0.1, 0.2, 0.3, 0.4\nparameter_map = {'alpha': a, beta: b, gamma: c, 'delta': d}\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(2), parameter_map=parameter_map)\nexpected_queue = [qml.Hadamard(0), qml.CNOT(wires=[0, 1]), qml.RX(0.1,\n    wires=[1]), qml.RZ(0.2, wires=[1]), qml.RX(0.3, wires=[1]), qml.CNOT(\n    wires=[0, 1]), qml.RZ(0.4, wires=[0]), qml.Hadamard(0)]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_simple_program_wire_assignment",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the assignment of qubits to wires works as expected.\"\"\"\nprogram = pyquil.Program()\nprogram += g.H(0)\nprogram += g.RZ(0.34, 1)\nprogram += g.CNOT(0, 3)\nprogram += g.H(2)\nprogram += g.H(7)\nprogram += g.X(7)\nprogram += g.Y(1)\nprogram += g.RZ(0.34, 1)\nwith OperationRecorder() as rec:\n    load_program(program)(wires=[3, 6, 4, 9, 1])\nexpected_queue = [qml.Hadamard(3), qml.RZ(0.34, wires=[6]), qml.CNOT(wires=\n    [3, 9]), qml.Hadamard(4), qml.Hadamard(1), qml.PauliX(1), qml.PauliY(6),\n    qml.RZ(0.34, wires=[6])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_wire_error",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the conversion raises an error if the given number\n        of wires doesn't match the number of qubits in the Program.\"\"\"\nprogram = pyquil.Program()\nprogram += g.H(0)\nprogram += g.H(1)\nprogram += g.H(2)\nwith pytest.raises(qml.DeviceError, match=\n    'The number of given wires does not match the number of qubits in the PyQuil Program'\n    ):\n    load_program(program)(wires=wires)\npytest.mark.parametrize('wires', [[0, 1, 2, 3], [4, 5]])",
        "CUT_1": "\"\"\"Build the map that assigns wires to qubits.\n\n        Args:\n            wires (Sequence[int]): The wires that should be assigned to the qubits\n\n        Raises:\n            qml.DeviceError: When the number of given wires does not match the number of qubits in the pyquil Program\n\n        Returns:\n            Dict[int, int]: The map that assigns wires to qubits\n        \"\"\"\nif len(wires) != len(self.qubits):\n    raise qml.DeviceError(\n        'The number of given wires does not match the number of qubits in the PyQuil Program. '\n         + '{} wires were given, Program has {} qubits'.format(len(wires),\n        len(self.qubits)))\nself._qubit_to_wire_map = dict(zip(self.qubits, wires))\nreturn self._qubit_to_wire_map\n",
        "CUT_2": "\"\"\"Build the map that assigns wires to qubits.\n\n        Args:\n            wires (Sequence[int]): The wires that should be assigned to the qubits\n\n        Raises:\n            qml.DeviceError: When the number of given wires does not match the number of qubits in the pyquil Program\n\n        Returns:\n            Dict[int, int]: The map that assigns wires to qubits\n        \"\"\"\nif len(wires) != len(self.qubits):\n    raise qml.DeviceError(\n        'The number of given wires does not match the number of qubits in the PyQuil Program. '\n         + '{} wires were given, Program has {} qubits'.format(len(wires),\n        len(self.qubits)))\nself._qubit_to_wire_map = dict(zip(self.qubits, wires))\nreturn self._qubit_to_wire_map\n",
        "CUT_3": "\"\"\"The names of the custom gates defined in the pyquil Program.\n\n        Returns:\n            List[str]: The names of the gates defined in the pyquil Program\n        \"\"\"\nreturn self._defined_gate_names\nproperty",
        "CUT_4": "\"\"\"The names of the custom gates defined in the pyquil Program.\n\n        Returns:\n            List[str]: The names of the gates defined in the pyquil Program\n        \"\"\"\nreturn self._defined_gate_names\nproperty",
        "CUT_5": "\"\"\"The declarations in the pyquil Program.\n\n        Returns:\n            List[pyquil.quil.Declaration]: The declarations in the pyquil Program\n        \"\"\"\nreturn self._declarations\nproperty"
    },
    {
        "functionName": "test_convert_program_with_inverses",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program with inverses is properly converted.\"\"\"\nprogram = pyquil.Program()\nprogram += g.H(0)\nprogram += g.RZ(0.34, 1).dagger()\nprogram += g.CNOT(0, 3).dagger()\nprogram += g.H(2)\nprogram += g.H(7).dagger().dagger()\nprogram += g.X(7).dagger()\nprogram += g.X(7)\nprogram += g.Y(1)\nprogram += g.RZ(0.34, 1)\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(5))\nexpected_queue = [qml.Hadamard(0), qml.RZ(0.34, wires=[1]).inv(), qml.CNOT(\n    wires=[0, 3]).inv(), qml.Hadamard(2), qml.Hadamard(4), qml.PauliX(4).\n    inv(), qml.PauliX(4), qml.PauliY(1), qml.RZ(0.34, wires=[1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_program_with_controlled_operations",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program with controlled operations is properly converted.\"\"\"\nprogram = pyquil.Program()\nprogram += g.RZ(0.34, 1)\nprogram += g.RY(0.2, 3).controlled(2)\nprogram += g.RX(0.4, 2).controlled(0)\nprogram += g.CNOT(1, 4)\nprogram += g.CNOT(1, 6).controlled(3)\nprogram += g.X(3).controlled(4).controlled(1)\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(6))\nexpected_queue = [qml.RZ(0.34, wires=[1]), qml.CRY(0.2, wires=[2, 3]), qml.\n    CRX(0.4, wires=[0, 2]), qml.CNOT(wires=[1, 4]), plf.ops.CCNOT(wires=[3,\n    1, 5]), plf.ops.CCNOT(wires=[1, 4, 3])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_program_with_controlled_operations_not_in_pl_core",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program with controlled operations out of scope of PL core/PLF\n        is properly converted, i.e. the operations are replaced with controlled operations.\"\"\"\nprogram = pyquil.Program()\nCS_matrix = np.eye(4, dtype=complex)\nCS_matrix[3, 3] = 1.0j\nCCT_matrix = np.eye(8, dtype=complex)\nCCT_matrix[7, 7] = np.exp(1.0j * np.pi / 4)\nprogram += g.CNOT(0, 1)\nprogram += g.S(0).controlled(1)\nprogram += g.S(1).controlled(0)\nprogram += g.T(0).controlled(1).controlled(2)\nprogram += g.T(1).controlled(0).controlled(2)\nprogram += g.T(2).controlled(1).controlled(0)\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(3))\nexpected_queue = [qml.CNOT(wires=[0, 1]), qml.QubitUnitary(CS_matrix, wires\n    =[1, 0]), qml.QubitUnitary(CS_matrix, wires=[0, 1]), qml.QubitUnitary(\n    CCT_matrix, wires=[2, 1, 0]), qml.QubitUnitary(CCT_matrix, wires=[2, 0,\n    1]), qml.QubitUnitary(CCT_matrix, wires=[0, 1, 2])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert np.allclose(converted.data, expected.data, atol=tol, rtol=0)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "\"\"\"Instantiate the QubitUnitary on the given wires.\n\n        Args:\n            wires (List[int]): The wires the QubitUnitary acts on\n\n        Returns:\n            qml.QubitUnitary: The instantiate QubitUnitary instance\n        \"\"\"\nreturn qml.QubitUnitary(self.matrix, wires=wires)\n",
        "CUT_4": "\"\"\"Instantiate the QubitUnitary on the given wires.\n\n        Args:\n            wires (List[int]): The wires the QubitUnitary acts on\n\n        Returns:\n            qml.QubitUnitary: The instantiate QubitUnitary instance\n        \"\"\"\nreturn qml.QubitUnitary(self.matrix, wires=wires)\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_program_with_controlled_dagger_operations",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program that combines controlled and daggered operations\n        is properly converted.\"\"\"\nprogram = pyquil.Program()\nprogram += g.CNOT(0, 1).controlled(2)\nprogram += g.CNOT(0, 1).dagger().controlled(2)\nprogram += g.CNOT(0, 1).controlled(2).dagger()\nprogram += g.CNOT(0, 1).dagger().controlled(2).dagger()\nprogram += g.RX(0.3, 3).controlled(4)\nprogram += g.RX(0.2, 3).controlled(4).dagger()\nprogram += g.RX(0.3, 3).dagger().controlled(4)\nprogram += g.RX(0.2, 3).dagger().controlled(4).dagger()\nprogram += g.X(2).dagger().controlled(4).controlled(1).dagger()\nprogram += g.X(0).dagger().controlled(4).controlled(1)\nprogram += g.X(0).dagger().controlled(4).dagger().dagger().controlled(1\n    ).dagger()\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(5))\nexpected_queue = [plf.ops.CCNOT(wires=[2, 0, 1]), plf.ops.CCNOT(wires=[2, 0,\n    1]).inv(), plf.ops.CCNOT(wires=[2, 0, 1]).inv(), plf.ops.CCNOT(wires=[2,\n    0, 1]), qml.CRX(0.3, wires=[4, 3]), qml.CRX(0.2, wires=[4, 3]).inv(),\n    qml.CRX(0.3, wires=[4, 3]).inv(), qml.CRX(0.2, wires=[4, 3]), plf.ops.\n    CCNOT(wires=[1, 4, 2]), plf.ops.CCNOT(wires=[1, 4, 0]).inv(), plf.ops.\n    CCNOT(wires=[1, 4, 0])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_program_with_defgates",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program that defines its own gates is properly converted.\"\"\"\nprogram = pyquil.Program()\nsqrt_x = np.array([[0.5 + 0.5j, 0.5 - 0.5j], [0.5 - 0.5j, 0.5 + 0.5j]])\nsqrt_x_t2 = np.kron(sqrt_x, sqrt_x)\nsqrt_x_t3 = np.kron(sqrt_x, sqrt_x_t2)\nsqrt_x_definition = pyquil.quil.DefGate('SQRT-X', sqrt_x)\nSQRT_X = sqrt_x_definition.get_constructor()\nsqrt_x_t2_definition = pyquil.quil.DefGate('SQRT-X-T2', sqrt_x_t2)\nSQRT_X_T2 = sqrt_x_t2_definition.get_constructor()\nsqrt_x_t3_definition = pyquil.quil.DefGate('SQRT-X-T3', sqrt_x_t3)\nSQRT_X_T3 = sqrt_x_t3_definition.get_constructor()\nprogram += sqrt_x_definition\nprogram += sqrt_x_t2_definition\nprogram += sqrt_x_t3_definition\nprogram += g.CNOT(0, 1)\nprogram += SQRT_X(0)\nprogram += SQRT_X_T2(1, 2)\nprogram += SQRT_X_T3(1, 0, 2)\nprogram += g.CNOT(0, 1)\nprogram += g.CNOT(1, 2)\nprogram += g.CNOT(2, 0)\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(3))\nexpected_queue = [qml.CNOT(wires=[0, 1]), qml.QubitUnitary(sqrt_x, wires=[0\n    ]), qml.QubitUnitary(sqrt_x_t2, wires=[1, 2]), qml.QubitUnitary(\n    sqrt_x_t3, wires=[1, 0, 2]), qml.CNOT(wires=[0, 1]), qml.CNOT(wires=[1,\n    2]), qml.CNOT(wires=[2, 0])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_program_with_controlled_defgates",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program with controlled defined gates is properly\n        converted.\"\"\"\nprogram = pyquil.Program()\nsqrt_x = np.array([[0.5 + 0.5j, 0.5 - 0.5j], [0.5 - 0.5j, 0.5 + 0.5j]])\nsqrt_x_t2 = np.kron(sqrt_x, sqrt_x)\nc_sqrt_x = np.eye(4, dtype=complex)\nc_sqrt_x[2:, 2:] = sqrt_x\nc_sqrt_x_t2 = np.eye(8, dtype=complex)\nc_sqrt_x_t2[4:, 4:] = sqrt_x_t2\nsqrt_x_definition = pyquil.quil.DefGate('SQRT-X', sqrt_x)\nSQRT_X = sqrt_x_definition.get_constructor()\nsqrt_x_t2_definition = pyquil.quil.DefGate('SQRT-X-T2', sqrt_x_t2)\nSQRT_X_T2 = sqrt_x_t2_definition.get_constructor()\nprogram += sqrt_x_definition\nprogram += sqrt_x_t2_definition\nprogram += g.CNOT(0, 1)\nprogram += SQRT_X(0).controlled(1)\nprogram += SQRT_X_T2(1, 2).controlled(0)\nprogram += g.X(0).controlled(1)\nprogram += g.RX(0.4, 0)\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(3))\nexpected_queue = [qml.CNOT(wires=[0, 1]), qml.QubitUnitary(c_sqrt_x, wires=\n    [1, 0]), qml.QubitUnitary(c_sqrt_x_t2, wires=[0, 1, 2]), qml.CNOT(wires\n    =[1, 0]), qml.RX(0.4, wires=[0])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert np.allclose(converted.data, expected.data, atol=tol, rtol=0)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_program_with_defpermutationgates",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program with gates defined via DefPermutationGate is\n        properly converted.\"\"\"\nprogram = pyquil.Program()\nexpected_matrix = np.eye(4)\nexpected_matrix = expected_matrix[:, ([1, 0, 3, 2])]\nx_plus_x_definition = pyquil.quil.DefPermutationGate('X+X', [1, 0, 3, 2])\nX_plus_X = x_plus_x_definition.get_constructor()\nprogram += x_plus_x_definition\nprogram += g.CNOT(0, 1)\nprogram += X_plus_X(0, 1)\nprogram += g.CNOT(0, 1)\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(2))\nexpected_queue = [qml.CNOT(wires=[0, 1]), qml.QubitUnitary(expected_matrix,\n    wires=[0, 1]), qml.CNOT(wires=[0, 1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert np.array_equal(converted.data, expected.data)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_program_with_controlled_defpermutationgates",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program that uses controlled permutation gates\n        is properly converted.\"\"\"\nprogram = pyquil.Program()\nexpected_matrix = np.eye(4)\nexpected_matrix = expected_matrix[:, ([1, 0, 3, 2])]\nexpected_controlled_matrix = np.eye(8)\nexpected_controlled_matrix[4:, 4:] = expected_matrix\nx_plus_x_definition = pyquil.quil.DefPermutationGate('X+X', [1, 0, 3, 2])\nX_plus_X = x_plus_x_definition.get_constructor()\nprogram += x_plus_x_definition\nprogram += g.CNOT(0, 1)\nprogram += X_plus_X(0, 1).controlled(2)\nprogram += X_plus_X(1, 2).controlled(0)\nprogram += g.CNOT(0, 1)\nwith OperationRecorder() as rec:\n    load_program(program)(wires=range(3))\nexpected_queue = [qml.CNOT(wires=[0, 1]), qml.QubitUnitary(\n    expected_controlled_matrix, wires=[2, 0, 1]), qml.QubitUnitary(\n    expected_controlled_matrix, wires=[0, 1, 2]), qml.CNOT(wires=[0, 1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert np.array_equal(converted.data, expected.data)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_forked_gate_error",
        "className": "TestProgramConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an error is raised if conversion of a\n        forked gate is attempted.\"\"\"\nprogram = pyquil.Program()\nprogram += g.CNOT(0, 1)\nprogram += g.RX(0.3, 1).forked(2, [0.5])\nprogram += g.CNOT(0, 1)\nwith pytest.raises(qml.DeviceError, match=\n    'Forked gates can not be imported into PennyLane, as this functionality is not supported'\n    ):\n    load_program(program)(wires=range(3))\n",
        "CUT_1": "\"\"\"Determine if a gate is forked.\n\n    Args:\n        gate (pyquil.quil.Gate): The gate that should be checked\n\n    Returns:\n        bool: True if the gate is forked, False otherwise\n    \"\"\"\nreturn 'FORKED' in gate.modifiers\n",
        "CUT_2": "\"\"\"Determine if a gate is forked.\n\n    Args:\n        gate (pyquil.quil.Gate): The gate that should be checked\n\n    Returns:\n        bool: True if the gate is forked, False otherwise\n    \"\"\"\nreturn 'FORKED' in gate.modifiers\n",
        "CUT_3": "\"\"\"Load the template corresponding to the pyquil Program.\n\n        Raises:\n            qml.DeviceError: When the import of a forked gate is attempted\n        \"\"\"\nself._parametrized_gates = []\nfor i, instruction in enumerate(self.program.instructions):\n    if not _is_gate(instruction):\n        if not _is_declaration(instruction):\n            warnings.warn(\n                'Instruction Nr. {} is not supported by PennyLane and was ignored: {}'\n                .format(i + 1, instruction))\n        continue\n    gate = instruction\n    if _is_forked(gate):\n        raise qml.DeviceError(\n            'Forked gates can not be imported into PennyLane, as this functionality is not supported. '\n             + 'Instruction Nr. {}, {} was a forked gate.'.format(i + 1, gate))\n    resolved_gate = _resolve_gate(gate)\n    if _is_controlled(resolved_gate) or self._is_defined_gate(resolved_gate):\n        pl_gate = ParametrizedQubitUnitary(self._resolve_gate_matrix(\n            resolved_gate))\n    else:\n        pl_gate = pyquil_inv_operation_map[resolved_gate.name]\n    parametrized_gate = ParametrizedGate(pl_gate, gate.qubits, gate.params,\n        _is_inverted(gate))\n    self._parametrized_gates.append(parametrized_gate)\n",
        "CUT_4": "\"\"\"Load the template corresponding to the pyquil Program.\n\n        Raises:\n            qml.DeviceError: When the import of a forked gate is attempted\n        \"\"\"\nself._parametrized_gates = []\nfor i, instruction in enumerate(self.program.instructions):\n    if not _is_gate(instruction):\n        if not _is_declaration(instruction):\n            warnings.warn(\n                'Instruction Nr. {} is not supported by PennyLane and was ignored: {}'\n                .format(i + 1, instruction))\n        continue\n    gate = instruction\n    if _is_forked(gate):\n        raise qml.DeviceError(\n            'Forked gates can not be imported into PennyLane, as this functionality is not supported. '\n             + 'Instruction Nr. {}, {} was a forked gate.'.format(i + 1, gate))\n    resolved_gate = _resolve_gate(gate)\n    if _is_controlled(resolved_gate) or self._is_defined_gate(resolved_gate):\n        pl_gate = ParametrizedQubitUnitary(self._resolve_gate_matrix(\n            resolved_gate))\n    else:\n        pl_gate = pyquil_inv_operation_map[resolved_gate.name]\n    parametrized_gate = ParametrizedGate(pl_gate, gate.qubits, gate.params,\n        _is_inverted(gate))\n    self._parametrized_gates.append(parametrized_gate)\n",
        "CUT_5": "\"\"\"Load a pyquil.Program instance as a PennyLane template.\n\n    During loading, gates are converted to PennyLane gates as far as possible. If\n    the gates are not supported they are replaced with QubitUnitary instances. The\n    import ignores all statements that are not declarations or gates (e.g. pragmas,\n    classical control flow and measurements).\n\n    Every variable that is present in the Program and that is not used as the target\n    register of a measurement has to be provided in the ``parameter_map`` of the template.\n\n    Args:\n        program (pyquil.Program): The program that should be loaded\n\n    Returns:\n        ProgramLoader: a ProgramLoader instance that can be called like a template\n    \"\"\"\nreturn ProgramLoader(program)\n"
    },
    {
        "functionName": "test_convert_simple_program",
        "className": "TestQuilConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a simple program is properly converted.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            H 0\n            RZ(0.34) 1\n            CNOT 0 3\n            H 2\n            H 7\n            X 7\n            Y 1\n            RZ(0.34) 1\n        \"\"\"\n    )\nwith OperationRecorder() as rec:\n    load_quil(quil_str)(wires=range(5))\nexpected_queue = [qml.Hadamard(0), qml.RZ(0.34, wires=[1]), qml.CNOT(wires=\n    [0, 3]), qml.Hadamard(2), qml.Hadamard(4), qml.PauliX(4), qml.PauliY(1),\n    qml.RZ(0.34, wires=[1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_program_with_classical_control_flow",
        "className": "TestQuilConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program with classical control flow is properly converted.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            DECLARE flag_register BIT[1]\n            MOVE flag_register 1\n            LABEL @START1\n            JUMP-UNLESS @END2 flag_register\n            X 0\n            H 0\n            MEASURE 0 flag_register\n            JUMP @START1\n            LABEL @END2\n        \"\"\"\n    )\nflag = 0.0\nwith OperationRecorder() as rec:\n    load_quil(quil_str)(wires=[0], parameter_map={'flag_register': flag})\nexpected_queue = [qml.PauliX(0), qml.Hadamard(0)]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "\"\"\"Load a quil string as a PennyLane template.\n\n    During loading, gates are converted to PennyLane gates as far as possible. If\n    the gates are not supported they are replaced with QubitUnitary instances. The\n    import ignores all statements that are not declarations or gates (e.g. pragmas,\n    classical control flow and measurements).\n\n    Every variable that is present in the Program and that is not used as the target\n    register of a measurement has to be provided in the ``parameter_map`` of the template.\n\n    Args:\n        quil_str (str): The program that should be loaded\n\n    Returns:\n        ProgramLoader: a ProgramLoader instance that can be called like a template\n    \"\"\"\nreturn load_program(pyquil.Program(quil_str))\n"
    },
    {
        "functionName": "test_convert_program_with_pragmas",
        "className": "TestQuilConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program with pragmas is properly converted.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            PRAGMA INITIAL_REWIRING \"GREEDY\"\n            PRAGMA PRESERVE_BLOCK\n            I 0\n            I 1\n            PRAGMA END_PRESERVE_BLOCK\n            PRAGMA COMMUTING_BLOCKS\n            PRAGMA BLOCK\n            CNOT 0 1\n            RZ(0.4) 1\n            CNOT 0 1\n            PRAGMA END_BLOCK\n            PRAGMA BLOCK\n            CNOT 1 2\n            RZ(0.6) 2\n            CNOT 1 2\n            PRAGMA END_BLOCK\n            PRAGMA END_COMMUTING_BLOCKS\n            H 0\n        \"\"\"\n    )\nwith OperationRecorder() as rec:\n    load_quil(quil_str)(wires=range(3))\nexpected_queue = [qml.Identity(wires=[0]), qml.Identity(wires=[1]), qml.\n    CNOT(wires=[0, 1]), qml.RZ(0.4, wires=[1]), qml.CNOT(wires=[0, 1]), qml\n    .CNOT(wires=[1, 2]), qml.RZ(0.6, wires=[2]), qml.CNOT(wires=[1, 2]),\n    qml.Hadamard(0)]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_complex_program",
        "className": "TestQuilConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a more complicated program is properly converted.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            H 0\n            DAGGER RZ(0.34) 1\n            CNOT 0 3\n            H 2\n            CONTROLLED S 1 7\n            DAGGER CONTROLLED X 3 7\n            DAGGER DAGGER Y 1\n            RZ(0.34) 1\n        \"\"\"\n    )\nwith OperationRecorder() as rec:\n    load_quil(quil_str)(wires=range(5))\nCS_matrix = np.eye(4, dtype=complex)\nCS_matrix[3, 3] = 1.0j\nexpected_queue = [qml.Hadamard(0), qml.RZ(0.34, wires=[1]).inv(), qml.CNOT(\n    wires=[0, 3]), qml.Hadamard(2), qml.QubitUnitary(CS_matrix, wires=[1, 4\n    ]), qml.CNOT(wires=[3, 4]).inv(), qml.PauliY(1), qml.RZ(0.34, wires=[1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert np.array_equal(converted.data, expected.data)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_simple_program_with_parameters",
        "className": "TestQuilConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a simple parametrized program is properly converted.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            DECLARE alpha REAL[1]\n            DECLARE beta REAL[1]\n            DECLARE gamma REAL[1]\n\n            H 0\n            CNOT 0 1\n            RX(alpha) 1\n            RZ(beta) 1\n            RX(gamma) 1\n            CNOT 0 1\n            H 0\n        \"\"\"\n    )\na, b, c = 0.1, 0.2, 0.3\nparameter_map = {'alpha': a, 'beta': b, 'gamma': c}\nwith OperationRecorder() as rec:\n    load_quil(quil_str)(wires=range(2), parameter_map=parameter_map)\nexpected_queue = [qml.Hadamard(0), qml.CNOT(wires=[0, 1]), qml.RX(0.1,\n    wires=[1]), qml.RZ(0.2, wires=[1]), qml.RX(0.3, wires=[1]), qml.CNOT(\n    wires=[0, 1]), qml.Hadamard(0)]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_program_with_parameters_and_measurements",
        "className": "TestQuilConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program with parameters and measurements is properly converted.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            DECLARE alpha REAL[1]\n            DECLARE beta REAL[1]\n            DECLARE gamma REAL[1]\n            DECLARE ro BIT[2]\n\n            H 0\n            CNOT 0 1\n            RX(alpha) 1\n            RZ(beta) 1\n            RX(gamma) 1\n            CNOT 0 1\n            H 0\n\n            MEASURE 0 ro[0]\n            MEASURE 1 ro[1]\n        \"\"\"\n    )\na, b, c = 0.1, 0.2, 0.3\nparameter_map = {'alpha': a, 'beta': b, 'gamma': c}\nwith OperationRecorder() as rec:\n    load_quil(quil_str)(wires=range(2), parameter_map=parameter_map)\nexpected_queue = [qml.Hadamard(0), qml.CNOT(wires=[0, 1]), qml.RX(0.1,\n    wires=[1]), qml.RZ(0.2, wires=[1]), qml.RX(0.3, wires=[1]), qml.CNOT(\n    wires=[0, 1]), qml.Hadamard(0)]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_program_with_defgates",
        "className": "TestQuilConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a program with defined gates is properly converted.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            DEFGATE SQRT-X:\n                0.5+0.5i, 0.5-0.5i\n                0.5-0.5i, 0.5+0.5i\n\n            H 0\n            CNOT 0 1\n            SQRT-X 0\n            SQRT-X 1\n            H 1\n            CONTROLLED SQRT-X 0 1\n        \"\"\"\n    )\nsqrt_x = np.array([[0.5 + 0.5j, 0.5 - 0.5j], [0.5 - 0.5j, 0.5 + 0.5j]])\nc_sqrt_x = np.eye(4, dtype=complex)\nc_sqrt_x[2:, 2:] = sqrt_x\nwith OperationRecorder() as rec:\n    load_quil(quil_str)(wires=range(2))\nexpected_queue = [qml.Hadamard(0), qml.CNOT(wires=[0, 1]), qml.QubitUnitary\n    (sqrt_x, wires=[0]), qml.QubitUnitary(sqrt_x, wires=[1]), qml.Hadamard(\n    1), qml.QubitUnitary(c_sqrt_x, wires=[0, 1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert np.array_equal(converted.data, expected.data)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_convert_simple_program",
        "className": "TestQuilFileConverter",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a simple program in a quil file is properly converted.\"\"\"\ncur_dir = os.path.dirname(os.path.abspath(__file__))\nwith OperationRecorder() as rec:\n    load_quil_from_file(os.path.join(cur_dir, 'simple_program.quil'))(wires\n        =range(5))\nexpected_queue = [qml.Hadamard(0), qml.RZ(0.34, wires=[1]), qml.CNOT(wires=\n    [0, 3]), qml.Hadamard(2), qml.Hadamard(4), qml.PauliX(4), qml.PauliY(1),\n    qml.RZ(0.34, wires=[1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_inspection",
        "className": "TestInspectionProperties",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the combined inspection properties.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            DECLARE alpha REAL[1]\n            DECLARE beta REAL[1]\n            DECLARE gamma REAL[1]\n\n            DEFGATE SQRT-X:\n                0.5+0.5i, 0.5-0.5i\n                0.5-0.5i, 0.5+0.5i\n\n            H 0\n            DAGGER RZ(0.34) 1\n            CNOT 0 3\n            H 2\n            RX(alpha) 1\n            RZ(beta) 1\n            CONTROLLED S 1 7\n            DAGGER CONTROLLED X 3 7\n            DAGGER DAGGER Y 1\n            H 1\n            CONTROLLED SQRT-X 0 1\n            RZ(0.34) 1\n        \"\"\"\n    )\nsqrt_x = np.array([[0.5 + 0.5j, 0.5 - 0.5j], [0.5 - 0.5j, 0.5 + 0.5j]])\nloader = load_quil(quil_str)\nassert loader.declarations[0].name == 'alpha'\nassert loader.declarations[1].name == 'beta'\nassert loader.declarations[2].name == 'gamma'\nassert loader.defined_variable_names[0] == 'alpha'\nassert loader.defined_variable_names[1] == 'beta'\nassert loader.defined_variable_names[2] == 'gamma'\nassert loader.defined_gates[0].name == 'SQRT-X'\nassert loader.defined_gate_names[0] == 'SQRT-X'\nassert loader.defined_qubits == [0, 1, 2, 3, 7]\n",
        "CUT_1": "\"\"\"Replaces unittest TestCase.assertTrue\"\"\"\nassert first\n",
        "CUT_2": "\"\"\"Replaces unittest TestCase.assertFalse\"\"\"\nassert not first\n",
        "CUT_3": "\"\"\"Replaces unittest TestCase.assertEqual\"\"\"\nassert first == second\n",
        "CUT_4": "\"\"\"Give the string representation of the ProgramLoader.\n\n        Returns:\n            str: The string representation of the ProgramLoader\n        \"\"\"\nreturn 'PennyLane Program Loader for PyQuil Program:\\n' + str(self.program)\n",
        "CUT_5": "\"\"\"Give the string representation of the ProgramLoader.\n\n        Returns:\n            str: The string representation of the ProgramLoader\n        \"\"\"\nreturn 'PennyLane Program Loader for PyQuil Program:\\n' + str(self.program)\n"
    },
    {
        "functionName": "test_str",
        "className": "TestInspectionProperties",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the string representation of ProgramLoader is correct.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            DECLARE alpha REAL[1]\n            DECLARE beta REAL[1]\n            DECLARE gamma REAL[1]\n            DEFGATE SQRT-X:\n                0.5+0.5i, 0.5-0.5i\n                0.5-0.5i, 0.5+0.5i\n            H 0\n            DAGGER RZ(0.34) 1\n            CNOT 0 3\n            H 2\n            RX(alpha) 1\n            RZ(beta) 1\n            CONTROLLED S 1 7\n            DAGGER CONTROLLED X 3 7\n            DAGGER DAGGER Y 1\n            H 1\n            CONTROLLED SQRT-X 0 1\n            RZ(0.34) 1\n        \"\"\"\n    )\nloader = load_quil(quil_str)\nassert str(loader) == 'PennyLane Program Loader for PyQuil Program:\\n' + str(\n    loader.program)\n",
        "CUT_1": "\"\"\"Give the string representation of the ProgramLoader.\n\n        Returns:\n            str: The string representation of the ProgramLoader\n        \"\"\"\nreturn 'PennyLane Program Loader for PyQuil Program:\\n' + str(self.program)\n",
        "CUT_2": "\"\"\"Give the string representation of the ProgramLoader.\n\n        Returns:\n            str: The string representation of the ProgramLoader\n        \"\"\"\nreturn 'PennyLane Program Loader for PyQuil Program:\\n' + str(self.program)\n",
        "CUT_3": "\"\"\"Load a quil string as a PennyLane template.\n\n    During loading, gates are converted to PennyLane gates as far as possible. If\n    the gates are not supported they are replaced with QubitUnitary instances. The\n    import ignores all statements that are not declarations or gates (e.g. pragmas,\n    classical control flow and measurements).\n\n    Every variable that is present in the Program and that is not used as the target\n    register of a measurement has to be provided in the ``parameter_map`` of the template.\n\n    Args:\n        quil_str (str): The program that should be loaded\n\n    Returns:\n        ProgramLoader: a ProgramLoader instance that can be called like a template\n    \"\"\"\nreturn load_program(pyquil.Program(quil_str))\n",
        "CUT_4": "\"\"\"Load a quil string as a PennyLane template.\n\n    During loading, gates are converted to PennyLane gates as far as possible. If\n    the gates are not supported they are replaced with QubitUnitary instances. The\n    import ignores all statements that are not declarations or gates (e.g. pragmas,\n    classical control flow and measurements).\n\n    Every variable that is present in the Program and that is not used as the target\n    register of a measurement has to be provided in the ``parameter_map`` of the template.\n\n    Args:\n        quil_str (str): The program that should be loaded\n\n    Returns:\n        ProgramLoader: a ProgramLoader instance that can be called like a template\n    \"\"\"\nreturn load_program(pyquil.Program(quil_str))\n",
        "CUT_5": "\"\"\"Arbitrary one-qubit rotation using three Euler angles.\n\n    Args:\n        a, b, c (float): rotation angles\n        wire (int): wire the rotation acts on\n\n    Returns:\n        list: Ry and Rz matrix operators acting on each wire\n    \"\"\"\nreturn [RZ(a, wire), RY(b, wire), RZ(c, wire)]\n"
    },
    {
        "functionName": "test_load_program_via_entry_point",
        "className": "TestIntegration",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a pyquil Program instance can be loaded via the load entrypoint.\"\"\"\nprogram = pyquil.Program()\nprogram += g.H(0)\nprogram += g.RZ(0.34, 1)\nprogram += g.CNOT(0, 3)\nprogram += g.H(2)\nprogram += g.H(7)\nprogram += g.X(7)\nprogram += g.Y(1)\nprogram += g.RZ(0.34, 1)\nwith OperationRecorder() as rec:\n    qml.load(program, format='pyquil_program')(wires=range(5))\nexpected_queue = [qml.Hadamard(0), qml.RZ(0.34, wires=[1]), qml.CNOT(wires=\n    [0, 3]), qml.Hadamard(2), qml.Hadamard(4), qml.PauliX(4), qml.PauliY(1),\n    qml.RZ(0.34, wires=[1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_load_quil_via_entry_point",
        "className": "TestIntegration",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a quil string can be loaded via the load entrypoint.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            H 0\n            RZ(0.34) 1\n            CNOT 0 3\n            H 2\n            H 7\n            X 7\n            Y 1\n            RZ(0.34) 1\n        \"\"\"\n    )\nwith OperationRecorder() as rec:\n    qml.load(quil_str, format='quil')(wires=range(5))\nexpected_queue = [qml.Hadamard(0), qml.RZ(0.34, wires=[1]), qml.CNOT(wires=\n    [0, 3]), qml.Hadamard(2), qml.Hadamard(4), qml.PauliX(4), qml.PauliY(1),\n    qml.RZ(0.34, wires=[1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_load_quil_file_via_entry_point",
        "className": "TestIntegration",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that a quil file can be loaded via the load entrypoint.\"\"\"\ncur_dir = os.path.dirname(os.path.abspath(__file__))\nwith OperationRecorder() as rec:\n    qml.load(os.path.join(cur_dir, 'simple_program.quil'), format='quil_file')(\n        wires=range(5))\nexpected_queue = [qml.Hadamard(0), qml.RZ(0.34, wires=[1]), qml.CNOT(wires=\n    [0, 3]), qml.Hadamard(2), qml.Hadamard(4), qml.PauliX(4), qml.PauliY(1),\n    qml.RZ(0.34, wires=[1])]\nfor converted, expected in zip(rec.queue, expected_queue):\n    assert converted.name == expected.name\n    assert converted.wires == expected.wires\n    assert converted.data == expected.data\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_program_in_qnode",
        "className": "TestIntegration",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test how a simple program is used inside a QNode.\"\"\"\nprogram = pyquil.Program()\ndelta = program.declare('delta', 'REAL')\nprogram += g.RX(delta, 0)\nprogram += g.CNOT(0, 1)\nloader = qml.load(program, format='pyquil_program')\ndev = qml.device('default.qubit', wires=2)\n@qml.qnode(dev)\ndef circuit(a):\n    loader(wires=[0, 1], parameter_map={delta: a})\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n@qml.qnode(dev)\ndef circuit_reg(a):\n    qml.RX(a, wires=[0])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\nassert np.array_equal(circuit(angle), circuit_reg(angle))\npytest.mark.parametrize('angle', [0.0, 0.3, 0.5, 0.7, -0.2, 2.4])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_quil_in_qnode",
        "className": "TestIntegration",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test how a simple quil string is used inside a QNode.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            DECLARE delta REAL[1]\n            RX(delta) 0\n            CNOT 0 1\n        \"\"\"\n    )\nloader = qml.load(quil_str, format='quil')\ndev = qml.device('default.qubit', wires=2)\n@qml.qnode(dev)\ndef circuit(a):\n    loader(wires=[0, 1], parameter_map={'delta': a})\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n@qml.qnode(dev)\ndef circuit_reg(a):\n    qml.RX(a, wires=[0])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\nassert np.array_equal(circuit(angle), circuit_reg(angle))\npytest.mark.parametrize('angle', [0.0, 0.3, 0.5, 0.7, -0.2, 2.4])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_differentiation_in_qnode",
        "className": "TestIntegration",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test a quil string used in a QNode can be differentiated.\"\"\"\nquil_str = textwrap.dedent(\n    \"\"\"\n            DECLARE delta REAL[1]\n            RX(delta) 0\n            CNOT 0 1\n        \"\"\"\n    )\nloader = qml.load(quil_str, format='quil')\ndev = qml.device('default.qubit', wires=2)\n@qml.qnode(dev)\ndef circuit(a):\n    loader(wires=[0, 1], parameter_map={'delta': a})\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n@qml.qnode(dev)\ndef circuit_reg(a):\n    qml.RX(a, wires=[0])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\nassert np.array_equal(circuit.jacobian([angle]), circuit_reg.jacobian([angle]))\npytest.mark.parametrize('angle', [0.0, 0.3, 0.5, 0.7, -0.2, 2.4])",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_gradient",
        "className": "TestIntegration",
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the gradient works correctly\"\"\"\nprogram = pyquil.Program()\ndelta1 = program.declare('delta1', 'REAL')\ndelta2 = program.declare('delta2', 'REAL')\ndelta3 = program.declare('delta3', 'REAL')\nprogram += g.RX(delta1, 0)\nprogram += g.RX(delta2, 1)\nprogram += g.RX(delta3, 2)\nprogram += g.CNOT(0, 1)\nprogram += g.CNOT(1, 2)\nprogram_pl = qml.load(program, format='pyquil_program')\ndev = qml.device('default.qubit', wires=3, analytic=analytic)\n@qml.qnode(dev)\ndef circuit(params):\n    program_pl(parameter_map={delta1: params[0], delta2: params[1], delta3:\n        params[2]}, wires=range(len(program_pl.defined_qubits)))\n    return qml.expval(qml.PauliX(0) @ qml.PauliY(2))\ndcircuit = qml.grad(circuit, 0)\nres = dcircuit([theta, phi, varphi])\nexpected = [np.cos(theta) * np.sin(phi) * np.sin(varphi), np.sin(theta) *\n    np.cos(phi) * np.sin(varphi), np.sin(theta) * np.sin(phi) * np.cos(varphi)]\nassert np.allclose(res, expected, tol)\npytest.mark.parametrize('analytic', [True])pytest.mark.parametrize('theta,phi,varphi', list(zip(THETA, PHI, VARPHI)))",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n"
    },
    {
        "functionName": "circuit",
        "className": null,
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "loader(wires=[0, 1], parameter_map={delta: a})\nreturn qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\nqml.qnode(dev)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit_reg",
        "className": null,
        "fileName": "/tests/test_converter.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "qml.RX(a, wires=[0])\nqml.CNOT(wires=[0, 1])\nreturn qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\nqml.qnode(dev)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_simulator_qvm_default_agree",
        "className": null,
        "fileName": "/tests/test_gradients.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that forest.wavefunction, forest.qvm, and default.qubit agree\n    on the calculation of quantum gradients.\"\"\"\nw = 2\ndev1 = qml.device('default.qubit', wires=w)\ndev2 = qml.device('forest.wavefunction', wires=w)\ndev3 = qml.device('forest.qvm', device='9q-square-qvm', shots=5000)\nin_state = np.zeros([w])\nin_state[0] = 1\nin_state[1] = 1\ndef func(x, y):\n    \"\"\"Reference QNode\"\"\"\n    qml.BasisState(in_state, wires=list(range(w)))\n    qml.RY(x, wires=0)\n    qml.RX(y, wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(1))\nfunc1 = qml.QNode(func, dev1)\nfunc2 = qml.QNode(func, dev2)\nfunc3 = qml.QNode(func, dev3)\nparams = [0.2, 0.453]\nassert np.all(np.abs(func1(*params) - func2(*params)) <= tol)\nassert np.all(np.abs(func1(*params) - func3(*params)) <= 0.1)\nassert np.all(np.abs(func2(*params) - func3(*params)) <= 0.1)\ndf1 = qml.grad(func1, argnum=[0, 1])\ndf2 = qml.grad(func2, argnum=[0, 1])\ndf3 = qml.grad(func3, argnum=[0, 1])\nassert np.all(np.abs(np.array(df1(*params)) - np.array(df2(*params))) <= tol)\nassert np.all(np.abs(np.array(df1(*params)) - np.array(df3(*params))) <= 0.1)\nassert np.all(np.abs(np.array(df2(*params)) - np.array(df3(*params))) <= 0.1)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "func",
        "className": null,
        "fileName": "/tests/test_gradients.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Reference QNode\"\"\"\nqml.BasisState(in_state, wires=list(range(w)))\nqml.RY(x, wires=0)\nqml.RX(y, wires=1)\nqml.CNOT(wires=[0, 1])\nreturn qml.expval(qml.PauliZ(1))\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_gradient_with_custom_operator",
        "className": null,
        "fileName": "/tests/test_gradients.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that forest.wavefunction forest.qvm agree\n    on the calculation of quantum gradients when a custom Forest\n    operator is used.\"\"\"\nw = 9\ndev2 = qml.device('forest.wavefunction', wires=w)\ndev3 = qml.device('forest.qvm', device='9q-square-qvm', shots=5000)\ndef func(x, y):\n    \"\"\"Reference QNode\"\"\"\n    qml.BasisState(np.array([1, 1]), wires=0)\n    qml.RY(x, wires=0)\n    qml.RX(y, wires=1)\n    PSWAP(0.432, wires=[0, 1])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(1))\nfunc2 = qml.QNode(func, dev2)\nfunc3 = qml.QNode(func, dev3)\nparams = [0.2, 0.453]\nassert np.all(np.abs(func2(*params) - func3(*params)) <= 0.1)\ndf2 = qml.grad(func2, argnum=[0, 1])\ndf3 = qml.grad(func3, argnum=[0, 1])\nassert np.all(np.abs(np.array(df2(*params)) - np.array(df3(*params))) <= 0.1)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_var",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for variance calculation\"\"\"\ndev = plf.NumpyWavefunctionDevice(wires=2)\nphi = 0.543\ntheta = 0.6543\ncircuit_operations = [qml.RX(phi, wires=[0]), qml.RY(theta, wires=[0])]\nO = qml.var(qml.PauliZ(wires=[0]))\nobservables = [O]\ncircuit_graph = qml.CircuitGraph(circuit_operations + observables, {}, dev.\n    wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\nvar = dev.var(O)\nexpected = 0.25 * (3 - np.cos(2 * theta) - 2 * np.cos(theta) ** 2 * np.cos(\n    2 * phi))\nself.assertAlmostEqual(var, expected, delta=tol)\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_var_hermitian",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for variance calculation using an arbitrary Hermitian observable\"\"\"\ndev = plf.NumpyWavefunctionDevice(wires=2)\nphi = 0.543\ntheta = 0.6543\nH = np.array([[4, -1 + 6.0j], [-1 - 6.0j, 2]])\ncircuit_operations = [qml.RX(phi, wires=[0]), qml.RY(theta, wires=[0])]\nO = qml.var(qml.Hermitian(H, wires=[0]))\nobservables = [O]\ncircuit_graph = qml.CircuitGraph(circuit_operations + observables, {}, dev.\n    wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\nvar = dev.var(O)\nexpected = 0.5 * (2 * np.sin(2 * theta) * np.cos(phi) ** 2 + 24 * np.sin(\n    phi) * np.cos(phi) * (np.sin(theta) - np.cos(theta)) + 35 * np.cos(2 *\n    phi) + 39)\nself.assertAlmostEqual(var, expected, delta=tol)\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_apply",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the application of gates to a state\"\"\"\ndev = plf.NumpyWavefunctionDevice(wires=3)\ntry:\n    op = getattr(qml.ops, gate)\nexcept AttributeError:\n    op = getattr(plf, gate)\nw = list(range(op.num_wires))\nobs = qml.expval(qml.PauliZ(0))\nif op.par_domain == 'A':\n    if gate == 'QubitUnitary':\n        p = np.array(U)\n        w = [0]\n        state = apply_unitary(U, 3)\n    elif gate == 'BasisState':\n        p = np.array([1, 1, 1])\n        state = np.array([0, 0, 0, 0, 0, 0, 0, 1])\n        w = list(range(dev.num_wires))\n    circuit_graph = qml.CircuitGraph([op(p, wires=w)] + [obs], {}, dev.wires)\nelse:\n    p = [0.432423, 2, 0.324][:op.num_params]\n    fn = test_operation_map[gate]\n    if callable(fn):\n        O = fn(*p)\n    else:\n        O = fn\n    state = apply_unitary(O, 3)\n    if p:\n        circuit_graph = qml.CircuitGraph([op(*p, wires=w)] + [obs], {}, dev\n            .wires)\n    else:\n        circuit_graph = qml.CircuitGraph([op(wires=w)] + [obs], {}, dev.wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\nres = dev.expval(obs)\nself.assertAllAlmostEqual(dev._state, state, delta=tol)\npytest.mark.parametrize('gate', plf.NumpyWavefunctionDevice._operation_map)",
        "CUT_1": "\"\"\"Return the matrix associated with the controlled operation.\n\n    Args:\n        op (np.array): Array representing the operation\n                       that should be controlled\n\n    Returns:\n        np.array: Array representing the controlled operations. If the input\n        array has shape (N, N) the output shape is (2*N, 2*N).\n    \"\"\"\nreturn _direct_sum(np.eye(op.shape[0], dtype=op.dtype), op)\n",
        "CUT_2": "\"\"\"Return the matrix associated with the controlled operation.\n\n    Args:\n        op (np.array): Array representing the operation\n                       that should be controlled\n\n    Returns:\n        np.array: Array representing the controlled operations. If the input\n        array has shape (N, N) the output shape is (2*N, 2*N).\n    \"\"\"\nreturn _direct_sum(np.eye(op.shape[0], dtype=op.dtype), op)\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_sample_values",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests if the samples returned by sample have\n        the correct values\n        \"\"\"\ndev = plf.NumpyWavefunctionDevice(wires=1, shots=10)\nphi = 1.5708\ncircuit_operations = [qml.RX(phi, wires=[0])]\nO = qml.sample(qml.PauliZ(0))\nobservables = [O]\ncircuit_graph = qml.CircuitGraph(circuit_operations + observables, {}, dev.\n    wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\ns1 = dev.sample(O)\nself.assertAllAlmostEqual(s1 ** 2, 1, delta=tol)\n",
        "CUT_1": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_sample_values_hermitian",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests if the samples of a Hermitian observable returned by sample have\n        the correct values\n        \"\"\"\ndev = plf.NumpyWavefunctionDevice(wires=1, shots=1000000)\ntheta = 0.543\nA = np.array([[1, 2.0j], [-2.0j, 0]])\ncircuit_operations = [qml.RX(theta, wires=[0])]\nO = qml.sample(qml.Hermitian(A, wires=[0]))\nobservables = [O]\ncircuit_graph = qml.CircuitGraph(circuit_operations + observables, {}, dev.\n    wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\ns1 = dev.sample(O)\neigvals = np.linalg.eigvalsh(A)\nassert np.allclose(sorted(list(set(s1))), sorted(eigvals), atol=tol, rtol=0)\nassert np.allclose(np.mean(s1), 2 * np.sin(theta) + 0.5 * np.cos(theta) + \n    0.5, atol=0.1, rtol=0)\nassert np.allclose(np.var(s1), 0.25 * (np.sin(theta) - 4 * np.cos(theta)) **\n    2, atol=0.1, rtol=0)\n",
        "CUT_1": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "\"\"\"\n        Like assertAlmostEqual, but works with arrays. All the corresponding elements have to be almost equal.\n        \"\"\"\nif isinstance(first, tuple):\n    if np.all([np.all(first[idx] == second[idx]) for idx, _ in enumerate(\n        first)]):\n        return\n    if np.all([(np.all(np.abs(first[idx] - second[idx])) <= delta) for idx,\n        _ in enumerate(first)]):\n        return\nelse:\n    if np.all(first == second):\n        return\n    if np.all(np.abs(first - second) <= delta):\n        return\nassert False, '{} != {} within {} delta'.format(first, second, delta)\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_sample_values_hermitian_multi_qubit",
        "className": "TestWavefunctionBasic",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests if the samples of a multi-qubit Hermitian observable returned by sample have\n        the correct values\n        \"\"\"\nshots = 1000000\ndev = plf.NumpyWavefunctionDevice(wires=2, shots=shots)\ntheta = 0.543\nA = np.array([[1, 2.0j, 1 - 2.0j, 0.5j], [-2.0j, 0, 3 + 4.0j, 1], [1 + 2.0j,\n    3 - 4.0j, 0.75, 1.5 - 2.0j], [-0.5j, 1, 1.5 + 2.0j, -1]])\ncircuit_operations = [qml.RX(theta, wires=[0]), qml.RY(2 * theta, wires=[1]\n    ), qml.CNOT(wires=[0, 1])]\nO = qml.sample(qml.Hermitian(A, wires=[0, 1]))\nobservables = [O]\ncircuit_graph = qml.CircuitGraph(circuit_operations + observables, {}, dev.\n    wires)\ndev.apply(circuit_graph.operations, rotations=circuit_graph.diagonalizing_gates\n    )\ndev._samples = dev.generate_samples()\ns1 = dev.sample(O)\neigvals = np.linalg.eigvalsh(A)\nassert np.allclose(sorted(list(set(s1))), sorted(eigvals), atol=tol, rtol=0)\nexpected = (88 * np.sin(theta) + 24 * np.sin(2 * theta) - 40 * np.sin(3 *\n    theta) + 5 * np.cos(theta) - 6 * np.cos(2 * theta) + 27 * np.cos(3 *\n    theta) + 6) / 32\nassert np.allclose(np.mean(s1), expected, atol=0.1, rtol=0)\n",
        "CUT_1": "\"\"\"Returns the matrix representation of the controlled phase gate\"\"\"\nmat = np.identity(4, dtype=np.complex128)\nmat[q, q] = np.exp(1.0j * phi)\nreturn mat\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n"
    },
    {
        "functionName": "test_qubit_unitary",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an arbitrary unitary operation works\"\"\"\ndev = qml.device('forest.numpy_wavefunction', wires=3)\n@qml.qnode(dev)\ndef circuit():\n    \"\"\"Test QNode\"\"\"\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.QubitUnitary(U2, wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\nout_state = U2 @ np.array([1, 0, 0, 1]) / np.sqrt(2)\nobs = np.kron(np.array([[1, 0], [0, -1]]), I)\nself.assertAllAlmostEqual(circuit(), np.vdot(out_state, obs @ out_state),\n    delta=tol)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_load_wavefunction_device",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction device loads correctly\"\"\"\ndev = qml.device('forest.numpy_wavefunction', wires=2)\nself.assertEqual(dev.num_wires, 2)\nself.assertEqual(dev.shots, 1000)\nself.assertEqual(dev.short_name, 'forest.numpy_wavefunction')\n",
        "CUT_1": "\"\"\"Replaces unittest TestCase.assertEqual\"\"\"\nassert first == second\n",
        "CUT_2": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_3": "if shots <= 0:\n    raise ValueError('Number of shots must be a positive integer.')\nanalytic = kwargs.get('analytic', False)\ntimeout = kwargs.pop('timeout', None)\nself._compiled_program = None\n\"\"\"Union[None, pyquil.ExecutableDesignator]: the latest compiled program. If parametric\n        compilation is turned on, this will be a parametric program.\"\"\"\nself.parametric_compilation = kwargs.get('parametric_compilation', True)\nif self.parametric_compilation:\n    self._compiled_program_dict = {}\n    \"\"\"dict[int, pyquil.ExecutableDesignator]: stores circuit hashes associated\n                with the corresponding compiled programs.\"\"\"\n    self._parameter_map = {}\n    \"\"\"dict[str, float]: stores the string of symbolic parameters associated with\n                their numeric values. This map will be used to bind parameters in a parametric\n                program using PyQuil.\"\"\"\n    self._parameter_reference_map = {}\n    \"\"\"dict[str, pyquil.quilatom.MemoryReference]: stores the string of symbolic\n                parameters associated with their PyQuil memory references.\"\"\"\nif analytic:\n    raise ValueError('QVM device cannot be run in analytic=True mode.')\nself.connection = super()._get_connection(**kwargs)\nif isinstance(device, nx.Graph):\n    self.qc = _get_qvm_with_topology('device', topology=device, noisy=noisy,\n        connection=self.connection)\nelif isinstance(device, str):\n    self.qc = get_qc(device, as_qvm=True, noisy=noisy, connection=self.\n        connection)\nself.num_wires = len(self.qc.qubits())\nif wires is None:\n    wires = range(self.num_wires)\nif isinstance(wires, int):\n    raise ValueError(\n        'Device has a fixed number of {} qubits. The wires argument can only be used to specify an iterable of wire labels.'\n        .format(self.num_wires))\nif self.num_wires != len(wires):\n    raise ValueError(\n        'Device has a fixed number of {} qubits and cannot be created with {} wires.'\n        .format(self.num_wires, len(wires)))\nsuper().__init__(wires, shots, analytic=analytic, **kwargs)\nif timeout is not None:\n    self.qc.compiler.client.timeout = timeout\nself.wiring = {i: q for i, q in enumerate(self.qc.qubits())}\nself.active_reset = False\n",
        "CUT_4": "\"\"\"Replaces unittest TestCase.assertEqual\"\"\"\nassert np.abs(first - second) <= delta\n",
        "CUT_5": "\"\"\"\n        Like assertEqual, but works with arrays. All the corresponding elements have to be equal.\n        \"\"\"\nreturn self.assertAllAlmostEqual(first, second, delta=0.0)\n"
    },
    {
        "functionName": "test_program_property",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the program property works as expected\"\"\"\ndev = qml.device('forest.numpy_wavefunction', wires=2)\n@qml.qnode(dev)\ndef circuit():\n    \"\"\"Test QNode\"\"\"\n    qml.Hadamard(wires=0)\n    qml.PauliY(wires=0)\n    return qml.expval(qml.PauliX(0))\nself.assertEqual(len(dev.program), 0)\ncircuit()\nself.assertEqual(len(dev.program), 3)\nself.assertEqual(str(dev.program), 'H 0\\nY 0\\nH 0\\n')\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_wavefunction_args",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction plugin requires correct arguments\"\"\"\nwith pytest.raises(TypeError, match=\n    \"missing 1 required positional argument: 'wires'\"):\n    qml.device('forest.numpy_wavefunction')\n",
        "CUT_1": "try:\n    config = PyquilConfig()\n    device = get_qc('3q-qvm').device\n    compiler = QVMCompiler(endpoint=config.quilc_url, device=device)\n    compiler.quil_to_native_quil(Program(Id(0)))\n    return compiler\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires compiler connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_2": "try:\n    qvm = QVMConnection(random_seed=52)\n    qvm.run(Program(Id(0)), [])\n    return qvm\nexcept (RequestException, UnknownApiError, QVMNotRunning, TypeError) as e:\n    return pytest.skip('This test requires QVM connection: {}'.format(e))\npytest.fixture(scope='session')",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_hermitian_expectation",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an arbitrary Hermitian expectation value works\"\"\"\ndev = qml.device('forest.numpy_wavefunction', wires=1)\n@qml.qnode(dev)\ndef circuit():\n    \"\"\"Test QNode\"\"\"\n    qml.Hadamard(wires=0)\n    qml.PauliY(wires=0)\n    return qml.expval(qml.Hermitian(H, 0))\nout_state = 1.0j * np.array([-1, 1]) / np.sqrt(2)\nself.assertAllAlmostEqual(circuit(), np.vdot(out_state, H @ out_state),\n    delta=tol)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_invalid_qubit_unitary",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an invalid unitary operation is not allowed\"\"\"\ndev = qml.device('forest.numpy_wavefunction', wires=3)\ndef circuit(Umat):\n    \"\"\"Test QNode\"\"\"\n    qml.QubitUnitary(Umat, wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\ncircuit1 = qml.QNode(circuit, dev)\nwith pytest.raises(ValueError, match='must be a square matrix'):\n    circuit1(np.array([[0, 1]]))\ncircuit1 = qml.QNode(circuit, dev)\nwith pytest.raises(ValueError, match='must be unitary'):\n    circuit1(np.array([[1, 1], [1, 1]]))\ncircuit1 = qml.QNode(circuit, dev)\nwith pytest.raises(ValueError, match='must be 2\\\\^Nx2\\\\^N'):\n    circuit1(U)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_one_qubit_wavefunction_circuit",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction plugin provides correct result for simple circuit\"\"\"\ndev = qml.device('forest.numpy_wavefunction', wires=1)\na = 0.543\nb = 0.123\nc = 0.987\n@qml.qnode(dev)\ndef circuit(x, y, z):\n    \"\"\"Test QNode\"\"\"\n    qml.BasisState(np.array([1]), wires=0)\n    qml.Hadamard(wires=0)\n    qml.Rot(x, y, z, wires=0)\n    return qml.expval(qml.PauliZ(0))\nprint(circuit(a, b, c))\nself.assertAlmostEqual(circuit(a, b, c), np.cos(a) * np.sin(b), delta=tol)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_two_qubit_wavefunction_circuit",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction plugin provides correct result for simple 2-qubit circuit,\n        even when the number of wires > number of qubits.\"\"\"\ndev = qml.device('forest.numpy_wavefunction', wires=3)\na = 0.543\nb = 0.123\nc = 0.987\ntheta = 0.6423\n@qml.qnode(dev)\ndef circuit(w, x, y, z):\n    \"\"\"Test QNode\"\"\"\n    qml.BasisState(np.array([0, 1]), wires=[0, 1])\n    qml.Hadamard(wires=1)\n    plf.CPHASE(w, 1, wires=[0, 1])\n    qml.Rot(x, y, z, wires=0)\n    plf.CPHASE(w, 3, wires=[0, 1])\n    plf.CPHASE(w, 0, wires=[0, 1])\n    return qml.expval(qml.PauliY(1))\nself.assertAlmostEqual(circuit(theta, a, b, c), -np.sin(b / 2) ** 2 * np.\n    sin(2 * theta), delta=tol)\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "test_nonzero_shots",
        "className": "TestWavefunctionIntegration",
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wavefunction plugin provides correct result for high shot number\"\"\"\nshots = 10 ** 2\ndev = qml.device('forest.numpy_wavefunction', wires=1, shots=shots)\na = 0.543\nb = 0.123\nc = 0.987\n@qml.qnode(dev)\ndef circuit(x, y, z):\n    \"\"\"Test QNode\"\"\"\n    qml.BasisState(np.array([1]), wires=0)\n    qml.Hadamard(wires=0)\n    qml.Rot(x, y, z, wires=0)\n    return qml.expval(qml.PauliZ(0))\nruns = []\nfor _ in range(100):\n    runs.append(circuit(a, b, c))\nexpected_var = np.sqrt(1 / shots)\nprint(np.mean(runs), np.cos(a) * np.sin(b))\nself.assertAlmostEqual(np.mean(runs), np.cos(a) * np.sin(b), delta=expected_var\n    )\n",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    },
    {
        "functionName": "circuit",
        "className": null,
        "fileName": "/tests/test_numpy_wavefunction.py",
        "projectName": "pennylane-forest",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test QNode\"\"\"\nqml.Hadamard(wires=0)\nqml.CNOT(wires=[0, 1])\nqml.QubitUnitary(U2, wires=[0, 1])\nreturn qml.expval(qml.PauliZ(0))\nqml.qnode(dev)",
        "CUT_1": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_2": "return [qml.SWAP(wires=wires), qml.CNOT(wires=wires), qml.PhaseShift(phi,\n    wires=[wires[1]]), qml.CNOT(wires=wires)]\n",
        "CUT_3": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_4": "return [qml.SWAP(wires=wires), qml.S(wires=[wires[0]]), qml.S(wires=[wires[\n    1]]), qml.CZ(wires=wires)]\n",
        "CUT_5": "if q == 0:\n    return [qml.PauliX(wires[0]), qml.PauliX(wires[1]), qml.PhaseShift(phi /\n        2, wires=[wires[0]]), qml.PhaseShift(phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PhaseShift(-phi / 2, wires=[wires[1]]),\n        qml.CNOT(wires=wires), qml.PauliX(wires[1]), qml.PauliX(wires[0])]\nelif q == 1:\n    return [qml.PauliX(wires[0]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[0])]\nelif q == 2:\n    return [qml.PauliX(wires[1]), qml.PhaseShift(phi / 2, wires=[wires[0]]),\n        qml.PhaseShift(phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PhaseShift(-phi / 2, wires=[wires[1]]), qml.CNOT(wires=wires),\n        qml.PauliX(wires[1])]\nelif q == 3:\n    return [qml.PhaseShift(phi / 2, wires=[wires[0]]), qml.PhaseShift(phi /\n        2, wires=[wires[1]]), qml.CNOT(wires=wires), qml.PhaseShift(-phi / \n        2, wires=[wires[1]]), qml.CNOT(wires=wires)]\n"
    }
]