[
    {
        "functionName": "layout_settings_dialog",
        "className": null,
        "fileName": "/spyder/preferences/tests/test_layoutdialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up LayoutSettingsDialog.\"\"\"\nnames, order, active = request.param\nwidget = LayoutSettingsDialog(None, names, order, active)\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\" \"\"\"\nnames, order, active = self.names, self.order, self.order\nname = from_qvariant(self.table.selectionModel().currentIndex().data(),\n    to_text_string)\nif name in names:\n    index = names.index(name)\nif index != -1:\n    order.remove(name)\n    names[index] = None\n    if name in active:\n        active.remove(name)\n    self.names, self.order, self.active = names, order, active\n    self.table.model().set_data(order, active)\n    index = self.table.model().index(0, 0)\n    self.table.setCurrentIndex(index)\n    self.table.setFocus()\n    self.selection_changed(None, None)\n    if len(order) == 0:\n        self.button_move_up.setDisabled(True)\n        self.button_move_down.setDisabled(True)\n        self.button_delete.setDisabled(True)\n",
        "CUT_2": "\"\"\" \"\"\"\nnames, order, active = self.names, self.order, self.order\nname = from_qvariant(self.table.selectionModel().currentIndex().data(),\n    to_text_string)\nif name in names:\n    index = names.index(name)\nif index != -1:\n    order.remove(name)\n    names[index] = None\n    if name in active:\n        active.remove(name)\n    self.names, self.order, self.active = names, order, active\n    self.table.model().set_data(order, active)\n    index = self.table.model().index(0, 0)\n    self.table.setCurrentIndex(index)\n    self.table.setFocus()\n    self.selection_changed(None, None)\n    if len(order) == 0:\n        self.button_move_up.setDisabled(True)\n        self.button_move_down.setDisabled(True)\n        self.button_delete.setDisabled(True)\n",
        "CUT_3": "\"\"\"Layout settings dialog\"\"\"\nsection = 'quick_layouts'\nnames = CONF.get(section, 'names')\norder = CONF.get(section, 'order')\nactive = CONF.get(section, 'active')\ndlg = self.dialog_layout_settings(self, names, order, active)\nif dlg.exec_():\n    CONF.set(section, 'names', dlg.names)\n    CONF.set(section, 'order', dlg.order)\n    CONF.set(section, 'active', dlg.active)\n    self.quick_layout_set_menu()\n",
        "CUT_4": "\"\"\"Layout settings dialog\"\"\"\nsection = 'quick_layouts'\nnames = CONF.get(section, 'names')\norder = CONF.get(section, 'order')\nactive = CONF.get(section, 'active')\ndlg = self.dialog_layout_settings(self, names, order, active)\nif dlg.exec_():\n    CONF.set(section, 'names', dlg.names)\n    CONF.set(section, 'order', dlg.order)\n    CONF.set(section, 'active', dlg.active)\n    self.quick_layout_set_menu()\n",
        "CUT_5": "super(LayoutModel, self).__init__(parent)\nself._parent = parent\nself.order = order\nself.active = active\nself._rows = []\nself.set_data(order, active)\n"
    },
    {
        "functionName": "layout_save_dialog",
        "className": null,
        "fileName": "/spyder/preferences/tests/test_layoutdialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up LayoutSaveDialog.\"\"\"\norder = request.param\nwidget = LayoutSaveDialog(None, order)\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "test_layout_settings_dialog",
        "className": null,
        "fileName": "/spyder/preferences/tests/test_layoutdialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run layout settings dialog.\"\"\"\nlayout_settings_dialog.show()\nassert layout_settings_dialog\npytest.mark.parametrize('layout_settings_dialog', [(['test', 'tester', '20',\n    '30', '40'], ['test', 'tester', '20', '30', '40'], ['test', 'tester'])],\n    indirect=True)",
        "CUT_1": "\"\"\"Run layout test widget test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nnames = ['test', 'tester', '20', '30', '40']\norder = ['test', 'tester', '20', '30', '40']\nactive = ['test', 'tester']\nwidget_1 = LayoutSettingsDialog(None, names, order, active)\nwidget_2 = LayoutSaveDialog(None, order)\nwidget_1.show()\nwidget_2.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "\"\"\"Run layout test widget test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nnames = ['test', 'tester', '20', '30', '40']\norder = ['test', 'tester', '20', '30', '40']\nactive = ['test', 'tester']\nwidget_1 = LayoutSettingsDialog(None, names, order, active)\nwidget_2 = LayoutSaveDialog(None, order)\nwidget_1.show()\nwidget_2.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n"
    },
    {
        "functionName": "test_layout_save_dialog",
        "className": null,
        "fileName": "/spyder/preferences/tests/test_layoutdialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run layout save dialog.\"\"\"\nlayout_save_dialog.show()\nassert layout_save_dialog\npytest.mark.parametrize('layout_save_dialog', [['test', 'tester', '20',\n    '30', '40']], indirect=True)",
        "CUT_1": "\"\"\"Run layout test widget test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nnames = ['test', 'tester', '20', '30', '40']\norder = ['test', 'tester', '20', '30', '40']\nactive = ['test', 'tester']\nwidget_1 = LayoutSettingsDialog(None, names, order, active)\nwidget_2 = LayoutSaveDialog(None, order)\nwidget_1.show()\nwidget_2.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "\"\"\"Run layout test widget test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nnames = ['test', 'tester', '20', '30', '40']\norder = ['test', 'tester', '20', '30', '40']\nactive = ['test', 'tester']\nwidget_1 = LayoutSettingsDialog(None, names, order, active)\nwidget_2 = LayoutSaveDialog(None, order)\nwidget_1.show()\nwidget_2.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "return _('Run')\n",
        "CUT_4": "return _('Run')\n",
        "CUT_5": "\"\"\"Test Collections editor.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\ndialog = CollectionsEditor()\ndialog.setup(get_test_data())\ndialog.show()\napp.exec_()\n"
    },
    {
        "functionName": "test_config_dialog_save_to_conf",
        "className": null,
        "fileName": "/spyder/preferences/tests/test_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "for index in range(global_config_dialog.pages_widget.count()):\n    configpage = global_config_dialog.get_page(index)\n    configpage.save_to_conf()\n    _save_lang = getattr(configpage, '_save_lang', None)\n    if _save_lang:\n        _save_lang()\n    assert configpage.is_valid()\n",
        "CUT_1": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_2": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_3": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_4": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "open_file_in_editor",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Open a file using the Editor and its open file dialog\"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QFileDialog):\n        if directory is not None:\n            w.setDirectory(directory)\n        input_field = w.findChildren(QLineEdit)[0]\n        input_field.setText(fname)\n        QTest.keyClick(w, Qt.Key_Enter)\n",
        "CUT_1": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n        Select working directory.\n\n        Parameters\n        ----------\n        directory: str, optional\n            The directory to change to.\n\n        Notes\n        -----\n        If directory is None, a get directorty dialog will be used.\n        \"\"\"\nif directory is None:\n    self.sig_redirect_stdio_requested.emit(False)\n    directory = getexistingdirectory(self, _('Select directory'),\n        getcwd_or_home())\n    self.sig_redirect_stdio_requested.emit(True)\nif directory:\n    self.chdir(directory)\nSlot()",
        "CUT_4": "\"\"\"\n        Select working directory.\n\n        Parameters\n        ----------\n        directory: str, optional\n            The directory to change to.\n\n        Notes\n        -----\n        If directory is None, a get directorty dialog will be used.\n        \"\"\"\nif directory is None:\n    self.sig_redirect_stdio_requested.emit(False)\n    directory = getexistingdirectory(self, _('Select directory'),\n        getcwd_or_home())\n    self.sig_redirect_stdio_requested.emit(True)\nif directory:\n    self.chdir(directory)\nSlot()",
        "CUT_5": "\"\"\"Set current script directory as working directory\"\"\"\nfname = self.get_current_filename()\nif fname is not None:\n    directory = osp.dirname(osp.abspath(fname))\n    self.sig_dir_opened.emit(directory)\nSlot()"
    },
    {
        "functionName": "get_thirdparty_plugin",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Get a reference to the thirdparty plugin with the title given.\"\"\"\nfor plugin in main_window.thirdparty_plugins:\n    try:\n        if plugin.get_name() == plugin_title:\n            return plugin\n    except AttributeError:\n        if plugin.get_plugin_title() == plugin_title:\n            return plugin\n",
        "CUT_1": "\"\"\"\n        Register a plugin in Spyder Main Window.\n        \"\"\"\nself.set_splash(_('Loading {}...'.format(plugin.get_name())))\nlogger.info('Loading {}...'.format(plugin.NAME))\nis_compatible, message = plugin.check_compatibility()\nplugin.is_compatible = is_compatible\nplugin.get_description()\nif not is_compatible:\n    self.show_compatibility_message(message)\n    return\nplugin.sig_exception_occurred.connect(self.handle_exception)\nplugin.sig_free_memory_requested.connect(self.free_memory)\nplugin.sig_quit_requested.connect(self.close)\nplugin.sig_restart_requested.connect(self.restart)\nplugin.sig_restart_requested.connect(self.restart)\nplugin.sig_redirect_stdio_requested.connect(self.redirect_internalshell_stdio)\nplugin.sig_status_message_requested.connect(self.show_status_message)\nif isinstance(plugin, SpyderDockablePlugin):\n    plugin.sig_focus_changed.connect(self.plugin_focus_changed)\n    plugin.sig_switch_to_plugin_requested.connect(self.switch_to_plugin)\n    plugin.sig_update_ancestor_requested.connect(lambda : plugin.\n        set_ancestor(self))\nplugin._register()\nplugin.register()\nif isinstance(plugin, SpyderDockablePlugin):\n    self.add_dockwidget(plugin)\n    margin = 0\n    if CONF.get('main', 'use_custom_margin'):\n        margin = CONF.get('main', 'custom_margin')\n    plugin.update_margins(margin)\nself.add_plugin(plugin, external=external)\nlogger.info('Registering shortcuts for {}...'.format(plugin.NAME))\nfor action_name, action in plugin.get_actions().items():\n    context = getattr(action, 'shortcut_context', plugin.NAME) or plugin.NAME\n    if getattr(action, 'register_shortcut', True):\n        if isinstance(action_name, Enum):\n            action_name = action_name.value\n        self.register_shortcut(action, context, action_name)\nif isinstance(plugin, SpyderDockablePlugin):\n    try:\n        context = '_'\n        name = 'switch to {}'.format(plugin.CONF_SECTION)\n        shortcut = CONF.get_shortcut(context, name, plugin_name=plugin.\n            CONF_SECTION)\n    except (cp.NoSectionError, cp.NoOptionError):\n        shortcut = None\n    sc = QShortcut(QKeySequence(), self, lambda : self.switch_to_plugin(plugin)\n        )\n    sc.setContext(Qt.ApplicationShortcut)\n    plugin._shortcut = sc\n    self.register_shortcut(sc, context, name)\n    self.register_shortcut(plugin.toggle_view_action, context, name)\ntoolbars = plugin.get_registered_application_toolbars()\nfor __, toolbar in toolbars.items():\n    toolbar._render()\n    self.toolbarslist.append(toolbar)\n",
        "CUT_2": "\"\"\"\n        Register a plugin in Spyder Main Window.\n        \"\"\"\nself.set_splash(_('Loading {}...'.format(plugin.get_name())))\nlogger.info('Loading {}...'.format(plugin.NAME))\nis_compatible, message = plugin.check_compatibility()\nplugin.is_compatible = is_compatible\nplugin.get_description()\nif not is_compatible:\n    self.show_compatibility_message(message)\n    return\nplugin.sig_exception_occurred.connect(self.handle_exception)\nplugin.sig_free_memory_requested.connect(self.free_memory)\nplugin.sig_quit_requested.connect(self.close)\nplugin.sig_restart_requested.connect(self.restart)\nplugin.sig_restart_requested.connect(self.restart)\nplugin.sig_redirect_stdio_requested.connect(self.redirect_internalshell_stdio)\nplugin.sig_status_message_requested.connect(self.show_status_message)\nif isinstance(plugin, SpyderDockablePlugin):\n    plugin.sig_focus_changed.connect(self.plugin_focus_changed)\n    plugin.sig_switch_to_plugin_requested.connect(self.switch_to_plugin)\n    plugin.sig_update_ancestor_requested.connect(lambda : plugin.\n        set_ancestor(self))\nplugin._register()\nplugin.register()\nif isinstance(plugin, SpyderDockablePlugin):\n    self.add_dockwidget(plugin)\n    margin = 0\n    if CONF.get('main', 'use_custom_margin'):\n        margin = CONF.get('main', 'custom_margin')\n    plugin.update_margins(margin)\nself.add_plugin(plugin, external=external)\nlogger.info('Registering shortcuts for {}...'.format(plugin.NAME))\nfor action_name, action in plugin.get_actions().items():\n    context = getattr(action, 'shortcut_context', plugin.NAME) or plugin.NAME\n    if getattr(action, 'register_shortcut', True):\n        if isinstance(action_name, Enum):\n            action_name = action_name.value\n        self.register_shortcut(action, context, action_name)\nif isinstance(plugin, SpyderDockablePlugin):\n    try:\n        context = '_'\n        name = 'switch to {}'.format(plugin.CONF_SECTION)\n        shortcut = CONF.get_shortcut(context, name, plugin_name=plugin.\n            CONF_SECTION)\n    except (cp.NoSectionError, cp.NoOptionError):\n        shortcut = None\n    sc = QShortcut(QKeySequence(), self, lambda : self.switch_to_plugin(plugin)\n        )\n    sc.setContext(Qt.ApplicationShortcut)\n    plugin._shortcut = sc\n    self.register_shortcut(sc, context, name)\n    self.register_shortcut(plugin.toggle_view_action, context, name)\ntoolbars = plugin.get_registered_application_toolbars()\nfor __, toolbar in toolbars.items():\n    toolbar._render()\n    self.toolbarslist.append(toolbar)\n",
        "CUT_3": "\"\"\"Reimplement Qt method.\"\"\"\nself.plugin.set_ancestor(self.plugin.main)\nself.plugin.dockwidget.setWidget(self.plugin)\nself.plugin.dockwidget.setVisible(True)\nself.plugin.switch_to_plugin()\nQMainWindow.closeEvent(self, event)\nself.plugin.__unsafe__window = self\nself.plugin._undocked_window = None\n",
        "CUT_4": "\"\"\"Reimplement Qt method.\"\"\"\nself.plugin.set_ancestor(self.plugin.main)\nself.plugin.dockwidget.setWidget(self.plugin)\nself.plugin.dockwidget.setVisible(True)\nself.plugin.switch_to_plugin()\nQMainWindow.closeEvent(self, event)\nself.plugin.__unsafe__window = self\nself.plugin._undocked_window = None\n",
        "CUT_5": "\"\"\"\n        Add plugin to plugins dictionary.\n        \"\"\"\nself._PLUGINS[plugin.CONF_SECTION] = plugin\nif external:\n    self._EXTERNAL_PLUGINS[plugin.CONF_SECTION] = plugin\nelse:\n    self._INTERNAL_PLUGINS[plugin.CONF_SECTION] = plugin\n"
    },
    {
        "functionName": "reset_run_code",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Reset state after a run code test\"\"\"\nqtbot.waitUntil(lambda : not shell._executing)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%reset -f')\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 0, timeout=\n    EVAL_TIMEOUT)\ncode_editor.setFocus()\nqtbot.keyClick(code_editor, Qt.Key_Home, modifier=Qt.ControlModifier)\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "return self.shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n"
    },
    {
        "functionName": "start_new_kernel",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Start a new kernel, and return its Manager and Client\"\"\"\nkm = KernelManager(kernel_name=kernel_name)\nif spykernel:\n    km._kernel_spec = SpyderKernelSpec()\nkm.start_kernel(**kwargs)\nkc = km.client()\nkc.start_channels()\ntry:\n    kc.wait_for_ready(timeout=startup_timeout)\nexcept RuntimeError:\n    kc.stop_channels()\n    km.shutdown_kernel()\n    raise\nreturn km, kc\n",
        "CUT_1": "\"\"\"Connect a client to its kernel\"\"\"\nconnection_file = client.connection_file\nstderr_handle = None if self.test_no_stderr else client.stderr_handle\nkm, kc = self.create_kernel_manager_and_kernel_client(connection_file,\n    stderr_handle, is_cython=is_cython, is_pylab=is_pylab, is_sympy=is_sympy)\nif is_string(km) and kc is None:\n    client.shellwidget.kernel_manager = None\n    client.show_kernel_error(km)\n    return\nif not self.testing:\n    kc.started_channels.connect(lambda c=client: self.process_started(c))\n    kc.stopped_channels.connect(lambda c=client: self.process_finished(c))\nkc.start_channels(shell=True, iopub=True)\nshellwidget = client.shellwidget\nshellwidget.set_kernel_client_and_manager(kc, km)\nshellwidget.sig_exception_occurred.connect(self.main.console.handle_exception)\n",
        "CUT_2": "\"\"\"Connect a client to its kernel\"\"\"\nconnection_file = client.connection_file\nstderr_handle = None if self.test_no_stderr else client.stderr_handle\nkm, kc = self.create_kernel_manager_and_kernel_client(connection_file,\n    stderr_handle, is_cython=is_cython, is_pylab=is_pylab, is_sympy=is_sympy)\nif is_string(km) and kc is None:\n    client.shellwidget.kernel_manager = None\n    client.show_kernel_error(km)\n    return\nif not self.testing:\n    kc.started_channels.connect(lambda c=client: self.process_started(c))\n    kc.stopped_channels.connect(lambda c=client: self.process_finished(c))\nkc.start_channels(shell=True, iopub=True)\nshellwidget = client.shellwidget\nshellwidget.set_kernel_client_and_manager(kc, km)\nshellwidget.sig_exception_occurred.connect(self.main.console.handle_exception)\n",
        "CUT_3": "\"\"\"\n        Connect an external kernel to the Variable Explorer, Help and\n        Plots, but only if it is a Spyder kernel.\n        \"\"\"\nsw = shellwidget\nkc = shellwidget.kernel_client\nself.sig_shellwidget_changed.emit(sw)\nif self.main.variableexplorer is not None:\n    self.main.variableexplorer.add_shellwidget(sw)\n    sw.set_namespace_view_settings()\n    sw.refresh_namespacebrowser()\n    kc.stopped_channels.connect(lambda : self.main.variableexplorer.\n        remove_shellwidget(id(sw)))\nif self.main.plots is not None:\n    self.main.plots.add_shellwidget(sw)\n    kc.stopped_channels.connect(lambda : self.main.plots.remove_shellwidget\n        (id(sw)))\n",
        "CUT_4": "\"\"\"\n        Connect an external kernel to the Variable Explorer, Help and\n        Plots, but only if it is a Spyder kernel.\n        \"\"\"\nsw = shellwidget\nkc = shellwidget.kernel_client\nself.sig_shellwidget_changed.emit(sw)\nif self.main.variableexplorer is not None:\n    self.main.variableexplorer.add_shellwidget(sw)\n    sw.set_namespace_view_settings()\n    sw.refresh_namespacebrowser()\n    kc.stopped_channels.connect(lambda : self.main.variableexplorer.\n        remove_shellwidget(id(sw)))\nif self.main.plots is not None:\n    self.main.plots.add_shellwidget(sw)\n    kc.stopped_channels.connect(lambda : self.main.plots.remove_shellwidget\n        (id(sw)))\n",
        "CUT_5": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n"
    },
    {
        "functionName": "find_desired_tab_in_window",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "all_tabbars = window.findChildren(QTabBar)\nfor current_tabbar in all_tabbars:\n    for tab_index in range(current_tabbar.count()):\n        if current_tabbar.tabText(tab_index) == str(tab_name):\n            return current_tabbar, tab_index\nreturn None, None\n",
        "CUT_1": "\"\"\"On clean exit, update tab name.\"\"\"\nself.hide()\nif isinstance(self.tab_index, int) and self.tab_index >= 0:\n    tab_text = to_text_string(self.text())\n    self.main.setTabText(self.tab_index, tab_text)\n    self.main.sig_change_name.emit(tab_text)\n",
        "CUT_2": "\"\"\"On clean exit, update tab name.\"\"\"\nself.hide()\nif isinstance(self.tab_index, int) and self.tab_index >= 0:\n    tab_text = to_text_string(self.text())\n    self.main.setTabText(self.tab_index, tab_text)\n    self.main.sig_change_name.emit(tab_text)\n",
        "CUT_3": "\"\"\"Remove the widget at the corresponding tab_index.\"\"\"\n_id = id(self.editor.tabs.widget(tab_index))\nif _id in self.history:\n    self.history.remove(_id)\n",
        "CUT_4": "\"\"\"Remove the widget at the corresponding tab_index.\"\"\"\n_id = id(self.editor.tabs.widget(tab_index))\nif _id in self.history:\n    self.history.remove(_id)\n",
        "CUT_5": "\"\"\"Insert the widget (at tab index) in the position i (index).\"\"\"\n_id = id(self.editor.tabs.widget(tab_index))\nself.history.insert(i, _id)\n"
    },
    {
        "functionName": "main_window",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Main Window fixture\"\"\"\nCONF.set('ipython_console', 'pylab/backend', 0)\nCONF.set('plots', 'mute_inline_plotting', False)\nCONF.set('ipython_console', 'pylab/inline/figure_format', 0)\nCONF.set('ipython_console', 'pdb_use_exclamation_mark', True)\nuse_introspection = request.node.get_closest_marker('use_introspection')\nif use_introspection:\n    os.environ['SPY_TEST_USE_INTROSPECTION'] = 'True'\nelse:\n    try:\n        os.environ.pop('SPY_TEST_USE_INTROSPECTION')\n    except KeyError:\n        pass\nsingle_instance = request.node.get_closest_marker('single_instance')\nif single_instance:\n    CONF.set('main', 'single_instance', True)\nelse:\n    CONF.set('main', 'single_instance', False)\npreload_project = request.node.get_closest_marker('preload_project')\nif preload_project:\n    project_path = str(tmpdir.mkdir('test_project'))\n    project = EmptyProject(project_path)\n    CONF.set('project_explorer', 'current_project_path', project_path)\n    filenames = [osp.join(project_path, f) for f in ['file1.py', 'file2.py',\n        'file3.txt']]\n    for filename in filenames:\n        with open(filename, 'w') as f:\n            if osp.splitext(filename)[1] == '.py':\n                f.write('def f(x):\\n    return x\\n')\n            else:\n                f.write('Hello world!')\n    project.set_recent_files(filenames)\nelse:\n    CONF.set('project_explorer', 'current_project_path', None)\ntry:\n    param = request.param\n    if isinstance(param, dict) and 'spy_config' in param:\n        CONF.set(*param['spy_config'])\nexcept AttributeError:\n    pass\nif not hasattr(main_window, 'window'):\n    window = start.main()\n    main_window.window = window\nelse:\n    window = main_window.window\n    window.editor.close_file()\n    window.projects.close_project()\n    if window.console.error_dialog:\n        window.console.close_error_dialog()\n    window.switcher.close()\n    for client in window.ipyconsole.get_clients():\n        window.ipyconsole.close_client(client=client, force=True)\n    window.outlineexplorer.stop_symbol_services('python')\n    window.explorer.chdir(get_home_dir())\nyield window\nif request.node.rep_setup.passed:\n    if request.node.rep_call.failed:\n        print(window.ipyconsole.get_current_shellwidget()._control.\n            toPlainText())\n        console = window.ipyconsole\n        client = console.get_current_client()\n        if client.info_page != client.blank_page:\n            print('info_page')\n            print(client.info_page)\n        window.close()\n        del main_window.window\npytest.fixture",
        "CUT_1": "oe_options = self.outlineexplorer.explorer.get_options()\nwindow = EditorMainWindow(self, self.stack_menu_actions, self.toolbar_list,\n    self.menu_list, outline_explorer_options=oe_options)\nwindow.add_toolbars_to_menu('&View', window.get_toolbars())\nwindow.load_toolbars()\nwindow.resize(self.size())\nwindow.show()\nwindow.editorwidget.editorsplitter.editorstack.new_window = True\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\nreturn window\n",
        "CUT_2": "oe_options = self.outlineexplorer.explorer.get_options()\nwindow = EditorMainWindow(self, self.stack_menu_actions, self.toolbar_list,\n    self.menu_list, outline_explorer_options=oe_options)\nwindow.add_toolbars_to_menu('&View', window.get_toolbars())\nwindow.load_toolbars()\nwindow.resize(self.size())\nwindow.show()\nwindow.editorwidget.editorsplitter.editorstack.new_window = True\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\nreturn window\n",
        "CUT_3": "window = EditorMainWindow(self, self.menu_actions, self.toolbar_list, self.\n    menu_list, show_fullpath=False, show_all_files=False, group_cells=True,\n    show_comments=True, sort_files_alphabetically=False)\nwindow.resize(self.size())\nwindow.show()\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\n",
        "CUT_4": "window = EditorMainWindow(self, self.menu_actions, self.toolbar_list, self.\n    menu_list, show_fullpath=False, show_all_files=False, group_cells=True,\n    show_comments=True, sort_files_alphabetically=False)\nwindow.resize(self.size())\nwindow.show()\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\n",
        "CUT_5": "\"\"\"Create a QMainWindow instance containing this plugin.\"\"\"\nself._undocked_window = window = PluginWindow(self)\nwindow.setAttribute(Qt.WA_DeleteOnClose)\nicon = self.get_plugin_icon()\nif is_text_string(icon):\n    icon = self.get_icon(icon)\nwindow.setWindowIcon(icon)\nwindow.setWindowTitle(self.get_plugin_title())\nwindow.setCentralWidget(self)\nwindow.resize(self.size())\nself.refresh_plugin()\nself.set_ancestor(window)\nself.dockwidget.setFloating(False)\nself.dockwidget.setVisible(False)\nwindow.show()\nSlot()"
    },
    {
        "functionName": "cleanup",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Cleanup a testing directory once we are finished.\"\"\"\ndef remove_test_dir():\n    if hasattr(main_window, 'window'):\n        main_window.window.close()\nrequest.addfinalizer(remove_test_dir)\npytest.fixture(scope='session', autouse=True)",
        "CUT_1": "oe_options = self.outlineexplorer.explorer.get_options()\nwindow = EditorMainWindow(self, self.stack_menu_actions, self.toolbar_list,\n    self.menu_list, outline_explorer_options=oe_options)\nwindow.add_toolbars_to_menu('&View', window.get_toolbars())\nwindow.load_toolbars()\nwindow.resize(self.size())\nwindow.show()\nwindow.editorwidget.editorsplitter.editorstack.new_window = True\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\nreturn window\n",
        "CUT_2": "oe_options = self.outlineexplorer.explorer.get_options()\nwindow = EditorMainWindow(self, self.stack_menu_actions, self.toolbar_list,\n    self.menu_list, outline_explorer_options=oe_options)\nwindow.add_toolbars_to_menu('&View', window.get_toolbars())\nwindow.load_toolbars()\nwindow.resize(self.size())\nwindow.show()\nwindow.editorwidget.editorsplitter.editorstack.new_window = True\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\nreturn window\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "window = EditorMainWindow(self, self.menu_actions, self.toolbar_list, self.\n    menu_list, show_fullpath=False, show_all_files=False, group_cells=True,\n    show_comments=True, sort_files_alphabetically=False)\nwindow.resize(self.size())\nwindow.show()\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\n",
        "CUT_5": "window = EditorMainWindow(self, self.menu_actions, self.toolbar_list, self.\n    menu_list, show_fullpath=False, show_all_files=False, group_cells=True,\n    show_comments=True, sort_files_alphabetically=False)\nwindow.resize(self.size())\nwindow.show()\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\n"
    },
    {
        "functionName": "remove_test_dir",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if hasattr(main_window, 'window'):\n    main_window.window.close()\n",
        "CUT_1": "oe_options = self.outlineexplorer.explorer.get_options()\nwindow = EditorMainWindow(self, self.stack_menu_actions, self.toolbar_list,\n    self.menu_list, outline_explorer_options=oe_options)\nwindow.add_toolbars_to_menu('&View', window.get_toolbars())\nwindow.load_toolbars()\nwindow.resize(self.size())\nwindow.show()\nwindow.editorwidget.editorsplitter.editorstack.new_window = True\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\nreturn window\n",
        "CUT_2": "oe_options = self.outlineexplorer.explorer.get_options()\nwindow = EditorMainWindow(self, self.stack_menu_actions, self.toolbar_list,\n    self.menu_list, outline_explorer_options=oe_options)\nwindow.add_toolbars_to_menu('&View', window.get_toolbars())\nwindow.load_toolbars()\nwindow.resize(self.size())\nwindow.show()\nwindow.editorwidget.editorsplitter.editorstack.new_window = True\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\nreturn window\n",
        "CUT_3": "window = EditorMainWindow(self, self.menu_actions, self.toolbar_list, self.\n    menu_list, show_fullpath=False, show_all_files=False, group_cells=True,\n    show_comments=True, sort_files_alphabetically=False)\nwindow.resize(self.size())\nwindow.show()\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\n",
        "CUT_4": "window = EditorMainWindow(self, self.menu_actions, self.toolbar_list, self.\n    menu_list, show_fullpath=False, show_all_files=False, group_cells=True,\n    show_comments=True, sort_files_alphabetically=False)\nwindow.resize(self.size())\nwindow.show()\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\n",
        "CUT_5": "\"\"\"Create a QMainWindow instance containing this plugin.\"\"\"\nself._undocked_window = window = PluginWindow(self)\nwindow.setAttribute(Qt.WA_DeleteOnClose)\nicon = self.get_plugin_icon()\nif is_text_string(icon):\n    icon = self.get_icon(icon)\nwindow.setWindowIcon(icon)\nwindow.setWindowTitle(self.get_plugin_title())\nwindow.setCentralWidget(self)\nwindow.resize(self.size())\nself.refresh_plugin()\nself.set_ancestor(window)\nself.dockwidget.setFloating(False)\nself.dockwidget.setVisible(False)\nwindow.show()\nSlot()"
    },
    {
        "functionName": "test_single_instance_and_edit_magic",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test single instance mode and %edit magic.\"\"\"\neditorstack = main_window.editor.get_current_editorstack()\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nspy_dir = osp.dirname(get_module_path('spyder'))\nlock_code = (\n    \"\"\"import sys\nsys.path.append(r'{spy_dir_str}')\nfrom spyder.utils.external import lockfile\nlock_file = r'{lock_file}'\nlock = lockfile.FilesystemLock(lock_file)\nlock_created = lock.lock()\nprint(lock_created)\"\"\"\n    .format(spy_dir_str=spy_dir, lock_file=get_conf_path('spyder.lock')))\nwith qtbot.waitSignal(shell.executed, timeout=2000):\n    shell.execute(lock_code)\nassert not shell.get_value('lock_created')\nn_editors = editorstack.get_stack_count()\np = tmpdir.mkdir('foo').join('bar.py')\np.write(lock_code)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%edit {}'.format(to_text_string(p)))\nqtbot.wait(3000)\nassert editorstack.get_stack_count() == n_editors + 1\nassert editorstack.get_current_editor().toPlainText() == lock_code\nmain_window.editor.close_file()\npytest.mark.slowpytest.mark.firstpytest.mark.single_instancepytest.mark.skipif(os.environ.get('CI', None) is None, reason=\n    \"It's not meant to be run outside of CIs\")",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_lock_action",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the lock interface action.\"\"\"\naction = main_window.lock_interface_action\nplugins = main_window.widgetlist\nassert main_window.interface_locked\nfor plugin in plugins:\n    title_bar = plugin.dockwidget.titleBarWidget()\n    assert not isinstance(title_bar, DockTitleBar)\n    assert isinstance(title_bar, QWidget)\naction.trigger()\nfor plugin in plugins:\n    title_bar = plugin.dockwidget.titleBarWidget()\n    assert isinstance(title_bar, DockTitleBar)\nassert not main_window.interface_locked\naction.trigger()\nassert main_window.interface_locked\npytest.mark.slow",
        "CUT_1": "\"\"\"Lock/Unlock dockwidgets and toolbars\"\"\"\nself.interface_locked = value\nCONF.set('main', 'panes_locked', value)\nself.lock_interface_action.setIcon(ima.icon('lock' if self.interface_locked\n     else 'lock_open'))\nself.lock_interface_action.setText(_('Unlock panes and toolbars') if self.\n    interface_locked else _('Lock panes and toolbars'))\nfor plugin in (self.widgetlist + self.thirdparty_plugins):\n    if self.interface_locked:\n        if plugin.dockwidget.isFloating():\n            plugin.dockwidget.setFloating(False)\n        plugin.dockwidget.remove_title_bar()\n    else:\n        plugin.dockwidget.set_title_bar()\nfor toolbar in self.toolbarslist:\n    if self.interface_locked:\n        toolbar.setMovable(False)\n    else:\n        toolbar.setMovable(True)\n",
        "CUT_2": "\"\"\"Lock/Unlock dockwidgets and toolbars\"\"\"\nself.interface_locked = value\nCONF.set('main', 'panes_locked', value)\nself.lock_interface_action.setIcon(ima.icon('lock' if self.interface_locked\n     else 'lock_open'))\nself.lock_interface_action.setText(_('Unlock panes and toolbars') if self.\n    interface_locked else _('Lock panes and toolbars'))\nfor plugin in (self.widgetlist + self.thirdparty_plugins):\n    if self.interface_locked:\n        if plugin.dockwidget.isFloating():\n            plugin.dockwidget.setFloating(False)\n        plugin.dockwidget.remove_title_bar()\n    else:\n        plugin.dockwidget.set_title_bar()\nfor toolbar in self.toolbarslist:\n    if self.interface_locked:\n        toolbar.setMovable(False)\n    else:\n        toolbar.setMovable(True)\n",
        "CUT_3": "order = ['editor', 'ipython_console', 'variable_explorer', 'help', 'plots',\n    None, 'explorer', 'outline_explorer', 'project_explorer',\n    'find_in_files', None, 'historylog', 'profiler', 'breakpoints',\n    'pylint', None, 'onlinehelp', 'internal_console', None]\nfor plugin in self.widgetlist:\n    try:\n        action = plugin.toggle_view_action\n    except AttributeError:\n        action = plugin._toggle_view_action\n    if action:\n        action.setChecked(plugin.dockwidget.isVisible())\n    try:\n        name = plugin.CONF_SECTION\n        pos = order.index(name)\n    except ValueError:\n        pos = None\n    if pos is not None:\n        order[pos] = action\n    else:\n        order.append(action)\nactions = order[:]\nfor action in order:\n    if type(action) is str:\n        actions.remove(action)\nself.plugins_menu_actions = actions\nadd_actions(self.plugins_menu, actions)\n",
        "CUT_4": "order = ['editor', 'ipython_console', 'variable_explorer', 'help', 'plots',\n    None, 'explorer', 'outline_explorer', 'project_explorer',\n    'find_in_files', None, 'historylog', 'profiler', 'breakpoints',\n    'pylint', None, 'onlinehelp', 'internal_console', None]\nfor plugin in self.widgetlist:\n    try:\n        action = plugin.toggle_view_action\n    except AttributeError:\n        action = plugin._toggle_view_action\n    if action:\n        action.setChecked(plugin.dockwidget.isVisible())\n    try:\n        name = plugin.CONF_SECTION\n        pos = order.index(name)\n    except ValueError:\n        pos = None\n    if pos is not None:\n        order[pos] = action\n    else:\n        order.append(action)\nactions = order[:]\nfor action in order:\n    if type(action) is str:\n        actions.remove(action)\nself.plugins_menu_actions = actions\nadd_actions(self.plugins_menu, actions)\n",
        "CUT_5": "\"\"\"\n        Register a plugin in Spyder Main Window.\n        \"\"\"\nself.set_splash(_('Loading {}...'.format(plugin.get_name())))\nlogger.info('Loading {}...'.format(plugin.NAME))\nis_compatible, message = plugin.check_compatibility()\nplugin.is_compatible = is_compatible\nplugin.get_description()\nif not is_compatible:\n    self.show_compatibility_message(message)\n    return\nplugin.sig_exception_occurred.connect(self.handle_exception)\nplugin.sig_free_memory_requested.connect(self.free_memory)\nplugin.sig_quit_requested.connect(self.close)\nplugin.sig_restart_requested.connect(self.restart)\nplugin.sig_restart_requested.connect(self.restart)\nplugin.sig_redirect_stdio_requested.connect(self.redirect_internalshell_stdio)\nplugin.sig_status_message_requested.connect(self.show_status_message)\nif isinstance(plugin, SpyderDockablePlugin):\n    plugin.sig_focus_changed.connect(self.plugin_focus_changed)\n    plugin.sig_switch_to_plugin_requested.connect(self.switch_to_plugin)\n    plugin.sig_update_ancestor_requested.connect(lambda : plugin.\n        set_ancestor(self))\nplugin._register()\nplugin.register()\nif isinstance(plugin, SpyderDockablePlugin):\n    self.add_dockwidget(plugin)\n    margin = 0\n    if CONF.get('main', 'use_custom_margin'):\n        margin = CONF.get('main', 'custom_margin')\n    plugin.update_margins(margin)\nself.add_plugin(plugin, external=external)\nlogger.info('Registering shortcuts for {}...'.format(plugin.NAME))\nfor action_name, action in plugin.get_actions().items():\n    context = getattr(action, 'shortcut_context', plugin.NAME) or plugin.NAME\n    if getattr(action, 'register_shortcut', True):\n        if isinstance(action_name, Enum):\n            action_name = action_name.value\n        self.register_shortcut(action, context, action_name)\nif isinstance(plugin, SpyderDockablePlugin):\n    try:\n        context = '_'\n        name = 'switch to {}'.format(plugin.CONF_SECTION)\n        shortcut = CONF.get_shortcut(context, name, plugin_name=plugin.\n            CONF_SECTION)\n    except (cp.NoSectionError, cp.NoOptionError):\n        shortcut = None\n    sc = QShortcut(QKeySequence(), self, lambda : self.switch_to_plugin(plugin)\n        )\n    sc.setContext(Qt.ApplicationShortcut)\n    plugin._shortcut = sc\n    self.register_shortcut(sc, context, name)\n    self.register_shortcut(plugin.toggle_view_action, context, name)\ntoolbars = plugin.get_registered_application_toolbars()\nfor __, toolbar in toolbars.items():\n    toolbar._render()\n    self.toolbarslist.append(toolbar)\n"
    },
    {
        "functionName": "test_default_plugin_actions",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the effect of dock, undock, close and toggle view actions.\"\"\"\nfile_explorer = main_window.explorer\nfile_explorer._undock_action.triggered.emit(True)\nqtbot.wait(500)\nassert not file_explorer.dockwidget.isVisible()\nassert file_explorer._undocked_window is not None\nassert isinstance(file_explorer._undocked_window, PluginWindow)\nassert file_explorer._undocked_window.centralWidget() == file_explorer\nfile_explorer._dock_action.triggered.emit(True)\nqtbot.wait(500)\nassert file_explorer.dockwidget.isVisible()\nassert file_explorer._undocked_window is None\nfile_explorer._close_plugin_action.triggered.emit(True)\nqtbot.wait(500)\nassert not file_explorer.dockwidget.isVisible()\nassert not file_explorer._toggle_view_action.isChecked()\nfile_explorer._toggle_view_action.setChecked(True)\nassert file_explorer.dockwidget.isVisible()\npytest.mark.slowpytest.mark.firstpytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on win and py2')",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "\"\"\"Update plugin title, i.e. dockwidget or window title\"\"\"\nif self.dockwidget is not None:\n    win = self.dockwidget\nelif self._undocked_window is not None:\n    win = self._undocked_window\nelse:\n    return\nwin.setWindowTitle(self.get_plugin_title())\n",
        "CUT_4": "\"\"\"Update plugin title, i.e. dockwidget or window title\"\"\"\nif self.dockwidget is not None:\n    win = self.dockwidget\nelif self._undocked_window is not None:\n    win = self._undocked_window\nelse:\n    return\nwin.setWindowTitle(self.get_plugin_title())\n",
        "CUT_5": "\"\"\"Close QMainWindow instance that contains this plugin.\"\"\"\nif self._undocked_window is not None:\n    self._undocked_window.close()\n    self._undocked_window = None\n    self._undock_action.setDisabled(False)\n    self._close_plugin_action.setDisabled(False)\nSlot()"
    },
    {
        "functionName": "test_opengl_implementation",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that we are setting the selected OpenGL implementation\n    \"\"\"\nassert main_window._test_setting_opengl('software')\nCONF.set('main', 'opengl', 'automatic')\npytest.mark.slowpytest.mark.parametrize('main_window', [{'spy_config': ('main', 'opengl',\n    'software')}], indirect=True)",
        "CUT_1": "\"\"\"\n    Set the OpenGL implementation used by Spyder.\n\n    See spyder-ide/spyder#7447 for the details.\n    \"\"\"\nif option == 'software':\n    QCoreApplication.setAttribute(Qt.AA_UseSoftwareOpenGL)\n    if QQuickWindow is not None:\n        QQuickWindow.setSceneGraphBackend(QSGRendererInterface.Software)\nelif option == 'desktop':\n    QCoreApplication.setAttribute(Qt.AA_UseDesktopOpenGL)\n    if QQuickWindow is not None:\n        QQuickWindow.setSceneGraphBackend(QSGRendererInterface.OpenGL)\nelif option == 'gles':\n    QCoreApplication.setAttribute(Qt.AA_UseOpenGLES)\n    if QQuickWindow is not None:\n        QQuickWindow.setSceneGraphBackend(QSGRendererInterface.OpenGL)\n",
        "CUT_2": "\"\"\"\n    Set the OpenGL implementation used by Spyder.\n\n    See spyder-ide/spyder#7447 for the details.\n    \"\"\"\nif option == 'software':\n    QCoreApplication.setAttribute(Qt.AA_UseSoftwareOpenGL)\n    if QQuickWindow is not None:\n        QQuickWindow.setSceneGraphBackend(QSGRendererInterface.Software)\nelif option == 'desktop':\n    QCoreApplication.setAttribute(Qt.AA_UseDesktopOpenGL)\n    if QQuickWindow is not None:\n        QQuickWindow.setSceneGraphBackend(QSGRendererInterface.OpenGL)\nelif option == 'gles':\n    QCoreApplication.setAttribute(Qt.AA_UseOpenGLES)\n    if QQuickWindow is not None:\n        QQuickWindow.setSceneGraphBackend(QSGRendererInterface.OpenGL)\n",
        "CUT_3": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n",
        "CUT_4": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n",
        "CUT_5": "\"\"\"Get the current OpenGL implementation in use\"\"\"\nif option == 'software':\n    return QCoreApplication.testAttribute(Qt.AA_UseSoftwareOpenGL)\nelif option == 'desktop':\n    return QCoreApplication.testAttribute(Qt.AA_UseDesktopOpenGL)\nelif option == 'gles':\n    return QCoreApplication.testAttribute(Qt.AA_UseOpenGLES)\n"
    },
    {
        "functionName": "test_filter_numpy_warning",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that we filter a warning shown when an array contains nan\n    values and the Variable Explorer option 'Show arrays min/man'\n    is on.\n\n    For spyder-ide/spyder#7063.\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\ncontrol = shell._control\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import numpy as np; A=np.full(16, np.nan)')\nqtbot.wait(1000)\nassert 'warning' not in control.toPlainText()\nassert 'Warning' not in control.toPlainText()\nCONF.set('variable_explorer', 'minmax', False)\npytest.mark.slowpytest.mark.skipif(np.__version__ < '1.14.0' or os.name == 'nt' and PY2,\n    reason='This only happens in Numpy 1.14+')pytest.mark.parametrize('main_window', [{'spy_config': ('variable_explorer',\n    'minmax', True)}], indirect=True)",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_get_help_combo",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that Help can display docstrings for names typed in its combobox.\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nhelp_plugin = main_window.help\nwebview = help_plugin.get_widget().rich_text.webview._webview\nif WEBENGINE:\n    webpage = webview.page()\nelse:\n    webpage = webview.page().mainFrame()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import numpy as np')\nobject_combo = help_plugin.get_widget().object_combo\nobject_combo.setFocus()\nqtbot.keyClicks(object_combo, 'numpy', delay=100)\nqtbot.waitUntil(lambda : check_text(webpage, 'NumPy'), timeout=6000)\nqtbot.keyClicks(object_combo, '.arange', delay=100)\nqtbot.waitUntil(lambda : check_text(webpage, 'arange'), timeout=6000)\nobject_combo.set_current_text('')\nqtbot.keyClicks(object_combo, 'np', delay=100)\nqtbot.waitUntil(lambda : check_text(webpage, 'NumPy'), timeout=6000)\nqtbot.keyClicks(object_combo, '.arange', delay=100)\nqtbot.waitUntil(lambda : check_text(webpage, 'arange'), timeout=6000)\npytest.mark.slowpytest.mark.skipif(PY2 or not sys.platform == 'darwin', reason=\n    'Times out in PY2 and fails on other than macOS')",
        "CUT_1": "self.object_combo.lineEdit().selectAll()\nreturn self.object_combo\n",
        "CUT_2": "self.object_combo.lineEdit().selectAll()\nreturn self.object_combo\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_5": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n"
    },
    {
        "functionName": "test_get_help_ipython_console_dot_notation",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that Help works when called from the IPython console\n    with dot calls i.e np.sin\n\n    See spyder-ide/spyder#11821\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\ncontrol = shell._control\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ntest_file = osp.join(LOCATION, 'script_unicode.py')\nmain_window.editor.load(test_file)\ncode_editor = main_window.editor.get_focus_widget()\nqtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.wait(500)\nhelp_plugin = main_window.help\nwebview = help_plugin.get_widget().rich_text.webview._webview\nwebpage = webview.page() if WEBENGINE else webview.page().mainFrame()\nqtbot.keyClicks(control, 'np.linalg.norm')\ncontrol.inspect_current_object()\nqtbot.waitUntil(lambda : check_text(webpage, 'Matrix or vector norm.'),\n    timeout=6000)\npytest.mark.slowpytest.mark.skipif(PY2, reason='Invalid definition of function in Python 2.')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_3": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_4": "QWidget.__init__(self, parent)\nself.webview = FrameWebView(self)\nself.webview.setup()\nif WEBENGINE:\n    self.webview.web_widget.page().setBackgroundColor(QColor(MAIN_BG_COLOR))\nelse:\n    self.webview.web_widget.setStyleSheet('background:{}'.format(MAIN_BG_COLOR)\n        )\n    self.viewview.page().setLinkDelegationPolicy(QWebEnginePage.\n        DelegateAllLinks)\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview.web_widget)\nself.find_widget.hide()\nlayout = QVBoxLayout()\nlayout.setContentsMargins(0, 0, 0, 0)\nlayout.addWidget(self.webview)\nlayout.addWidget(self.find_widget)\nself.setLayout(layout)\nself.webview.linkClicked.connect(self.sig_link_clicked)\n",
        "CUT_5": "QWidget.__init__(self, parent)\nself.webview = FrameWebView(self)\nself.webview.setup()\nif WEBENGINE:\n    self.webview.web_widget.page().setBackgroundColor(QColor(MAIN_BG_COLOR))\nelse:\n    self.webview.web_widget.setStyleSheet('background:{}'.format(MAIN_BG_COLOR)\n        )\n    self.viewview.page().setLinkDelegationPolicy(QWebEnginePage.\n        DelegateAllLinks)\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview.web_widget)\nself.find_widget.hide()\nlayout = QVBoxLayout()\nlayout.setContentsMargins(0, 0, 0, 0)\nlayout.addWidget(self.webview)\nlayout.addWidget(self.find_widget)\nself.setLayout(layout)\nself.webview.linkClicked.connect(self.sig_link_clicked)\n"
    },
    {
        "functionName": "test_get_help_ipython_console_special_characters",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that Help works when called from the IPython console\n    for unusual characters.\n\n    See spyder-ide/spyder#7699\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\ncontrol = shell._control\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ntest_file = osp.join(LOCATION, 'script_unicode.py')\nmain_window.editor.load(test_file)\ncode_editor = main_window.editor.get_focus_widget()\nqtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.wait(500)\nhelp_plugin = main_window.help\nwebview = help_plugin.get_widget().rich_text.webview._webview\nwebpage = webview.page() if WEBENGINE else webview.page().mainFrame()\ndef check_control(control, value):\n    return value in control.toPlainText()\nqtbot.keyClicks(control, 'aa\\t')\nqtbot.waitUntil(lambda : check_control(control, 'aa\u02b9bb'), timeout=2000)\ncontrol.inspect_current_object()\nqtbot.waitUntil(lambda : check_text(webpage, 'This function docstring.'),\n    timeout=6000)\npytest.mark.slowpytest.mark.skipif(PY2, reason='Invalid definition of function in Python 2.')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_5": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n"
    },
    {
        "functionName": "check_control",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return value in control.toPlainText()\n",
        "CUT_1": "return self.value\n",
        "CUT_2": "return self.value\n",
        "CUT_3": "self.value = value\n",
        "CUT_4": "self.value = value\n",
        "CUT_5": "return ','.join(value) if isinstance(value, list) else value\n"
    },
    {
        "functionName": "test_get_help_ipython_console",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that Help works when called from the IPython console.\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\ncontrol = shell._control\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nhelp_plugin = main_window.help\nwebview = help_plugin.get_widget().rich_text.webview._webview\nwebpage = webview.page() if WEBENGINE else webview.page().mainFrame()\nqtbot.keyClicks(control, 'runfile')\ncontrol.inspect_current_object()\nqtbot.waitUntil(lambda : check_text(webpage, 'namespace'), timeout=6000)\npytest.mark.slowpytest.mark.skipif(os.name == 'nt' and os.environ.get('CI') is not None,\n    reason='Times out on AppVeyor')",
        "CUT_1": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_2": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_3": "QWidget.__init__(self, parent)\nself.webview = FrameWebView(self)\nself.webview.setup()\nif WEBENGINE:\n    self.webview.web_widget.page().setBackgroundColor(QColor(MAIN_BG_COLOR))\nelse:\n    self.webview.web_widget.setStyleSheet('background:{}'.format(MAIN_BG_COLOR)\n        )\n    self.viewview.page().setLinkDelegationPolicy(QWebEnginePage.\n        DelegateAllLinks)\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview.web_widget)\nself.find_widget.hide()\nlayout = QVBoxLayout()\nlayout.setContentsMargins(0, 0, 0, 0)\nlayout.addWidget(self.webview)\nlayout.addWidget(self.find_widget)\nself.setLayout(layout)\nself.webview.linkClicked.connect(self.sig_link_clicked)\n",
        "CUT_4": "QWidget.__init__(self, parent)\nself.webview = FrameWebView(self)\nself.webview.setup()\nif WEBENGINE:\n    self.webview.web_widget.page().setBackgroundColor(QColor(MAIN_BG_COLOR))\nelse:\n    self.webview.web_widget.setStyleSheet('background:{}'.format(MAIN_BG_COLOR)\n        )\n    self.viewview.page().setLinkDelegationPolicy(QWebEnginePage.\n        DelegateAllLinks)\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview.web_widget)\nself.find_widget.hide()\nlayout = QVBoxLayout()\nlayout.setContentsMargins(0, 0, 0, 0)\nlayout.addWidget(self.webview)\nlayout.addWidget(self.find_widget)\nself.setLayout(layout)\nself.webview.linkClicked.connect(self.sig_link_clicked)\n",
        "CUT_5": "super().__init__(name, plugin, parent=parent, options=options)\nself._is_running = False\nself.home_url = None\nself.server = None\nself.label = QLabel(_('Package:'))\nself.url_combo = UrlComboBox(self)\nself.webview = WebView(self, handle_links=self.get_option('handle_links'))\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview)\nself.find_widget.hide()\nself.url_combo.setMaxCount(self.get_option('max_history_entries'))\ntip = _('Write a package name here, e.g. pandas')\nself.url_combo.lineEdit().setPlaceholderText(tip)\nself.url_combo.lineEdit().setToolTip(tip)\nself.webview.setup()\nself.webview.set_zoom_factor(self.get_option('zoom_factor'))\nspacing = 10\nlayout = QVBoxLayout()\nlayout.addWidget(self.webview)\nlayout.addSpacing(spacing)\nlayout.addWidget(self.find_widget)\nlayout.addSpacing(int(spacing / 2))\nself.setLayout(layout)\nself.url_combo.valid.connect(lambda x: self._handle_url_combo_activation())\nself.webview.loadStarted.connect(self._start)\nself.webview.loadFinished.connect(self._finish)\nself.webview.titleChanged.connect(self.setWindowTitle)\nself.webview.urlChanged.connect(self._change_url)\nif not WEBENGINE:\n    self.webview.iconChanged.connect(self._handle_icon_change)\n"
    },
    {
        "functionName": "test_get_help_editor",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that Help works when called from the Editor.\"\"\"\nhelp_plugin = main_window.help\nwebview = help_plugin.get_widget().rich_text.webview._webview\nwebpage = webview.page() if WEBENGINE else webview.page().mainFrame()\nmain_window.editor.new(fname='test.py', text='')\ncode_editor = main_window.editor.get_focus_widget()\neditorstack = main_window.editor.get_current_editorstack()\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_open()\nobject_name, expected_text = object_info\ncode_editor.set_text(object_name)\ncode_editor.move_cursor(len(object_name))\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(code_editor.sig_display_object_info, timeout=30000):\n    editorstack.inspect_current_object()\nqtbot.waitUntil(lambda : check_text(webpage, expected_text), timeout=30000)\npytest.mark.slowpytest.mark.skipif(not sys.platform.startswith('linux'), reason=\n    'Does not work on Mac and Windows!')pytest.mark.use_introspectionpytest.mark.parametrize('object_info', [('range', 'range'), (\n    'import matplotlib.pyplot as plt',\n    'The object-oriented API is recommended for more complex plots.')])",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_window_title",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test window title with non-ascii characters.\"\"\"\nprojects = main_window.projects\npath = to_text_string(tmpdir.mkdir('\u6e2c\u8a66'))\nprojects.open_project(path=path)\nmain_window.window_title = '\u0627\u062e\u062a\u0628\u0627\u0631'\nmain_window.set_window_title()\ntitle = main_window.base_title\nassert 'Spyder' in title\nassert 'Python' in title\nassert '\u0627\u062e\u062a\u0628\u0627\u0631' in title\nassert '\u6e2c\u8a66' in title\nprojects.close_project()\npytest.mark.slow",
        "CUT_1": "\"\"\"Set window title.\"\"\"\nif DEV is not None:\n    title = 'Spyder %s (Python %s.%s)' % (__version__, sys.version_info[0],\n        sys.version_info[1])\nelse:\n    title = 'Spyder (Python %s.%s)' % (sys.version_info[0], sys.version_info[1]\n        )\nif get_debug_level():\n    title += ' [DEBUG MODE %d]' % get_debug_level()\nif self.window_title is not None:\n    title += ' -- ' + to_text_string(self.window_title)\nif self.projects is not None:\n    path = self.projects.get_active_project_path()\n    if path:\n        path = path.replace(get_home_dir(), '~')\n        title = '{0} - {1}'.format(path, title)\nself.base_title = title\nself.setWindowTitle(self.base_title)\n",
        "CUT_2": "\"\"\"Set window title.\"\"\"\nif DEV is not None:\n    title = 'Spyder %s (Python %s.%s)' % (__version__, sys.version_info[0],\n        sys.version_info[1])\nelse:\n    title = 'Spyder (Python %s.%s)' % (sys.version_info[0], sys.version_info[1]\n        )\nif get_debug_level():\n    title += ' [DEBUG MODE %d]' % get_debug_level()\nif self.window_title is not None:\n    title += ' -- ' + to_text_string(self.window_title)\nif self.projects is not None:\n    path = self.projects.get_active_project_path()\n    if path:\n        path = path.replace(get_home_dir(), '~')\n        title = '{0} - {1}'.format(path, title)\nself.base_title = title\nself.setWindowTitle(self.base_title)\n",
        "CUT_3": "\"\"\"Return widget title\"\"\"\ntitle = _('Editor')\nreturn title\n",
        "CUT_4": "\"\"\"Return widget title\"\"\"\ntitle = _('Editor')\nreturn title\n",
        "CUT_5": "self.projects = projects\n"
    },
    {
        "functionName": "test_move_to_first_breakpoint",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that we move to the first breakpoint if there's one present.\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = shell._control\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nmain_window.editor.clear_all_breakpoints()\ntest_file = osp.join(LOCATION, 'script.py')\nmain_window.editor.load(test_file)\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.debugger.toogle_breakpoint(line_number=10)\nqtbot.wait(500)\ncursor = code_editor.textCursor()\ncursor.setPosition(0)\ncode_editor.setTextCursor(cursor)\nif debugcell:\n    for i in range(2):\n        qtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\n        qtbot.wait(500)\n    with qtbot.waitSignal(shell.executed):\n        qtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.AltModifier |\n            Qt.ShiftModifier)\n    assert shell.spyder_kernel_comm.is_open()\n    assert shell.is_waiting_pdb_input()\n    with qtbot.waitSignal(shell.executed):\n        shell.pdb_execute('!b')\n    assert 'script.py:10' in shell._control.toPlainText()\n    with qtbot.waitSignal(shell.executed):\n        shell.pdb_execute('!c')\nelse:\n    with qtbot.waitSignal(shell.executed):\n        qtbot.mouseClick(debug_button, Qt.LeftButton)\nshell.clear_console()\nqtbot.wait(500)\nwith qtbot.waitSignal(shell.executed):\n    shell.pdb_execute('!list')\nassert '1--> 10 arr = np.array(li)' in control.toPlainText()\nshell.pdb_execute('!exit')\nqtbot.wait(500)\ncode_editor.debugger.toogle_breakpoint(line_number=2)\nqtbot.wait(500)\nqtbot.mouseClick(debug_button, Qt.LeftButton)\nqtbot.wait(1000)\ntry:\n    assert shell.is_waiting_pdb_input()\nexcept Exception:\n    print('Shell content: ', shell._control.toPlainText(), '\\n\\n')\n    raise\nmain_window.editor.clear_all_breakpoints()\nmain_window.editor.close_file()\npytest.mark.slowpytest.mark.skipif(os.name == 'nt' or PY2, reason='It fails sometimes')pytest.mark.parametrize('debugcell', [True, False])",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_runconfig_workdir",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test runconfig workdir options.\"\"\"\nCONF.set('run', 'configurations', [])\ntest_file = osp.join(LOCATION, 'script.py')\nmain_window.editor.load(test_file)\ncode_editor = main_window.editor.get_focus_widget()\nrc = RunConfiguration().get()\nrc['file_dir'] = False\nrc['cw_dir'] = True\nconfig_entry = test_file, rc\nCONF.set('run', 'configurations', [config_entry])\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nqtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.wait(500)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import os; current_dir = os.getcwd()')\nassert shell.get_value('current_dir') == get_home_dir()\ntemp_dir = str(tmpdir.mkdir('test_dir'))\nrc['file_dir'] = False\nrc['cw_dir'] = False\nrc['fixed_dir'] = True\nrc['dir'] = temp_dir\nconfig_entry = test_file, rc\nCONF.set('run', 'configurations', [config_entry])\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nqtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.wait(500)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import os; current_dir = os.getcwd()')\nassert shell.get_value('current_dir') == temp_dir\nmain_window.editor.close_file()\nCONF.set('run', 'configurations', [])\npytest.mark.slowpytest.mark.skipif(os.name == 'nt', reason='Fails on windows!')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_dedicated_consoles",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test running code in dedicated consoles.\"\"\"\ntest_file = osp.join(LOCATION, 'script.py')\nmain_window.editor.load(test_file)\ncode_editor = main_window.editor.get_focus_widget()\nrc = RunConfiguration().get()\nrc['current'] = rc['systerm'] = False\nconfig_entry = test_file, rc\nCONF.set('run', 'configurations', [config_entry])\nqtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.wait(500)\nshell = main_window.ipyconsole.get_current_shellwidget()\ncontrol = shell._control\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nnsb = main_window.variableexplorer.get_focus_widget()\nassert len(main_window.ipyconsole.get_clients()) == 2\nassert main_window.ipyconsole.filenames == ['', test_file]\nassert main_window.ipyconsole.tabwidget.tabText(1) == 'script.py/A'\nqtbot.wait(500)\nassert nsb.editor.source_model.rowCount() == 4\ntext = control.toPlainText()\nassert 'runfile' in text and not ('Python' in text or 'IPython' in text)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('zz = -1')\nqtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.wait(500)\nassert not shell.is_defined('zz')\nassert 'runfile' in control.toPlainText()\nmain_window.editor.close_file()\nCONF.set('run', 'configurations', [])\npytest.mark.slowpytest.mark.skipif(os.name == 'nt' or sys.platform == 'darwin', reason=\n    \"It's failing there\")",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_connection_to_external_kernel",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that only Spyder kernels are connected to the Variable Explorer.\"\"\"\nkm, kc = start_new_kernel()\nmain_window.ipyconsole._create_client_for_kernel(kc.connection_file, None,\n    None, None)\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 10')\nmain_window.variableexplorer._visibility_changed(True)\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.wait(500)\nassert nsb.editor.source_model.rowCount() == 0\nspykm, spykc = start_new_kernel(spykernel=True)\nmain_window.ipyconsole._create_client_for_kernel(spykc.connection_file,\n    None, None, None)\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 10')\nmain_window.variableexplorer._visibility_changed(True)\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.wait(500)\nassert nsb.editor.source_model.rowCount() == 1\nspykm.stop_restarter()\nkm.stop_restarter()\nspykm.shutdown_kernel(now=True)\nkm.shutdown_kernel(now=True)\nspykc.stop_channels()\nkc.stop_channels()\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_change_types_in_varexp",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that variable types can't be changed in the Variable Explorer.\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 10')\nmain_window.variableexplorer._visibility_changed(True)\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() > 0, timeout=\n    EVAL_TIMEOUT)\nnsb.editor.setFocus()\nnsb.editor.edit_item()\nqtbot.keyClicks(QApplication.focusWidget(), \"'s'\")\nqtbot.keyClick(QApplication.focusWidget(), Qt.Key_Enter)\nqtbot.wait(1000)\nassert shell.get_value('a') == 10\npytest.mark.slowpytest.mark.skipif(os.name == 'nt', reason='It times out sometimes on Windows')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_3": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_change_cwd_ipython_console",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test synchronization with working directory and File Explorer when\n    changing cwd in the IPython console.\n    \"\"\"\nwdir = main_window.workingdirectory\ntreewidget = main_window.explorer.fileexplorer.treewidget\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ntemp_dir = to_text_string(tmpdir.mkdir(test_directory))\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%cd {}'.format(temp_dir))\nqtbot.wait(1000)\nassert osp.normpath(wdir.get_container().history[-1]) == osp.normpath(temp_dir)\nassert osp.normpath(treewidget.get_current_folder()) == osp.normpath(temp_dir)\npytest.mark.slowpytest.mark.parametrize('test_directory', ['non_ascii_\u00f1_\u00ed_\u00e7', 'test_dir'])pytest.mark.skipif(sys.platform == 'darwin', reason='It fails on macOS')",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"Download the installer or installation script.\"\"\"\ntemp_dir = gettempdir()\npath = osp.join(temp_dir, self._installer_name)\nif sys.platform.startswith('linux'):\n    self._change_installation_status(status=DOWNLOADING_SCRIPT)\nelse:\n    self._change_installation_status(status=DOWNLOADING_INSTALLER)\nreturn urlretrieve(self._download_url, path, reporthook=self._progress_reporter\n    )\n"
    },
    {
        "functionName": "test_change_cwd_explorer",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test synchronization with working directory and IPython console when\n    changing directories in the File Explorer.\n    \"\"\"\nwdir = main_window.workingdirectory\nexplorer = main_window.explorer\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ntemp_dir = to_text_string(tmpdir.mkdir(test_directory))\nexplorer.chdir(temp_dir)\nqtbot.wait(1000)\nassert osp.normpath(wdir.get_container().history[-1]) == osp.normpath(temp_dir)\nassert osp.normpath(temp_dir) == osp.normpath(shell._cwd)\npytest.mark.slowpytest.mark.parametrize('test_directory', ['non_ascii_\u00f1_\u00ed_\u00e7', 'test_dir'])pytest.mark.skipif(sys.platform == 'darwin', reason='It fails on macOS')",
        "CUT_1": "\"\"\"Download the installer or installation script.\"\"\"\ntemp_dir = gettempdir()\npath = osp.join(temp_dir, self._installer_name)\nif sys.platform.startswith('linux'):\n    self._change_installation_status(status=DOWNLOADING_SCRIPT)\nelse:\n    self._change_installation_status(status=DOWNLOADING_INSTALLER)\nreturn urlretrieve(self._download_url, path, reporthook=self._progress_reporter\n    )\n",
        "CUT_2": "\"\"\"Download the installer or installation script.\"\"\"\ntemp_dir = gettempdir()\npath = osp.join(temp_dir, self._installer_name)\nif sys.platform.startswith('linux'):\n    self._change_installation_status(status=DOWNLOADING_SCRIPT)\nelse:\n    self._change_installation_status(status=DOWNLOADING_INSTALLER)\nreturn urlretrieve(self._download_url, path, reporthook=self._progress_reporter\n    )\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"Setup proxy model filter parameters\"\"\"\nself.root_path = osp.normpath(to_text_string(root_path))\nself.path_list = [osp.normpath(to_text_string(p)) for p in path_list]\nself.invalidateFilter()\n"
    },
    {
        "functionName": "test_run_cython_code",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test all the different ways we have to run Cython code\"\"\"\ncode_editor = main_window.editor.get_focus_widget()\nmain_window.editor.load(osp.join(LOCATION, 'pyx_script.pyx'))\nqtbot.keyClick(code_editor, Qt.Key_F5)\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 1, timeout=\n    COMPILE_AND_EVAL_TIMEOUT)\nshell = main_window.ipyconsole.get_current_shellwidget()\nassert shell.get_value('a') == 3628800\nreset_run_code(qtbot, shell, code_editor, nsb)\nmain_window.editor.close_file()\nmain_window.editor.load(osp.join(LOCATION, 'pyx_lib_import.py'))\nqtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 1, timeout=\n    COMPILE_AND_EVAL_TIMEOUT)\nassert shell.get_value('b') == 3628800\nmain_window.editor.close_file()\npytest.mark.slowpytest.mark.skipif(os.name == 'nt' or sys.platform == 'darwin' or \n    LooseVersion(ipy_release.version) == LooseVersion('7.11.0'), reason=\n    'Hard to test on Windows and macOS and fails for IPython 7.11.0')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_3": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_4": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_5": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n"
    },
    {
        "functionName": "test_open_notebooks_from_project_explorer",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that notebooks are open from the Project explorer.\"\"\"\nprojects = main_window.projects\neditorstack = main_window.editor.get_current_editorstack()\nproject_dir = to_text_string(tmpdir.mkdir('test'))\nnb = osp.join(LOCATION, 'notebook.ipynb')\nshutil.copy(nb, osp.join(project_dir, 'notebook.ipynb'))\nwith qtbot.waitSignal(projects.sig_project_loaded):\n    projects._create_project(project_dir)\nidx = projects.explorer.treewidget.get_index('notebook.ipynb')\nprojects.explorer.treewidget.setCurrentIndex(idx)\nqtbot.keyClick(projects.explorer.treewidget, Qt.Key_Enter)\nassert 'notebook.ipynb' in editorstack.get_current_filename()\nprojects.explorer.treewidget.convert_notebook(osp.join(project_dir,\n    'notebook.ipynb'))\nassert 'untitled' in editorstack.get_current_filename()\nfile_text = editorstack.get_current_editor().toPlainText()\nif nbconvert.__version__ >= '5.4.0':\n    expected_text = \"\"\"#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\n1 + 1\n\n\n# In[ ]:\n\n\n\n\n\"\"\"\nelse:\n    expected_text = '\\n# coding: utf-8\\n\\n# In[1]:\\n\\n\\n1 + 1\\n\\n\\n'\nassert file_text == expected_text\nprojects.close_project()\npytest.mark.slowpytest.mark.skipif(os.name == 'nt', reason='It fails on Windows.')",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n"
    },
    {
        "functionName": "test_runfile_from_project_explorer",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that file are run from the Project explorer.\"\"\"\nprojects = main_window.projects\neditorstack = main_window.editor.get_current_editorstack()\nproject_dir = to_text_string(tmpdir.mkdir('test'))\ntest_file = osp.join(LOCATION, 'script.py')\nshutil.copy(test_file, osp.join(project_dir, 'script.py'))\nwith qtbot.waitSignal(projects.sig_project_loaded):\n    projects._create_project(project_dir)\nidx = projects.explorer.treewidget.get_index('script.py')\nprojects.explorer.treewidget.setCurrentIndex(idx)\nqtbot.keyClick(projects.explorer.treewidget, Qt.Key_Enter)\nassert 'script.py' in editorstack.get_current_filename()\nprojects.explorer.treewidget.run([osp.join(project_dir, 'script.py')])\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 4, timeout=\n    EVAL_TIMEOUT)\nassert shell.get_value('a') == 10\nassert shell.get_value('s') == 'Z:\\\\escape\\\\test\\\\string\\n'\nassert shell.get_value('li') == [1, 2, 3]\nassert_array_equal(shell.get_value('arr'), np.array([1, 2, 3]))\nprojects.close_project()\npytest.mark.slow",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_set_new_breakpoints",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that new breakpoints are set in the IPython console.\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\ncontrol = shell._control\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nmain_window.editor.clear_all_breakpoints()\ntest_file = osp.join(LOCATION, 'script.py')\nmain_window.editor.load(test_file)\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nqtbot.mouseClick(debug_button, Qt.LeftButton)\nqtbot.wait(1000)\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.debugger.toogle_breakpoint(line_number=6)\nqtbot.wait(500)\nshell.pdb_execute('!b')\nqtbot.wait(500)\nassert '1   breakpoint   keep yes   at {}:6'.format(test_file\n    ) in control.toPlainText()\nmain_window.editor.clear_all_breakpoints()\nmain_window.editor.close_file()\npytest.mark.slowpytest.mark.skipif(os.name == 'nt', reason='It times out sometimes on Windows')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_run_code",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test all the different ways we have to run code\"\"\"\np = tmpdir.mkdir(\"runtest's folder \u00e8\u00e1\u00ef\u00fc \u00d8\u03b1\u00f4\u00e5 \u5b57\u5206\u8bef\").join(\n    \"runtest's file \u00e8\u00e1\u00ef\u00fc \u00d8\u03b1\u00f4\u00e5 \u5b57\u5206\u8bef.py\")\nfilepath = to_text_string(p)\nshutil.copyfile(osp.join(LOCATION, 'script.py'), filepath)\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nmain_window.editor.load(filepath)\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.setFocus()\nqtbot.keyClick(code_editor, Qt.Key_Home, modifier=Qt.ControlModifier)\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 4, timeout=\n    EVAL_TIMEOUT)\nassert shell.get_value('a') == 10\nassert shell.get_value('s') == 'Z:\\\\escape\\\\test\\\\string\\n'\nassert shell.get_value('li') == [1, 2, 3]\nassert_array_equal(shell.get_value('arr'), np.array([1, 2, 3]))\nreset_run_code(qtbot, shell, code_editor, nsb)\nfor _ in range(code_editor.blockCount()):\n    qtbot.keyClick(code_editor, Qt.Key_F9)\n    qtbot.wait(200)\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 4, timeout=\n    EVAL_TIMEOUT)\nassert shell.get_value('a') == 10\nassert shell.get_value('s') == 'Z:\\\\escape\\\\test\\\\string\\n'\nassert shell.get_value('li') == [1, 2, 3]\nassert_array_equal(shell.get_value('arr'), np.array([1, 2, 3]))\nreset_run_code(qtbot, shell, code_editor, nsb)\nqtbot.keyClicks(code_editor, 'a = 10')\nqtbot.keyClick(code_editor, Qt.Key_Return)\nqtbot.keyClick(code_editor, Qt.Key_Up)\nfor _ in range(5):\n    qtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\n    qtbot.wait(500)\nassert 'runcell' in shell._control.toPlainText()\nassert 'Error:' not in shell._control.toPlainText()\ncontrol_text = shell._control.toPlainText()\nshell.setFocus()\nqtbot.keyClick(shell._control, Qt.Key_Up)\nqtbot.wait(500)\nqtbot.keyClick(shell._control, Qt.Key_Enter, modifier=Qt.ShiftModifier)\nqtbot.wait(500)\ncode_editor.setFocus()\nassert control_text != shell._control.toPlainText()\ncontrol_text = shell._control.toPlainText()[len(control_text):]\nassert 'runcell' in control_text\nassert 'Error' not in control_text\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 4, timeout=\n    EVAL_TIMEOUT)\nassert ']: 10\\n' in shell._control.toPlainText()\nassert shell.get_value('a') == 10\nassert shell.get_value('s') == 'Z:\\\\escape\\\\test\\\\string\\n'\nassert shell.get_value('li') == [1, 2, 3]\nassert_array_equal(shell.get_value('arr'), np.array([1, 2, 3]))\nreset_run_code(qtbot, shell, code_editor, nsb)\nmodifier = Qt.ControlModifier\nif sys.platform == 'darwin':\n    modifier = Qt.MetaModifier\nqtbot.keyClick(code_editor, Qt.Key_Return, modifier=modifier)\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 1, timeout=\n    EVAL_TIMEOUT)\nassert shell.get_value('a') == 10\nqtbot.keyClick(code_editor, Qt.Key_Return, modifier=modifier)\nassert nsb.editor.source_model.rowCount() == 1\nreset_run_code(qtbot, shell, code_editor, nsb)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.AltModifier | Qt\n        .ShiftModifier)\nqtbot.keyClicks(shell._control, '!c')\nqtbot.keyClick(shell._control, Qt.Key_Enter)\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 1, timeout=\n    EVAL_TIMEOUT)\nreset_run_code(qtbot, shell, code_editor, nsb)\nqtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nqtbot.wait(500)\nqtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nqtbot.wait(500)\nqtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 2, timeout=\n    EVAL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%reset -f')\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 0, timeout=\n    EVAL_TIMEOUT)\nqtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.AltModifier)\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 1, timeout=\n    EVAL_TIMEOUT)\nassert shell.get_value('li') == [1, 2, 3]\nmain_window.editor.close_file()\npytest.mark.slow",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "return self.shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n"
    },
    {
        "functionName": "test_run_cell_copy",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test all the different ways we have to run code\"\"\"\np = tmpdir.mkdir(\"runtest's folder \u00e8\u00e1\u00ef\u00fc \u00d8\u03b1\u00f4\u00e5 \u5b57\u5206\u8bef\").join(\n    \"runtest's file \u00e8\u00e1\u00ef\u00fc \u00d8\u03b1\u00f4\u00e5 \u5b57\u5206\u8bef.py\")\nfilepath = to_text_string(p)\nshutil.copyfile(osp.join(LOCATION, 'script.py'), filepath)\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nfor editorstack in main_window.editor.editorstacks:\n    editorstack.set_run_cell_copy(True)\nmain_window.editor.load(filepath)\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.setFocus()\nqtbot.keyClick(code_editor, Qt.Key_Home, modifier=Qt.ControlModifier)\nnsb = main_window.variableexplorer.get_focus_widget()\nfor _ in range(4):\n    qtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\n    qtbot.wait(500)\nassert 'runcell' not in shell._control.toPlainText()\nassert 'a = 10' in shell._control.toPlainText()\nassert 'Error:' not in shell._control.toPlainText()\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 4, timeout=\n    EVAL_TIMEOUT)\nassert ']: 10\\n' in shell._control.toPlainText()\nassert shell.get_value('a') == 10\nassert shell.get_value('s') == 'Z:\\\\escape\\\\test\\\\string\\n'\nassert shell.get_value('li') == [1, 2, 3]\nassert_array_equal(shell.get_value('arr'), np.array([1, 2, 3]))\nmain_window.editor.close_file()\nCONF.set('editor', 'run_cell_copy', False)\npytest.mark.slowpytest.mark.skipif(sys.platform == 'darwin', reason='It fails on macOS')pytest.mark.parametrize('main_window', [{'spy_config': ('editor',\n    'run_cell_copy', True)}], indirect=True)",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_open_files_in_new_editor_window",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    This tests that opening files in a new editor window\n    is working as expected.\n\n    Test for spyder-ide/spyder#4085.\n    \"\"\"\nQTimer.singleShot(2000, lambda : open_file_in_editor(main_window,\n    'script.py', directory=LOCATION))\nmain_window.editor.create_new_window()\nmain_window.editor.load()\neditorstack = main_window.editor.get_current_editorstack()\nassert editorstack.get_stack_count() == 2\npytest.mark.slowpytest.mark.skipif(os.name == 'nt' or os.environ.get('CI', None) is None or\n    PYQT5, reason=\n    \"It times out sometimes on Windows, it's not meant to be run outside of a CI and it segfaults too frequently in PyQt5\"\n    )",
        "CUT_1": "\"\"\"Get editor for filename and set it as the current editor.\"\"\"\neditorstack = self.get_editorstack()\nif editorstack is None:\n    return None\nif not filename:\n    return None\nindex = editorstack.has_filename(filename)\nif index is None:\n    return None\nreturn editorstack.data[index].editor\n",
        "CUT_2": "\"\"\"Get editor for filename and set it as the current editor.\"\"\"\neditorstack = self.get_editorstack()\nif editorstack is None:\n    return None\nif not filename:\n    return None\nindex = editorstack.has_filename(filename)\nif index is None:\n    return None\nreturn editorstack.data[index].editor\n",
        "CUT_3": "\"\"\"Get the current editorstack.\"\"\"\nplugin = self.ipyclient.plugin\nif plugin.main.editor is not None:\n    editor = plugin.main.editor\n    return editor.get_current_editorstack()\nraise RuntimeError('No editorstack found.')\n",
        "CUT_4": "\"\"\"Get the current editorstack.\"\"\"\nplugin = self.ipyclient.plugin\nif plugin.main.editor is not None:\n    editor = plugin.main.editor\n    return editor.get_current_editorstack()\nraise RuntimeError('No editorstack found.')\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n"
    },
    {
        "functionName": "test_close_when_file_is_changed",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test closing spyder when there is a file with modifications open.\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ntest_file = osp.join(LOCATION, 'script.py')\nmain_window.editor.load(test_file)\neditorstack = main_window.editor.get_current_editorstack()\neditor = editorstack.get_current_editor()\neditor.document().setModified(True)\nqtbot.wait(3000)\npytest.mark.slow",
        "CUT_1": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "test_maximize_minimize_plugins",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the maximize button is working correctly.\"\"\"\nmain_window.editor.get_focus_widget().setFocus()\nmax_action = main_window.maximize_action\nmax_button = main_window.main_toolbar.widgetForAction(max_action)\nqtbot.mouseClick(max_button, Qt.LeftButton)\nassert main_window.editor._ismaximized\nqtbot.mouseClick(max_button, Qt.LeftButton)\nassert not main_window.editor._ismaximized\npytest.mark.slow",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Create configuration dialog box page widget\"\"\"\nif self.CONFIGWIDGET_CLASS is not None:\n    parent = self\n    main = dlg\n    if not hasattr(self, 'dockwidget'):\n        parent = dlg\n        main = main_window\n    configwidget = self.CONFIGWIDGET_CLASS(parent, main)\n    configwidget.initialize()\n    return configwidget\n",
        "CUT_3": "\"\"\"Create configuration dialog box page widget\"\"\"\nif self.CONFIGWIDGET_CLASS is not None:\n    parent = self\n    main = dlg\n    if not hasattr(self, 'dockwidget'):\n        parent = dlg\n        main = main_window\n    configwidget = self.CONFIGWIDGET_CLASS(parent, main)\n    configwidget.initialize()\n    return configwidget\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_issue_4066",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test for a segfault when these steps are followed:\n\n    1. Open an object present in the Variable Explorer (e.g. a list).\n    2. Delete that object in its corresponding console while its\n       editor is still opem.\n    3. Closing that editor by pressing its *Ok* button.\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('myobj = [1, 2, 3]')\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() > 0, timeout=\n    EVAL_TIMEOUT)\nnsb.editor.setFocus()\nnsb.editor.edit_item()\nobj_editor_id = list(nsb.editor.delegate._editors.keys())[0]\nobj_editor = nsb.editor.delegate._editors[obj_editor_id]['editor']\nmain_window.ipyconsole.get_focus_widget().setFocus()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('del myobj')\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 0, timeout=\n    EVAL_TIMEOUT)\nok_widget = obj_editor.btn_close\nqtbot.mouseClick(ok_widget, Qt.LeftButton)\nqtbot.wait(3000)\npytest.mark.slowpytest.mark.skipif(os.name == 'nt' or os.environ.get('CI', None) is not\n    None and PYQT_VERSION >= '5.9', reason=\n    'It times out on Windows and segfaults in our CIs with PyQt >= 5.9')",
        "CUT_1": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_2": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_3": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_4": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_5": "\"\"\"Import data in current namespace\"\"\"\nif self.count():\n    nsb = self.current_widget()\n    nsb.refresh_table()\n    nsb.import_data(filenames=fname)\n    if self.dockwidget:\n        self.switch_to_plugin()\n"
    },
    {
        "functionName": "test_varexp_edit_inline",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test for errors when editing inline values in the Variable Explorer\n    and then moving to another plugin.\n\n    Note: Errors for this test don't appear related to it but instead they\n    are shown down the road. That's because they are generated by an\n    async C++ RuntimeError.\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 10')\nmain_window.variableexplorer._visibility_changed(True)\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() > 0, timeout=\n    EVAL_TIMEOUT)\nnsb.editor.setFocus()\nnsb.editor.edit_item()\nmain_window.ipyconsole.get_focus_widget().setFocus()\nqtbot.wait(3000)\npytest.mark.slowpytest.mark.skipif(os.name == 'nt', reason='It times out sometimes on Windows')",
        "CUT_1": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_2": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_3": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_4": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_5": "\"\"\"Import data in current namespace\"\"\"\nif self.count():\n    nsb = self.current_widget()\n    nsb.refresh_table()\n    nsb.import_data(filenames=fname)\n    if self.dockwidget:\n        self.switch_to_plugin()\n"
    },
    {
        "functionName": "test_c_and_n_pdb_commands",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that c and n Pdb commands update the Variable Explorer.\"\"\"\nnsb = main_window.variableexplorer.get_focus_widget()\nshell = main_window.ipyconsole.get_current_shellwidget()\ncontrol = shell._control\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nmain_window.editor.clear_all_breakpoints()\ntest_file = osp.join(LOCATION, 'script.py')\nmain_window.editor.load(test_file)\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.mouseClick(debug_button, Qt.LeftButton)\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.debugger.toogle_breakpoint(line_number=6)\nqtbot.wait(500)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, '!c')\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 1)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, '!n')\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 2)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, '!n')\n    qtbot.keyClick(control, Qt.Key_Enter)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, '!n')\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.waitUntil(lambda : nsb.editor.source_model.rowCount() == 3)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, '!n')\n    qtbot.keyClick(control, Qt.Key_Enter)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, '!n')\n    qtbot.keyClick(control, Qt.Key_Enter)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, '!n')\n    qtbot.keyClick(control, Qt.Key_Enter)\nshell.clear_console()\nassert 'In [2]:' in control.toPlainText()\nmain_window.editor.clear_all_breakpoints()\nmain_window.editor.close_file()\npytest.mark.slowpytest.mark.skipif(not sys.platform.startswith('linux'), reason=\n    'It times out sometimes on Windows and macOS')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_stop_dbg",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that we correctly stop a debugging session.\"\"\"\nnsb = main_window.variableexplorer.get_focus_widget()\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nmain_window.editor.clear_all_breakpoints()\ntest_file = osp.join(LOCATION, 'script.py')\nmain_window.editor.load(test_file)\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nqtbot.mouseClick(debug_button, Qt.LeftButton)\nqtbot.wait(1000)\nshell.pdb_execute('!n')\nqtbot.wait(1000)\nstop_debug_action = main_window.debug_toolbar_actions[5]\nstop_debug_button = main_window.debug_toolbar.widgetForAction(stop_debug_action\n    )\nqtbot.mouseClick(stop_debug_button, Qt.LeftButton)\nqtbot.wait(1000)\nassert shell._control.toPlainText().count('IPdb') == 2\nmain_window.editor.clear_all_breakpoints()\nmain_window.editor.close_file()\npytest.mark.slowpytest.mark.skipif(os.name == 'nt', reason='It times out sometimes on Windows')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_change_cwd_dbg",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that using the Working directory toolbar is working while debugging.\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ntest_file = osp.join(LOCATION, 'script.py')\nmain_window.editor.load(test_file)\ncontrol = main_window.ipyconsole.get_focus_widget()\ncontrol.setFocus()\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nqtbot.mouseClick(debug_button, Qt.LeftButton)\nqtbot.wait(1000)\nmain_window.workingdirectory.chdir(tempfile.gettempdir())\nqtbot.wait(1000)\nprint(repr(control.toPlainText()))\nshell.clear_console()\nqtbot.wait(500)\nqtbot.keyClicks(control, 'import os; os.getcwd()')\nqtbot.keyClick(control, Qt.Key_Enter)\nqtbot.wait(1000)\nassert tempfile.gettempdir() in control.toPlainText()\npytest.mark.slowpytest.mark.skipif(not sys.platform.startswith('linux'), reason=\n    'It only works on Linux')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\":param editor: CodeEditor instance to control.\"\"\"\nself._editor = weakref.ref(editor)\n",
        "CUT_5": "\"\"\":param editor: CodeEditor instance to control.\"\"\"\nself._editor = weakref.ref(editor)\n"
    },
    {
        "functionName": "test_varexp_magic_dbg",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that %varexp is working while debugging.\"\"\"\nnsb = main_window.variableexplorer.get_focus_widget()\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ntest_file = osp.join(LOCATION, 'script.py')\nmain_window.editor.load(test_file)\ncontrol = main_window.ipyconsole.get_focus_widget()\ncontrol.setFocus()\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.mouseClick(debug_button, Qt.LeftButton)\nfor _ in range(2):\n    with qtbot.waitSignal(shell.executed):\n        qtbot.keyClicks(control, '!n')\n        qtbot.keyClick(control, Qt.Key_Enter)\nnsb.editor.plot('li', 'plot')\nqtbot.wait(1000)\nassert shell._control.toHtml().count('img src') == 1\npytest.mark.slowpytest.mark.skipif(os.name == 'nt' or PY2, reason='It times out sometimes')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_plots_plugin",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that plots generated in the IPython console are properly displayed\n    in the plots plugin.\n    \"\"\"\nassert CONF.get('plots', 'mute_inline_plotting') is False\nshell = main_window.ipyconsole.get_current_shellwidget()\nfigbrowser = main_window.plots.current_widget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\n        \"import matplotlib.pyplot as plt\\nfig = plt.plot([1, 2, 3, 4], '.')\\n\")\nif CONF.get('ipython_console', 'pylab/inline/figure_format') == 0:\n    assert figbrowser.figviewer.figcanvas.fmt == 'image/png'\nelse:\n    assert figbrowser.figviewer.figcanvas.fmt == 'image/svg+xml'\nhtml = shell._control.toHtml()\nimg_name = re.search('<img src=\"(.+?)\" /></p>', html).group(1)\nipython_figname = osp.join(to_text_string(tmpdir), 'ipython_img.png')\nipython_qimg = shell._get_image(img_name)\nipython_qimg.save(ipython_figname)\nplots_figname = osp.join(to_text_string(tmpdir), 'plots_img.png')\nmocker.patch('spyder.plugins.plots.widgets.figurebrowser.getsavefilename',\n    return_value=(plots_figname, '.png'))\nfigbrowser.save_figure()\nassert compare_images(ipython_figname, plots_figname, 0.1) is None\npytest.mark.slowpytest.mark.skipif(PY2, reason='It times out sometimes')pytest.mark.parametrize('main_window', [{'spy_config': ('ipython_console',\n    'pylab/inline/figure_format', 1)}, {'spy_config': ('ipython_console',\n    'pylab/inline/figure_format', 0)}], indirect=True)",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return _('Plots')\n",
        "CUT_4": "return _('Plots')\n",
        "CUT_5": "return _('Plots')\n"
    },
    {
        "functionName": "test_tight_layout_option_for_inline_plot",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the option to set bbox_inches to 'tight' or 'None' is\n    working when plotting inline in the IPython console. By default, figures\n    are plotted inline with bbox_inches='tight'.\n    \"\"\"\ntmpdir = to_text_string(tmpdir)\nassert CONF.get('ipython_console', 'pylab/inline/bbox_inches') is True\nfig_dpi = float(CONF.get('ipython_console', 'pylab/inline/resolution'))\nfig_width = float(CONF.get('ipython_console', 'pylab/inline/width'))\nfig_height = float(CONF.get('ipython_console', 'pylab/inline/height'))\nshell = main_window.ipyconsole.get_current_shellwidget()\nclient = main_window.ipyconsole.get_current_client()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = main_window.ipyconsole.get_focus_widget()\ncontrol.setFocus()\nsavefig_figname = osp.join(tmpdir, 'savefig_bbox_inches_tight.png').replace(\n    '\\\\', '/')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\n        \"\"\"import matplotlib.pyplot as plt\nfig, ax = plt.subplots()\nfig.set_size_inches(%f, %f)\nax.set_position([0.25, 0.25, 0.5, 0.5])\nax.set_xticks(range(10))\nax.xaxis.set_ticklabels([])\nax.set_yticks(range(10))\nax.yaxis.set_ticklabels([])\nax.tick_params(axis='both', length=0)\nfor loc in ax.spines:\n    ax.spines[loc].set_color('#000000')\n    ax.spines[loc].set_linewidth(2)\nax.axis([0, 9, 0, 9])\nax.plot(range(10), color='#000000', lw=2)\nfig.savefig('%s',\n            bbox_inches='tight',\n            dpi=%f)\"\"\"\n         % (fig_width, fig_height, savefig_figname, fig_dpi))\nhtml = shell._control.toHtml()\nimg_name = re.search('<img src=\"(.+?)\" /></p>', html).group(1)\nqimg = shell._get_image(img_name)\nassert isinstance(qimg, QImage)\ninline_figname = osp.join(tmpdir, 'inline_bbox_inches_tight.png')\nqimg.save(inline_figname)\nassert compare_images(savefig_figname, inline_figname, 0.1) is None\nCONF.set('ipython_console', 'pylab/inline/bbox_inches', False)\nshell._prompt_html = None\nclient.restart_kernel()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nsavefig_figname = osp.join(tmpdir, 'savefig_bbox_inches_None.png').replace('\\\\'\n    , '/')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\n        \"\"\"import matplotlib.pyplot as plt\nfig, ax = plt.subplots()\nfig.set_size_inches(%f, %f)\nax.set_position([0.25, 0.25, 0.5, 0.5])\nax.set_xticks(range(10))\nax.xaxis.set_ticklabels([])\nax.set_yticks(range(10))\nax.yaxis.set_ticklabels([])\nax.tick_params(axis='both', length=0)\nfor loc in ax.spines:\n    ax.spines[loc].set_color('#000000')\n    ax.spines[loc].set_linewidth(2)\nax.axis([0, 9, 0, 9])\nax.plot(range(10), color='#000000', lw=2)\nfig.savefig('%s',\n            bbox_inches=None,\n            dpi=%f)\"\"\"\n         % (fig_width, fig_height, savefig_figname, fig_dpi))\nhtml = shell._control.toHtml()\nimg_name = re.search('<img src=\"(.+?)\" /></p>', html).group(1)\nqimg = shell._get_image(img_name)\nassert isinstance(qimg, QImage)\ninline_figname = osp.join(tmpdir, 'inline_bbox_inches_None.png')\nqimg.save(inline_figname)\nassert compare_images(savefig_figname, inline_figname, 0.1) is None\npytest.mark.slowpytest.mark.skipif(PY2, reason='It times out sometimes')",
        "CUT_1": "\"\"\"Return the labels of the levels if any.\"\"\"\nax = self._axis(axis)\nif hasattr(ax, 'levels'):\n    return ax.names[level]\nif ax.name:\n    return ax.name\n",
        "CUT_2": "\"\"\"Return the labels of the levels if any.\"\"\"\nax = self._axis(axis)\nif hasattr(ax, 'levels'):\n    return ax.names[level]\nif ax.name:\n    return ax.name\n",
        "CUT_3": "\"\"\"\n        Return the values of the labels for the header of columns or rows.\n\n        The value corresponds to the header of column or row x in the\n        given level.\n        \"\"\"\nax = self._axis(axis)\nif not hasattr(ax, 'levels'):\n    ax = self._axis_list(axis)\n    return ax[x]\nelse:\n    return ax.values[x][level]\n",
        "CUT_4": "\"\"\"\n        Return the values of the labels for the header of columns or rows.\n\n        The value corresponds to the header of column or row x in the\n        given level.\n        \"\"\"\nax = self._axis(axis)\nif not hasattr(ax, 'levels'):\n    ax = self._axis_list(axis)\n    return ax[x]\nelse:\n    return ax.values[x][level]\n",
        "CUT_5": "\"\"\"\n        Return the number of levels in the labels taking into account the axis.\n\n        Get the number of levels for the columns (0) or rows (1).\n        \"\"\"\nax = self._axis(axis)\nreturn 1 if not hasattr(ax, 'levels') else len(ax.levels)\n"
    },
    {
        "functionName": "test_switcher",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the use of shorten paths when necessary in the switcher.\"\"\"\nswitcher = main_window.switcher\nfile_a = tmpdir.join('test_file_a.py')\nfile_a.write(\"\"\"\ndef example_def():\n    pass\n\ndef example_def_2():\n    pass\n\"\"\"\n    )\nmain_window.editor.load(str(file_a))\nmain_window.open_switcher()\nswitcher_paths = [switcher.model.item(item_idx).get_description() for\n    item_idx in range(switcher.model.rowCount())]\nassert osp.dirname(str(file_a)) in switcher_paths or len(str(file_a)) > 75\nswitcher.close()\ndir_b = tmpdir\nfor _ in range(3):\n    dir_b = dir_b.mkdir(str(uuid.uuid4()))\nfile_b = dir_b.join('test_file_b.py')\nfile_b.write('bar\\n')\nmain_window.editor.load(str(file_b))\nmain_window.open_switcher()\nfile_b_text = switcher.model.item(switcher.model.rowCount() - 1\n    ).get_description()\nassert '...' in file_b_text\nswitcher.close()\nsearch_texts = ['test_file_a', 'file_b', 'foo_spam']\nexpected_paths = [file_a, file_b, None]\nfor search_text, expected_path in zip(search_texts, expected_paths):\n    main_window.open_switcher()\n    qtbot.keyClicks(switcher.edit, search_text)\n    qtbot.wait(200)\n    assert switcher.count() == bool(expected_path)\n    switcher.close()\nmain_window.editor.set_current_filename(str(file_a))\nmain_window.open_switcher()\nqtbot.keyClicks(switcher.edit, '@')\nqtbot.wait(200)\nassert switcher.count() == 2\nswitcher.close()\npytest.mark.slow",
        "CUT_1": "\"\"\"Create switcher dialog instance.\"\"\"\nif self.switcher is None:\n    from spyder.widgets.switcher import Switcher\n    self.switcher = Switcher(self)\nreturn self.switcher\n",
        "CUT_2": "\"\"\"Create switcher dialog instance.\"\"\"\nif self.switcher is None:\n    from spyder.widgets.switcher import Switcher\n    self.switcher = Switcher(self)\nreturn self.switcher\n",
        "CUT_3": "\"\"\"Open switcher dialog box.\"\"\"\nif self.switcher is not None and self.switcher.isVisible():\n    self.switcher.clear()\n    self.switcher.hide()\n    return\nif symbol:\n    self.switcher.set_search_text('@')\nelse:\n    self.switcher.set_search_text('')\n    self.switcher.setup()\nself.switcher.show()\ndelta_top = self.toolbars_menu.geometry().height() + self.menuBar().geometry(\n    ).height() + 6\nself.switcher.set_position(delta_top)\n",
        "CUT_4": "\"\"\"Open switcher dialog box.\"\"\"\nif self.switcher is not None and self.switcher.isVisible():\n    self.switcher.clear()\n    self.switcher.hide()\n    return\nif symbol:\n    self.switcher.set_search_text('@')\nelse:\n    self.switcher.set_search_text('')\n    self.switcher.setup()\nself.switcher.show()\ndelta_top = self.toolbars_menu.geometry().height() + self.menuBar().geometry(\n    ).height() + 6\nself.switcher.set_position(delta_top)\n",
        "CUT_5": "\"\"\"Override Qt method.\"\"\"\nsuper(Switcher, self).accept()\n"
    },
    {
        "functionName": "test_edidorstack_open_switcher_dlg",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the file switcher is working as expected when called from the\n    editorstack.\n\n    Regression test for spyder-ide/spyder#10684\n    \"\"\"\nfile = tmpdir.join('test_file_open_switcher_dlg.py')\nfile.write('a test file for test_edidorstack_open_switcher_dlg')\nmain_window.editor.load(str(file))\neditorstack = main_window.editor.get_current_editorstack()\nassert editorstack.switcher_dlg is None\neditorstack.open_switcher_dlg()\nassert editorstack.switcher_dlg\nassert editorstack.switcher_dlg.isVisible()\nassert editorstack.switcher_dlg.count() == len(main_window.editor.\n    get_filenames())\npytest.mark.slow",
        "CUT_1": "\"\"\"Open file list management dialog box\"\"\"\nif not self.tabs.count():\n    return\nif self.switcher_dlg is not None and self.switcher_dlg.isVisible():\n    self.switcher_dlg.hide()\n    self.switcher_dlg.clear()\n    return\nif self.switcher_dlg is None:\n    from spyder.widgets.switcher import Switcher\n    self.switcher_dlg = Switcher(self)\n    self.switcher_manager = EditorSwitcherManager(self.get_plugin(), self.\n        switcher_dlg, lambda : self.get_current_editor(), lambda : self,\n        section=self.get_plugin_title())\nself.switcher_dlg.set_search_text(initial_text)\nself.switcher_dlg.setup()\nself.switcher_dlg.show()\ndelta_top = self.tabs.tabBar().geometry().height() + self.fname_label.geometry(\n    ).height() + 1\nself.switcher_dlg.set_position(delta_top)\nSlot()Slot(str)",
        "CUT_2": "\"\"\"Open file list management dialog box\"\"\"\nif not self.tabs.count():\n    return\nif self.switcher_dlg is not None and self.switcher_dlg.isVisible():\n    self.switcher_dlg.hide()\n    self.switcher_dlg.clear()\n    return\nif self.switcher_dlg is None:\n    from spyder.widgets.switcher import Switcher\n    self.switcher_dlg = Switcher(self)\n    self.switcher_manager = EditorSwitcherManager(self.get_plugin(), self.\n        switcher_dlg, lambda : self.get_current_editor(), lambda : self,\n        section=self.get_plugin_title())\nself.switcher_dlg.set_search_text(initial_text)\nself.switcher_dlg.setup()\nself.switcher_dlg.show()\ndelta_top = self.tabs.tabBar().geometry().height() + self.fname_label.geometry(\n    ).height() + 1\nself.switcher_dlg.set_position(delta_top)\nSlot()Slot(str)",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "test_edidorstack_open_symbolfinder_dlg",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the symbol finder is working as expected when called from the\n    editorstack.\n\n    Regression test for spyder-ide/spyder#10684\n    \"\"\"\nfile = tmpdir.join('test_file.py')\nfile.write(\n    \"\"\"\n               def example_def():\n                   pass\n\n               def example_def_2():\n                   pass\n               \"\"\"\n    )\nmain_window.editor.load(str(file))\neditorstack = main_window.editor.get_current_editorstack()\nassert editorstack.switcher_dlg is None\neditorstack.open_symbolfinder_dlg()\nassert editorstack.switcher_dlg\nassert editorstack.switcher_dlg.isVisible()\nassert editorstack.switcher_dlg.count() == 2\npytest.mark.slow",
        "CUT_1": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_5": "\"\"\"Open file list management dialog box\"\"\"\nif not self.tabs.count():\n    return\nif self.switcher_dlg is not None and self.switcher_dlg.isVisible():\n    self.switcher_dlg.hide()\n    self.switcher_dlg.clear()\n    return\nif self.switcher_dlg is None:\n    from spyder.widgets.switcher import Switcher\n    self.switcher_dlg = Switcher(self)\n    self.switcher_manager = EditorSwitcherManager(self.get_plugin(), self.\n        switcher_dlg, lambda : self.get_current_editor(), lambda : self,\n        section=self.get_plugin_title())\nself.switcher_dlg.set_search_text(initial_text)\nself.switcher_dlg.setup()\nself.switcher_dlg.show()\ndelta_top = self.tabs.tabBar().geometry().height() + self.fname_label.geometry(\n    ).height() + 1\nself.switcher_dlg.set_position(delta_top)\nSlot()Slot(str)"
    },
    {
        "functionName": "test_run_static_code_analysis",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"This tests that the Pylint plugin is working as expected.\"\"\"\npylint_plugin = get_thirdparty_plugin(main_window, 'Code Analysis')\ntest_file = osp.join(LOCATION, 'script_pylint.py')\nmain_window.editor.load(test_file)\ncode_editor = main_window.editor.get_focus_widget()\nqtbot.keyClick(code_editor, Qt.Key_F8)\nqtbot.wait(3000)\ntreewidget = pylint_plugin.get_focus_widget()\nqtbot.waitUntil(lambda : treewidget.results is not None, timeout=SHELL_TIMEOUT)\nresult_content = treewidget.results\nassert result_content['C:']\npylint_version = LooseVersion(pylint.__version__)\nif pylint_version < LooseVersion('2.5.0'):\n    number_of_conventions = 5\nelse:\n    number_of_conventions = 3\nassert len(result_content['C:']) == number_of_conventions\nmain_window.editor.close_file()\npytest.mark.slowpytest.mark.skipif(sys.platform == 'darwin', reason=\n    'Times out sometimes on macOS')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Register plugin in Spyder's main window\"\"\"\nipyconsole = self.main.ipyconsole\ntreewidget = self.fileexplorer.treewidget\nself.add_dockwidget()\nself.fileexplorer.sig_open_file.connect(self.main.open_file)\nself.register_widget_shortcuts(treewidget)\ntreewidget.sig_edit.connect(self.main.editor.load)\ntreewidget.sig_removed.connect(self.main.editor.removed)\ntreewidget.sig_removed_tree.connect(self.main.editor.removed_tree)\ntreewidget.sig_renamed.connect(self.main.editor.renamed)\ntreewidget.sig_renamed_tree.connect(self.main.editor.renamed_tree)\ntreewidget.sig_create_module.connect(self.main.editor.new)\ntreewidget.sig_new_file.connect(lambda t: self.main.editor.new(text=t))\ntreewidget.sig_open_interpreter.connect(ipyconsole.create_client_from_path)\ntreewidget.redirect_stdio.connect(self.main.redirect_internalshell_stdio)\ntreewidget.sig_run.connect(lambda fname: ipyconsole.run_script(fname, osp.\n    dirname(fname), '', False, False, False, True, False))\ntreewidget.sig_dir_opened.connect(self.sig_dir_opened)\n",
        "CUT_3": "\"\"\"Register plugin in Spyder's main window\"\"\"\nipyconsole = self.main.ipyconsole\ntreewidget = self.fileexplorer.treewidget\nself.add_dockwidget()\nself.fileexplorer.sig_open_file.connect(self.main.open_file)\nself.register_widget_shortcuts(treewidget)\ntreewidget.sig_edit.connect(self.main.editor.load)\ntreewidget.sig_removed.connect(self.main.editor.removed)\ntreewidget.sig_removed_tree.connect(self.main.editor.removed_tree)\ntreewidget.sig_renamed.connect(self.main.editor.renamed)\ntreewidget.sig_renamed_tree.connect(self.main.editor.renamed_tree)\ntreewidget.sig_create_module.connect(self.main.editor.new)\ntreewidget.sig_new_file.connect(lambda t: self.main.editor.new(text=t))\ntreewidget.sig_open_interpreter.connect(ipyconsole.create_client_from_path)\ntreewidget.redirect_stdio.connect(self.main.redirect_internalshell_stdio)\ntreewidget.sig_run.connect(lambda fname: ipyconsole.run_script(fname, osp.\n    dirname(fname), '', False, False, False, True, False))\ntreewidget.sig_dir_opened.connect(self.sig_dir_opened)\n",
        "CUT_4": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_5": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n"
    },
    {
        "functionName": "test_troubleshooting_menu_item_and_url",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the troubleshooting menu item calls the valid URL.\"\"\"\nMockMainWindow = MagicMock(spec=MainWindow)\nmockMainWindow_instance = MockMainWindow()\nmockMainWindow_instance.__class__ = MainWindow\nMockQDesktopServices = Mock()\nmockQDesktopServices_instance = MockQDesktopServices()\nattr_to_patch = 'spyder.app.mainwindow.QDesktopServices'\nmonkeypatch.setattr(attr_to_patch, MockQDesktopServices)\nMainWindow.trouble_guide(mockMainWindow_instance)\nassert MockQDesktopServices.openUrl.call_count == 1\nmockQDesktopServices_instance.openUrl.called_once_with(__trouble_url__)\n",
        "CUT_1": "return self.get_widget().create_dockwidget(mainwindow)\n",
        "CUT_2": "return self.get_widget().create_dockwidget(mainwindow)\n",
        "CUT_3": "\"\"\"Open Spyder troubleshooting guide in a web browser.\"\"\"\nurl = QUrl(__trouble_url__)\nQDesktopServices.openUrl(url)\nSlot()",
        "CUT_4": "\"\"\"Open Spyder troubleshooting guide in a web browser.\"\"\"\nurl = QUrl(__trouble_url__)\nQDesktopServices.openUrl(url)\nSlot()",
        "CUT_5": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture"
    },
    {
        "functionName": "test_help_opens_when_show_tutorial_full",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test fix for spyder-ide/spyder#6317.\n\n    'Show tutorial' opens the help plugin if closed.\n    \"\"\"\nHELP_STR = 'Help'\nhelp_pane_menuitem = None\nfor action in main_window.plugins_menu.actions():\n    if action.text() == HELP_STR:\n        help_pane_menuitem = action\n        break\nmain_window.help.toggle_view_action.setChecked(False)\nqtbot.wait(500)\nhelp_tabbar, help_index = find_desired_tab_in_window(HELP_STR, main_window)\nassert help_tabbar is None and help_index is None\nassert not isinstance(main_window.focusWidget(), ObjectComboBox)\nassert not help_pane_menuitem.isChecked()\nmain_window.help.show_tutorial()\nqtbot.wait(500)\nhelp_tabbar, help_index = find_desired_tab_in_window(HELP_STR, main_window)\nassert None not in (help_tabbar, help_index)\nassert help_index == help_tabbar.currentIndex()\nassert help_pane_menuitem.isChecked()\nhelp_tabbar.setCurrentIndex((help_tabbar.currentIndex() + 1) % help_tabbar.\n    count())\nqtbot.wait(500)\nhelp_tabbar, help_index = find_desired_tab_in_window(HELP_STR, main_window)\nassert None not in (help_tabbar, help_index)\nassert help_index != help_tabbar.currentIndex()\nassert help_pane_menuitem.isChecked()\nmain_window.help.show_tutorial()\nqtbot.wait(500)\nhelp_tabbar, help_index = find_desired_tab_in_window(HELP_STR, main_window)\nassert None not in (help_tabbar, help_index)\nassert help_index == help_tabbar.currentIndex()\nassert help_pane_menuitem.isChecked()\nqtbot.wait(500)\nmain_window.help.show_tutorial()\nhelp_tabbar, help_index = find_desired_tab_in_window(HELP_STR, main_window)\nqtbot.wait(500)\nassert None not in (help_tabbar, help_index)\nassert help_index == help_tabbar.currentIndex()\nassert help_pane_menuitem.isChecked()\npytest.mark.slowpytest.mark.skipif(os.name == 'nt', reason='It fails on Windows')",
        "CUT_1": "return _('Help')\n",
        "CUT_2": "return _('Help')\n",
        "CUT_3": "return _('Help')\n",
        "CUT_4": "return _('Help')\n",
        "CUT_5": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n"
    },
    {
        "functionName": "test_report_issue",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the report error dialog opens correctly.\"\"\"\nmain_window.report_issue()\nqtbot.wait(300)\nassert main_window._report_dlg is not None\nassert main_window._report_dlg.isVisible()\nassert main_window._report_dlg.close()\npytest.mark.slow",
        "CUT_1": "\"\"\"Report a Spyder issue to github.\"\"\"\nfrom spyder.widgets.reporterror import SpyderErrorDialog\nself._report_dlg = SpyderErrorDialog(self, is_report=True)\nself._report_dlg.set_color_scheme(CONF.get('appearance', 'selected'))\nself._report_dlg.show()\nSlot()",
        "CUT_2": "\"\"\"Report a Spyder issue to github.\"\"\"\nfrom spyder.widgets.reporterror import SpyderErrorDialog\nself._report_dlg = SpyderErrorDialog(self, is_report=True)\nself._report_dlg.set_color_scheme(CONF.get('appearance', 'selected'))\nself._report_dlg.show()\nSlot()",
        "CUT_3": "\"\"\"Create configuration dialog box page widget\"\"\"\nif self.CONFIGWIDGET_CLASS is not None:\n    parent = self\n    main = dlg\n    if not hasattr(self, 'dockwidget'):\n        parent = dlg\n        main = main_window\n    configwidget = self.CONFIGWIDGET_CLASS(parent, main)\n    configwidget.initialize()\n    return configwidget\n",
        "CUT_4": "\"\"\"Create configuration dialog box page widget\"\"\"\nif self.CONFIGWIDGET_CLASS is not None:\n    parent = self\n    main = dlg\n    if not hasattr(self, 'dockwidget'):\n        parent = dlg\n        main = main_window\n    configwidget = self.CONFIGWIDGET_CLASS(parent, main)\n    configwidget.initialize()\n    return configwidget\n",
        "CUT_5": "\"\"\"\n    Decide what tests to run (slow or fast) according to the --run-slow\n    option.\n    \"\"\"\nslow_option = config.getoption('--run-slow')\nskip_slow = pytest.mark.skip(reason='Need --run-slow option to run')\nskip_fast = pytest.mark.skip(reason=\"Don't need --run-slow option to run\")\nfor item in items:\n    if slow_option:\n        if 'slow' not in item.keywords:\n            item.add_marker(skip_fast)\n    elif 'slow' in item.keywords:\n        item.add_marker(skip_slow)\n"
    },
    {
        "functionName": "test_custom_layouts",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that layout are showing the expected widgets visible.\"\"\"\nmw = main_window\nmw.first_spyder_run = False\nprefix = 'window' + '/'\nsettings = mw.load_window_settings(prefix=prefix, default=True)\nfor layout_idx in (['default'] + list(range(4))):\n    with qtbot.waitSignal(mw.sig_layout_setup_ready, timeout=5000):\n        layout = mw.setup_default_layouts(layout_idx, settings=settings)\n        with qtbot.waitSignal(None, timeout=500, raising=False):\n            pass\n        widgets_layout = layout['widgets']\n        hidden_widgets = layout['hidden widgets']\n        for column in widgets_layout:\n            for row in column:\n                for idx, widget in enumerate(row):\n                    if idx == 0:\n                        if widget not in hidden_widgets:\n                            print(widget)\n                            try:\n                                assert widget.get_widget().isVisible()\n                            except AttributeError:\n                                assert widget.isVisible()\npytest.mark.slowpytest.mark.skipif(sys.platform.startswith('linux'), reason=\n    'It segfaults on Linux')",
        "CUT_1": "\"\"\"Helper to add toolbar widgets to top and bottom layout.\"\"\"\nlayout.setAlignment(Qt.AlignLeft)\nfor widget in widgets:\n    if widget is None:\n        layout.addStretch(1)\n    else:\n        layout.addWidget(widget)\n",
        "CUT_2": "\"\"\"Helper to add toolbar widgets to top and bottom layout.\"\"\"\nlayout.setAlignment(Qt.AlignLeft)\nfor widget in widgets:\n    if widget is None:\n        layout.addStretch(1)\n    else:\n        layout.addWidget(widget)\n",
        "CUT_3": "\"\"\"Create simple tab widget page: widgets added in a vertical layout\"\"\"\nwidget = QWidget()\nlayout = QVBoxLayout()\nfor widg in widgets:\n    layout.addWidget(widg)\nlayout.addStretch(1)\nwidget.setLayout(layout)\nreturn widget\n",
        "CUT_4": "\"\"\"Create simple tab widget page: widgets added in a vertical layout\"\"\"\nwidget = QWidget()\nlayout = QVBoxLayout()\nfor widg in widgets:\n    layout.addWidget(widg)\nlayout.addStretch(1)\nwidget.setLayout(layout)\nreturn widget\n",
        "CUT_5": "\"\"\" \"\"\"\nfor widget in self.widgets:\n    widget.setDisabled(True)\n"
    },
    {
        "functionName": "test_save_on_runfile",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that layout are showing the expected widgets visible.\"\"\"\ntest_file = osp.join(LOCATION, 'script.py')\ntest_file_copy = test_file[:-3] + '_copy.py'\nshutil.copyfile(test_file, test_file_copy)\nmain_window.editor.load(test_file_copy)\ncode_editor = main_window.editor.get_focus_widget()\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nqtbot.keyClicks(code_editor, 'test_var = 123', delay=100)\nfilename = code_editor.filename\nwith qtbot.waitSignal(shell.sig_prompt_ready):\n    shell.execute('runfile(\"{}\")'.format(remove_backslashes(filename)))\nassert shell.get_value('test_var') == 123\nmain_window.editor.close_file()\nos.remove(test_file_copy)\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_pylint_follows_file",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that file editor focus change updates pylint combobox filename.\"\"\"\nfor plugin in main_window.thirdparty_plugins:\n    if plugin.CONF_SECTION == 'pylint':\n        pylint_plugin = plugin\n        break\npylint_plugin.dockwidget.show()\npylint_plugin.dockwidget.raise_()\nbasedir = tmpdir.mkdir('foo')\nfor idx in range(2):\n    fh = basedir.join('{}.py'.format(idx))\n    fname = str(fh)\n    fh.write('print(\"Hello world!\")')\n    main_window.open_file(fh)\n    qtbot.wait(200)\n    assert fname == pylint_plugin.get_filename()\nmain_window.editor.editorsplitter.split(orientation=Qt.Vertical)\nqtbot.wait(500)\nfor idx in range(4):\n    fh = basedir.join('{}.py'.format(idx))\n    fh.write('print(\"Hello world!\")')\n    fname = str(fh)\n    main_window.open_file(fh)\n    qtbot.wait(200)\n    assert fname == pylint_plugin.get_filename()\nfor editorstack in reversed(main_window.editor.editorstacks):\n    editorstack.close_split()\n    break\nqtbot.wait(1000)\npytest.mark.slowpytest.mark.skipif(sys.platform == 'darwin', reason='Fails on macOS')",
        "CUT_1": "\"\"\"\n        Save history to a text file in the Spyder configuration directory.\n        \"\"\"\ndata = '\\n'.join(self.get_widget().get_history())\nwith open(self.LOG_PATH, 'w') as fh:\n    fh.write(data)\n",
        "CUT_2": "\"\"\"\n        Save history to a text file in the Spyder configuration directory.\n        \"\"\"\ndata = '\\n'.join(self.get_widget().get_history())\nwith open(self.LOG_PATH, 'w') as fh:\n    fh.write(data)\n",
        "CUT_3": "\"\"\"\n        Save history to a text file in the user configuration directory.\n        \"\"\"\ntry:\n    search_history = '\\n'.join(self.get_widget().get_history())\n    with open(self.LOG_PATH, 'w') as fh:\n        fh.write(search_history)\nexcept (UnicodeEncodeError, UnicodeDecodeError, EnvironmentError):\n    pass\n",
        "CUT_4": "\"\"\"\n        Save history to a text file in the user configuration directory.\n        \"\"\"\ntry:\n    search_history = '\\n'.join(self.get_widget().get_history())\n    with open(self.LOG_PATH, 'w') as fh:\n        fh.write(search_history)\nexcept (UnicodeEncodeError, UnicodeDecodeError, EnvironmentError):\n    pass\n",
        "CUT_5": "\"\"\"\n        Load history from a text file in the Spyder configuration directory.\n        \"\"\"\nif osp.isfile(self.LOG_PATH):\n    with open(self.LOG_PATH, 'r') as fh:\n        lines = fh.read().split('\\n')\n    history = [line.replace('\\n', '') for line in lines]\nelse:\n    history = []\nreturn history\n"
    },
    {
        "functionName": "test_report_comms_error",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test if a comms error is correctly displayed.\"\"\"\nCONF.set('main', 'show_internal_errors', True)\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('def get_cwd(): import foo')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\n        \"get_ipython().kernel.frontend_comm.register_call_handler('get_cwd', get_cwd)\"\n        )\nwith qtbot.waitSignal(shell.executed, timeout=3000):\n    shell.execute('ls')\nerror_dialog = main_window.console.error_dialog\nassert error_dialog is not None\nassert 'Exception in comms call get_cwd' in error_dialog.error_traceback\nassert 'No module named' in error_dialog.error_traceback\nmain_window.console.close_error_dialog()\nCONF.set('main', 'show_internal_errors', False)\npytest.mark.slowpytest.mark.skipif(os.name == 'nt', reason='Fails on Windows')",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_break_while_running",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that we can set breakpoints while running.\"\"\"\ncode = \"\"\"import time\nfor i in range(100):\n    print(i)\n    time.sleep(0.1)\n\"\"\"\np = tmpdir.join('loop_script.py')\np.write(code)\ntest_file = to_text_string(p)\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nmain_window.editor.load(test_file)\ncode_editor = main_window.editor.get_focus_widget()\nmain_window.editor.clear_all_breakpoints()\nwith qtbot.waitSignal(shell.executed):\n    qtbot.mouseClick(debug_button, Qt.LeftButton)\n    qtbot.wait(1000)\nqtbot.keyClicks(shell._control, '!c')\nqtbot.keyClick(shell._control, Qt.Key_Enter)\nqtbot.wait(500)\nwith qtbot.waitSignal(shell.executed):\n    code_editor.debugger.toogle_breakpoint(line_number=3)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(shell._control, '!q')\n    qtbot.keyClick(shell._control, Qt.Key_Enter)\nmain_window.editor.clear_all_breakpoints()\npytest.mark.slow",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "return self.shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n"
    },
    {
        "functionName": "preferences_dialog_helper",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Open preferences dialog and select page with `section` (CONF_SECTION).\n    \"\"\"\nmain_window.show_preferences()\nqtbot.waitUntil(lambda : main_window.prefs_dialog_instance is not None,\n    timeout=5000)\ndlg = main_window.prefs_dialog_instance\nindex = dlg.get_index_by_name(section)\npage = dlg.get_page(index)\ndlg.set_current_index(index)\nreturn dlg, index, page\n",
        "CUT_1": "\"\"\"Edit Spyder preferences.\"\"\"\nfrom spyder.preferences.configdialog import ConfigDialog\ndef _dialog_finished(result_code):\n    \"\"\"Restore preferences dialog instance variable.\"\"\"\n    self.prefs_dialog_instance = None\nif self.prefs_dialog_instance is None:\n    dlg = ConfigDialog(self)\n    dlg.setStyleSheet('QTabWidget::tab-bar {alignment: left;}')\n    self.prefs_dialog_instance = dlg\n    if self.prefs_dialog_size is not None:\n        dlg.resize(self.prefs_dialog_size)\n    for PrefPageClass in self.general_prefs:\n        widget = PrefPageClass(dlg, main=self)\n        widget.initialize()\n        dlg.add_page(widget)\n    widget = self.completions._create_configwidget(dlg, self)\n    if widget is not None:\n        dlg.add_page(widget)\n    for completion_plugin in self.completions.clients.values():\n        completion_plugin = completion_plugin['plugin']\n        widget = completion_plugin._create_configwidget(dlg, self)\n        if widget is not None:\n            dlg.add_page(widget)\n    for plugin in ([self.appearance, self.run, self.shortcuts, self.\n        workingdirectory, self.editor, self.projects, self.ipyconsole, self\n        .historylog, self.help, self.variableexplorer, self.onlinehelp,\n        self.explorer, self.findinfiles] + self.thirdparty_plugins):\n        if plugin is not None:\n            if getattr(plugin, 'CONF_WIDGET_CLASS', None):\n                try:\n                    widget = self.create_plugin_conf_widget(plugin)\n                    if widget is not None:\n                        dlg.add_page(widget)\n                except Exception:\n                    traceback.print_exc(file=sys.stderr)\n            try:\n                widget = plugin._create_configwidget(dlg, self)\n                if widget is not None:\n                    dlg.add_page(widget)\n            except AttributeError:\n                pass\n            except Exception:\n                traceback.print_exc(file=sys.stderr)\n    if self.prefs_index is not None:\n        dlg.set_current_index(self.prefs_index)\n    dlg.show()\n    dlg.check_all_settings()\n    dlg.finished.connect(_dialog_finished)\n    dlg.pages_widget.currentChanged.connect(self.__preference_page_changed)\n    dlg.size_change.connect(self.set_prefs_size)\nelse:\n    self.prefs_dialog_instance.show()\n    self.prefs_dialog_instance.activateWindow()\n    self.prefs_dialog_instance.raise_()\n    self.prefs_dialog_instance.setFocus()\nSlot()",
        "CUT_2": "\"\"\"Edit Spyder preferences.\"\"\"\nfrom spyder.preferences.configdialog import ConfigDialog\ndef _dialog_finished(result_code):\n    \"\"\"Restore preferences dialog instance variable.\"\"\"\n    self.prefs_dialog_instance = None\nif self.prefs_dialog_instance is None:\n    dlg = ConfigDialog(self)\n    dlg.setStyleSheet('QTabWidget::tab-bar {alignment: left;}')\n    self.prefs_dialog_instance = dlg\n    if self.prefs_dialog_size is not None:\n        dlg.resize(self.prefs_dialog_size)\n    for PrefPageClass in self.general_prefs:\n        widget = PrefPageClass(dlg, main=self)\n        widget.initialize()\n        dlg.add_page(widget)\n    widget = self.completions._create_configwidget(dlg, self)\n    if widget is not None:\n        dlg.add_page(widget)\n    for completion_plugin in self.completions.clients.values():\n        completion_plugin = completion_plugin['plugin']\n        widget = completion_plugin._create_configwidget(dlg, self)\n        if widget is not None:\n            dlg.add_page(widget)\n    for plugin in ([self.appearance, self.run, self.shortcuts, self.\n        workingdirectory, self.editor, self.projects, self.ipyconsole, self\n        .historylog, self.help, self.variableexplorer, self.onlinehelp,\n        self.explorer, self.findinfiles] + self.thirdparty_plugins):\n        if plugin is not None:\n            if getattr(plugin, 'CONF_WIDGET_CLASS', None):\n                try:\n                    widget = self.create_plugin_conf_widget(plugin)\n                    if widget is not None:\n                        dlg.add_page(widget)\n                except Exception:\n                    traceback.print_exc(file=sys.stderr)\n            try:\n                widget = plugin._create_configwidget(dlg, self)\n                if widget is not None:\n                    dlg.add_page(widget)\n            except AttributeError:\n                pass\n            except Exception:\n                traceback.print_exc(file=sys.stderr)\n    if self.prefs_index is not None:\n        dlg.set_current_index(self.prefs_index)\n    dlg.show()\n    dlg.check_all_settings()\n    dlg.finished.connect(_dialog_finished)\n    dlg.pages_widget.currentChanged.connect(self.__preference_page_changed)\n    dlg.size_change.connect(self.set_prefs_size)\nelse:\n    self.prefs_dialog_instance.show()\n    self.prefs_dialog_instance.activateWindow()\n    self.prefs_dialog_instance.raise_()\n    self.prefs_dialog_instance.setFocus()\nSlot()",
        "CUT_3": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_4": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_5": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n"
    },
    {
        "functionName": "test_preferences_run_section_exists",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test for spyder-ide/spyder#13524 regression.\n    Ensure the Run section exists.\n    \"\"\"\nassert preferences_dialog_helper(qtbot, main_window, 'run')\npytest.mark.slow",
        "CUT_1": "\"\"\"\n    Decide what tests to run (slow or fast) according to the --run-slow\n    option.\n    \"\"\"\nslow_option = config.getoption('--run-slow')\nskip_slow = pytest.mark.skip(reason='Need --run-slow option to run')\nskip_fast = pytest.mark.skip(reason=\"Don't need --run-slow option to run\")\nfor item in items:\n    if slow_option:\n        if 'slow' not in item.keywords:\n            item.add_marker(skip_fast)\n    elif 'slow' in item.keywords:\n        item.add_marker(skip_slow)\n",
        "CUT_2": "return _('Run')\n",
        "CUT_3": "return _('Run')\n",
        "CUT_4": "\"\"\"Add option to run slow tests.\"\"\"\nparser.addoption('--run-slow', action='store_true', default=False, help=\n    'Run slow tests')\n",
        "CUT_5": "\"\"\"Parse args then run the pytest suite for Spyder.\"\"\"\ntest_parser = argparse.ArgumentParser(usage=\n    'python runtests.py [-h] [--run-slow] [pytest_args]', description=\n    \"Helper script to run Spyder's test suite\")\ntest_parser.add_argument('--run-slow', action='store_true', default=False,\n    help='Run the slow tests')\ntest_args, pytest_args = test_parser.parse_known_args()\nrun_pytest(run_slow=test_args.run_slow, extra_args=pytest_args)\n"
    },
    {
        "functionName": "test_preferences_checkboxes_not_checked_regression",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test for spyder-ide/spyder/#10139 regression.\n\n    Enabling codestyle/docstyle on the completion section of preferences,\n    was not updating correctly.\n    \"\"\"\nCONF.set('lsp-server', 'pycodestyle', False)\nCONF.set('lsp-server', 'pydocstyle', False)\ndlg, index, page = preferences_dialog_helper(qtbot, main_window, 'lsp-server')\ntnames = [page.tabs.tabText(i).lower() for i in range(page.tabs.count())]\ntab_widgets = {tnames.index('code style'): page.code_style_check, tnames.\n    index('docstring style'): page.docstring_style_check}\nfor idx, check in tab_widgets.items():\n    page.tabs.setCurrentIndex(idx)\n    check.animateClick()\n    qtbot.wait(500)\ndlg.ok_btn.animateClick()\nqtbot.waitUntil(lambda : main_window.prefs_dialog_instance is None, timeout\n    =5000)\ncount = 0\nfor menu_item in main_window.source_menu_actions:\n    if menu_item and isinstance(menu_item, QAction):\n        print(menu_item.text(), menu_item.isChecked())\n        if 'code style' in menu_item.text():\n            assert menu_item.isChecked()\n            count += 1\n        elif 'docstring style' in menu_item.text():\n            assert menu_item.isChecked()\n            count += 1\nassert count == 2\nCONF.set('lsp-server', 'pycodestyle', False)\nCONF.set('lsp-server', 'pydocstyle', False)\npytest.mark.slow",
        "CUT_1": "manager.shutdown()\nos.environ['SPY_TEST_USE_INTROSPECTION'] = 'False'\nCONF.set('lsp-server', 'pycodestyle', False)\nCONF.set('lsp-server', 'pydocstyle', False)\n",
        "CUT_2": "CONF.set('lsp-server', 'pycodestyle', True)\nCONF.set('lsp-server', 'pydocstyle', True)\nCONF.set('lsp-server', 'stdio', False)\nCONF.set('lsp-server', 'code_snippets', False)\nos.environ['SPY_TEST_USE_INTROSPECTION'] = 'True'\nmain = MainWindowMock()\ncompletions = CompletionManager(main, ['lsp'])\ncompletions.start()\nwith qtbot_module.waitSignal(main.editor.sig_lsp_initialized, timeout=30000):\n    completions.start_client('python')\ncompletions.language_status['python']['lsp'] = True\ndef teardown():\n    completions.shutdown()\n    os.environ['SPY_TEST_USE_INTROSPECTION'] = 'False'\n    CONF.set('lsp-server', 'pycodestyle', False)\n    CONF.set('lsp-server', 'pydocstyle', False)\nrequest.addfinalizer(teardown)\nreturn completions\npytest.fixture(scope='function')",
        "CUT_3": "CONF.set('lsp-server', 'pycodestyle', True)\nCONF.set('lsp-server', 'pydocstyle', True)\nCONF.set('lsp-server', 'stdio', is_stdio)\nos.environ['SPY_TEST_USE_INTROSPECTION'] = 'True'\nmanager = LanguageServerPlugin(parent=MainWindowMock())\neditor = manager.main.editor\nwith qtbot_module.waitSignal(editor.sig_lsp_initialized, timeout=30000):\n    manager.start_client('python')\ncapabilities = editor.completion_capabilities['python']\nassert all([(option in SERVER_CAPABILITES) for option in capabilities.keys()])\ndef teardown():\n    manager.shutdown()\n    os.environ['SPY_TEST_USE_INTROSPECTION'] = 'False'\n    CONF.set('lsp-server', 'pycodestyle', False)\n    CONF.set('lsp-server', 'pydocstyle', False)\nrequest.addfinalizer(teardown)\nreturn manager\npytest.fixture(scope='module')",
        "CUT_4": "@pytest.fixture(scope='module')\ndef wrapper(qtbot_module, request):\n    CONF.set('lsp-server', 'pycodestyle', True)\n    CONF.set('lsp-server', 'pydocstyle', True)\n    CONF.set('lsp-server', 'stdio', is_stdio)\n    os.environ['SPY_TEST_USE_INTROSPECTION'] = 'True'\n    manager = LanguageServerPlugin(parent=MainWindowMock())\n    editor = manager.main.editor\n    with qtbot_module.waitSignal(editor.sig_lsp_initialized, timeout=30000):\n        manager.start_client('python')\n    capabilities = editor.completion_capabilities['python']\n    assert all([(option in SERVER_CAPABILITES) for option in capabilities.\n        keys()])\n\n    def teardown():\n        manager.shutdown()\n        os.environ['SPY_TEST_USE_INTROSPECTION'] = 'False'\n        CONF.set('lsp-server', 'pycodestyle', False)\n        CONF.set('lsp-server', 'pydocstyle', False)\n    request.addfinalizer(teardown)\n    return manager\nreturn wrapper\n",
        "CUT_5": "return self.tabs.count()\n"
    },
    {
        "functionName": "test_preferences_change_font_regression",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test for spyder-ide/spyder/#10284 regression.\n\n    Changing font resulted in error.\n    \"\"\"\ndlg, index, page = preferences_dialog_helper(qtbot, main_window, 'appearance')\nfor fontbox in [page.plain_text_font.fontbox, page.rich_text_font.fontbox]:\n    fontbox.setFocus()\n    idx = fontbox.currentIndex()\n    fontbox.setCurrentIndex(idx + 1)\ndlg.ok_btn.animateClick()\nqtbot.waitUntil(lambda : main_window.prefs_dialog_instance is None, timeout\n    =5000)\npytest.mark.slow",
        "CUT_1": "\"\"\"Option=None -> setting plugin font\"\"\"\nif title:\n    fontlabel = QLabel(title)\nelse:\n    fontlabel = QLabel(_('Font'))\nfontbox = QFontComboBox()\nif fontfilters is not None:\n    fontbox.setFontFilters(fontfilters)\nsizelabel = QLabel('  ' + _('Size'))\nsizebox = QSpinBox()\nsizebox.setRange(7, 100)\nself.fontboxes[fontbox, sizebox] = option\nlayout = QHBoxLayout()\nfor subwidget in (fontlabel, fontbox, sizelabel, sizebox):\n    layout.addWidget(subwidget)\nlayout.addStretch(1)\nwidget = QWidget(self)\nwidget.fontlabel = fontlabel\nwidget.sizelabel = sizelabel\nwidget.fontbox = fontbox\nwidget.sizebox = sizebox\nwidget.setLayout(layout)\nif not without_group:\n    if text is None:\n        text = _('Font style')\n    group = QGroupBox(text)\n    group.setLayout(layout)\n    if tip is not None:\n        group.setToolTip(tip)\n    return group\nelse:\n    return widget\n",
        "CUT_2": "\"\"\"Option=None -> setting plugin font\"\"\"\nif title:\n    fontlabel = QLabel(title)\nelse:\n    fontlabel = QLabel(_('Font'))\nfontbox = QFontComboBox()\nif fontfilters is not None:\n    fontbox.setFontFilters(fontfilters)\nsizelabel = QLabel('  ' + _('Size'))\nsizebox = QSpinBox()\nsizebox.setRange(7, 100)\nself.fontboxes[fontbox, sizebox] = option\nlayout = QHBoxLayout()\nfor subwidget in (fontlabel, fontbox, sizelabel, sizebox):\n    layout.addWidget(subwidget)\nlayout.addStretch(1)\nwidget = QWidget(self)\nwidget.fontlabel = fontlabel\nwidget.sizelabel = sizelabel\nwidget.fontbox = fontbox\nwidget.sizebox = sizebox\nwidget.setLayout(layout)\nif not without_group:\n    if text is None:\n        text = _('Font style')\n    group = QGroupBox(text)\n    group.setLayout(layout)\n    if tip is not None:\n        group.setToolTip(tip)\n    return group\nelse:\n    return widget\n",
        "CUT_3": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_4": "\"\"\"Edit Spyder preferences.\"\"\"\nfrom spyder.preferences.configdialog import ConfigDialog\ndef _dialog_finished(result_code):\n    \"\"\"Restore preferences dialog instance variable.\"\"\"\n    self.prefs_dialog_instance = None\nif self.prefs_dialog_instance is None:\n    dlg = ConfigDialog(self)\n    dlg.setStyleSheet('QTabWidget::tab-bar {alignment: left;}')\n    self.prefs_dialog_instance = dlg\n    if self.prefs_dialog_size is not None:\n        dlg.resize(self.prefs_dialog_size)\n    for PrefPageClass in self.general_prefs:\n        widget = PrefPageClass(dlg, main=self)\n        widget.initialize()\n        dlg.add_page(widget)\n    widget = self.completions._create_configwidget(dlg, self)\n    if widget is not None:\n        dlg.add_page(widget)\n    for completion_plugin in self.completions.clients.values():\n        completion_plugin = completion_plugin['plugin']\n        widget = completion_plugin._create_configwidget(dlg, self)\n        if widget is not None:\n            dlg.add_page(widget)\n    for plugin in ([self.appearance, self.run, self.shortcuts, self.\n        workingdirectory, self.editor, self.projects, self.ipyconsole, self\n        .historylog, self.help, self.variableexplorer, self.onlinehelp,\n        self.explorer, self.findinfiles] + self.thirdparty_plugins):\n        if plugin is not None:\n            if getattr(plugin, 'CONF_WIDGET_CLASS', None):\n                try:\n                    widget = self.create_plugin_conf_widget(plugin)\n                    if widget is not None:\n                        dlg.add_page(widget)\n                except Exception:\n                    traceback.print_exc(file=sys.stderr)\n            try:\n                widget = plugin._create_configwidget(dlg, self)\n                if widget is not None:\n                    dlg.add_page(widget)\n            except AttributeError:\n                pass\n            except Exception:\n                traceback.print_exc(file=sys.stderr)\n    if self.prefs_index is not None:\n        dlg.set_current_index(self.prefs_index)\n    dlg.show()\n    dlg.check_all_settings()\n    dlg.finished.connect(_dialog_finished)\n    dlg.pages_widget.currentChanged.connect(self.__preference_page_changed)\n    dlg.size_change.connect(self.set_prefs_size)\nelse:\n    self.prefs_dialog_instance.show()\n    self.prefs_dialog_instance.activateWindow()\n    self.prefs_dialog_instance.raise_()\n    self.prefs_dialog_instance.setFocus()\nSlot()",
        "CUT_5": "\"\"\"Edit Spyder preferences.\"\"\"\nfrom spyder.preferences.configdialog import ConfigDialog\ndef _dialog_finished(result_code):\n    \"\"\"Restore preferences dialog instance variable.\"\"\"\n    self.prefs_dialog_instance = None\nif self.prefs_dialog_instance is None:\n    dlg = ConfigDialog(self)\n    dlg.setStyleSheet('QTabWidget::tab-bar {alignment: left;}')\n    self.prefs_dialog_instance = dlg\n    if self.prefs_dialog_size is not None:\n        dlg.resize(self.prefs_dialog_size)\n    for PrefPageClass in self.general_prefs:\n        widget = PrefPageClass(dlg, main=self)\n        widget.initialize()\n        dlg.add_page(widget)\n    widget = self.completions._create_configwidget(dlg, self)\n    if widget is not None:\n        dlg.add_page(widget)\n    for completion_plugin in self.completions.clients.values():\n        completion_plugin = completion_plugin['plugin']\n        widget = completion_plugin._create_configwidget(dlg, self)\n        if widget is not None:\n            dlg.add_page(widget)\n    for plugin in ([self.appearance, self.run, self.shortcuts, self.\n        workingdirectory, self.editor, self.projects, self.ipyconsole, self\n        .historylog, self.help, self.variableexplorer, self.onlinehelp,\n        self.explorer, self.findinfiles] + self.thirdparty_plugins):\n        if plugin is not None:\n            if getattr(plugin, 'CONF_WIDGET_CLASS', None):\n                try:\n                    widget = self.create_plugin_conf_widget(plugin)\n                    if widget is not None:\n                        dlg.add_page(widget)\n                except Exception:\n                    traceback.print_exc(file=sys.stderr)\n            try:\n                widget = plugin._create_configwidget(dlg, self)\n                if widget is not None:\n                    dlg.add_page(widget)\n            except AttributeError:\n                pass\n            except Exception:\n                traceback.print_exc(file=sys.stderr)\n    if self.prefs_index is not None:\n        dlg.set_current_index(self.prefs_index)\n    dlg.show()\n    dlg.check_all_settings()\n    dlg.finished.connect(_dialog_finished)\n    dlg.pages_widget.currentChanged.connect(self.__preference_page_changed)\n    dlg.size_change.connect(self.set_prefs_size)\nelse:\n    self.prefs_dialog_instance.show()\n    self.prefs_dialog_instance.activateWindow()\n    self.prefs_dialog_instance.raise_()\n    self.prefs_dialog_instance.setFocus()\nSlot()"
    },
    {
        "functionName": "test_preferences_empty_shortcut_regression",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test for spyder-ide/spyder/#12992 regression.\n\n    Overwritting shortcuts results in a shortcuts conflict.\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nbase_run_cell_advance = CONF.get_shortcut('editor', 'run cell and advance')\nbase_run_selection = CONF.get_shortcut('editor', 'run selection')\nassert base_run_cell_advance == 'Shift+Return'\nassert base_run_selection == 'F9'\nCONF.set_shortcut('editor', 'run cell and advance', '')\nCONF.set_shortcut('editor', 'run selection', base_run_cell_advance)\nmain_window.shortcuts.apply_shortcuts()\nmain_window.editor.new()\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.set_text(\"\"\"print(0)\nprint(\u00f1\u00f1)\"\"\")\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nqtbot.waitUntil(lambda : 'print(0)' in shell._control.toPlainText())\nassert '\u00f1\u00f1' not in shell._control.toPlainText()\nCONF.set_shortcut('editor', 'run selection', 'F9')\nCONF.set_shortcut('editor', 'run cell and advance', 'Shift+Return')\nmain_window.shortcuts.apply_shortcuts()\nqtbot.wait(500)\ncode_editor.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nqtbot.waitUntil(lambda : 'runcell(0' in shell._control.toPlainText())\npytest.mark.slowpytest.mark.skipif(sys.platform == 'darwin', reason=\n    'Changes of Shitf+Return shortcut cause an ambiguos shortcut')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "return self.shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n"
    },
    {
        "functionName": "test_preferences_shortcut_reset_regression",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test for spyder-ide/spyder/#11132 regression.\n\n    Resetting shortcut resulted in error.\n    \"\"\"\ndlg, index, page = preferences_dialog_helper(qtbot, main_window, 'shortcuts')\npage.reset_to_default(force=True)\ndlg.ok_btn.animateClick()\nqtbot.waitUntil(lambda : main_window.prefs_dialog_instance is None, timeout\n    =5000)\npytest.mark.slow",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"Edit Spyder preferences.\"\"\"\nfrom spyder.preferences.configdialog import ConfigDialog\ndef _dialog_finished(result_code):\n    \"\"\"Restore preferences dialog instance variable.\"\"\"\n    self.prefs_dialog_instance = None\nif self.prefs_dialog_instance is None:\n    dlg = ConfigDialog(self)\n    dlg.setStyleSheet('QTabWidget::tab-bar {alignment: left;}')\n    self.prefs_dialog_instance = dlg\n    if self.prefs_dialog_size is not None:\n        dlg.resize(self.prefs_dialog_size)\n    for PrefPageClass in self.general_prefs:\n        widget = PrefPageClass(dlg, main=self)\n        widget.initialize()\n        dlg.add_page(widget)\n    widget = self.completions._create_configwidget(dlg, self)\n    if widget is not None:\n        dlg.add_page(widget)\n    for completion_plugin in self.completions.clients.values():\n        completion_plugin = completion_plugin['plugin']\n        widget = completion_plugin._create_configwidget(dlg, self)\n        if widget is not None:\n            dlg.add_page(widget)\n    for plugin in ([self.appearance, self.run, self.shortcuts, self.\n        workingdirectory, self.editor, self.projects, self.ipyconsole, self\n        .historylog, self.help, self.variableexplorer, self.onlinehelp,\n        self.explorer, self.findinfiles] + self.thirdparty_plugins):\n        if plugin is not None:\n            if getattr(plugin, 'CONF_WIDGET_CLASS', None):\n                try:\n                    widget = self.create_plugin_conf_widget(plugin)\n                    if widget is not None:\n                        dlg.add_page(widget)\n                except Exception:\n                    traceback.print_exc(file=sys.stderr)\n            try:\n                widget = plugin._create_configwidget(dlg, self)\n                if widget is not None:\n                    dlg.add_page(widget)\n            except AttributeError:\n                pass\n            except Exception:\n                traceback.print_exc(file=sys.stderr)\n    if self.prefs_index is not None:\n        dlg.set_current_index(self.prefs_index)\n    dlg.show()\n    dlg.check_all_settings()\n    dlg.finished.connect(_dialog_finished)\n    dlg.pages_widget.currentChanged.connect(self.__preference_page_changed)\n    dlg.size_change.connect(self.set_prefs_size)\nelse:\n    self.prefs_dialog_instance.show()\n    self.prefs_dialog_instance.activateWindow()\n    self.prefs_dialog_instance.raise_()\n    self.prefs_dialog_instance.setFocus()\nSlot()",
        "CUT_3": "\"\"\"Edit Spyder preferences.\"\"\"\nfrom spyder.preferences.configdialog import ConfigDialog\ndef _dialog_finished(result_code):\n    \"\"\"Restore preferences dialog instance variable.\"\"\"\n    self.prefs_dialog_instance = None\nif self.prefs_dialog_instance is None:\n    dlg = ConfigDialog(self)\n    dlg.setStyleSheet('QTabWidget::tab-bar {alignment: left;}')\n    self.prefs_dialog_instance = dlg\n    if self.prefs_dialog_size is not None:\n        dlg.resize(self.prefs_dialog_size)\n    for PrefPageClass in self.general_prefs:\n        widget = PrefPageClass(dlg, main=self)\n        widget.initialize()\n        dlg.add_page(widget)\n    widget = self.completions._create_configwidget(dlg, self)\n    if widget is not None:\n        dlg.add_page(widget)\n    for completion_plugin in self.completions.clients.values():\n        completion_plugin = completion_plugin['plugin']\n        widget = completion_plugin._create_configwidget(dlg, self)\n        if widget is not None:\n            dlg.add_page(widget)\n    for plugin in ([self.appearance, self.run, self.shortcuts, self.\n        workingdirectory, self.editor, self.projects, self.ipyconsole, self\n        .historylog, self.help, self.variableexplorer, self.onlinehelp,\n        self.explorer, self.findinfiles] + self.thirdparty_plugins):\n        if plugin is not None:\n            if getattr(plugin, 'CONF_WIDGET_CLASS', None):\n                try:\n                    widget = self.create_plugin_conf_widget(plugin)\n                    if widget is not None:\n                        dlg.add_page(widget)\n                except Exception:\n                    traceback.print_exc(file=sys.stderr)\n            try:\n                widget = plugin._create_configwidget(dlg, self)\n                if widget is not None:\n                    dlg.add_page(widget)\n            except AttributeError:\n                pass\n            except Exception:\n                traceback.print_exc(file=sys.stderr)\n    if self.prefs_index is not None:\n        dlg.set_current_index(self.prefs_index)\n    dlg.show()\n    dlg.check_all_settings()\n    dlg.finished.connect(_dialog_finished)\n    dlg.pages_widget.currentChanged.connect(self.__preference_page_changed)\n    dlg.size_change.connect(self.set_prefs_size)\nelse:\n    self.prefs_dialog_instance.show()\n    self.prefs_dialog_instance.activateWindow()\n    self.prefs_dialog_instance.raise_()\n    self.prefs_dialog_instance.setFocus()\nSlot()",
        "CUT_4": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_5": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n"
    },
    {
        "functionName": "test_preferences_change_interpreter",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that on main interpreter change signal is emitted.\"\"\"\nlsp = main_window.completions.get_client('lsp')\nconfig = lsp.generate_python_config()\njedi = config['configurations']['pyls']['plugins']['jedi']\nassert jedi['environment'] is None\nassert jedi['extra_paths'] == []\ndlg, index, page = preferences_dialog_helper(qtbot, main_window,\n    'main_interpreter')\npage.cus_exec_radio.setChecked(True)\npage.cus_exec_combo.combobox.setCurrentText(sys.executable)\nwith qtbot.waitSignal(main_window.sig_main_interpreter_changed, timeout=\n    5000, raising=True):\n    dlg.ok_btn.animateClick()\nconfig = lsp.generate_python_config()\njedi = config['configurations']['pyls']['plugins']['jedi']\nassert jedi['environment'] == sys.executable\nassert jedi['extra_paths'] == []\npytest.mark.slow",
        "CUT_1": "if environment_path is None:\n    environment = jedi.api.environment.get_cached_default_environment()\nelif environment_path in self._workspace._environments:\n    environment = self._workspace._environments[environment_path]\nelse:\n    environment = jedi.api.environment.create_environment(path=\n        environment_path, safe=False, env_vars=env_vars)\n    self._workspace._environments[environment_path] = environment\nreturn environment\n",
        "CUT_2": "extra_paths = []\nenvironment_path = None\nenv_vars = None\nif self._config:\n    jedi_settings = self._config.plugin_settings('jedi', document_path=self\n        .path)\n    environment_path = jedi_settings.get('environment')\n    extra_paths = jedi_settings.get('extra_paths') or []\n    env_vars = jedi_settings.get('env_vars')\nif env_vars is None:\n    env_vars = os.environ.copy()\nenv_vars.pop('PYTHONPATH', None)\nenvironment = self.get_enviroment(environment_path, env_vars=env_vars\n    ) if environment_path else None\nsys_path = self.sys_path(environment_path, env_vars=env_vars) + extra_paths\nproject_path = self._workspace.root_path\nif use_document_path:\n    sys_path += [os.path.dirname(self.path)]\nkwargs = {'code': self.source, 'path': self.path, 'environment':\n    environment, 'project': jedi.Project(path=project_path, sys_path=sys_path)}\nif position:\n    kwargs += _utils.position_to_jedi_linecolumn(self, position)\nreturn jedi.Script(**kwargs)\nlock",
        "CUT_3": "CONF.set('lsp-server', 'pycodestyle', True)\nCONF.set('lsp-server', 'pydocstyle', True)\nCONF.set('lsp-server', 'stdio', False)\nCONF.set('lsp-server', 'code_snippets', False)\nos.environ['SPY_TEST_USE_INTROSPECTION'] = 'True'\nmain = MainWindowMock()\ncompletions = CompletionManager(main, ['lsp'])\ncompletions.start()\nwith qtbot_module.waitSignal(main.editor.sig_lsp_initialized, timeout=30000):\n    completions.start_client('python')\ncompletions.language_status['python']['lsp'] = True\ndef teardown():\n    completions.shutdown()\n    os.environ['SPY_TEST_USE_INTROSPECTION'] = 'False'\n    CONF.set('lsp-server', 'pycodestyle', False)\n    CONF.set('lsp-server', 'pydocstyle', False)\nrequest.addfinalizer(teardown)\nreturn completions\npytest.fixture(scope='function')",
        "CUT_4": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_5": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture"
    },
    {
        "functionName": "test_preferences_last_page_is_loaded",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "dlg, index, page = preferences_dialog_helper(qtbot, main_window,\n    'main_interpreter')\nqtbot.waitUntil(lambda : main_window.prefs_dialog_instance is not None,\n    timeout=5000)\ndlg.ok_btn.animateClick()\nqtbot.waitUntil(lambda : main_window.prefs_dialog_instance is None, timeout\n    =5000)\nmain_window.show_preferences()\nqtbot.waitUntil(lambda : main_window.prefs_dialog_instance is not None,\n    timeout=5000)\ndlg = main_window.prefs_dialog_instance\nassert dlg.get_current_index() == index\ndlg.ok_btn.animateClick()\nqtbot.waitUntil(lambda : main_window.prefs_dialog_instance is None, timeout\n    =5000)\npytest.mark.slow",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"Edit Spyder preferences.\"\"\"\nfrom spyder.preferences.configdialog import ConfigDialog\ndef _dialog_finished(result_code):\n    \"\"\"Restore preferences dialog instance variable.\"\"\"\n    self.prefs_dialog_instance = None\nif self.prefs_dialog_instance is None:\n    dlg = ConfigDialog(self)\n    dlg.setStyleSheet('QTabWidget::tab-bar {alignment: left;}')\n    self.prefs_dialog_instance = dlg\n    if self.prefs_dialog_size is not None:\n        dlg.resize(self.prefs_dialog_size)\n    for PrefPageClass in self.general_prefs:\n        widget = PrefPageClass(dlg, main=self)\n        widget.initialize()\n        dlg.add_page(widget)\n    widget = self.completions._create_configwidget(dlg, self)\n    if widget is not None:\n        dlg.add_page(widget)\n    for completion_plugin in self.completions.clients.values():\n        completion_plugin = completion_plugin['plugin']\n        widget = completion_plugin._create_configwidget(dlg, self)\n        if widget is not None:\n            dlg.add_page(widget)\n    for plugin in ([self.appearance, self.run, self.shortcuts, self.\n        workingdirectory, self.editor, self.projects, self.ipyconsole, self\n        .historylog, self.help, self.variableexplorer, self.onlinehelp,\n        self.explorer, self.findinfiles] + self.thirdparty_plugins):\n        if plugin is not None:\n            if getattr(plugin, 'CONF_WIDGET_CLASS', None):\n                try:\n                    widget = self.create_plugin_conf_widget(plugin)\n                    if widget is not None:\n                        dlg.add_page(widget)\n                except Exception:\n                    traceback.print_exc(file=sys.stderr)\n            try:\n                widget = plugin._create_configwidget(dlg, self)\n                if widget is not None:\n                    dlg.add_page(widget)\n            except AttributeError:\n                pass\n            except Exception:\n                traceback.print_exc(file=sys.stderr)\n    if self.prefs_index is not None:\n        dlg.set_current_index(self.prefs_index)\n    dlg.show()\n    dlg.check_all_settings()\n    dlg.finished.connect(_dialog_finished)\n    dlg.pages_widget.currentChanged.connect(self.__preference_page_changed)\n    dlg.size_change.connect(self.set_prefs_size)\nelse:\n    self.prefs_dialog_instance.show()\n    self.prefs_dialog_instance.activateWindow()\n    self.prefs_dialog_instance.raise_()\n    self.prefs_dialog_instance.setFocus()\nSlot()",
        "CUT_3": "\"\"\"Edit Spyder preferences.\"\"\"\nfrom spyder.preferences.configdialog import ConfigDialog\ndef _dialog_finished(result_code):\n    \"\"\"Restore preferences dialog instance variable.\"\"\"\n    self.prefs_dialog_instance = None\nif self.prefs_dialog_instance is None:\n    dlg = ConfigDialog(self)\n    dlg.setStyleSheet('QTabWidget::tab-bar {alignment: left;}')\n    self.prefs_dialog_instance = dlg\n    if self.prefs_dialog_size is not None:\n        dlg.resize(self.prefs_dialog_size)\n    for PrefPageClass in self.general_prefs:\n        widget = PrefPageClass(dlg, main=self)\n        widget.initialize()\n        dlg.add_page(widget)\n    widget = self.completions._create_configwidget(dlg, self)\n    if widget is not None:\n        dlg.add_page(widget)\n    for completion_plugin in self.completions.clients.values():\n        completion_plugin = completion_plugin['plugin']\n        widget = completion_plugin._create_configwidget(dlg, self)\n        if widget is not None:\n            dlg.add_page(widget)\n    for plugin in ([self.appearance, self.run, self.shortcuts, self.\n        workingdirectory, self.editor, self.projects, self.ipyconsole, self\n        .historylog, self.help, self.variableexplorer, self.onlinehelp,\n        self.explorer, self.findinfiles] + self.thirdparty_plugins):\n        if plugin is not None:\n            if getattr(plugin, 'CONF_WIDGET_CLASS', None):\n                try:\n                    widget = self.create_plugin_conf_widget(plugin)\n                    if widget is not None:\n                        dlg.add_page(widget)\n                except Exception:\n                    traceback.print_exc(file=sys.stderr)\n            try:\n                widget = plugin._create_configwidget(dlg, self)\n                if widget is not None:\n                    dlg.add_page(widget)\n            except AttributeError:\n                pass\n            except Exception:\n                traceback.print_exc(file=sys.stderr)\n    if self.prefs_index is not None:\n        dlg.set_current_index(self.prefs_index)\n    dlg.show()\n    dlg.check_all_settings()\n    dlg.finished.connect(_dialog_finished)\n    dlg.pages_widget.currentChanged.connect(self.__preference_page_changed)\n    dlg.size_change.connect(self.set_prefs_size)\nelse:\n    self.prefs_dialog_instance.show()\n    self.prefs_dialog_instance.activateWindow()\n    self.prefs_dialog_instance.raise_()\n    self.prefs_dialog_instance.setFocus()\nSlot()",
        "CUT_4": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_5": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n"
    },
    {
        "functionName": "test_go_to_definition",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that go-to-definition works as expected.\"\"\"\ncode_no_def = dedent(\n    \"\"\"\n    from qtpy.QtCore import Qt\n    Qt.FramelessWindowHint\"\"\")\nmain_window.editor.new(text=code_no_def)\ncode_editor = main_window.editor.get_focus_widget()\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_open()\ncode_editor.move_cursor(-1)\nwith qtbot.waitSignal(code_editor.lsp_response_signal):\n    code_editor.go_to_definition_from_cursor()\nsys_stream = capsys.readouterr()\nassert sys_stream.err == ''\ncode_def = 'import qtpy.QtCore'\nmain_window.editor.new(text=code_def)\nn_editors = len(main_window.editor.get_filenames())\ncode_editor = main_window.editor.get_focus_widget()\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_open()\ncode_editor.move_cursor(-1)\nwith qtbot.waitSignal(code_editor.lsp_response_signal):\n    code_editor.go_to_definition_from_cursor()\ndef _get_filenames():\n    return [osp.basename(f) for f in main_window.editor.get_filenames()]\nqtbot.waitUntil(lambda : 'QtCore.py' in _get_filenames())\nassert 'QtCore.py' in _get_filenames()\npytest.mark.slowpytest.mark.use_introspectionpytest.mark.skipif(not sys.platform.startswith('linux'), reason=\n    'It times out too much on Windows and macOS')",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "_get_filenames",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return [osp.basename(f) for f in main_window.editor.get_filenames()]\n",
        "CUT_1": "self.editor.set_text_from_file(filename)\nself.setWindowTitle('%s - %s (%s)' % (_('Editor'), osp.basename(filename),\n    osp.dirname(filename)))\nself.editor.hide_tooltip()\n",
        "CUT_2": "self.editor.set_text_from_file(filename)\nself.setWindowTitle('%s - %s (%s)' % (_('Editor'), osp.basename(filename),\n    osp.dirname(filename)))\nself.editor.hide_tooltip()\n",
        "CUT_3": "\"\"\"\n    Return program absolute path if installed in PATH.\n\n    Otherwise, return None\n\n    On macOS systems, a .app is considered installed if\n    it exists.\n    \"\"\"\nif sys.platform == 'darwin' and basename.endswith('.app') and osp.exists(\n    basename):\n    return basename\nfor path in os.environ['PATH'].split(os.pathsep):\n    abspath = osp.join(path, basename)\n    if osp.isfile(abspath):\n        return abspath\n",
        "CUT_4": "\"\"\"\n    Return program absolute path if installed in PATH.\n\n    Otherwise, return None\n\n    On macOS systems, a .app is considered installed if\n    it exists.\n    \"\"\"\nif sys.platform == 'darwin' and basename.endswith('.app') and osp.exists(\n    basename):\n    return basename\nfor path in os.environ['PATH'].split(os.pathsep):\n    abspath = osp.join(path, basename)\n    if osp.isfile(abspath):\n        return abspath\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_debug_unsaved_file",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that we can debug an unsaved file.\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = shell._control\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nmain_window.editor.clear_all_breakpoints()\nmain_window.editor.new()\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.set_text(\"\"\"print(0)\nprint(1)\nprint(2)\"\"\")\ncode_editor.debugger.toogle_breakpoint(line_number=2)\nqtbot.wait(500)\nqtbot.mouseClick(debug_button, Qt.LeftButton)\nqtbot.waitUntil(lambda : '!continue' in shell._control.toPlainText())\nqtbot.waitUntil(lambda : '1---> 2 print(1)' in control.toPlainText())\npytest.mark.slowpytest.mark.skipif(sys.platform == 'darwin' and not PY2, reason=\n    'It times out on macOS/PY3')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "return self.shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n"
    },
    {
        "functionName": "test_runcell",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the runcell command.\"\"\"\ncode = 'result = 10; fname = __file__'\np = tmpdir.join('cell-test.py')\np.write(code)\nmain_window.editor.load(to_text_string(p))\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nif debug:\n    function = 'debugcell'\nelse:\n    function = 'runcell'\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(function + \"(0, r'{}')\".format(to_text_string(p)))\ncontrol = main_window.ipyconsole.get_focus_widget()\nif debug:\n    shell.pdb_execute('!c')\nqtbot.wait(1000)\nassert shell.get_value('result') == 10\nassert 'cell-test.py' in shell.get_value('fname')\ntry:\n    shell.get_value('__file__')\n    assert False\nexcept KeyError:\n    pass\npytest.mark.slowpytest.mark.parametrize('debug', [True, False])",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_runcell_leading_indent",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the runcell command with leading indent.\"\"\"\ncode = \"\"\"def a():\n    return\nif __name__ == '__main__':\n# %%\n    print(1233 + 1)\n\"\"\"\np = tmpdir.join('cell-test.py')\np.write(code)\nmain_window.editor.load(to_text_string(p))\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\"runcell(1, r'{}')\".format(to_text_string(p)))\nassert '1234' in shell._control.toPlainText()\nassert 'This is not valid Python code' not in shell._control.toPlainText()\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_varexp_rename",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test renaming a variable.\n    Regression test for spyder-ide/spyder#10735\n    \"\"\"\np = tmpdir.mkdir('varexp_rename').join('script.py')\nfilepath = to_text_string(p)\nshutil.copyfile(osp.join(LOCATION, 'script.py'), filepath)\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nmain_window.editor.load(filepath)\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.setFocus()\nqtbot.keyClick(code_editor, Qt.Key_Home, modifier=Qt.ControlModifier)\nnsb = main_window.variableexplorer.get_focus_widget()\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.waitUntil(lambda : nsb.editor.model.rowCount() == 4, timeout=EVAL_TIMEOUT\n    )\nnsb.editor.setCurrentIndex(nsb.editor.model.index(1, 0))\nnsb.editor.rename_item(new_name='arr2')\ndef data(cm, i, j):\n    return cm.data(cm.index(i, j))\nqtbot.waitUntil(lambda : data(nsb.editor.model, 1, 0) == 'arr2', timeout=\n    EVAL_TIMEOUT)\nassert data(nsb.editor.model, 0, 0) == 'a'\nassert data(nsb.editor.model, 1, 0) == 'arr2'\nassert data(nsb.editor.model, 2, 0) == 'li'\nassert data(nsb.editor.model, 3, 0) == 's'\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.waitUntil(lambda : nsb.editor.model.rowCount() == 5, timeout=EVAL_TIMEOUT\n    )\nassert data(nsb.editor.model, 0, 0) == 'a'\nassert data(nsb.editor.model, 1, 0) == 'arr'\nassert data(nsb.editor.model, 2, 0) == 'arr2'\nassert data(nsb.editor.model, 3, 0) == 'li'\nassert data(nsb.editor.model, 4, 0) == 's'\npytest.mark.slow",
        "CUT_1": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_2": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_3": "\"\"\"Import data in current namespace\"\"\"\nif self.count():\n    nsb = self.current_widget()\n    nsb.refresh_table()\n    nsb.import_data(filenames=fname)\n    if self.dockwidget:\n        self.switch_to_plugin()\n",
        "CUT_4": "\"\"\"Import data in current namespace\"\"\"\nif self.count():\n    nsb = self.current_widget()\n    nsb.refresh_table()\n    nsb.import_data(filenames=fname)\n    if self.dockwidget:\n        self.switch_to_plugin()\n",
        "CUT_5": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n"
    },
    {
        "functionName": "data",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return cm.data(cm.index(i, j))\n",
        "CUT_1": "finfo.editor.oe_proxy = None\nindex = 0 if add_where == 'start' else len(self.data)\nself.data.insert(index, finfo)\nindex = self.data.index(finfo)\neditor = finfo.editor\nself.tabs.insertTab(index, editor, self.get_tab_text(index))\nself.set_stack_title(index, False)\nif set_current:\n    self.set_stack_index(index)\n    self.current_changed(index)\nself.update_actions()\n",
        "CUT_2": "finfo.editor.oe_proxy = None\nindex = 0 if add_where == 'start' else len(self.data)\nself.data.insert(index, finfo)\nindex = self.data.index(finfo)\neditor = finfo.editor\nself.tabs.insertTab(index, editor, self.get_tab_text(index))\nself.set_stack_title(index, False)\nif set_current:\n    self.set_stack_index(index)\n    self.current_changed(index)\nself.update_actions()\n",
        "CUT_3": "if index.isValid():\n    return index.model().get_value(index)\n",
        "CUT_4": "if index.isValid():\n    return index.model().get_value(index)\n",
        "CUT_5": "\"\"\"Return a data element\"\"\"\nreturn to_qvariant(self._data[index.row()][index.column()])\n"
    },
    {
        "functionName": "test_varexp_remove",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test removing a variable.\n    Regression test for spyder-ide/spyder#10709\n    \"\"\"\np = tmpdir.mkdir('varexp_remove').join('script.py')\nfilepath = to_text_string(p)\nshutil.copyfile(osp.join(LOCATION, 'script.py'), filepath)\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nmain_window.editor.load(filepath)\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.setFocus()\nqtbot.keyClick(code_editor, Qt.Key_Home, modifier=Qt.ControlModifier)\nnsb = main_window.variableexplorer.get_focus_widget()\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(code_editor, Qt.Key_F5)\nqtbot.waitUntil(lambda : nsb.editor.model.rowCount() == 4, timeout=EVAL_TIMEOUT\n    )\nnsb.editor.setCurrentIndex(nsb.editor.model.index(1, 0))\nnsb.editor.remove_item(force=True)\nqtbot.waitUntil(lambda : nsb.editor.model.rowCount() == 3, timeout=EVAL_TIMEOUT\n    )\ndef data(cm, i, j):\n    assert cm.rowCount() == 3\n    return cm.data(cm.index(i, j))\nassert data(nsb.editor.model, 0, 0) == 'a'\nassert data(nsb.editor.model, 1, 0) == 'li'\nassert data(nsb.editor.model, 2, 0) == 's'\npytest.mark.slow",
        "CUT_1": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_2": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_3": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_4": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_5": "\"\"\"Import data in current namespace\"\"\"\nif self.count():\n    nsb = self.current_widget()\n    nsb.refresh_table()\n    nsb.import_data(filenames=fname)\n    if self.dockwidget:\n        self.switch_to_plugin()\n"
    },
    {
        "functionName": "test_varexp_refresh",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test refreshing the variable explorer while the kernel is executing.\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\ncontrol = main_window.ipyconsole.get_focus_widget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nshell.execute(\n    \"\"\"import time\nfor i in range(10):\n    print('i = {}'.format(i))\n    time.sleep(.1)\n\"\"\"\n    )\nqtbot.waitUntil(lambda : 'i = 0' in control.toPlainText())\nqtbot.wait(300)\nnsb = main_window.variableexplorer.get_focus_widget()\nassert len(nsb.editor.source_model._data) == 0\nnsb.refresh_table()\nqtbot.waitUntil(lambda : len(nsb.editor.source_model._data) == 1)\nassert 0 < int(nsb.editor.source_model._data['i']['view']) < 9\npytest.mark.slow",
        "CUT_1": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_2": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_3": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_4": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_5": "\"\"\"Import data in current namespace\"\"\"\nif self.count():\n    nsb = self.current_widget()\n    nsb.refresh_table()\n    nsb.import_data(filenames=fname)\n    if self.dockwidget:\n        self.switch_to_plugin()\n"
    },
    {
        "functionName": "test_runcell_edge_cases",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test if runcell works with an unnamed cell at the top of the file\n    and with an empty cell.\n    \"\"\"\ncode = \"\"\"if True:\n    a = 1\n#%%\"\"\"\np = tmpdir.join('test.py')\np.write(code)\nmain_window.editor.load(to_text_string(p))\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncode_editor = main_window.editor.get_focus_widget()\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nassert 'runcell(0' in shell._control.toPlainText()\nassert 'cell is empty' not in shell._control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nassert 'runcell(1' in shell._control.toPlainText()\nassert 'Error' not in shell._control.toPlainText()\nassert 'cell is empty' in shell._control.toPlainText()\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_runcell_pdb",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the runcell command in pdb.\"\"\"\ncode = \"\"\"if 'abba' in dir():\n    print('abba {}'.format(abba))\nelse:\n    def foo():\n        abba = 27\n    foo()\n\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nmain_window.editor.clear_all_breakpoints()\nmain_window.editor.new()\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.set_text(code)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.mouseClick(debug_button, Qt.LeftButton)\nfor key in ['!n', '!n', '!s', '!n', '!n']:\n    with qtbot.waitSignal(shell.executed):\n        qtbot.keyClicks(shell._control, key)\n        qtbot.keyClick(shell._control, Qt.Key_Enter)\nassert shell.get_value('abba') == 27\ncode_editor.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nassert 'runcell' in shell._control.toPlainText()\nassert 'abba 27' in shell._control.toPlainText()\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_runcell_cache",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the runcell command cache.\"\"\"\ncode = \"\"\"import time\ntime.sleep(.5)\n# %%\nprint('Done')\n\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nmain_window.editor.new()\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.set_text(code)\nif debug:\n    with qtbot.waitSignal(shell.executed):\n        shell.execute('%debug print()')\ncode_editor.setFocus()\ncode_editor.move_cursor(0)\nqtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nqtbot.wait(100)\nqtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nqtbot.wait(500)\nqtbot.waitUntil(lambda : 'Done' in shell._control.toPlainText())\npytest.mark.slowpytest.mark.parametrize('debug', [False, True])",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n"
    },
    {
        "functionName": "test_path_manager_updates_clients",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Check that on path manager updates, consoles correctly update.\"\"\"\nmain_window.show_path_manager()\ndlg = main_window._path_manager\ntest_folder = 'foo-spam-bar-123'\nfolder = str(tmpdir.mkdir(test_folder))\ndlg.add_path(folder)\nqtbot.waitUntil(lambda : dlg.button_ok.isEnabled(), timeout=EVAL_TIMEOUT)\nwith qtbot.waitSignal(dlg.sig_path_changed, timeout=EVAL_TIMEOUT):\n    dlg.button_ok.animateClick()\ncmd = 'import sys;print(sys.path)'\nmain_window.console.execute_lines(cmd)\nsyspath = main_window.console.get_sys_path()\nassert folder in syspath\ncount = 0\nfor client in main_window.ipyconsole.get_clients():\n    shell = client.shellwidget\n    if shell is not None:\n        syspath = shell.execute(cmd)\n        control = shell._control\n        qtbot.waitUntil(lambda : 'In [2]:' in control.toPlainText(),\n            timeout=EVAL_TIMEOUT)\n        assert test_folder in control.toPlainText()\n        count += 1\nassert count >= 1\npytest.mark.slow",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n"
    },
    {
        "functionName": "test_pdb_key_leak",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Check that pdb notify spyder doesn't call\n    QApplication.processEvents(). If it does there might be keystoke leakage.\n    see #10834\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = shell._control\ncode1 = 'def a():\\n    1/0'\ncode2 = \"\"\"from tmp import a\na()\"\"\"\nfolder = tmpdir.join('tmp_folder')\ntest_file = folder.join('tmp.py')\ntest_file.write(code1, ensure=True)\ntest_file2 = folder.join('tmp2.py')\ntest_file2.write(code2)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('runfile(\"' + str(test_file2).replace('\\\\', '/') +\n        '\", wdir=\"' + str(folder).replace('\\\\', '/') + '\")')\nassert '1/0' in control.toPlainText()\nsuper_processEvents = QApplication.processEvents\ndef processEvents():\n    processEvents.called = True\n    return super_processEvents()\nprocessEvents.called = False\ntry:\n    QApplication.processEvents = processEvents\n    with qtbot.waitSignal(shell.executed):\n        shell.execute('%debug')\n    with qtbot.waitSignal(shell.executed):\n        qtbot.keyClicks(control, '!u')\n        qtbot.keyClick(control, Qt.Key_Enter)\n    qtbot.waitUntil(lambda : osp.normpath(str(test_file)) in [osp.normpath(\n        p) for p in main_window.editor.get_filenames()])\n    qtbot.waitUntil(lambda : str(test_file2) in [osp.normpath(p) for p in\n        main_window.editor.get_filenames()])\n    assert not processEvents.called\nfinally:\n    QApplication.processEvents = super_processEvents\npytest.mark.slowpytest.mark.skipif(os.name == 'nt' or sys.platform == 'darwin', reason=\n    'It times out on macOS and Windows')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "processEvents",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "processEvents.called = True\nreturn super_processEvents()\n",
        "CUT_1": "return True, ''\n",
        "CUT_2": "return True\n",
        "CUT_3": "return True\n",
        "CUT_4": "return True, ''\n",
        "CUT_5": "return True, ''\n"
    },
    {
        "functionName": "test_pdb_step",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Check that pdb notify Spyder only moves when a new line is reached.\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = shell._control\ncode1 = 'def a():\\n    1/0'\ncode2 = \"\"\"from tmp import a\na()\"\"\"\nfolder = tmpdir.join('tmp_folder')\ntest_file = folder.join('tmp.py')\ntest_file.write(code1, ensure=True)\ntest_file2 = folder.join('tmp2.py')\ntest_file2.write(code2)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('runfile(\"' + str(test_file2).replace('\\\\', '/') +\n        '\", wdir=\"' + str(folder).replace('\\\\', '/') + '\")')\nassert '1/0' in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug')\nqtbot.waitUntil(lambda : osp.samefile(main_window.editor.get_current_editor\n    ().filename, str(test_file)))\nmain_window.editor.new()\nqtbot.wait(100)\nassert main_window.editor.get_current_editor().filename != str(test_file)\ncurrent_filename = main_window.editor.get_current_editor().filename\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, '!a')\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.wait(1000)\nassert current_filename == main_window.editor.get_current_editor().filename\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, '!u')\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.waitUntil(lambda : osp.samefile(main_window.editor.get_current_editor\n    ().filename, str(test_file2)))\neditor_stack = main_window.editor.get_current_editorstack()\nindex = editor_stack.has_filename(str(test_file))\nassert index is not None\neditor_stack.set_stack_index(index)\nassert osp.samefile(main_window.editor.get_current_editor().filename, str(\n    test_file))\nif where:\n    with qtbot.waitSignal(shell.executed):\n        qtbot.keyClicks(control, '!w')\n        qtbot.keyClick(control, Qt.Key_Enter)\n    qtbot.wait(1000)\n    assert osp.samefile(main_window.editor.get_current_editor().filename,\n        str(test_file2))\nelse:\n    with qtbot.waitSignal(shell.executed):\n        qtbot.keyClicks(control, '!a')\n        qtbot.keyClick(control, Qt.Key_Enter)\n    qtbot.wait(1000)\n    assert osp.samefile(main_window.editor.get_current_editor().filename,\n        str(test_file))\npytest.mark.slowpytest.mark.skipif(sys.platform == 'darwin', reason='It times out on macOS')pytest.mark.parametrize('where', [True, False])",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_runcell_after_restart",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test runcell after a kernel restart.\"\"\"\ncode = \"print('test_runcell_after_restart')\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nmain_window.editor.new()\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.set_text(code)\nwith qtbot.waitSignal(shell.sig_prompt_ready, timeout=10000):\n    shell.ipyclient.restart_kernel()\ncode_editor.setFocus()\nqtbot.keyClick(code_editor, Qt.Key_Return, modifier=Qt.ShiftModifier)\nqtbot.waitUntil(lambda : 'test_runcell_after_restart' in shell._control.\n    toPlainText())\nassert 'error' not in shell._control.toPlainText().lower()\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_ipython_magic",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the runcell command with cell magic.\"\"\"\nwrite_file = tmpdir.mkdir('foo').join('bar.txt')\nassert not osp.exists(to_text_string(write_file))\nif test_cell_magic:\n    code = '\\n\\n%%writefile ' + to_text_string(write_file) + '\\ntest\\n'\nelse:\n    code = '\\n\\n%debug print()'\nif ipython:\n    fn = 'cell-test.ipy'\nelse:\n    fn = 'cell-test.py'\np = tmpdir.join(fn)\np.write(code)\nmain_window.editor.load(to_text_string(p))\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\"runcell(0, r'{}')\".format(to_text_string(p)))\ncontrol = main_window.ipyconsole.get_focus_widget()\nerror_text = 'save this file with the .ipy extension'\ntry:\n    if ipython:\n        if test_cell_magic:\n            qtbot.waitUntil(lambda : 'Writing' in control.toPlainText())\n            assert osp.exists(to_text_string(write_file))\n        else:\n            qtbot.waitSignal(shell.executed)\n        assert error_text not in control.toPlainText()\n    else:\n        qtbot.waitUntil(lambda : error_text in control.toPlainText())\nfinally:\n    if osp.exists(to_text_string(write_file)):\n        os.remove(to_text_string(write_file))\npytest.mark.slowpytest.mark.skipif(sys.platform.startswith('linux'), reason=\n    'It fails sometimes on Linux')pytest.mark.parametrize('ipython', [True, False])pytest.mark.parametrize('test_cell_magic', [True, False])",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_running_namespace",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the running namespace is correctly sent when debugging in a\n    new namespace.\n    \"\"\"\ncode = \"\"\"def test(a):\n    print('a:',a)\na = 10\ntest(5)\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nmain_window.editor.clear_all_breakpoints()\nmain_window.editor.new()\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.set_text(code)\ncode_editor.debugger.toogle_breakpoint(line_number=2)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('b = 10')\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.waitUntil(lambda : 'b' in nsb.editor.source_model._data)\nassert nsb.editor.source_model._data['b']['view'] == '10'\nwith qtbot.waitSignal(shell.executed):\n    qtbot.mouseClick(debug_button, Qt.LeftButton)\nqtbot.waitUntil(lambda : 'a' in nsb.editor.source_model._data and nsb.\n    editor.source_model._data['a']['view'] == '5', timeout=3000)\nassert 'b' not in nsb.editor.source_model._data\nassert nsb.editor.source_model._data['a']['view'] == '5'\nqtbot.waitUntil(shell.is_waiting_pdb_input)\nwith qtbot.waitSignal(shell.executed):\n    shell.pdb_execute('!c')\nqtbot.waitUntil(lambda : 'b' in nsb.editor.source_model._data)\nassert nsb.editor.source_model._data['a']['view'] == '10'\nassert nsb.editor.source_model._data['b']['view'] == '10'\npytest.mark.slow",
        "CUT_1": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_2": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_3": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_4": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_5": "\"\"\"Import data in current namespace\"\"\"\nif self.count():\n    nsb = self.current_widget()\n    nsb.refresh_table()\n    nsb.import_data(filenames=fname)\n    if self.dockwidget:\n        self.switch_to_plugin()\n"
    },
    {
        "functionName": "test_post_mortem",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test post mortem works\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = main_window.ipyconsole.get_focus_widget()\ntest_file = tmpdir.join('test.py')\ntest_file.write('raise RuntimeError\\n')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('runfile(' + repr(str(test_file)) + ', post_mortem=True)')\nassert 'IPdb [' in control.toPlainText()\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_run_unsaved_file_multiprocessing",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that we can run an unsaved file with multiprocessing.\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nrun_action = main_window.run_toolbar_actions[0]\nrun_button = main_window.run_toolbar.widgetForAction(run_action)\nmain_window.editor.new()\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.set_text(\n    \"\"\"import multiprocessing\nimport traceback\nif __name__ is \"__main__\":\n    p = multiprocessing.Process(target=traceback.print_exc)\n    p.start()\n    p.join()\n\"\"\"\n    )\nqtbot.mouseClick(run_button, Qt.LeftButton)\nif os.name == 'nt':\n    qtbot.waitUntil(lambda : 'Warning: multiprocessing' in shell._control.\n        toPlainText())\nelse:\n    qtbot.waitUntil(lambda : 'None' in shell._control.toPlainText())\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n"
    },
    {
        "functionName": "test_varexp_cleared_after_kernel_restart",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the variable explorer is cleared after a kernel restart.\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\ncontrol = main_window.ipyconsole.get_focus_widget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 10')\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.waitUntil(lambda : 'a' in nsb.editor.source_model._data, timeout=3000)\nwith qtbot.waitSignal(shell.sig_prompt_ready, timeout=10000):\n    shell.ipyclient.restart_kernel()\nqtbot.waitUntil(lambda : 'a' not in nsb.editor.source_model._data, timeout=3000\n    )\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_varexp_cleared_after_reset",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the variable explorer is cleared after triggering a\n    reset in the IPython console and variable explorer panes.\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\ncontrol = main_window.ipyconsole.get_focus_widget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 10')\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.waitUntil(lambda : 'a' in nsb.editor.source_model._data, timeout=3000)\nnsb.reset_namespace()\nqtbot.waitUntil(lambda : 'a' not in nsb.editor.source_model._data, timeout=3000\n    )\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 10')\nnsb = main_window.variableexplorer.get_focus_widget()\nqtbot.waitUntil(lambda : 'a' in nsb.editor.source_model._data, timeout=3000)\nshell.ipyclient.reset_namespace()\nqtbot.waitUntil(lambda : 'a' not in nsb.editor.source_model._data, timeout=3000\n    )\npytest.mark.slow",
        "CUT_1": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_2": "\"\"\"\n        Register shell with variable explorer.\n\n        This function opens a new NamespaceBrowser for browsing the variables\n        in the shell.\n        \"\"\"\nshellwidget_id = id(shellwidget)\nif shellwidget_id not in self.shellwidgets:\n    self.options_button.setVisible(True)\n    nsb = NamespaceBrowser(self, options_button=self.options_button)\n    nsb.set_shellwidget(shellwidget)\n    nsb.setup(**self.get_settings())\n    nsb.sig_option_changed.connect(self.change_option)\n    nsb.sig_free_memory.connect(self.free_memory)\n    self.add_widget(nsb)\n    self.shellwidgets[shellwidget_id] = nsb\n    self.set_shellwidget_from_id(shellwidget_id)\n    return nsb\n",
        "CUT_3": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_4": "self.register_widget_shortcuts(nsb)\nself.stack.addWidget(nsb)\n",
        "CUT_5": "\"\"\"Import data in current namespace\"\"\"\nif self.count():\n    nsb = self.current_widget()\n    nsb.refresh_table()\n    nsb.import_data(filenames=fname)\n    if self.dockwidget:\n        self.switch_to_plugin()\n"
    },
    {
        "functionName": "test_immediate_debug",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Check if we can enter debugging immediately\n    \"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nwith qtbot.waitSignal(shell.executed, timeout=SHELL_TIMEOUT):\n    shell.execute('%debug print()')\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_local_namespace",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the local namespace is not reset.\n\n    This can happen if `frame.f_locals` is called on the current frame, as this\n    has the side effect of discarding the pdb locals.\n    \"\"\"\ncode = \"\"\"\ndef hello():\n    test = 1\n    print('test ==', test)\nhello()\n\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nmain_window.editor.clear_all_breakpoints()\nmain_window.editor.new()\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.set_text(code)\ncode_editor.debugger.toogle_breakpoint(line_number=4)\nnsb = main_window.variableexplorer.get_focus_widget()\nwith qtbot.waitSignal(shell.executed):\n    qtbot.mouseClick(debug_button, Qt.LeftButton)\nqtbot.waitUntil(lambda : 'test' in nsb.editor.source_model._data and nsb.\n    editor.source_model._data['test']['view'] == '1', timeout=3000)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('test = 1 + 1')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\"print('test =', test)\")\nassert 'test = 2' in shell._control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('test = 1 + 1 + 1')\nwith qtbot.waitSignal(shell.executed):\n    shell.pdb_execute('!next')\nassert 'test == 3' in shell._control.toPlainText()\nassert 'test' in nsb.editor.source_model._data and nsb.editor.source_model._data[\n    'test']['view'] == '3'\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_ordering_lsp_requests_at_startup",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test the ordering of requests we send to the LSP at startup when a\n    project was left open during the previous session.\n\n    This is a regression test for spyder-ide/spyder#13351.\n    \"\"\"\ncode_editor = main_window.editor.get_current_editor()\nqtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000)\nlsp = main_window.completions.get_client('lsp')\npython_client = lsp.clients['python']\nqtbot.wait(5000)\nexpected_requests = [(0, 'initialize'), (1, 'initialized'), (2,\n    'workspace/didChangeConfiguration'), (3,\n    'workspace/didChangeWorkspaceFolders'), (4, 'textDocument/didOpen')]\nassert python_client['instance']._requests[:5] == expected_requests\npytest.mark.slowpytest.mark.use_introspectionpytest.mark.preload_project",
        "CUT_1": "CONF.set('lsp-server', 'pycodestyle', True)\nCONF.set('lsp-server', 'pydocstyle', True)\nCONF.set('lsp-server', 'stdio', False)\nCONF.set('lsp-server', 'code_snippets', False)\nos.environ['SPY_TEST_USE_INTROSPECTION'] = 'True'\nmain = MainWindowMock()\ncompletions = CompletionManager(main, ['lsp'])\ncompletions.start()\nwith qtbot_module.waitSignal(main.editor.sig_lsp_initialized, timeout=30000):\n    completions.start_client('python')\ncompletions.language_status['python']['lsp'] = True\ndef teardown():\n    completions.shutdown()\n    os.environ['SPY_TEST_USE_INTROSPECTION'] = 'False'\n    CONF.set('lsp-server', 'pycodestyle', False)\n    CONF.set('lsp-server', 'pydocstyle', False)\nrequest.addfinalizer(teardown)\nreturn completions\npytest.fixture(scope='function')",
        "CUT_2": "\"\"\"Disable LSP workspace functionality.\"\"\"\nself.completions_available = False\n",
        "CUT_3": "\"\"\"Disable LSP workspace functionality.\"\"\"\nself.completions_available = False\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n"
    },
    {
        "functionName": "test_tour_message",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the tour message displays and sends users to the tour.\"\"\"\nqtbot.waitSignal(main_window.sig_setup_finished, timeout=30000)\nassert CONF.get('main', 'show_tour_message')\nmain_window.show_tour_message(force=True)\nqtbot.waitUntil(lambda : bool(main_window.tour_dialog), timeout=5000)\nqtbot.waitUntil(lambda : main_window.tour_dialog.isVisible(), timeout=2000)\nqtbot.mouseClick(main_window.tour_dialog.dismiss_button, Qt.LeftButton)\nqtbot.waitUntil(lambda : not main_window.tour_dialog.isVisible(), timeout=2000)\nassert not CONF.get('main', 'show_tour_message')\nmain_window.show_tour_message()\nqtbot.wait(2000)\nassert not main_window.tour_dialog.isVisible()\nmain_window.show_tour_message(force=True)\nqtbot.waitUntil(lambda : main_window.tour_dialog.isVisible(), timeout=5000)\nqtbot.mouseClick(main_window.tour_dialog.launch_tour_button, Qt.LeftButton)\nqtbot.waitUntil(lambda : main_window.tour.is_running, timeout=9000)\nassert not main_window.tour_dialog.isVisible()\nassert not CONF.get('main', 'show_tour_message')\nmain_window.tour.close_tour()\nqtbot.waitUntil(lambda : not main_window.tour.is_running, timeout=9000)\nmain_window.tour_dialog.hide()\npytest.mark.slowpytest.mark.parametrize('main_window', [{'spy_config': ('main',\n    'show_tour_message', 2)}], indirect=True)",
        "CUT_1": "\"\"\"\n        Show message about starting the tour the first time Spyder starts.\n        \"\"\"\nshould_show_tour = CONF.get('main', 'show_tour_message')\nif force or should_show_tour and not running_under_pytest(\n    ) and not get_safe_mode():\n    CONF.set('main', 'show_tour_message', False)\n    self.tour_dialog = tour.OpenTourDialog(self, lambda : self.show_tour(\n        DEFAULT_TOUR))\n    self.tour_dialog.show()\nSlot()",
        "CUT_2": "\"\"\"\n        Show message about starting the tour the first time Spyder starts.\n        \"\"\"\nshould_show_tour = CONF.get('main', 'show_tour_message')\nif force or should_show_tour and not running_under_pytest(\n    ) and not get_safe_mode():\n    CONF.set('main', 'show_tour_message', False)\n    self.tour_dialog = tour.OpenTourDialog(self, lambda : self.show_tour(\n        DEFAULT_TOUR))\n    self.tour_dialog.show()\nSlot()",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Create configuration dialog box page widget\"\"\"\nif self.CONFIGWIDGET_CLASS is not None:\n    parent = self\n    main = dlg\n    if not hasattr(self, 'dockwidget'):\n        parent = dlg\n        main = main_window\n    configwidget = self.CONFIGWIDGET_CLASS(parent, main)\n    configwidget.initialize()\n    return configwidget\n",
        "CUT_5": "\"\"\"Create configuration dialog box page widget\"\"\"\nif self.CONFIGWIDGET_CLASS is not None:\n    parent = self\n    main = dlg\n    if not hasattr(self, 'dockwidget'):\n        parent = dlg\n        main = main_window\n    configwidget = self.CONFIGWIDGET_CLASS(parent, main)\n    configwidget.initialize()\n    return configwidget\n"
    },
    {
        "functionName": "test_update_outline",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that files in the Outline pane are updated at startup and\n    after switching projects.\n    \"\"\"\noutline_explorer = main_window.outlineexplorer\noutline_explorer._toggle_view_action.setChecked(True)\ntreewidget = outline_explorer.explorer.treewidget\neditors_py = [editor for editor in treewidget.editor_ids.keys() if editor.\n    get_language() == 'Python']\nqtbot.wait(5000)\nassert all([(len(treewidget.editor_tree_cache[editor.get_id()]) > 0) for\n    editor in editors_py])\neditorstack = main_window.editor.get_current_editorstack()\neditorstack.sig_split_vertically.emit()\nqtbot.wait(1000)\neditorstack = main_window.editor.get_current_editorstack()\neditorstack.set_stack_index(2)\neditor = editorstack.get_current_editor()\nassert osp.splitext(editor.filename)[1] == '.txt'\nassert editor.is_cloned\neditor_tree = treewidget.current_editor\ntree = treewidget.editor_tree_cache[editor_tree.get_id()]\nassert len(tree) == 0\nassert not outline_explorer.explorer.loading_widget.isSpinning()\nprev_file = tmpdir.join('foo.py')\nprev_file.write(\"\"\"def zz(x):\n    return x**2\n\"\"\")\nCONF.set('editor', 'filenames', [str(prev_file)])\nmain_window.projects.close_project()\nqtbot.wait(1000)\neditor = list(treewidget.editor_ids.keys())[0]\nassert len(treewidget.editor_tree_cache[editor.get_id()]) > 0\nCONF.set('editor', 'filenames', [])\npytest.mark.slowpytest.mark.use_introspectionpytest.mark.preload_projectpytest.mark.skipif(os.name == 'nt', reason='Fails on Windows')",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Register plugin in Spyder's main window\"\"\"\nipyconsole = self.main.ipyconsole\ntreewidget = self.fileexplorer.treewidget\nself.add_dockwidget()\nself.fileexplorer.sig_open_file.connect(self.main.open_file)\nself.register_widget_shortcuts(treewidget)\ntreewidget.sig_edit.connect(self.main.editor.load)\ntreewidget.sig_removed.connect(self.main.editor.removed)\ntreewidget.sig_removed_tree.connect(self.main.editor.removed_tree)\ntreewidget.sig_renamed.connect(self.main.editor.renamed)\ntreewidget.sig_renamed_tree.connect(self.main.editor.renamed_tree)\ntreewidget.sig_create_module.connect(self.main.editor.new)\ntreewidget.sig_new_file.connect(lambda t: self.main.editor.new(text=t))\ntreewidget.sig_open_interpreter.connect(ipyconsole.create_client_from_path)\ntreewidget.redirect_stdio.connect(self.main.redirect_internalshell_stdio)\ntreewidget.sig_run.connect(lambda fname: ipyconsole.run_script(fname, osp.\n    dirname(fname), '', False, False, False, True, False))\ntreewidget.sig_dir_opened.connect(self.sig_dir_opened)\n",
        "CUT_4": "\"\"\"Register plugin in Spyder's main window\"\"\"\nipyconsole = self.main.ipyconsole\ntreewidget = self.fileexplorer.treewidget\nself.add_dockwidget()\nself.fileexplorer.sig_open_file.connect(self.main.open_file)\nself.register_widget_shortcuts(treewidget)\ntreewidget.sig_edit.connect(self.main.editor.load)\ntreewidget.sig_removed.connect(self.main.editor.removed)\ntreewidget.sig_removed_tree.connect(self.main.editor.removed_tree)\ntreewidget.sig_renamed.connect(self.main.editor.renamed)\ntreewidget.sig_renamed_tree.connect(self.main.editor.renamed_tree)\ntreewidget.sig_create_module.connect(self.main.editor.new)\ntreewidget.sig_new_file.connect(lambda t: self.main.editor.new(text=t))\ntreewidget.sig_open_interpreter.connect(ipyconsole.create_client_from_path)\ntreewidget.redirect_stdio.connect(self.main.redirect_internalshell_stdio)\ntreewidget.sig_run.connect(lambda fname: ipyconsole.run_script(fname, osp.\n    dirname(fname), '', False, False, False, True, False))\ntreewidget.sig_dir_opened.connect(self.sig_dir_opened)\n",
        "CUT_5": "self.treewidget.remove_editor(editor)\n"
    },
    {
        "functionName": "test_prevent_closing",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Check we can bypass prevent closing.\n    \"\"\"\ncode = \"\"\"print(1 + 6)\nprint(1 + 6)\n\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nmain_window.editor.clear_all_breakpoints()\nmain_window.editor.new()\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.set_text(code)\ncode_editor.debugger.toogle_breakpoint(line_number=1)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.mouseClick(debug_button, Qt.LeftButton)\nCONF.set('ipython_console', 'pdb_prevent_closing', False)\nassert main_window.editor.get_current_editorstack().close_file()\nCONF.set('ipython_console', 'pdb_prevent_closing', True)\nassert shell.is_debugging()\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_continue_first_line",
        "className": null,
        "fileName": "/spyder/app/tests/test_mainwindow.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Check we can bypass prevent closing.\n    \"\"\"\ncode = \"\"\"print('a =', 1 + 6)\nprint('b =', 1 + 8)\n\"\"\"\nshell = main_window.ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ndebug_action = main_window.debug_toolbar_actions[0]\ndebug_button = main_window.debug_toolbar.widgetForAction(debug_action)\nmain_window.editor.clear_all_breakpoints()\nmain_window.editor.new()\ncode_editor = main_window.editor.get_focus_widget()\ncode_editor.set_text(code)\nCONF.set('ipython_console', 'pdb_stop_first_line', False)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.mouseClick(debug_button, Qt.LeftButton)\nqtbot.waitUntil(lambda : not shell.is_debugging())\nCONF.set('ipython_console', 'pdb_stop_first_line', True)\nqtbot.waitUntil(lambda : 'a = 7' in shell._control.toPlainText())\nassert 'b = 9' in shell._control.toPlainText()\npytest.mark.slow",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_solve_plugin_dependencies_none_values",
        "className": null,
        "fileName": "/spyder/app/tests/test_solver.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "found_plugins = [None1]\nassert solve_plugin_dependencies(found_plugins) == found_plugins\n",
        "CUT_1": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_4": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_5": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n"
    },
    {
        "functionName": "test_solve_plugin_dependencies_self_reference",
        "className": null,
        "fileName": "/spyder/app/tests/test_solver.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "found_plugins = [Self]\nwith pytest.raises(SpyderAPIError):\n    solve_plugin_dependencies(found_plugins)\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture",
        "CUT_3": "\"\"\"\n        Setup and register plugin in Spyder's main window and connect it to\n        other plugins.\n        \"\"\"\nif self.NAME is None:\n    raise SpyderAPIError('A Spyder Plugin must define a `NAME`!')\nif self.NAME in self._main._PLUGINS:\n    raise SpyderAPIError('A Spyder Plugin with NAME=\"{}\" already exists!'.\n        format(self.NAME))\nif self._conf is not None:\n    self._conf.register_plugin(self)\nself.sig_option_changed.connect(self.set_conf_option)\nself.is_registered = True\nself.update_font()\n",
        "CUT_4": "\"\"\"\n        Setup and register plugin in Spyder's main window and connect it to\n        other plugins.\n        \"\"\"\nif self.NAME is None:\n    raise SpyderAPIError('A Spyder Plugin must define a `NAME`!')\nif self.NAME in self._main._PLUGINS:\n    raise SpyderAPIError('A Spyder Plugin with NAME=\"{}\" already exists!'.\n        format(self.NAME))\nif self._conf is not None:\n    self._conf.register_plugin(self)\nself.sig_option_changed.connect(self.set_conf_option)\nself.is_registered = True\nself.update_font()\n",
        "CUT_5": "\"\"\"\n        Switch to this plugin.\n\n        Notes\n        -----\n        This operation unmaximizes the current plugin (if any), raises\n        this plugin to view (if it's hidden) and gives it focus (if\n        possible).\n        \"\"\"\nsuper(BasePluginWidget, self)._switch_to_plugin()\n"
    },
    {
        "functionName": "test_solve_plugin_dependencies_circular",
        "className": null,
        "fileName": "/spyder/app/tests/test_solver.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "found_plugins = [Circular1, Circular2]\nwith pytest.raises(CircularDependencyError):\n    solve_plugin_dependencies(found_plugins)\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "s = 'Circular dependencies exist among these items: {{{}}}'.format(', '.\n    join('{!r}:{!r}'.format(key, value) for key, value in sorted(data.items()))\n    )\nsuper(CircularDependencyError, self).__init__(s)\nself.data = data\n",
        "CUT_3": "s = 'Circular dependencies exist among these items: {{{}}}'.format(', '.\n    join('{!r}:{!r}'.format(key, value) for key, value in sorted(data.items()))\n    )\nsuper(CircularDependencyError, self).__init__(s)\nself.data = data\n",
        "CUT_4": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture",
        "CUT_5": "\"\"\"\n        Switch to this plugin.\n\n        Notes\n        -----\n        This operation unmaximizes the current plugin (if any), raises\n        this plugin to view (if it's hidden) and gives it focus (if\n        possible).\n        \"\"\"\nsuper(BasePluginWidget, self)._switch_to_plugin()\n"
    },
    {
        "functionName": "test_solve_plugin_dependencies_missing_optional",
        "className": null,
        "fileName": "/spyder/app/tests/test_solver.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "found_plugins = [A, B, C]\nassert solve_plugin_dependencies(found_plugins) == found_plugins\n",
        "CUT_1": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_4": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_5": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n"
    },
    {
        "functionName": "test_solve_plugin_dependencies_missing_requires",
        "className": null,
        "fileName": "/spyder/app/tests/test_solver.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "found_plugins = [A, B, C, D]\nassert solve_plugin_dependencies(found_plugins) == found_plugins[:-1]\n",
        "CUT_1": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_4": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_5": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n"
    },
    {
        "functionName": "test_solve_plugin_dependencies_1",
        "className": null,
        "fileName": "/spyder/app/tests/test_solver.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "found_plugins = [E, F, D]\nassert solve_plugin_dependencies(found_plugins) == found_plugins\n",
        "CUT_1": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_4": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_5": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n"
    },
    {
        "functionName": "test_solve_plugin_dependencies_2",
        "className": null,
        "fileName": "/spyder/app/tests/test_solver.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "found_plugins = [E, D]\nassert solve_plugin_dependencies(found_plugins) == found_plugins\n",
        "CUT_1": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_4": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_5": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n"
    },
    {
        "functionName": "test_solve_plugin_dependencies_3",
        "className": null,
        "fileName": "/spyder/app/tests/test_solver.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "found_plugins = [F, D]\nassert solve_plugin_dependencies(found_plugins) == [F]\n",
        "CUT_1": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_4": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_5": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n"
    },
    {
        "functionName": "test_find_internal_plugins",
        "className": null,
        "fileName": "/spyder/app/tests/test_solver.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "internal = find_internal_plugins()\nassert len(internal) == 20\n",
        "CUT_1": "return _('Internal console')\n",
        "CUT_2": "return _('Internal console')\n",
        "CUT_3": "return _('Internal console')\n",
        "CUT_4": "return _('Internal console')\n",
        "CUT_5": "return _('Internal console running Spyder.')\n"
    },
    {
        "functionName": "test_get_options",
        "className": null,
        "fileName": "/spyder/app/tests/test_cli_options.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "getopt = cli_options.get_options\noptions, args = getopt([])\nassert not options.new_instance\nassert not options.reset_to_defaults\nassert not options.reset_config_files\nassert not options.optimize\nassert not options.paths\nassert options.working_directory is None\nassert not options.hide_console\nassert not options.show_console\nassert not options.multithreaded\nassert not options.profile\nassert options.window_title is None\nassert options.project is None\nassert options.opengl_implementation is None\nassert options.files == []\nassert args == []\noptions, args = getopt(['--new-instance'])\nassert options.new_instance\noptions, args = getopt(['--defaults', '--reset'])\nassert options.reset_to_defaults\nassert options.reset_config_files\noptions, args = getopt(['--optimize', '--workdir', 'test dir'])\nassert options.optimize\nassert options.working_directory == 'test dir'\noptions, args = getopt('--window-title MyWindow'.split())\nassert options.window_title == 'MyWindow'\noptions, args = getopt('-p myproject test_file.py another_file.py'.split())\nassert options.project == 'myproject'\nassert options.files == ['test_file.py', 'another_file.py']\nassert args == ['test_file.py', 'another_file.py']\nwith pytest.raises(SystemExit):\n    options, args = getopt(['--version'])\nwith pytest.raises(SystemExit):\n    options, args = getopt(['-w'])\nwith pytest.raises(SystemExit):\n    options, args = getopt(['-p'])\noptions, args = getopt('--opengl software'.split())\nassert options.opengl_implementation == 'software'\npytest.mark.first",
        "CUT_1": "options = params['options']\noptions = {snake_to_camel(opt): options[opt] for opt in options}\nparams = {'textDocument': {'uri': path_as_uri(params['file'])}, 'options':\n    options}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_FORMATTING)",
        "CUT_2": "options = params['options']\noptions = {snake_to_camel(opt): options[opt] for opt in options}\nparams = {'textDocument': {'uri': path_as_uri(params['file'])}, 'options':\n    options}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_FORMATTING)",
        "CUT_3": "options = params['options']\noptions = {snake_to_camel(opt): options[opt] for opt in options}\nparams = {'textDocument': {'uri': path_as_uri(params['file'])}, 'options':\n    options, 'range': params['range']}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_RANGE_FORMATTING)",
        "CUT_4": "options = params['options']\noptions = {snake_to_camel(opt): options[opt] for opt in options}\nparams = {'textDocument': {'uri': path_as_uri(params['file'])}, 'options':\n    options, 'range': params['range']}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_RANGE_FORMATTING)",
        "CUT_5": "self.diagnostics = []\nsuper(PyCodeStyleDiagnosticReport, self).__init__(options=options)\n"
    },
    {
        "functionName": "tour",
        "className": null,
        "fileName": "/spyder/app/tests/test_tour.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Setup the QMainWindow for the tour.\"\"\"\ntour = TourTestWindow()\nqtbot.addWidget(tour)\nreturn tour\npytest.fixture",
        "CUT_1": "\"\"\"Override Qt method.\"\"\"\nif self.tour.step_current != 0:\n    self.tour.lost_focus()\n",
        "CUT_2": "\"\"\"Override Qt method.\"\"\"\nif self.tour.step_current != 0:\n    self.tour.lost_focus()\n",
        "CUT_3": "\"\"\"Show interactive tour.\"\"\"\nself.maximize_dockwidget(restore=True)\nframes = self.tours_available[index]\nself.tour.set_tour(index, frames, self)\nself.tour.start_tour()\n",
        "CUT_4": "\"\"\"Show interactive tour.\"\"\"\nself.maximize_dockwidget(restore=True)\nframes = self.tours_available[index]\nself.tour.set_tour(index, frames, self)\nself.tour.start_tour()\n",
        "CUT_5": "\"\"\" \"\"\"\nframes = get_tour('test')\nindex = 0\ndic = {'last': 0, 'tour': frames}\nself.tour.set_tour(index, dic, self)\nself.tour.start_tour()\n"
    },
    {
        "functionName": "test_tour",
        "className": null,
        "fileName": "/spyder/app/tests/test_tour.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test tour.\"\"\"\ntour.show()\nassert tour\n",
        "CUT_1": "\"\"\"Override Qt method.\"\"\"\nif self.tour.step_current != 0:\n    self.tour.lost_focus()\n",
        "CUT_2": "\"\"\"Override Qt method.\"\"\"\nif self.tour.step_current != 0:\n    self.tour.lost_focus()\n",
        "CUT_3": "\"\"\"Show interactive tour.\"\"\"\nself.maximize_dockwidget(restore=True)\nframes = self.tours_available[index]\nself.tour.set_tour(index, frames, self)\nself.tour.start_tour()\n",
        "CUT_4": "\"\"\"Show interactive tour.\"\"\"\nself.maximize_dockwidget(restore=True)\nframes = self.tours_available[index]\nself.tour.set_tour(index, frames, self)\nself.tour.start_tour()\n",
        "CUT_5": "\"\"\" \"\"\"\nframes = get_tour('test')\nindex = 0\ndic = {'last': 0, 'tour': frames}\nself.tour.set_tour(index, dic, self)\nself.tour.start_tour()\n"
    },
    {
        "functionName": "test_default_config_set",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "section, option, value = test_input\ndefaultconfig._set(section, option, value, verbose=True)\nassert defaultconfig.sections() == [section]\ncaptured = capsys.readouterr()\nassert captured.out == expected\npytest.mark.parametrize('test_input, expected', [(('sec', 'opt', 'val'),\n    '[sec][opt] = val\\n'), (('sec', 'opt', 50), '[sec][opt] = 50\\n'), ((\n    'sec', 'opt', [50]), \"\"\"[sec][opt] = [50]\n\"\"\"), (('sec', 'opt', (50, 2)\n    ), '[sec][opt] = (50, 2)\\n'), (('sec', 'opt', {50}),\n    '[sec][opt] = {}\\n'.format('set([50])' if PY2 else '{50}')), (('sec',\n    'opt', {'k': 50}), \"\"\"[sec][opt] = {'k': 50}\n\"\"\"), (('sec', 'opt',\n    False), '[sec][opt] = False\\n'), (('sec', 'opt', True),\n    '[sec][opt] = True\\n'), (('sec space', 'opt', True),\n    \"\"\"[sec space][opt] = True\n\"\"\"), (('sec space', 'opt space', True),\n    '[sec space][opt space] = True\\n')])",
        "CUT_1": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_2": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_3": "\"\"\"Reset config to Default values.\"\"\"\nfor sec, options in self.defaults:\n    if section == None or section == sec:\n        for option in options:\n            value = options[option]\n            self._set(sec, option, value, verbose)\nif save:\n    self._save()\n",
        "CUT_4": "\"\"\"Reset config to Default values.\"\"\"\nfor sec, options in self.defaults:\n    if section == None or section == sec:\n        for option in options:\n            value = options[option]\n            self._set(sec, option, value, verbose)\nif save:\n    self._save()\n",
        "CUT_5": "\"\"\"\n        Search for section and option on the name_map and return the name.\n        \"\"\"\nfor name, sec_opts in self._name_map.items():\n    default_sec_name = self._configs_map.get(name).DEFAULT_SECTION_NAME\n    if name == default_sec_name:\n        continue\n    for sec, options in sec_opts:\n        if sec == section:\n            if len(options) == 0:\n                return name\n            else:\n                for opt in options:\n                    if opt == option:\n                        return name\n"
    },
    {
        "functionName": "test_default_config_save_write",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "defaultconfig._save()\n",
        "CUT_1": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_2": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_3": "\"\"\"Remove `section` and all options within it.\"\"\"\nsuper(UserConfig, self).remove_section(section)\nself._save()\n",
        "CUT_4": "\"\"\"Remove `section` and all options within it.\"\"\"\nsuper(UserConfig, self).remove_section(section)\nself._save()\n",
        "CUT_5": "\"\"\"Reset config to Default values.\"\"\"\nfor sec, options in self.defaults:\n    if section == None or section == sec:\n        for option in options:\n            value = options[option]\n            self._set(sec, option, value, verbose)\nif save:\n    self._save()\n"
    },
    {
        "functionName": "test_default_config_set_defaults",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "defaults = [('main2', {'opt': 1})]\ndefaultconfig.set_defaults(defaults)\nassert 'main2' in defaultconfig.sections()\n",
        "CUT_1": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n",
        "CUT_2": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n",
        "CUT_3": "\"\"\"Return all sections of the configuration file.\"\"\"\nsections = set()\nfor _, config in self._configs_map.items():\n    for section in config.sections():\n        sections.add(section)\nreturn list(sorted(sections))\n",
        "CUT_4": "\"\"\"Return all sections of the configuration file.\"\"\"\nsections = set()\nfor _, config in self._configs_map.items():\n    for section in config.sections():\n        sections.add(section)\nreturn list(sorted(sections))\n",
        "CUT_5": "\"\"\"Set defaults from the current config.\"\"\"\nself.defaults = []\nfor section in self.sections():\n    secdict = {}\n    for option, value in self.items(section, raw=self._raw):\n        secdict[option] = value\n    self.defaults.append((section, secdict))\n"
    },
    {
        "functionName": "test_userconfig_get_minor_version",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "result = UserConfig._get_minor_version(value)\nassert result == expected\npytest.mark.parametrize('value,expected', [('3.2.1', '3.2'), ('3.2.0', '3.2')])",
        "CUT_1": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_2": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_3": "self.value = value\n",
        "CUT_4": "self.value = value\n",
        "CUT_5": "return self.value\n"
    },
    {
        "functionName": "test_userconfig_get_major_version",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "result = UserConfig._get_major_version(value)\nassert result == expected\npytest.mark.parametrize('value,expected', [('3.2.1', '3'), ('0.2.0', '0')])",
        "CUT_1": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_2": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_3": "self.value = value\n",
        "CUT_4": "self.value = value\n",
        "CUT_5": "return self.value\n"
    },
    {
        "functionName": "test_userconfig_check_version",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "name = 'spyder-test'\npath = str(tmpdir)\nwith pytest.raises(ValueError):\n    UserConfig(name=name, path=path, defaults=DEFAULTS, load=False, version\n        =test_version, raw_mode=True)\nwith pytest.raises(ValueError):\n    userconfig.set_version(test_version)\npytest.mark.parametrize('test_version', ['abc', 'x.x.x', '1.0', '-1.0',\n    '-1.0.0', ''])",
        "CUT_1": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_2": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_3": "ini_contents = \"\"\"[main]\nversion = 1.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\\n\\n\"\nelse:\n    ini_contents += '[section]\\noption = value\\n\\n'\nname = 'spyder-test'\npath = str(tmpdir)\ndefault_kwargs = {'name': name, 'path': path, 'defaults': {}, 'load': True,\n    'version': '1.0.0', 'backup': False, 'raw_mode': True,\n    'remove_obsolete': False}\nparam = getattr(request, 'param', None)\nif param:\n    modified_kwargs = request.param[0]\n    kwargs = default_kwargs.copy().update(modified_kwargs)\nelse:\n    kwargs = default_kwargs\ninifile = tmpdir.join('{}.ini'.format(name))\ninifile.write(ini_contents)\nreturn UserConfig(**kwargs)\npytest.fixture",
        "CUT_4": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_5": "\"\"\"\n        Configuration manager to provide access to user/site/project config.\n        \"\"\"\npath = self.get_user_config_path()\nif not osp.isdir(path):\n    os.makedirs(path)\nconf_paths = get_conf_paths()\nsite_defaults = DEFAULTS\nfor conf_path in reversed(conf_paths):\n    conf_fpath = os.path.join(conf_path, 'spyder.ini')\n    if os.path.isfile(conf_fpath):\n        site_config = UserConfig('spyder', path=conf_path, defaults=\n            site_defaults, load=False, version=CONF_VERSION, backup=False,\n            raw_mode=True, remove_obsolete=False)\n        site_defaults = site_config.to_list()\nself._parent = parent\nself._active_project_callback = active_project_callback\nself._user_config = MultiUserConfig(NAME_MAP, path=path, defaults=\n    site_defaults, load=True, version=CONF_VERSION, backup=True, raw_mode=\n    True, remove_obsolete=False)\nself._plugin_configs = {}\nself._project_configs = {}\nself.remove_deprecated_config_locations()\n"
    },
    {
        "functionName": "test_userconfig_check_defaults",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "name = 'foobar'\npath = str(tmpdir)\nconf = UserConfig(name=name, path=path, defaults={}, load=False, version=\n    '1.0.0', backup=False, raw_mode=True)\nconf._check_defaults({})\nconf._check_defaults({'option2': 'value2'})\nconf._check_defaults([])\nconf._check_defaults([('sec', {'opt1': 'val1'})])\nwith pytest.raises(AssertionError):\n    conf._check_defaults([(123, {'opt1': 'val1'})])\nwith pytest.raises(AssertionError):\n    conf._check_defaults([('sec', {(123): 'val1'})])\nwith pytest.raises(ValueError):\n    conf._check_defaults({1, 2, 3})\nwith pytest.raises(ValueError):\n    conf._check_defaults('asd')\n",
        "CUT_1": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_2": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_3": "CONF.set('run', 'breakpoints', {})\n",
        "CUT_4": "CONF.set('run', 'breakpoints', {})\n",
        "CUT_5": "self.key = CONF.get_shortcut(self.context, self.name)\n"
    },
    {
        "functionName": "test_userconfig_check_section_option",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "section = userconfig._check_section_option(None, 'version')\nassert section == userconfig.DEFAULT_SECTION_NAME\nsection = userconfig._check_section_option(None, 'opt')\nassert section == userconfig.DEFAULT_SECTION_NAME\nsection = userconfig._check_section_option('sec', 'opt')\nassert section == 'sec'\nwith pytest.raises(RuntimeError):\n    section = userconfig._check_section_option(123, 'opt')\nwith pytest.raises(RuntimeError):\n    section = userconfig._check_section_option(None, 123)\n",
        "CUT_1": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_2": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_3": "\"\"\"Remove `section` and all options within it.\"\"\"\nsuper(UserConfig, self).remove_section(section)\nself._save()\n",
        "CUT_4": "\"\"\"Remove `section` and all options within it.\"\"\"\nsuper(UserConfig, self).remove_section(section)\nself._save()\n",
        "CUT_5": "section = self.CONF_SECTION if section is None else section\nCONF.set(section, option, value)\n"
    },
    {
        "functionName": "test_userconfig_load_from_ini",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "name = 'foobar'\npath = str(tmpdir)\nfpath = os.path.join(path, '{}.ini'.format(name))\nwith open(fpath, 'w') as fh:\n    fh.write('[sec\\n')\nconf = UserConfig(name=name, path=path, defaults=DEFAULTS, load=True,\n    version=CONF_VERSION, backup=False, raw_mode=True)\nassert conf.get_config_fpath() == fpath\ncaptured = capsys.readouterr()\nassert 'Warning' in captured.out\n",
        "CUT_1": "\"\"\"\n        Override method.\n\n        Return the configuration path for given version.\n\n        If no version is provided, it returns the current file path.\n        \"\"\"\nif version is None or self._external_plugin:\n    fpath = self.get_config_fpath()\nelif check_version(version, '51.0.0', '<'):\n    fpath = osp.join(get_conf_path(), 'spyder.ini')\nelse:\n    fpath = self.get_config_fpath()\nreturn fpath\n",
        "CUT_2": "\"\"\"\n        Override method.\n\n        Return the configuration path for given version.\n\n        If no version is provided, it returns the current file path.\n        \"\"\"\nif version is None or self._external_plugin:\n    fpath = self.get_config_fpath()\nelif check_version(version, '51.0.0', '<'):\n    fpath = osp.join(get_conf_path(), 'spyder.ini')\nelse:\n    fpath = self.get_config_fpath()\nreturn fpath\n",
        "CUT_3": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_4": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_5": "\"\"\"\n        Override method.\n\n        Return the last configuration file used if found.\n        \"\"\"\nfpath = self.get_config_fpath()\nif self._external_plugin:\n    previous_paths = [fpath]\nelse:\n    previous_paths = [fpath, os.path.join(get_conf_path(), 'spyder.ini')]\nfor fpath in previous_paths:\n    if osp.isfile(fpath):\n        break\nreturn fpath\n"
    },
    {
        "functionName": "test_userconfig_get_version",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert tmpconfig.get_version() == CONF_VERSION\nassert userconfig.get_version() == '1.0.0'\nuserconfig.remove_option('main', 'version')\nassert userconfig.get_version() == '0.0.0'\n",
        "CUT_1": "\"\"\"Return the UserConfig class to use.\"\"\"\nreturn SpyderUserConfig\n",
        "CUT_2": "\"\"\"Return the UserConfig class to use.\"\"\"\nreturn SpyderUserConfig\n",
        "CUT_3": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_4": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_5": "\"\"\"Remove `section` and all options within it.\"\"\"\nsuper(UserConfig, self).remove_section(section)\nself._save()\n"
    },
    {
        "functionName": "test_userconfig_set_version",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "version = '1000.1000.1000'\nuserconfig.set_version(version)\nassert userconfig.get_version() == version\n",
        "CUT_1": "\"\"\"Set configuration (not application!) version.\"\"\"\nversion = self._check_version(version)\nself.set(self.DEFAULT_SECTION_NAME, 'version', version, save=save)\n",
        "CUT_2": "\"\"\"Set configuration (not application!) version.\"\"\"\nversion = self._check_version(version)\nself.set(self.DEFAULT_SECTION_NAME, 'version', version, save=save)\n",
        "CUT_3": "\"\"\"Return configuration (not application!) version.\"\"\"\nreturn self.get(self.DEFAULT_SECTION_NAME, 'version', version)\n",
        "CUT_4": "\"\"\"Return configuration (not application!) version.\"\"\"\nreturn self.get(self.DEFAULT_SECTION_NAME, 'version', version)\n",
        "CUT_5": "\"\"\"Return the 'major' component of the version.\"\"\"\nreturn version[:version.find('.')]\nstaticmethod"
    },
    {
        "functionName": "test_userconfig_reset_to_defaults",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "name = 'foobar'\npath = str(tmpdir)\ndefaults = [('main', {'opt': False}), ('test', {'opt': False})]\nconf = UserConfig(name=name, path=path, defaults=defaults, load=False,\n    version='1.0.0', backup=False, raw_mode=True)\nassert conf.defaults == defaults\nconf.set(None, 'opt', True)\nassert conf.get(None, 'opt') is True\nconf.reset_to_defaults()\nassert conf.get(None, 'opt') is False\nassert conf.defaults == defaults\nconf.set('test', 'opt', True)\nassert conf.get('test', 'opt') is True\nconf.reset_to_defaults()\nassert conf.get('test', 'opt') is False\n",
        "CUT_1": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n",
        "CUT_2": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n",
        "CUT_3": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_4": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_5": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n"
    },
    {
        "functionName": "test_userconfig_set_as_defaults",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "name = 'foobar'\npath = str(tmpdir)\nconf = UserConfig(name=name, path=path, defaults={}, load=False, version=\n    '1.0.0', backup=False, raw_mode=True)\nassert conf.defaults == [('main', {})]\nconf.set_as_defaults()\nassert conf.defaults == []\n",
        "CUT_1": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_2": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_3": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n",
        "CUT_4": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n",
        "CUT_5": "\"\"\"Multi user config class based on UserConfig class.\"\"\"\nself._name_map = self._check_name_map(name_map)\nself._path = path\nself._defaults = defaults\nself._load = load\nself._version = version\nself._backup = backup\nself._raw_mode = 1 if raw_mode else 0\nself._remove_obsolete = remove_obsolete\nself._external_plugin = external_plugin\nself._configs_map = {}\nself._config_defaults_map = self._get_defaults_for_name_map(defaults, name_map)\nself._config_kwargs = {'path': path, 'defaults': defaults, 'load': load,\n    'version': version, 'backup': backup, 'raw_mode': raw_mode,\n    'remove_obsolete': False, 'external_plugin': external_plugin}\nfor name in name_map:\n    defaults = self._config_defaults_map.get(name)\n    mod_kwargs = {'name': name, 'defaults': defaults}\n    new_kwargs = self._config_kwargs.copy()\n    new_kwargs.update(mod_kwargs)\n    config_class = self.get_config_class()\n    self._configs_map[name] = config_class(**new_kwargs)\ndefault_config = self._configs_map.get(self.DEFAULT_FILE_NAME)\nmajor_ver = default_config._get_major_version(version)\nmajor_old_ver = default_config._get_major_version(default_config._old_version)\nif remove_obsolete or major_ver != major_old_ver:\n    for _, config in self._configs_map.items():\n        config._remove_deprecated_options(config._old_version)\n"
    },
    {
        "functionName": "test_userconfig_get_default",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "value = userconfig.get_default('other_section', 'other_option')\nassert value == NoDefault\nvalue = userconfig.get_default('section', 'option')\nassert value == NoDefault\nvalue = tmpconfig.get_default('main', 'window/is_maximized')\nassert value is True\n",
        "CUT_1": "self.value = value\n",
        "CUT_2": "self.value = value\n",
        "CUT_3": "return self.value\n",
        "CUT_4": "return self.value\n",
        "CUT_5": "\"\"\"Get the section,option value from the defaults.\"\"\"\nvalue = NoDefault\nfor sec, options in defaults:\n    if section == sec:\n        value = options.get(option, NoDefault)\n        break\nreturn value\nstaticmethod"
    },
    {
        "functionName": "test_userconfig_get",
        "className": "TestUserConfigGet",
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "name = 'foobar'\npath = str(tmpdir)\nconf = UserConfig(name=name, path=path, defaults=defaults, load=False,\n    version='1.0.0', backup=False, raw_mode=True)\nassert conf.get('test', 'opt') == value\npytest.mark.parametrize('defaults,value', [([('test', {'opt': 'value'})],\n    'value'), ([('test', {'opt': '\"\u00e9\u00e0\u00c7\u00c3\u00e3\u00e9\u00e8\u00ef\"'})], '\"\u00e9\u00e0\u00c7\u00c3\u00e3\u00e9\u00e8\u00ef\"'), ([('test',\n    {'opt': '\u00e9\u00e0\u00c7\u00c3\u00e3\u00e9\u00e8\u00ef'})], '\u00e9\u00e0\u00c7\u00c3\u00e3\u00e9\u00e8\u00ef'), ([('test', {'opt': True})], True),\n    ([('test', {'opt': UserConfig})], repr(UserConfig)), ([('test', {'opt':\n    123})], 123), ([('test', {'opt': 123.123})], 123.123), ([('test', {\n    'opt': [1]})], [1]), ([('test', {'opt': {'key': 'val'}})], {'key': 'val'})]\n    )",
        "CUT_1": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_2": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "\"\"\"\n        Draw the fold indicator/trigger (arrow).\n\n        :param top: Top position\n        :param mouse_over: Whether the mouse is over the indicator\n        :param collapsed: Whether the trigger is collapsed or not.\n        :param painter: QPainter\n        \"\"\"\nrect = QRect(0, top, self.sizeHint().width(), self.sizeHint().height())\nif self._native_icons:\n    opt = QStyleOptionViewItem()\n    opt.rect = rect\n    opt.state = QStyle.State_Active | QStyle.State_Item | QStyle.State_Children\n    if not collapsed:\n        opt.state |= QStyle.State_Open\n    if mouse_over:\n        opt.state |= (QStyle.State_MouseOver | QStyle.State_Enabled |\n            QStyle.State_Selected)\n        opt.palette.setBrush(QPalette.Window, self.palette().highlight())\n    opt.rect.translate(-2, 0)\n    self.style().drawPrimitive(QStyle.PE_IndicatorBranch, opt, painter, self)\nelse:\n    index = 0\n    if not collapsed:\n        index = 2\n    if mouse_over:\n        index += 1\n    ima.icon(self._indicators_icons[index]).paint(painter, rect)\n"
    },
    {
        "functionName": "test_userconfig_get2",
        "className": "TestUserConfigGet",
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "name = 'foobar'\npath = str(tmpdir)\nconf = UserConfig(name=name, path=path, defaults=defaults, load=False,\n    version='1.0.0', backup=False, raw_mode=True)\nif raises:\n    with pytest.raises(cp.NoSectionError):\n        conf.get('test', 'opt')\nelse:\n    conf.get('test', 'opt', default)\npytest.mark.parametrize('defaults,default,raises', [([('test2', {'opt':\n    'value'})], 'val', True), ([('test2', {'opt': 'value'})], 'val', False),\n    ([('test', {'opt': 'value'})], 'val', False)])",
        "CUT_1": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_2": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_3": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_4": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_5": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n"
    },
    {
        "functionName": "test_userconfig_get_string_from_inifile",
        "className": "TestUserConfigGet",
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert userconfig.get('section', 'option') == 'value'\n",
        "CUT_1": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_2": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_3": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n",
        "CUT_4": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n",
        "CUT_5": "\"\"\"\n        Get an option.\n\n        Parameters\n        ----------\n        section: str\n            Section name. If `None` is provide use the default section name.\n        option: str\n            Option name for `section`.\n        default:\n            Default value (if not specified, an exception will be raised if\n            option doesn't exist).\n        \"\"\"\nsection = self._check_section_option(section, option)\nif not self.has_section(section):\n    if default is NoDefault:\n        raise cp.NoSectionError(section)\n    else:\n        self.add_section(section)\nif not self.has_option(section, option):\n    if default is NoDefault:\n        raise cp.NoOptionError(option, section)\n    else:\n        self.set(section, option, default)\n        return default\nvalue = super(UserConfig, self).get(section, option, raw=self._raw)\ndefault_value = self.get_default(section, option)\nif isinstance(default_value, bool):\n    value = ast.literal_eval(value)\nelif isinstance(default_value, float):\n    value = float(value)\nelif isinstance(default_value, int):\n    value = int(value)\nelif is_text_string(default_value):\n    if PY2:\n        try:\n            value = value.decode('utf-8')\n            try:\n                new_value = ast.literal_eval(value)\n                if is_text_string(new_value):\n                    value = new_value\n            except (SyntaxError, ValueError):\n                pass\n        except (UnicodeEncodeError, UnicodeDecodeError):\n            pass\nelse:\n    try:\n        value = ast.literal_eval(value)\n    except (SyntaxError, ValueError):\n        pass\nreturn value\n"
    },
    {
        "functionName": "test_userconfig_get_does_not_eval_functions",
        "className": "TestUserConfigGet",
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "userconfig.set('section', 'option', 'print(\"foo\")')\nassert userconfig.get('section', 'option') == 'print(\"foo\")'\n",
        "CUT_1": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_2": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_3": "\"\"\"\n        Get an `option` on a given `section`.\n\n        If section is None, the `option` is requested from default section.\n        \"\"\"\nconfig = self.get_active_conf(section)\nreturn config.get(section=section, option=option, default=default)\n",
        "CUT_4": "\"\"\"\n        Get an `option` on a given `section`.\n\n        If section is None, the `option` is requested from default section.\n        \"\"\"\nconfig = self.get_active_conf(section)\nreturn config.get(section=section, option=option, default=default)\n",
        "CUT_5": "\"\"\"\n        Set an `option` on a given `section`.\n\n        If section is None, the `option` is added to the default section.\n        \"\"\"\nconfig = self._get_config(section, option)\nconfig.set(section=section, option=option, value=value, verbose=verbose,\n    save=save)\n"
    },
    {
        "functionName": "test_userconfig_set_default",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "value = userconfig.get_default('section', 'option')\nassert value == NoDefault\ndefault_value = 'foobar'\nvalue = userconfig.set_default('section', 'option', default_value)\nvalue = userconfig.get_default('section', 'option')\nassert value == NoDefault\nuserconfig.set_as_defaults()\nvalue = userconfig.get_default('section', 'option')\nexpected = \"'value'\" if PY2 else 'value'\nassert value == expected\nvalue = userconfig.set_default('section', 'option', default_value)\nvalue = userconfig.get_default('section', 'option')\nassert value == default_value\n",
        "CUT_1": "\"\"\"\n        Set an `option` on a given `section`.\n\n        If section is None, the `option` is added to the default section.\n        \"\"\"\nsection = self._check_section_option(section, option)\ndefault_value = self.get_default(section, option)\nif default_value is NoDefault:\n    if PY2 and is_text_string(value):\n        value = repr(value)\n    default_value = value\n    self.set_default(section, option, default_value)\nif isinstance(default_value, bool):\n    value = bool(value)\nelif isinstance(default_value, float):\n    value = float(value)\nelif isinstance(default_value, int):\n    value = int(value)\nelif not is_text_string(default_value):\n    value = repr(value)\nself._set(section, option, value, verbose)\nif save:\n    self._save()\n",
        "CUT_2": "\"\"\"\n        Set an `option` on a given `section`.\n\n        If section is None, the `option` is added to the default section.\n        \"\"\"\nsection = self._check_section_option(section, option)\ndefault_value = self.get_default(section, option)\nif default_value is NoDefault:\n    if PY2 and is_text_string(value):\n        value = repr(value)\n    default_value = value\n    self.set_default(section, option, default_value)\nif isinstance(default_value, bool):\n    value = bool(value)\nelif isinstance(default_value, float):\n    value = float(value)\nelif isinstance(default_value, int):\n    value = int(value)\nelif not is_text_string(default_value):\n    value = repr(value)\nself._set(section, option, value, verbose)\nif save:\n    self._save()\n",
        "CUT_3": "\"\"\"\n        Get an option.\n\n        Parameters\n        ----------\n        section: str\n            Section name. If `None` is provide use the default section name.\n        option: str\n            Option name for `section`.\n        default:\n            Default value (if not specified, an exception will be raised if\n            option doesn't exist).\n        \"\"\"\nsection = self._check_section_option(section, option)\nif not self.has_section(section):\n    if default is NoDefault:\n        raise cp.NoSectionError(section)\n    else:\n        self.add_section(section)\nif not self.has_option(section, option):\n    if default is NoDefault:\n        raise cp.NoOptionError(option, section)\n    else:\n        self.set(section, option, default)\n        return default\nvalue = super(UserConfig, self).get(section, option, raw=self._raw)\ndefault_value = self.get_default(section, option)\nif isinstance(default_value, bool):\n    value = ast.literal_eval(value)\nelif isinstance(default_value, float):\n    value = float(value)\nelif isinstance(default_value, int):\n    value = int(value)\nelif is_text_string(default_value):\n    if PY2:\n        try:\n            value = value.decode('utf-8')\n            try:\n                new_value = ast.literal_eval(value)\n                if is_text_string(new_value):\n                    value = new_value\n            except (SyntaxError, ValueError):\n                pass\n        except (UnicodeEncodeError, UnicodeDecodeError):\n            pass\nelse:\n    try:\n        value = ast.literal_eval(value)\n    except (SyntaxError, ValueError):\n        pass\nreturn value\n",
        "CUT_4": "\"\"\"\n        Get an option.\n\n        Parameters\n        ----------\n        section: str\n            Section name. If `None` is provide use the default section name.\n        option: str\n            Option name for `section`.\n        default:\n            Default value (if not specified, an exception will be raised if\n            option doesn't exist).\n        \"\"\"\nsection = self._check_section_option(section, option)\nif not self.has_section(section):\n    if default is NoDefault:\n        raise cp.NoSectionError(section)\n    else:\n        self.add_section(section)\nif not self.has_option(section, option):\n    if default is NoDefault:\n        raise cp.NoOptionError(option, section)\n    else:\n        self.set(section, option, default)\n        return default\nvalue = super(UserConfig, self).get(section, option, raw=self._raw)\ndefault_value = self.get_default(section, option)\nif isinstance(default_value, bool):\n    value = ast.literal_eval(value)\nelif isinstance(default_value, float):\n    value = float(value)\nelif isinstance(default_value, int):\n    value = int(value)\nelif is_text_string(default_value):\n    if PY2:\n        try:\n            value = value.decode('utf-8')\n            try:\n                new_value = ast.literal_eval(value)\n                if is_text_string(new_value):\n                    value = new_value\n            except (SyntaxError, ValueError):\n                pass\n        except (UnicodeEncodeError, UnicodeDecodeError):\n            pass\nelse:\n    try:\n        value = ast.literal_eval(value)\n    except (SyntaxError, ValueError):\n        pass\nreturn value\n",
        "CUT_5": "\"\"\"Convert back to value\"\"\"\nfrom qtpy.compat import from_qvariant\nvalue = from_qvariant(value, to_text_string)\ntry:\n    np_dtype = get_numpy_dtype(default_value)\n    if isinstance(default_value, bool):\n        try:\n            value = bool(float(value))\n        except ValueError:\n            value = value.lower() == 'true'\n    elif np_dtype is not None:\n        if 'complex' in str(type(default_value)):\n            value = np_dtype(complex(value))\n        else:\n            value = np_dtype(value)\n    elif is_binary_string(default_value):\n        value = to_binary_string(value, 'utf8')\n    elif is_text_string(default_value):\n        value = to_text_string(value)\n    elif isinstance(default_value, complex):\n        value = complex(value)\n    elif isinstance(default_value, float):\n        value = float(value)\n    elif isinstance(default_value, int):\n        try:\n            value = int(value)\n        except ValueError:\n            value = float(value)\n    elif isinstance(default_value, datetime.datetime):\n        value = datestr_to_datetime(value)\n    elif isinstance(default_value, datetime.date):\n        value = datestr_to_datetime(value).date()\n    elif isinstance(default_value, datetime.timedelta):\n        value = str_to_timedelta(value)\n    elif ignore_errors:\n        value = try_to_eval(value)\n    else:\n        value = eval(value)\nexcept (ValueError, SyntaxError):\n    if ignore_errors:\n        value = try_to_eval(value)\n    else:\n        return default_value\nreturn value\n"
    },
    {
        "functionName": "test_userconfig_set_valid",
        "className": "TestUserConfigSet",
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "name = 'foobar'\npath = str(tmpdir)\nconf = UserConfig(name=name, path=path, defaults=defaults, load=False,\n    version='1.0.0', backup=False, raw_mode=True)\nconf.set('test', 'opt', value)\npytest.mark.parametrize('defaults,value', [([('test', {'opt': 'value'})],\n    'other'), ([('test', {'opt': '\u00e9\u00e0\u00c7\u00c3\u00e3\u00e9\u00e8\u00ef'})], '\u00e3\u00e9\u00e8\u00ef'), ([('test', {'opt':\n    True})], False), ([('test', {'opt': UserConfig})], dict), ([('test', {\n    'opt': 123})], 345), ([('test', {'opt': 123.123})], 345.345), ([('test',\n    {'opt': [1]})], [1]), ([('test', {'opt': {'key': 'val'}})], {'key2':\n    'val2'}), ([('test', {'opt1': 'value'})], 'other')])",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_4": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n"
    },
    {
        "functionName": "test_userconfig_set_invalid",
        "className": "TestUserConfigSet",
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "name = 'foobar'\npath = str(tmpdir)\nconf = UserConfig(name=name, path=path, defaults=defaults, load=False,\n    version='1.0.0', backup=False, raw_mode=True)\nwith pytest.raises(ValueError):\n    conf.set('test', 'opt', value)\npytest.mark.parametrize('defaults,value', [([('test', {'opt': 123})], 'no'),\n    ([('test', {'opt': 123.123})], 'n9'), ([('test', {'opt': 123.123})], 'n9')]\n    )",
        "CUT_1": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_2": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_3": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n",
        "CUT_4": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n",
        "CUT_5": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n"
    },
    {
        "functionName": "test_userconfig_set_with_string",
        "className": "TestUserConfigSet",
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "userconfig.set('section', 'option', 'new value')\nwith open(userconfig.get_config_fpath()) as inifile:\n    ini_contents = inifile.read()\nexpected = \"\"\"[main]\nversion = 1.0.0\n\n\"\"\"\nif PY2:\n    expected += \"[section]\\noption = 'new value'\\n\\n\"\nelse:\n    expected += '[section]\\noption = new value\\n\\n'\nassert ini_contents == expected\n",
        "CUT_1": "ini_contents = \"\"\"[main]\nversion = 1.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\\n\\n\"\nelse:\n    ini_contents += '[section]\\noption = value\\n\\n'\nname = 'spyder-test'\npath = str(tmpdir)\ndefault_kwargs = {'name': name, 'path': path, 'defaults': {}, 'load': True,\n    'version': '1.0.0', 'backup': False, 'raw_mode': True,\n    'remove_obsolete': False}\nparam = getattr(request, 'param', None)\nif param:\n    modified_kwargs = request.param[0]\n    kwargs = default_kwargs.copy().update(modified_kwargs)\nelse:\n    kwargs = default_kwargs\ninifile = tmpdir.join('{}.ini'.format(name))\ninifile.write(ini_contents)\nreturn UserConfig(**kwargs)\npytest.fixture",
        "CUT_2": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_3": "section = self.CONF_SECTION if section is None else section\nCONF.set(section, option, value)\n",
        "CUT_4": "section = self.CONF_SECTION if section is None else section\nCONF.set(section, option, value)\n",
        "CUT_5": "\"\"\"Set method.\"\"\"\nif not self.has_section(section):\n    self.add_section(section)\nif not is_text_string(value):\n    value = repr(value)\nif verbose:\n    text = '[{}][{}] = {}'.format(section, option, value)\n    print(text)\nsuper(DefaultsConfig, self).set(section, option, value)\n"
    },
    {
        "functionName": "test_userconfig_set_percentage_string",
        "className": "TestUserConfigSet",
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test to set an option with a '%'.\"\"\"\nuserconfig.set('section', 'option', '%value')\nassert userconfig.get('section', 'option') == '%value'\n",
        "CUT_1": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n",
        "CUT_2": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n",
        "CUT_3": "\"\"\"\n        Set an `option` on a given `section`.\n\n        If section is None, the `option` is added to the default section.\n        \"\"\"\nconfig = self._get_config(section, option)\nconfig.set(section=section, option=option, value=value, verbose=verbose,\n    save=save)\n",
        "CUT_4": "\"\"\"\n        Set an `option` on a given `section`.\n\n        If section is None, the `option` is added to the default section.\n        \"\"\"\nconfig = self._get_config(section, option)\nconfig.set(section=section, option=option, value=value, verbose=verbose,\n    save=save)\n",
        "CUT_5": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n"
    },
    {
        "functionName": "test_userconfig_remove_section",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert 'section' in userconfig.sections()\nuserconfig.remove_section('section')\nassert 'section' not in userconfig.sections()\n",
        "CUT_1": "\"\"\"Remove `section` and all options within it.\"\"\"\nsuper(UserConfig, self).remove_section(section)\nself._save()\n",
        "CUT_2": "\"\"\"Remove `section` and all options within it.\"\"\"\nsuper(UserConfig, self).remove_section(section)\nself._save()\n",
        "CUT_3": "\"\"\"Return all sections of the configuration file.\"\"\"\nsections = set()\nfor _, config in self._configs_map.items():\n    for section in config.sections():\n        sections.add(section)\nreturn list(sorted(sections))\n",
        "CUT_4": "\"\"\"Return all sections of the configuration file.\"\"\"\nsections = set()\nfor _, config in self._configs_map.items():\n    for section in config.sections():\n        sections.add(section)\nreturn list(sorted(sections))\n",
        "CUT_5": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n"
    },
    {
        "functionName": "test_userconfig_remove_option",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert userconfig.get('section', 'option') == 'value'\nuserconfig.remove_option('section', 'option')\nwith pytest.raises(cp.NoOptionError):\n    userconfig.get('section', 'option')\n",
        "CUT_1": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_2": "\"\"\"Remove `option` from `section`.\"\"\"\nsuper(UserConfig, self).remove_option(section, option)\nself._save()\n",
        "CUT_3": "\"\"\"Remove `option` from `section`.\"\"\"\nconfig = self._get_config(section, option)\nconfig.remove_option(section, option)\n",
        "CUT_4": "\"\"\"Remove `option` from `section`.\"\"\"\nconfig = self._get_config(section, option)\nconfig.remove_option(section, option)\n",
        "CUT_5": "\"\"\"\n        Get an `option` on a given `section`.\n\n        If section is None, the `option` is requested from default section.\n        \"\"\"\nconfig = self.get_active_conf(section)\nreturn config.get(section=section, option=option, default=default)\n"
    },
    {
        "functionName": "test_userconfig_cleanup",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpath = userconfig.get_config_fpath()\nassert os.path.isfile(configpath)\nuserconfig.cleanup()\nassert not os.path.isfile(configpath)\n",
        "CUT_1": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_2": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_3": "\"\"\"Return the UserConfig class to use.\"\"\"\nreturn SpyderUserConfig\n",
        "CUT_4": "\"\"\"Return the UserConfig class to use.\"\"\"\nreturn SpyderUserConfig\n",
        "CUT_5": "\"\"\"\n    Return absolute path if Python script exists (otherwise, return None)\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\ntry:\n    if package is None:\n        path = imp.find_module(module)[1]\n    else:\n        path = osp.join(imp.find_module(package)[1], module) + '.py'\nexcept ImportError:\n    return\nif not osp.isfile(path):\n    path += 'w'\nif osp.isfile(path):\n    return path\n"
    },
    {
        "functionName": "test_spyderconfig_apply_configuration_patches_42",
        "className": "TestSpyderConfigApplyPatches",
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "value = spyderconfig_patches_42.get('ipython_console', 'startup/run_lines')\nexpected_value = 'value1; value2'\nassert value == expected_value\n",
        "CUT_1": "\"\"\"\n        Override method.\n\n        Apply any patch to configuration values on version changes.\n        \"\"\"\nself._update_defaults(self.defaults, old_version)\nif self._external_plugin:\n    return\nif old_version and check_version(old_version, '44.1.0', '<'):\n    run_lines = to_text_string(self.get('ipython_console', 'startup/run_lines')\n        )\n    if run_lines is not NoDefault:\n        run_lines = run_lines.replace(',', '; ')\n        self.set('ipython_console', 'startup/run_lines', run_lines)\n",
        "CUT_2": "\"\"\"\n        Override method.\n\n        Apply any patch to configuration values on version changes.\n        \"\"\"\nself._update_defaults(self.defaults, old_version)\nif self._external_plugin:\n    return\nif old_version and check_version(old_version, '44.1.0', '<'):\n    run_lines = to_text_string(self.get('ipython_console', 'startup/run_lines')\n        )\n    if run_lines is not NoDefault:\n        run_lines = run_lines.replace(',', '; ')\n        self.set('ipython_console', 'startup/run_lines', run_lines)\n",
        "CUT_3": "ini_contents = \"\"\"[main]\nversion = 45.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[ipython_console]\\nstartup/run_lines = 'value1,value2'\"\nelse:\n    ini_contents += '[ipython_console]\\nstartup/run_lines = value1,value2'\nname = 'spyder'\ninifile = tmpdir.join('{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=str(tmpdir), defaults={}, load=True,\n    version='46.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_4": "ini_contents = \"\"\"[main]\nversion = 42.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[ipython_console]\\nstartup/run_lines = 'value1,value2'\"\nelse:\n    ini_contents += '[ipython_console]\\nstartup/run_lines = value1,value2'\nname = 'spyder'\ninifile = tmpdir.join('{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=str(tmpdir), defaults={}, load=True,\n    version='43.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_5": "self.value = value\n"
    },
    {
        "functionName": "test_spyderconfig_apply_configuration_patches_45",
        "className": "TestSpyderConfigApplyPatches",
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "value = spyderconfig_patches_45.get('ipython_console', 'startup/run_lines')\nexpected_value = 'value1,value2'\nassert value == expected_value\n",
        "CUT_1": "\"\"\"\n        Override method.\n\n        Apply any patch to configuration values on version changes.\n        \"\"\"\nself._update_defaults(self.defaults, old_version)\nif self._external_plugin:\n    return\nif old_version and check_version(old_version, '44.1.0', '<'):\n    run_lines = to_text_string(self.get('ipython_console', 'startup/run_lines')\n        )\n    if run_lines is not NoDefault:\n        run_lines = run_lines.replace(',', '; ')\n        self.set('ipython_console', 'startup/run_lines', run_lines)\n",
        "CUT_2": "\"\"\"\n        Override method.\n\n        Apply any patch to configuration values on version changes.\n        \"\"\"\nself._update_defaults(self.defaults, old_version)\nif self._external_plugin:\n    return\nif old_version and check_version(old_version, '44.1.0', '<'):\n    run_lines = to_text_string(self.get('ipython_console', 'startup/run_lines')\n        )\n    if run_lines is not NoDefault:\n        run_lines = run_lines.replace(',', '; ')\n        self.set('ipython_console', 'startup/run_lines', run_lines)\n",
        "CUT_3": "ini_contents = \"\"\"[main]\nversion = 45.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[ipython_console]\\nstartup/run_lines = 'value1,value2'\"\nelse:\n    ini_contents += '[ipython_console]\\nstartup/run_lines = value1,value2'\nname = 'spyder'\ninifile = tmpdir.join('{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=str(tmpdir), defaults={}, load=True,\n    version='46.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_4": "ini_contents = \"\"\"[main]\nversion = 42.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[ipython_console]\\nstartup/run_lines = 'value1,value2'\"\nelse:\n    ini_contents += '[ipython_console]\\nstartup/run_lines = value1,value2'\nname = 'spyder'\ninifile = tmpdir.join('{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=str(tmpdir), defaults={}, load=True,\n    version='43.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_5": "self.value = value\n"
    },
    {
        "functionName": "test_spyderconfig_get_defaults_path_name_from_version",
        "className": null,
        "fileName": "/spyder/config/tests/test_user.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "func = spyderconfig.get_defaults_path_name_from_version\n_, name = func('50.0.0')\nassert name == 'defaults-50.0.0'\npath, name = func('51.0.0')\nassert name == 'defaults-spyder-test-51.0.0'\nassert path.endswith('defaults')\npath, name = func('53.0.0')\nassert name == 'defaults-spyder-test-53.0.0'\nassert path.endswith('defaults')\n",
        "CUT_1": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n",
        "CUT_2": "\"\"\"Check if defaults are valid and update defaults values.\"\"\"\nif defaults is None:\n    defaults = [(self.DEFAULT_SECTION_NAME, {})]\nelif isinstance(defaults, dict):\n    defaults = [(self.DEFAULT_SECTION_NAME, defaults)]\nelif isinstance(defaults, list):\n    for sec, options in defaults:\n        assert is_text_string(sec)\n        assert isinstance(options, dict)\n        for opt, _ in options.items():\n            assert is_text_string(opt)\nelse:\n    raise ValueError('`defaults` must be a dict or a list of tuples!')\nself.defaults = defaults\nif defaults is not None:\n    self.reset_to_defaults(save=False)\nreturn defaults\n",
        "CUT_3": "\"\"\" \"\"\"\nfor func in funcs:\n    func()\n",
        "CUT_4": "\"\"\" \"\"\"\nfor func in funcs:\n    func()\n",
        "CUT_5": "self.name = name\n"
    },
    {
        "functionName": "clear_site_config",
        "className": null,
        "fileName": "/spyder/config/tests/test_manager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Delete all test site config folders.\"\"\"\nfor path in get_conf_paths():\n    shutil.rmtree(path)\n",
        "CUT_1": "\"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\nshutil.rmtree(path)\n",
        "CUT_2": "\"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\nshutil.rmtree(path)\n",
        "CUT_3": "return path\n",
        "CUT_4": "shutil.rmtree(pyls_installation_dir, ignore_errors=True)\nshutil.rmtree(pyls_installation_egg, ignore_errors=True)\n",
        "CUT_5": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n"
    },
    {
        "functionName": "test_site_config_load",
        "className": null,
        "fileName": "/spyder/config/tests/test_manager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the site/system config preferences are loaded with correct\n    precedence.\n    \"\"\"\nclear_site_config()\nfor i, path in enumerate(reversed(get_conf_paths())):\n    exp_value = 100 * (1 + i)\n    content = '[main]\\nmemory_usage/timeout = ' + str(exp_value) + '\\n'\n    conf_fpath = os.path.join(path, 'spyder.ini')\n    with open(conf_fpath, 'w') as fh:\n        fh.write(content)\n    config = ConfigurationManager()\n    config.reset_to_defaults()\n    value = config.get('main', 'memory_usage/timeout')\n    print(path, value, exp_value)\n    assert value == exp_value\nclear_site_config()\n",
        "CUT_1": "config = configparser.RawConfigParser()\nfor filename in files:\n    if os.path.exists(filename) and not os.path.isdir(filename):\n        config.read(filename)\nreturn config\nstaticmethod",
        "CUT_2": "\"\"\"Reset config to Default values.\"\"\"\nconfig = self.get_active_conf(section)\nconfig.reset_to_defaults(section=section)\n",
        "CUT_3": "\"\"\"Reset config to Default values.\"\"\"\nconfig = self.get_active_conf(section)\nconfig.reset_to_defaults(section=section)\n",
        "CUT_4": "\"\"\"Return the project configuration path.\"\"\"\npath = osp.join(project_root, '.spyproj', 'config')\nif not osp.isdir(path):\n    os.makedirs(path)\n",
        "CUT_5": "\"\"\"Return the project configuration path.\"\"\"\npath = osp.join(project_root, '.spyproj', 'config')\nif not osp.isdir(path):\n    os.makedirs(path)\n"
    },
    {
        "functionName": "test_external_plugin_config",
        "className": null,
        "fileName": "/spyder/config/tests/test_manager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that config for external plugins is saved as expected.\n\n    This includes a regression for part two (the shortcuts conflict) of\n    issue spyder-ide/spyder#11132\n    \"\"\"\nclear_site_config()\nspy3_config = \"\"\"\n[main]\nversion = 1.0.0\n\n[shortcuts]\nfoo/bar = Alt+1\n\n[ipython_console]\nstartup/run_lines =\n\"\"\"\nconf_fpath = get_conf_path('spyder.ini')\nwith open(conf_fpath, 'w') as f:\n    f.write(spy3_config)\nmanager = ConfigurationManager()\nConsole.CONF_FILE = True\ndefaults = [('internal_console', {'max_line_count': 300,\n    'working_dir_history': 30, 'working_dir_adjusttocontents': False,\n    'wrap': True, 'codecompletion/auto': False, 'external_editor/path':\n    'SciTE', 'external_editor/gotoline': '-goto:'})]\nConsole.CONF_DEFAULTS = defaults\nmanager.register_plugin(Console)\nwith pytest.raises(configparser.NoSectionError):\n    manager.get_shortcut('foo', 'bar', plugin_name='internal_console')\nconsole = Console(None, configuration=manager)\nconsole.set_conf_option('max_line_count', 600)\nuser_path = manager.get_user_config_path()\nwith open(osp.join(user_path, 'spyder.ini'), 'r') as f:\n    user_contents = f.read()\nplugin_path = manager.get_plugin_config_path('internal_console')\nwith open(osp.join(plugin_path, 'spyder.ini'), 'r') as f:\n    plugin_contents = f.read()\nassert 'max_line_count = 600' not in user_contents\nassert 'max_line_count = 600' in plugin_contents\nshutil.rmtree(plugin_path)\nConsole.CONF_FILE = False\nclear_site_config()\n",
        "CUT_1": "\"\"\"\n        Set the internal console shell.\n\n        Parameters\n        ----------\n        console: :py:class:spyder.plugins.console.plugin.Console\n            Console plugin.\n        \"\"\"\nself.internal_console = console\nself.internal_shell = console.get_widget().shell\n",
        "CUT_2": "\"\"\"\n        Set the internal console shell.\n\n        Parameters\n        ----------\n        console: :py:class:spyder.plugins.console.plugin.Console\n            Console plugin.\n        \"\"\"\nself.internal_console = console\nself.internal_shell = console.get_widget().shell\n",
        "CUT_3": "return _('Internal console running Spyder.')\n",
        "CUT_4": "return _('Internal console running Spyder.')\n",
        "CUT_5": "\"\"\"\n        Execute lines in IPython console and eventually set focus\n        to the Editor.\n        \"\"\"\nconsole = self.ipyconsole\nconsole.switch_to_plugin()\nconsole.execute_code(lines)\nif focus_to_editor:\n    self.editor.switch_to_plugin()\n"
    },
    {
        "functionName": "test_is_stable_version",
        "className": null,
        "fileName": "/spyder/config/tests/test_base.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that stable and non-stable versions are recognized correctly.\"\"\"\nfor stable_version in ['3.3.0', '2', ('0', '5')]:\n    assert spyder.config.base.is_stable_version(stable_version)\nfor not_stable_version in ['4.0.0b1', '3.3.2.dev0', 'beta', ('2', '0', 'alpha')\n    ]:\n    assert not spyder.config.base.is_stable_version(not_stable_version)\n",
        "CUT_1": "\"\"\"\n    Return true if version is stable, i.e. with letters in the final component.\n\n    Stable version examples: ``1.2``, ``1.3.4``, ``1.0.5``.\n    Non-stable version examples: ``1.3.4beta``, ``0.1.0rc1``, ``3.0.0dev0``.\n    \"\"\"\nif not isinstance(version, tuple):\n    version = version.split('.')\nlast_part = version[-1]\nif not re.search('[a-zA-Z]', last_part):\n    return True\nelse:\n    return False\n",
        "CUT_2": "\"\"\"\n    Return true if version is stable, i.e. with letters in the final component.\n\n    Stable version examples: ``1.2``, ``1.3.4``, ``1.0.5``.\n    Non-stable version examples: ``1.3.4beta``, ``0.1.0rc1``, ``3.0.0dev0``.\n    \"\"\"\nif not isinstance(version, tuple):\n    version = version.split('.')\nlast_part = version[-1]\nif not re.search('[a-zA-Z]', last_part):\n    return True\nelse:\n    return False\n",
        "CUT_3": "\"\"\"Return True if object is defined in namespace\n    If namespace is None --> namespace = locals()\"\"\"\nif namespace is None:\n    namespace = locals()\nattr_list = obj.split('.')\nbase = attr_list.pop(0)\nif len(base) == 0:\n    return False\nif base not in builtins.__dict__ and base not in namespace:\n    if force_import:\n        try:\n            module = __import__(base, globals(), namespace)\n            if base not in globals():\n                globals()[base] = module\n            namespace[base] = module\n        except Exception:\n            return False\n    else:\n        return False\nfor attr in attr_list:\n    try:\n        attr_not_found = not hasattr(eval(base, namespace), attr)\n    except (SyntaxError, AttributeError):\n        return False\n    if attr_not_found:\n        if force_import:\n            try:\n                __import__(base + '.' + attr, globals(), namespace)\n            except (ImportError, SyntaxError):\n                return False\n        else:\n            return False\n    base += '.' + attr\nreturn True\n",
        "CUT_4": "from spyder.config.base import get_module_source_path\nfname = get_module_source_path('spyder', 'default_config.py')\nreturn open(fname, 'rb').read()\n",
        "CUT_5": "from spyder.config.base import get_module_source_path\nfname = get_module_source_path('spyder', 'default_config.py')\nreturn open(fname, 'rb').read()\n"
    },
    {
        "functionName": "test_get_conf_path",
        "className": null,
        "fileName": "/spyder/config/tests/test_base.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the config dir path is set under dev and release builds.\"\"\"\nmonkeypatch.setenv('SPYDER_USE_DEV_CONFIG_DIR', str(use_dev_config_dir))\nmonkeypatch.setenv('SPYDER_PYTEST', '')\nreload(spyder.config.base)\nconf_path = spyder.config.base.get_conf_path()\nassert conf_path\nassert (osp.basename(conf_path).split('-')[-1] == 'dev') == use_dev_config_dir\nassert osp.isdir(conf_path)\nmonkeypatch.undo()\nreload(spyder.config.base)\npytest.mark.parametrize('use_dev_config_dir', [True, False])",
        "CUT_1": "\"\"\"Return whether the dev configuration directory should used.\"\"\"\nif use_dev_config_dir is not None:\n    if use_dev_config_dir.lower() in {'false', '0'}:\n        use_dev_config_dir = False\nelse:\n    use_dev_config_dir = DEV or not is_stable_version(__version__)\nreturn use_dev_config_dir\n",
        "CUT_2": "\"\"\"Return whether the dev configuration directory should used.\"\"\"\nif use_dev_config_dir is not None:\n    if use_dev_config_dir.lower() in {'false', '0'}:\n        use_dev_config_dir = False\nelse:\n    use_dev_config_dir = DEV or not is_stable_version(__version__)\nreturn use_dev_config_dir\n",
        "CUT_3": "\"\"\"\n        Configuration manager to provide access to user/site/project config.\n        \"\"\"\npath = self.get_user_config_path()\nif not osp.isdir(path):\n    os.makedirs(path)\nconf_paths = get_conf_paths()\nsite_defaults = DEFAULTS\nfor conf_path in reversed(conf_paths):\n    conf_fpath = os.path.join(conf_path, 'spyder.ini')\n    if os.path.isfile(conf_fpath):\n        site_config = UserConfig('spyder', path=conf_path, defaults=\n            site_defaults, load=False, version=CONF_VERSION, backup=False,\n            raw_mode=True, remove_obsolete=False)\n        site_defaults = site_config.to_list()\nself._parent = parent\nself._active_project_callback = active_project_callback\nself._user_config = MultiUserConfig(NAME_MAP, path=path, defaults=\n    site_defaults, load=True, version=CONF_VERSION, backup=True, raw_mode=\n    True, remove_obsolete=False)\nself._plugin_configs = {}\nself._project_configs = {}\nself.remove_deprecated_config_locations()\n",
        "CUT_4": "\"\"\"\n        Configuration manager to provide access to user/site/project config.\n        \"\"\"\npath = self.get_user_config_path()\nif not osp.isdir(path):\n    os.makedirs(path)\nconf_paths = get_conf_paths()\nsite_defaults = DEFAULTS\nfor conf_path in reversed(conf_paths):\n    conf_fpath = os.path.join(conf_path, 'spyder.ini')\n    if os.path.isfile(conf_fpath):\n        site_config = UserConfig('spyder', path=conf_path, defaults=\n            site_defaults, load=False, version=CONF_VERSION, backup=False,\n            raw_mode=True, remove_obsolete=False)\n        site_defaults = site_config.to_list()\nself._parent = parent\nself._active_project_callback = active_project_callback\nself._user_config = MultiUserConfig(NAME_MAP, path=path, defaults=\n    site_defaults, load=True, version=CONF_VERSION, backup=True, raw_mode=\n    True, remove_obsolete=False)\nself._plugin_configs = {}\nself._project_configs = {}\nself.remove_deprecated_config_locations()\n",
        "CUT_5": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture"
    },
    {
        "functionName": "findinfiles",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up SearchInComboBox combobox.\"\"\"\nfindinfiles_plugin = FindInFiles(None, configuration=CONF)\nfindinfiles_plugin.close = lambda : True\nqtbot.addWidget(findinfiles_plugin)\nreturn findinfiles_plugin\npytest.fixture",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_4": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture",
        "CUT_5": "\"\"\"choices: couples (name, key)\"\"\"\nlabel = QLabel(text)\ncombobox = QComboBox()\nif tip is not None:\n    combobox.setToolTip(tip)\nfor name, key in choices:\n    if not (name is None and key is None):\n        combobox.addItem(name, to_qvariant(key))\ncount = 0\nfor index, item in enumerate(choices):\n    name, key = item\n    if name is None and key is None:\n        combobox.insertSeparator(index + count)\n        count += 1\nself.comboboxes[combobox] = section, option, default\nlayout = QHBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(combobox)\nlayout.addStretch(1)\nlayout.setContentsMargins(0, 0, 0, 0)\nwidget = QWidget(self)\nwidget.label = label\nwidget.combobox = combobox\nwidget.setLayout(layout)\ncombobox.restart_required = restart\ncombobox.label_text = text\nreturn widget\n"
    },
    {
        "functionName": "test_closing_plugin",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the external paths listed in the combobox are saved and loaded\n    correctly from the spyder config file.\n    \"\"\"\npath_selection_combo = findinfiles.get_widget().path_selection_combo\npath_selection_combo.clear_external_paths()\nassert path_selection_combo.get_external_paths() == []\nexpected_results = [LOCATION, osp.dirname(LOCATION), osp.dirname(osp.\n    dirname(LOCATION)), NONASCII_DIR]\nfor external_path in expected_results:\n    mocker.patch('spyder.plugins.findinfiles.widgets.getexistingdirectory',\n        return_value=external_path)\n    path_selection_combo.setCurrentIndex(SELECT_OTHER)\nassert path_selection_combo.get_external_paths() == expected_results\nfindinfiles.on_close()\npath_history = findinfiles.get_widget().get_option('path_history')\nassert path_history == expected_results\npath_selection_combo = findinfiles.get_widget().path_selection_combo\nassert path_selection_combo.get_external_paths() == expected_results\npytest.mark.first",
        "CUT_1": "\"\"\"Return the current path.\"\"\"\nreturn self.path_selection_combo.path\nproperty",
        "CUT_2": "\"\"\"Return the current path.\"\"\"\nreturn self.path_selection_combo.path\nproperty",
        "CUT_3": "\"\"\"Return the current file path.\"\"\"\nreturn self.path_selection_combo.file_path\nproperty",
        "CUT_4": "\"\"\"Return the current file path.\"\"\"\nreturn self.path_selection_combo.file_path\nproperty",
        "CUT_5": "\"\"\"Return the current project path.\"\"\"\nreturn self.path_selection_combo.project_path\nproperty"
    },
    {
        "functionName": "process_search_results",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Transform result representation from the output of the widget to the\n    test framework comparison representation.\n    \"\"\"\nmatches = {}\nfor result in results.values():\n    file, line, col = result\n    filename = osp.basename(file)\n    if filename not in matches:\n        matches[filename] = []\n    matches[filename].append((line, col))\n    matches[filename] = sorted(matches[filename])\nreturn matches\n",
        "CUT_1": "patterns = [pattern.format(token, '[^0-9a-zA-Z.[]') for pattern in patterns]\npattern = re.compile('|^'.join(patterns))\nlines = [(line.strip() + ' ') for line in source.splitlines()]\nif start_line == -1:\n    start_line = len(lines)\nmatches = []\nfor index, line in enumerate(lines):\n    if re.match(pattern, line):\n        matches.append(index + 1)\nreturn matches\n",
        "CUT_2": "patterns = [pattern.format(token, '[^0-9a-zA-Z.[]') for pattern in patterns]\npattern = re.compile('|^'.join(patterns))\nlines = [(line.strip() + ' ') for line in source.splitlines()]\nif start_line == -1:\n    start_line = len(lines)\nmatches = []\nfor index, line in enumerate(lines):\n    if re.match(pattern, line):\n        matches.append(index + 1)\nreturn matches\n",
        "CUT_3": "\"\"\"\n    Find the definition of an object within a source closest to a given line\n    \"\"\"\nif not token:\n    return None\nif DEBUG_EDITOR:\n    t0 = time.time()\npatterns = ['^c?import.*\\\\W{0}{1}', 'from.*\\\\W{0}\\\\W.*c?import ',\n    'from .* c?import.*\\\\W{0}{1}', 'class\\\\s*{0}{1}',\n    'c?p?def[^=]*\\\\W{0}{1}', 'cdef.*\\\\[.*\\\\].*\\\\W{0}{1}',\n    'enamldef.*\\\\W{0}{1}', 'attr.*\\\\W{0}{1}', 'event.*\\\\W{0}{1}',\n    'id\\\\s*:.*\\\\W{0}{1}']\nmatches = get_matches(patterns, source, token, start_line)\nif not matches:\n    patterns = ['.*\\\\Wself.{0}{1}[^=!<>]*=[^=]', '.*\\\\W{0}{1}[^=!<>]*=[^=]',\n        'self.{0}{1}[^=!<>]*=[^=]', '{0}{1}[^=!<>]*=[^=]']\n    matches = get_matches(patterns, source, token, start_line)\nif matches:\n    min_dist = len(source.splitlines())\n    best_ind = 0\n    for match in matches:\n        dist = abs(start_line - match)\n        if match <= start_line or not best_ind:\n            if dist < min_dist:\n                min_dist = dist\n                best_ind = match\nif matches:\n    if DEBUG_EDITOR:\n        log_dt(LOG_FILENAME, 'regex definition match', t0)\n    return best_ind\nelse:\n    if DEBUG_EDITOR:\n        log_dt(LOG_FILENAME, 'regex definition failed match', t0)\n    return None\n",
        "CUT_4": "\"\"\"\n    Find the definition of an object within a source closest to a given line\n    \"\"\"\nif not token:\n    return None\nif DEBUG_EDITOR:\n    t0 = time.time()\npatterns = ['^c?import.*\\\\W{0}{1}', 'from.*\\\\W{0}\\\\W.*c?import ',\n    'from .* c?import.*\\\\W{0}{1}', 'class\\\\s*{0}{1}',\n    'c?p?def[^=]*\\\\W{0}{1}', 'cdef.*\\\\[.*\\\\].*\\\\W{0}{1}',\n    'enamldef.*\\\\W{0}{1}', 'attr.*\\\\W{0}{1}', 'event.*\\\\W{0}{1}',\n    'id\\\\s*:.*\\\\W{0}{1}']\nmatches = get_matches(patterns, source, token, start_line)\nif not matches:\n    patterns = ['.*\\\\Wself.{0}{1}[^=!<>]*=[^=]', '.*\\\\W{0}{1}[^=!<>]*=[^=]',\n        'self.{0}{1}[^=!<>]*=[^=]', '{0}{1}[^=!<>]*=[^=]']\n    matches = get_matches(patterns, source, token, start_line)\nif matches:\n    min_dist = len(source.splitlines())\n    best_ind = 0\n    for match in matches:\n        dist = abs(start_line - match)\n        if match <= start_line or not best_ind:\n            if dist < min_dist:\n                min_dist = dist\n                best_ind = match\nif matches:\n    if DEBUG_EDITOR:\n        log_dt(LOG_FILENAME, 'regex definition match', t0)\n    return best_ind\nelse:\n    if DEBUG_EDITOR:\n        log_dt(LOG_FILENAME, 'regex definition failed match', t0)\n    return None\n",
        "CUT_5": "\"\"\"\n        Respond to a complete request if not pdb_use_exclamation_mark.\n        \"\"\"\nif cursor_pos is None:\n    cursor_pos = len(code)\ntext = code[:cursor_pos].split(' ')[-1]\norigline = code\nline = origline.lstrip()\nif not line:\n    return\nstripped = len(origline) - len(line)\nbegidx = cursor_pos - len(text) - stripped\nendidx = cursor_pos - stripped\ncompfunc = None\nipython_do_complete = True\nif begidx > 0:\n    cmd, args, _ = self.parseline(line)\n    if cmd != '':\n        try:\n            compfunc = getattr(self, 'complete_' + cmd)\n            ipython_do_complete = False\n        except AttributeError:\n            pass\nelif line[0] != '!':\n    compfunc = self.completenames\ndef is_name_or_composed(text):\n    if not text or text[0] == '.':\n        return False\n    return isidentifier(text.replace('.', ''))\nwhile text and not is_name_or_composed(text):\n    text = text[1:]\n    begidx += 1\nmatches = []\nif compfunc:\n    matches = compfunc(text, line, begidx, endidx)\ncursor_start = cursor_pos - len(text)\nif ipython_do_complete:\n    kernel = get_ipython().kernel\n    if self.curframe:\n        if self.curframe_locals:\n            Frame = namedtuple('Frame', ['f_locals', 'f_globals'])\n            frame = Frame(self.curframe_locals, self.curframe.f_globals)\n        else:\n            frame = self.curframe\n        kernel.shell.set_completer_frame(frame)\n    result = kernel._do_complete(code, cursor_pos)\n    kernel.shell.set_completer_frame()\n    if not compfunc:\n        return result\n    ipy_matches = result['matches']\n    if cursor_start < result['cursor_start']:\n        missing_txt = code[cursor_start:result['cursor_start']]\n        ipy_matches = [(missing_txt + m) for m in ipy_matches]\n    elif result['cursor_start'] < cursor_start:\n        missing_txt = code[result['cursor_start']:cursor_start]\n        matches = [(missing_txt + m) for m in matches]\n        cursor_start = result['cursor_start']\n    matches += [match for match in ipy_matches if match not in matches]\nreturn {'matches': matches, 'cursor_end': cursor_pos, 'cursor_start':\n    cursor_start, 'metadata': {}, 'status': 'ok'}\n"
    },
    {
        "functionName": "findinfiles",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up find in files widget.\"\"\"\nif getattr(request, 'param', False):\n    param = request.param\nelse:\n    param = None\nif param:\n    options = FindInFilesWidget.DEFAULT_OPTIONS.copy()\n    options.update(param)\n    widget = FindInFilesWidget('find_in_files', options=options)\n    widget._setup(options=options)\n    widget.setup(options=options)\nelse:\n    widget = FindInFilesWidget('find_in_files')\n    widget._setup()\n    widget.setup()\nwidget.resize(640, 480)\nqtbot.addWidget(widget)\nwidget.show()\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Run history widget.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = HistoryWidget.DEFAULT_OPTIONS.copy()\nwidget = HistoryWidget('historylog', None, None, options=options)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "\"\"\"Run history widget.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = HistoryWidget.DEFAULT_OPTIONS.copy()\nwidget = HistoryWidget('historylog', None, None, options=options)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "\"\"\"\n    Run Find in Files widget test.\n    \"\"\"\nfrom os.path import dirname\nimport sys\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\noptions = FindInFilesWidget.DEFAULT_OPTIONS.copy()\nwidget = FindInFilesWidget('find_in_files', options=options)\nwidget._setup(options=options)\nwidget.setup(options=options)\nwidget.resize(640, 480)\nwidget.show()\nexternal_paths = [dirname(__file__), dirname(dirname(__file__)), dirname(\n    dirname(dirname(__file__))), dirname(dirname(dirname(dirname(__file__))))]\nfor path in external_paths:\n    widget.add_external_path(path)\nsys.exit(app.exec_())\n",
        "CUT_4": "\"\"\"\n    Run Find in Files widget test.\n    \"\"\"\nfrom os.path import dirname\nimport sys\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\noptions = FindInFilesWidget.DEFAULT_OPTIONS.copy()\nwidget = FindInFilesWidget('find_in_files', options=options)\nwidget._setup(options=options)\nwidget.setup(options=options)\nwidget.resize(640, 480)\nwidget.show()\nexternal_paths = [dirname(__file__), dirname(dirname(__file__)), dirname(\n    dirname(dirname(__file__))), dirname(dirname(dirname(dirname(__file__))))]\nfor path in external_paths:\n    widget.add_external_path(path)\nsys.exit(app.exec_())\n",
        "CUT_5": "\"\"\"Run web browser.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = PydocBrowser.DEFAULT_OPTIONS.copy()\nwidget = PydocBrowser(None)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "searchin_combobox",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up SearchInComboBox combobox.\"\"\"\nfrom spyder.plugins.findinfiles import widgets\nif getattr(request, 'param', False):\n    param = request.param\nelse:\n    param = None\nif param and param.get('max_history_path'):\n    widgets.MAX_PATH_HISTORY = param.get('max_history_path')\nexternal_path_history = [LOCATION, osp.dirname(LOCATION), osp.dirname(osp.\n    dirname(LOCATION)), osp.dirname(osp.dirname(osp.dirname(LOCATION))),\n    osp.dirname(LOCATION), osp.join(LOCATION, 'path_that_does_not_exist')]\nsearchin_combobox = SearchInComboBox(external_path_history)\nqtbot.addWidget(searchin_combobox)\nreturn searchin_combobox\npytest.fixture",
        "CUT_1": "\"\"\"\n        Get filename to redirect server or transport logs to in\n        debugging mode.\n\n        Parameters\n        ----------\n        kind: str\n            It can be \"server\" or \"transport\".\n        \"\"\"\nif get_debug_level() == 0:\n    return None\nfname = '{0}_{1}_{2}.log'.format(kind, self.language, os.getpid())\nlocation = get_conf_path(osp.join('lsp_logs', fname))\nif not osp.exists(osp.dirname(location)):\n    os.makedirs(osp.dirname(location))\nreturn location\n",
        "CUT_2": "\"\"\"\n        Get filename to redirect server or transport logs to in\n        debugging mode.\n\n        Parameters\n        ----------\n        kind: str\n            It can be \"server\" or \"transport\".\n        \"\"\"\nif get_debug_level() == 0:\n    return None\nfname = '{0}_{1}_{2}.log'.format(kind, self.language, os.getpid())\nlocation = get_conf_path(osp.join('lsp_logs', fname))\nif not osp.exists(osp.dirname(location)):\n    os.makedirs(osp.dirname(location))\nreturn location\n",
        "CUT_3": "\"\"\"Select directory.\"\"\"\nlocation = osp.normpath(getexistingdirectory(self, _('Select directory'),\n    self.location))\nif location:\n    if is_writable(location):\n        self.location = location\n        self.update_location()\n",
        "CUT_4": "\"\"\"Select directory.\"\"\"\nlocation = osp.normpath(getexistingdirectory(self, _('Select directory'),\n    self.location))\nif location:\n    if is_writable(location):\n        self.location = location\n        self.update_location()\n",
        "CUT_5": "\"\"\"Check sys.path: is Spyder properly installed?\"\"\"\ndirname = osp.abspath(osp.join(osp.dirname(__file__), osp.pardir))\nif dirname not in sys.path:\n    show_warning(\n        \"\"\"Spyder must be installed properly (e.g. from source: 'python setup.py install'),\nor directory '%s' must be in PYTHONPATH environment variable.\"\"\"\n         % dirname)\n"
    },
    {
        "functionName": "expected_results",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "results = {'spam.txt': [(1, 0), (1, 5), (3, 22)], 'spam.py': [(2, 7), (5, 1\n    ), (7, 12)], 'spam.cpp': [(2, 9), (6, 15), (8, 2), (11, 4), (11, 10), (\n    13, 12)]}\nreturn results\n",
        "CUT_1": "return 'spam'\nspam.eggs",
        "CUT_2": "self.filename = filename\nself.results = results\nself.refresh()\n",
        "CUT_3": "self.filename = filename\nself.results = results\nself.refresh()\n",
        "CUT_4": "\"\"\"Set TODO results and update markers in editor\"\"\"\nself.todo_results = results\nself.editor.process_todo(results)\n",
        "CUT_5": "\"\"\"Set TODO results and update markers in editor\"\"\"\nself.todo_results = results\nself.editor.process_todo(results)\n"
    },
    {
        "functionName": "expected_case_unsensitive_results",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "results = {'spam.txt': [(1, 10)], 'ham.txt': [(1, 0), (1, 10), (3, 0), (4, \n    0), (5, 4), (9, 0), (10, 0)]}\nreturn results\n",
        "CUT_1": "self.filename = filename\nself.results = results\nself.refresh()\n",
        "CUT_2": "self.filename = filename\nself.results = results\nself.refresh()\n",
        "CUT_3": "return 'spam'\nspam.eggs",
        "CUT_4": "\"\"\"Set TODO results and update markers in editor\"\"\"\nself.todo_results = results\nself.editor.process_todo(results)\n",
        "CUT_5": "\"\"\"Set TODO results and update markers in editor\"\"\"\nself.todo_results = results\nself.editor.process_todo(results)\n"
    },
    {
        "functionName": "test_find_in_files_search",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test the find in files utility by searching a string located on a set of\n    known files.\n\n    The results of the test should be equal to the expected search result\n    values.\n    \"\"\"\nfindinfiles.set_search_text('spam')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\nblocker = qtbot.waitSignal(findinfiles.sig_finished)\nblocker.wait()\nmatches = process_search_results(findinfiles.result_browser.data)\nassert expected_results() == matches\n",
        "CUT_1": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "return _('Find')\n",
        "CUT_4": "return _('Find')\n",
        "CUT_5": "return _('Find')\n"
    },
    {
        "functionName": "test_exclude_extension_regex",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "findinfiles.set_search_text('spam')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\nblocker = qtbot.waitSignal(findinfiles.sig_finished)\nblocker.wait()\nmatches = process_search_results(findinfiles.result_browser.data)\nfiles_filtered = True\nfor file in matches:\n    filename, ext = osp.splitext(file)\n    if ext == '.py':\n        files_filtered = False\n        break\nassert files_filtered\npytest.mark.parametrize('findinfiles', [{'exclude': '\\\\.py$',\n    'exclude_regexp': True}], indirect=True)",
        "CUT_1": "ext = osp.splitext(filename)[1].lower()\nif ext in self.save_funcs:\n    return self.save_funcs[ext](data, filename)\nelse:\n    return \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_2": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_3": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_4": "ext = osp.splitext(filename)[1].lower()\nif ext in self.load_funcs:\n    return self.load_funcs[ext](filename)\nelse:\n    return None, \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_5": "\"\"\"Get file language from filename\"\"\"\next = osp.splitext(filename)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nlanguage = ext\nif not ext:\n    if text is None:\n        text, _enc = encoding.read(filename)\n    for line in text.splitlines():\n        if not line.strip():\n            continue\n        if line.startswith('#!'):\n            shebang = line[2:]\n            if 'python' in shebang:\n                language = 'python'\n        else:\n            break\nreturn language\n"
    },
    {
        "functionName": "test_exclude_extension_string",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "findinfiles.set_search_text('spam')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\nblocker = qtbot.waitSignal(findinfiles.sig_finished)\nblocker.wait()\nmatches = process_search_results(findinfiles.result_browser.data)\nfiles_filtered = True\nfor file in matches:\n    filename, ext = osp.splitext(file)\n    if ext == '.py':\n        files_filtered = False\n        break\nassert files_filtered\npytest.mark.parametrize('findinfiles', [{'exclude': '*.py',\n    'exclude_regexp': False}], indirect=True)",
        "CUT_1": "ext = osp.splitext(filename)[1].lower()\nif ext in self.save_funcs:\n    return self.save_funcs[ext](data, filename)\nelse:\n    return \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_2": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_3": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_4": "ext = osp.splitext(filename)[1].lower()\nif ext in self.load_funcs:\n    return self.load_funcs[ext](filename)\nelse:\n    return None, \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_5": "\"\"\"Get file language from filename\"\"\"\next = osp.splitext(filename)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nlanguage = ext\nif not ext:\n    if text is None:\n        text, _enc = encoding.read(filename)\n    for line in text.splitlines():\n        if not line.strip():\n            continue\n        if line.startswith('#!'):\n            shebang = line[2:]\n            if 'python' in shebang:\n                language = 'python'\n        else:\n            break\nreturn language\n"
    },
    {
        "functionName": "test_exclude_extension_empty_regex",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "findinfiles.set_search_text('spam')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\nblocker = qtbot.waitSignal(findinfiles.sig_finished)\nblocker.wait()\nmatches = process_search_results(findinfiles.result_browser.data)\nassert expected_results() == matches\npytest.mark.parametrize('findinfiles', [{'exclude': '', 'exclude_regexp':\n    True}], indirect=True)",
        "CUT_1": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "return 'spam'\nspam.eggs",
        "CUT_4": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_5": "\"\"\"\n        Current search thread has finished.\n        \"\"\"\nself.result_browser.set_sorting(ON)\nself.result_browser.expandAll()\nif self.search_thread is None:\n    return\nself.sig_finished.emit()\nfound = self.search_thread.get_results()\nself._stop_and_reset_thread()\nif found is not None:\n    self.result_browser.show()\nself.stop_spinner()\nself.update_actions()\n"
    },
    {
        "functionName": "test_exclude_extension_string_no_regexp",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "findinfiles.set_search_text('spam')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\nblocker = qtbot.waitSignal(findinfiles.sig_finished)\nblocker.wait()\nmatches = process_search_results(findinfiles.result_browser.data)\nassert expected_results() == matches\npytest.mark.parametrize('findinfiles', [{'exclude': '', 'exclude_regexp':\n    False}], indirect=True)",
        "CUT_1": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "return 'spam'\nspam.eggs",
        "CUT_4": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_5": "\"\"\"\n        Current search thread has finished.\n        \"\"\"\nself.result_browser.set_sorting(ON)\nself.result_browser.expandAll()\nif self.search_thread is None:\n    return\nself.sig_finished.emit()\nfound = self.search_thread.get_results()\nself._stop_and_reset_thread()\nif found is not None:\n    self.result_browser.show()\nself.stop_spinner()\nself.update_actions()\n"
    },
    {
        "functionName": "test_exclude_extension_multiple_string",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "findinfiles.set_search_text('spam')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\nblocker = qtbot.waitSignal(findinfiles.sig_finished)\nblocker.wait()\nmatches = process_search_results(findinfiles.result_browser.data)\nfiles_filtered = True\nfor file in matches:\n    filename, ext = osp.splitext(file)\n    if ext in ['.py', '.cpp']:\n        files_filtered = False\n        break\nassert files_filtered\npytest.mark.parametrize('findinfiles', [{'exclude': '*.py, *.cpp',\n    'exclude_regexp': False}], indirect=True)",
        "CUT_1": "ext = osp.splitext(filename)[1].lower()\nif ext in self.save_funcs:\n    return self.save_funcs[ext](data, filename)\nelse:\n    return \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_2": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_3": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_4": "ext = osp.splitext(filename)[1].lower()\nif ext in self.load_funcs:\n    return self.load_funcs[ext](filename)\nelse:\n    return None, \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_5": "\"\"\"Get file language from filename\"\"\"\next = osp.splitext(filename)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nlanguage = ext\nif not ext:\n    if text is None:\n        text, _enc = encoding.read(filename)\n    for line in text.splitlines():\n        if not line.strip():\n            continue\n        if line.startswith('#!'):\n            shebang = line[2:]\n            if 'python' in shebang:\n                language = 'python'\n        else:\n            break\nreturn language\n"
    },
    {
        "functionName": "test_truncate_result_with_different_input",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Issue: 6218 - checking if truncate_result raise UnicodeDecodeError\n    \"\"\"\nslice_start = 1\nslice_end = 2\nline_input_expected = line_input\nexpected_result = '<span style=\"color:None\">%s<b>%s</b>%s</span>' % (\n    line_input_expected[:slice_start], line_input_expected[slice_start:\n    slice_end], line_input_expected[slice_end:])\nthread = SearchThread(None, '')\ntruncated_line = thread.truncate_result(line_input, slice_start, slice_end)\nassert truncated_line == expected_result\npytest.mark.parametrize('line_input', ['nnnnn', '\u00f1and\u00fa'])",
        "CUT_1": "\"\"\"Grey span.\"\"\"\nreturn '<span class=\"grey\">%s</span>' % text\n",
        "CUT_2": "\"\"\"Grey span.\"\"\"\nreturn '<span class=\"grey\">%s</span>' % text\n",
        "CUT_3": "\"\"\"Start thread.\"\"\"\nself.thread.start()\n",
        "CUT_4": "\"\"\"Start thread.\"\"\"\nself.thread.start()\n",
        "CUT_5": "\"\"\"Start thread.\"\"\"\nself.thread.start()\n"
    },
    {
        "functionName": "test_case_unsensitive_search",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "findinfiles.set_search_text('ham')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\nblocker = qtbot.waitSignal(findinfiles.sig_finished)\nblocker.wait()\nmatches = process_search_results(findinfiles.result_browser.data)\nprint(matches)\nassert expected_case_unsensitive_results() == matches\npytest.mark.parametrize('findinfiles', [{'case_sensitive': False}],\n    indirect=True)",
        "CUT_1": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "patterns = [pattern.format(token, '[^0-9a-zA-Z.[]') for pattern in patterns]\npattern = re.compile('|^'.join(patterns))\nlines = [(line.strip() + ' ') for line in source.splitlines()]\nif start_line == -1:\n    start_line = len(lines)\nmatches = []\nfor index, line in enumerate(lines):\n    if re.match(pattern, line):\n        matches.append(index + 1)\nreturn matches\n",
        "CUT_4": "patterns = [pattern.format(token, '[^0-9a-zA-Z.[]') for pattern in patterns]\npattern = re.compile('|^'.join(patterns))\nlines = [(line.strip() + ' ') for line in source.splitlines()]\nif start_line == -1:\n    start_line = len(lines)\nmatches = []\nfor index, line in enumerate(lines):\n    if re.match(pattern, line):\n        matches.append(index + 1)\nreturn matches\n",
        "CUT_5": "\"\"\"\n    Find the definition of an object within a source closest to a given line\n    \"\"\"\nif not token:\n    return None\nif DEBUG_EDITOR:\n    t0 = time.time()\npatterns = ['^c?import.*\\\\W{0}{1}', 'from.*\\\\W{0}\\\\W.*c?import ',\n    'from .* c?import.*\\\\W{0}{1}', 'class\\\\s*{0}{1}',\n    'c?p?def[^=]*\\\\W{0}{1}', 'cdef.*\\\\[.*\\\\].*\\\\W{0}{1}',\n    'enamldef.*\\\\W{0}{1}', 'attr.*\\\\W{0}{1}', 'event.*\\\\W{0}{1}',\n    'id\\\\s*:.*\\\\W{0}{1}']\nmatches = get_matches(patterns, source, token, start_line)\nif not matches:\n    patterns = ['.*\\\\Wself.{0}{1}[^=!<>]*=[^=]', '.*\\\\W{0}{1}[^=!<>]*=[^=]',\n        'self.{0}{1}[^=!<>]*=[^=]', '{0}{1}[^=!<>]*=[^=]']\n    matches = get_matches(patterns, source, token, start_line)\nif matches:\n    min_dist = len(source.splitlines())\n    best_ind = 0\n    for match in matches:\n        dist = abs(start_line - match)\n        if match <= start_line or not best_ind:\n            if dist < min_dist:\n                min_dist = dist\n                best_ind = match\nif matches:\n    if DEBUG_EDITOR:\n        log_dt(LOG_FILENAME, 'regex definition match', t0)\n    return best_ind\nelse:\n    if DEBUG_EDITOR:\n        log_dt(LOG_FILENAME, 'regex definition failed match', t0)\n    return None\n"
    },
    {
        "functionName": "test_case_sensitive_search",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "findinfiles.set_search_text('HaM')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\nblocker = qtbot.waitSignal(findinfiles.sig_finished)\nblocker.wait()\nmatches = process_search_results(findinfiles.result_browser.data)\nprint(matches)\nassert matches == {'ham.txt': [(9, 0)]}\npytest.mark.parametrize('findinfiles', [{'case_sensitive': True}], indirect\n    =True)",
        "CUT_1": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "patterns = [pattern.format(token, '[^0-9a-zA-Z.[]') for pattern in patterns]\npattern = re.compile('|^'.join(patterns))\nlines = [(line.strip() + ' ') for line in source.splitlines()]\nif start_line == -1:\n    start_line = len(lines)\nmatches = []\nfor index, line in enumerate(lines):\n    if re.match(pattern, line):\n        matches.append(index + 1)\nreturn matches\n",
        "CUT_4": "patterns = [pattern.format(token, '[^0-9a-zA-Z.[]') for pattern in patterns]\npattern = re.compile('|^'.join(patterns))\nlines = [(line.strip() + ' ') for line in source.splitlines()]\nif start_line == -1:\n    start_line = len(lines)\nmatches = []\nfor index, line in enumerate(lines):\n    if re.match(pattern, line):\n        matches.append(index + 1)\nreturn matches\n",
        "CUT_5": "\"\"\"\n    Find the definition of an object within a source closest to a given line\n    \"\"\"\nif not token:\n    return None\nif DEBUG_EDITOR:\n    t0 = time.time()\npatterns = ['^c?import.*\\\\W{0}{1}', 'from.*\\\\W{0}\\\\W.*c?import ',\n    'from .* c?import.*\\\\W{0}{1}', 'class\\\\s*{0}{1}',\n    'c?p?def[^=]*\\\\W{0}{1}', 'cdef.*\\\\[.*\\\\].*\\\\W{0}{1}',\n    'enamldef.*\\\\W{0}{1}', 'attr.*\\\\W{0}{1}', 'event.*\\\\W{0}{1}',\n    'id\\\\s*:.*\\\\W{0}{1}']\nmatches = get_matches(patterns, source, token, start_line)\nif not matches:\n    patterns = ['.*\\\\Wself.{0}{1}[^=!<>]*=[^=]', '.*\\\\W{0}{1}[^=!<>]*=[^=]',\n        'self.{0}{1}[^=!<>]*=[^=]', '{0}{1}[^=!<>]*=[^=]']\n    matches = get_matches(patterns, source, token, start_line)\nif matches:\n    min_dist = len(source.splitlines())\n    best_ind = 0\n    for match in matches:\n        dist = abs(start_line - match)\n        if match <= start_line or not best_ind:\n            if dist < min_dist:\n                min_dist = dist\n                best_ind = match\nif matches:\n    if DEBUG_EDITOR:\n        log_dt(LOG_FILENAME, 'regex definition match', t0)\n    return best_ind\nelse:\n    if DEBUG_EDITOR:\n        log_dt(LOG_FILENAME, 'regex definition failed match', t0)\n    return None\n"
    },
    {
        "functionName": "test_search_regexp_error",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "findinfiles.set_search_text('\\\\')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\ntooltip = findinfiles.search_text_edit.toolTip()\nassert findinfiles.REGEX_ERROR in tooltip\npytest.mark.parametrize('findinfiles', [{'search_text_regexp': True}],\n    indirect=True)",
        "CUT_1": "\"\"\"Update tooltip for widget.\"\"\"\ntooltip = self.get_tooltip()\nif tooltip:\n    self.label_value.setToolTip(tooltip)\n    if self.label_icon:\n        self.label_icon.setToolTip(tooltip)\n    self.setToolTip(tooltip)\n",
        "CUT_2": "\"\"\"Update tooltip for widget.\"\"\"\ntooltip = self.get_tooltip()\nif tooltip:\n    self.label_value.setToolTip(tooltip)\n    if self.label_icon:\n        self.label_icon.setToolTip(tooltip)\n    self.setToolTip(tooltip)\n",
        "CUT_3": "\"\"\"Reimplementation to get a dynamic tooltip.\"\"\"\nreturn self.tooltip\n",
        "CUT_4": "\"\"\"Reimplementation to get a dynamic tooltip.\"\"\"\nreturn self.tooltip\n",
        "CUT_5": "\"\"\"Reimplementation to get a dynamic tooltip.\"\"\"\nreturn self.tooltip\n"
    },
    {
        "functionName": "test_exclude_regexp_error",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "findinfiles.set_search_text('foo')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\ntooltip = findinfiles.exclude_pattern_edit.toolTip()\nassert findinfiles.REGEX_ERROR in tooltip\npytest.mark.parametrize('findinfiles', [{'exclude': '\\\\', 'exclude_regexp':\n    True}], indirect=True)",
        "CUT_1": "\"\"\"Update tooltip for widget.\"\"\"\ntooltip = self.get_tooltip()\nif tooltip:\n    self.label_value.setToolTip(tooltip)\n    if self.label_icon:\n        self.label_icon.setToolTip(tooltip)\n    self.setToolTip(tooltip)\n",
        "CUT_2": "\"\"\"Update tooltip for widget.\"\"\"\ntooltip = self.get_tooltip()\nif tooltip:\n    self.label_value.setToolTip(tooltip)\n    if self.label_icon:\n        self.label_icon.setToolTip(tooltip)\n    self.setToolTip(tooltip)\n",
        "CUT_3": "\"\"\"Reimplementation to get a dynamic tooltip.\"\"\"\nreturn self.tooltip\n",
        "CUT_4": "\"\"\"Reimplementation to get a dynamic tooltip.\"\"\"\nreturn self.tooltip\n",
        "CUT_5": "\"\"\"Reimplementation to get a dynamic tooltip.\"\"\"\nreturn self.tooltip\n"
    },
    {
        "functionName": "test_add_external_paths",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the external_path_history is added correctly to the\n    combobox and test that adding new external path to the combobox\n    with the QFileDialog is working as expected.\n    \"\"\"\nsearchin_combobox.show()\nexpected_results = [LOCATION, osp.dirname(osp.dirname(LOCATION)), osp.\n    dirname(osp.dirname(osp.dirname(LOCATION))), osp.dirname(LOCATION)]\nassert searchin_combobox.count() == len(expected_results) + EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == expected_results\nfor i, expected_result in enumerate(expected_results):\n    assert expected_result == searchin_combobox.itemText(i + EXTERNAL_PATHS)\nnew_path = NONASCII_DIR\nmocker.patch('spyder.plugins.findinfiles.widgets.getexistingdirectory',\n    return_value=new_path)\nsearchin_combobox.setCurrentIndex(SELECT_OTHER)\nexpected_results.append(new_path)\nassert searchin_combobox.count() == len(expected_results) + EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == expected_results\nassert searchin_combobox.currentIndex() == searchin_combobox.count() - 1\nnew_path = LOCATION\nmocker.patch('spyder.plugins.findinfiles.widgets.getexistingdirectory',\n    return_value=new_path)\nsearchin_combobox.setCurrentIndex(SELECT_OTHER)\nexpected_results.pop(0)\nexpected_results.append(new_path)\nassert searchin_combobox.count() == len(expected_results) + EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == expected_results\nassert searchin_combobox.currentIndex() == searchin_combobox.count() - 1\nmocker.patch('spyder.plugins.findinfiles.widgets.getexistingdirectory',\n    return_value='')\nsearchin_combobox.setCurrentIndex(SELECT_OTHER)\nassert searchin_combobox.count() == len(expected_results) + EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == expected_results\nassert searchin_combobox.currentIndex() == CWD\n",
        "CUT_1": "\"\"\"Remove all the external paths listed in the combobox.\"\"\"\nwhile self.count() > EXTERNAL_PATHS:\n    self.removeItem(EXTERNAL_PATHS)\n",
        "CUT_2": "\"\"\"Remove all the external paths listed in the combobox.\"\"\"\nwhile self.count() > EXTERNAL_PATHS:\n    self.removeItem(EXTERNAL_PATHS)\n",
        "CUT_3": "\"\"\"Select directory.\"\"\"\nlocation = osp.normpath(getexistingdirectory(self, _('Select directory'),\n    self.location))\nif location:\n    if is_writable(location):\n        self.location = location\n        self.update_location()\n",
        "CUT_4": "\"\"\"Select directory.\"\"\"\nlocation = osp.normpath(getexistingdirectory(self, _('Select directory'),\n    self.location))\nif location:\n    if is_writable(location):\n        self.location = location\n        self.update_location()\n",
        "CUT_5": "\"\"\"Returns a list of the external paths listed in the combobox.\"\"\"\nreturn [str(self.itemText(i)) for i in range(EXTERNAL_PATHS, self.count())]\n"
    },
    {
        "functionName": "test_clear_this_list",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the option in the searchin combobox to clear the list of\n    external paths.\n    \"\"\"\nsearchin_combobox.show()\nmocker.patch.object(QMessageBox, 'question', return_value=QMessageBox.No)\nsearchin_combobox.setCurrentIndex(CLEAR_LIST)\nexpected_results = [LOCATION, osp.dirname(osp.dirname(LOCATION)), osp.\n    dirname(osp.dirname(osp.dirname(LOCATION))), osp.dirname(LOCATION)]\nassert searchin_combobox.count() == len(expected_results) + EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == expected_results\nassert searchin_combobox.currentIndex() == CWD\nmocker.patch.object(QMessageBox, 'question', return_value=QMessageBox.Yes)\nsearchin_combobox.setCurrentIndex(CLEAR_LIST)\nassert searchin_combobox.count() == EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == []\nassert searchin_combobox.currentIndex() == CWD\n",
        "CUT_1": "\"\"\"\n        Get filename to redirect server or transport logs to in\n        debugging mode.\n\n        Parameters\n        ----------\n        kind: str\n            It can be \"server\" or \"transport\".\n        \"\"\"\nif get_debug_level() == 0:\n    return None\nfname = '{0}_{1}_{2}.log'.format(kind, self.language, os.getpid())\nlocation = get_conf_path(osp.join('lsp_logs', fname))\nif not osp.exists(osp.dirname(location)):\n    os.makedirs(osp.dirname(location))\nreturn location\n",
        "CUT_2": "\"\"\"\n        Get filename to redirect server or transport logs to in\n        debugging mode.\n\n        Parameters\n        ----------\n        kind: str\n            It can be \"server\" or \"transport\".\n        \"\"\"\nif get_debug_level() == 0:\n    return None\nfname = '{0}_{1}_{2}.log'.format(kind, self.language, os.getpid())\nlocation = get_conf_path(osp.join('lsp_logs', fname))\nif not osp.exists(osp.dirname(location)):\n    os.makedirs(osp.dirname(location))\nreturn location\n",
        "CUT_3": "\"\"\"\n    Run Find in Files widget test.\n    \"\"\"\nfrom os.path import dirname\nimport sys\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\noptions = FindInFilesWidget.DEFAULT_OPTIONS.copy()\nwidget = FindInFilesWidget('find_in_files', options=options)\nwidget._setup(options=options)\nwidget.setup(options=options)\nwidget.resize(640, 480)\nwidget.show()\nexternal_paths = [dirname(__file__), dirname(dirname(__file__)), dirname(\n    dirname(dirname(__file__))), dirname(dirname(dirname(dirname(__file__))))]\nfor path in external_paths:\n    widget.add_external_path(path)\nsys.exit(app.exec_())\n",
        "CUT_4": "\"\"\"\n    Run Find in Files widget test.\n    \"\"\"\nfrom os.path import dirname\nimport sys\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\noptions = FindInFilesWidget.DEFAULT_OPTIONS.copy()\nwidget = FindInFilesWidget('find_in_files', options=options)\nwidget._setup(options=options)\nwidget.setup(options=options)\nwidget.resize(640, 480)\nwidget.show()\nexternal_paths = [dirname(__file__), dirname(dirname(__file__)), dirname(\n    dirname(dirname(__file__))), dirname(dirname(dirname(dirname(__file__))))]\nfor path in external_paths:\n    widget.add_external_path(path)\nsys.exit(app.exec_())\n",
        "CUT_5": "\"\"\"\n    Given a file path, determine the full module path.\n\n    e.g. '/usr/lib/python2.7/dist-packages/numpy/core/__init__.pyc' yields\n    'numpy.core'\n    \"\"\"\ndirname = osp.dirname(path)\ntry:\n    mod = osp.basename(path)\n    mod = osp.splitext(mod)[0]\n    imp.find_module(mod, [dirname])\nexcept ImportError:\n    return\nitems = [mod]\nwhile 1:\n    items.append(osp.basename(dirname))\n    try:\n        dirname = osp.dirname(dirname)\n        imp.find_module('__init__', [dirname + os.sep])\n    except ImportError:\n        break\nreturn '.'.join(reversed(items))\nmemoize"
    },
    {
        "functionName": "test_delete_path",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the selected external path in the combobox view is removed\n    correctly when the Delete key is pressed.\n    \"\"\"\nsearchin_combobox.show()\nexpected_results = [LOCATION, osp.dirname(osp.dirname(LOCATION)), osp.\n    dirname(osp.dirname(osp.dirname(LOCATION))), osp.dirname(LOCATION)]\nsearchin_combobox.showPopup()\nassert searchin_combobox.currentIndex() == CWD\nassert searchin_combobox.view().currentIndex().row() == CWD\nfor i in range(EXTERNAL_PATHS):\n    searchin_combobox.view().setCurrentIndex(searchin_combobox.model().\n        index(i, 0))\n    qtbot.keyPress(searchin_combobox.view(), Qt.Key_Delete)\nassert searchin_combobox.count() == len(expected_results) + EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == expected_results\nassert searchin_combobox.currentIndex() == CWD\nsearchin_combobox.view().setCurrentIndex(searchin_combobox.model().index(\n    EXTERNAL_PATHS, 0))\nqtbot.keyPress(searchin_combobox.view(), Qt.Key_Delete)\nexpected_results.pop(0)\nassert searchin_combobox.count() == len(expected_results) + EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == expected_results\nassert searchin_combobox.currentIndex() == EXTERNAL_PATHS\nassert searchin_combobox.view().currentIndex().row() == EXTERNAL_PATHS\nsearchin_combobox.view().setCurrentIndex(searchin_combobox.model().index(\n    EXTERNAL_PATHS + 1, 0))\nqtbot.keyPress(searchin_combobox.view(), Qt.Key_Delete)\nexpected_results.pop(1)\nassert searchin_combobox.count() == len(expected_results) + EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == expected_results\nassert searchin_combobox.currentIndex() == EXTERNAL_PATHS + 1\nassert searchin_combobox.view().currentIndex().row() == EXTERNAL_PATHS + 1\nsearchin_combobox.view().setCurrentIndex(searchin_combobox.model().index(\n    searchin_combobox.count() - 1, 0))\nqtbot.keyPress(searchin_combobox.view(), Qt.Key_Delete)\nexpected_results.pop()\nassert searchin_combobox.count() == len(expected_results) + EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == expected_results\nassert searchin_combobox.currentIndex() == searchin_combobox.count() - 1\nassert searchin_combobox.view().currentIndex().row(\n    ) == searchin_combobox.count() - 1\nsearchin_combobox.view().setCurrentIndex(searchin_combobox.model().index(\n    EXTERNAL_PATHS, 0))\nqtbot.keyPress(searchin_combobox.view(), Qt.Key_Delete)\nassert searchin_combobox.count() == EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == []\nassert searchin_combobox.currentIndex() == CWD\nassert searchin_combobox.view().currentIndex().row() == CWD\n",
        "CUT_1": "\"\"\"Remove all the external paths listed in the combobox.\"\"\"\nwhile self.count() > EXTERNAL_PATHS:\n    self.removeItem(EXTERNAL_PATHS)\n",
        "CUT_2": "\"\"\"Remove all the external paths listed in the combobox.\"\"\"\nwhile self.count() > EXTERNAL_PATHS:\n    self.removeItem(EXTERNAL_PATHS)\n",
        "CUT_3": "\"\"\"Used to handle key events on the QListView of the combobox.\"\"\"\nif event.type() == QEvent.KeyPress and event.key() == Qt.Key_Delete:\n    index = self.view().currentIndex().row()\n    if index >= EXTERNAL_PATHS:\n        self.removeItem(index)\n        self.showPopup()\n        new_index = min(self.count() - 1, index)\n        new_index = 0 if new_index < EXTERNAL_PATHS else new_index\n        self.view().setCurrentIndex(self.model().index(new_index, 0))\n        self.setCurrentIndex(new_index)\n    return True\nreturn QComboBox.eventFilter(self, widget, event)\n",
        "CUT_4": "\"\"\"Used to handle key events on the QListView of the combobox.\"\"\"\nif event.type() == QEvent.KeyPress and event.key() == Qt.Key_Delete:\n    index = self.view().currentIndex().row()\n    if index >= EXTERNAL_PATHS:\n        self.removeItem(index)\n        self.showPopup()\n        new_index = min(self.count() - 1, index)\n        new_index = 0 if new_index < EXTERNAL_PATHS else new_index\n        self.view().setCurrentIndex(self.model().index(new_index, 0))\n        self.setCurrentIndex(new_index)\n    return True\nreturn QComboBox.eventFilter(self, widget, event)\n",
        "CUT_5": "\"\"\"Returns a list of the external paths listed in the combobox.\"\"\"\nreturn [str(self.itemText(i)) for i in range(EXTERNAL_PATHS, self.count())]\n"
    },
    {
        "functionName": "test_set_project_path",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test setting the project path of the SearchInComboBox from the\n    FindInFilesWidget.\n    \"\"\"\npath_selection_combo = findinfiles.path_selection_combo\nfindinfiles.show()\nassert path_selection_combo.model().item(PROJECT, 0).isEnabled() is False\nassert findinfiles.project_path is None\nassert path_selection_combo.project_path is None\nproject_path = NONASCII_DIR\nfindinfiles.set_project_path(project_path)\nassert path_selection_combo.model().item(PROJECT, 0).isEnabled() is True\nassert findinfiles.project_path == project_path\nassert path_selection_combo.project_path == project_path\npath_selection_combo.setCurrentIndex(PROJECT)\nfindinfiles.disable_project_search()\nassert path_selection_combo.model().item(PROJECT, 0).isEnabled() is False\nassert findinfiles.project_path is None\nassert path_selection_combo.project_path is None\nassert path_selection_combo.currentIndex() == CWD\n",
        "CUT_1": "\"\"\"Return the current project path.\"\"\"\nreturn self.path_selection_combo.project_path\nproperty",
        "CUT_2": "\"\"\"Return the current project path.\"\"\"\nreturn self.path_selection_combo.project_path\nproperty",
        "CUT_3": "\"\"\"\n        Sets the project path and disables the project search in the combobox\n        if the value of path is None.\n        \"\"\"\nif path is None:\n    self.project_path = None\n    self.model().item(PROJECT, 0).setEnabled(False)\n    if self.currentIndex() == PROJECT:\n        self.setCurrentIndex(CWD)\nelse:\n    path = osp.abspath(path)\n    self.project_path = path\n    self.model().item(PROJECT, 0).setEnabled(True)\n",
        "CUT_4": "\"\"\"\n        Sets the project path and disables the project search in the combobox\n        if the value of path is None.\n        \"\"\"\nif path is None:\n    self.project_path = None\n    self.model().item(PROJECT, 0).setEnabled(False)\n    if self.currentIndex() == PROJECT:\n        self.setCurrentIndex(CWD)\nelse:\n    path = osp.abspath(path)\n    self.project_path = path\n    self.model().item(PROJECT, 0).setEnabled(True)\n",
        "CUT_5": "\"\"\"Disable project search path in combobox.\"\"\"\nself.path_selection_combo.set_project_path(None)\n"
    },
    {
        "functionName": "test_current_search_path",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the expected search path is returned for the corresponding\n    option selected in the SearchInComboBox. This test is done using the\n    FindInFilesWidget.\n    \"\"\"\nexternal_paths = [LOCATION, osp.dirname(LOCATION), osp.dirname(osp.dirname(\n    LOCATION)), NONASCII_DIR]\npath_selection_combo = findinfiles.path_selection_combo\nfindinfiles.show()\ndirectory = NONASCII_DIR\nproject_path = NONASCII_DIR\nfile_path = osp.join(directory, 'spam.py')\nfindinfiles.set_directory(directory)\nassert findinfiles.path == directory\nassert path_selection_combo.path == directory\nfindinfiles.set_project_path(project_path)\nassert findinfiles.project_path == project_path\nassert path_selection_combo.project_path == project_path\nfindinfiles.set_file_path(file_path)\nassert findinfiles.file_path == file_path\nassert path_selection_combo.file_path == file_path\npath_selection_combo.setCurrentIndex(CWD)\nassert path_selection_combo.get_current_searchpath() == directory\nassert path_selection_combo.is_file_search() is False\npath_selection_combo.setCurrentIndex(PROJECT)\nassert path_selection_combo.get_current_searchpath() == project_path\nassert path_selection_combo.is_file_search() is False\npath_selection_combo.setCurrentIndex(FILE_PATH)\nassert path_selection_combo.get_current_searchpath() == file_path\nassert path_selection_combo.is_file_search() is True\nfor i, path in enumerate(external_paths):\n    path_selection_combo.setCurrentIndex(EXTERNAL_PATHS + i)\n    assert path_selection_combo.get_current_searchpath() == path\n    assert path_selection_combo.is_file_search() is False\npytest.mark.parametrize('findinfiles', [{'path_history': [LOCATION, osp.\n    dirname(LOCATION), osp.dirname(osp.dirname(LOCATION)), NONASCII_DIR]}],\n    indirect=True)",
        "CUT_1": "\"\"\"Return the current file path.\"\"\"\nreturn self.path_selection_combo.file_path\nproperty",
        "CUT_2": "\"\"\"Return the current file path.\"\"\"\nreturn self.path_selection_combo.file_path\nproperty",
        "CUT_3": "\"\"\"Return the current project path.\"\"\"\nreturn self.path_selection_combo.project_path\nproperty",
        "CUT_4": "\"\"\"Return the current project path.\"\"\"\nreturn self.path_selection_combo.project_path\nproperty",
        "CUT_5": "\"\"\"Return the current path.\"\"\"\nreturn self.path_selection_combo.path\nproperty"
    },
    {
        "functionName": "test_max_history",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the specified maximum number of external path is observed.\n    \"\"\"\nsearchin_combobox.show()\nexpected_results = [osp.dirname(osp.dirname(LOCATION)), osp.dirname(osp.\n    dirname(osp.dirname(LOCATION))), osp.dirname(LOCATION)]\nassert searchin_combobox.count() == len(expected_results) + EXTERNAL_PATHS\nassert searchin_combobox.get_external_paths() == expected_results\npytest.mark.parametrize('searchin_combobox', [{'max_history_path': 3}],\n    indirect=True)",
        "CUT_1": "\"\"\"\n    Given a file path, determine the full module path.\n\n    e.g. '/usr/lib/python2.7/dist-packages/numpy/core/__init__.pyc' yields\n    'numpy.core'\n    \"\"\"\ndirname = osp.dirname(path)\ntry:\n    mod = osp.basename(path)\n    mod = osp.splitext(mod)[0]\n    imp.find_module(mod, [dirname])\nexcept ImportError:\n    return\nitems = [mod]\nwhile 1:\n    items.append(osp.basename(dirname))\n    try:\n        dirname = osp.dirname(dirname)\n        imp.find_module('__init__', [dirname + os.sep])\n    except ImportError:\n        break\nreturn '.'.join(reversed(items))\nmemoize",
        "CUT_2": "\"\"\"\n    Given a file path, determine the full module path.\n\n    e.g. '/usr/lib/python2.7/dist-packages/numpy/core/__init__.pyc' yields\n    'numpy.core'\n    \"\"\"\ndirname = osp.dirname(path)\ntry:\n    mod = osp.basename(path)\n    mod = osp.splitext(mod)[0]\n    imp.find_module(mod, [dirname])\nexcept ImportError:\n    return\nitems = [mod]\nwhile 1:\n    items.append(osp.basename(dirname))\n    try:\n        dirname = osp.dirname(dirname)\n        imp.find_module('__init__', [dirname + os.sep])\n    except ImportError:\n        break\nreturn '.'.join(reversed(items))\nmemoize",
        "CUT_3": "\"\"\"Check sys.path: is Spyder properly installed?\"\"\"\ndirname = osp.abspath(osp.join(osp.dirname(__file__), osp.pardir))\nif dirname not in sys.path:\n    show_warning(\n        \"\"\"Spyder must be installed properly (e.g. from source: 'python setup.py install'),\nor directory '%s' must be in PYTHONPATH environment variable.\"\"\"\n         % dirname)\n",
        "CUT_4": "\"\"\"Check sys.path: is Spyder properly installed?\"\"\"\ndirname = osp.abspath(osp.join(osp.dirname(__file__), osp.pardir))\nif dirname not in sys.path:\n    show_warning(\n        \"\"\"Spyder must be installed properly (e.g. from source: 'python setup.py install'),\nor directory '%s' must be in PYTHONPATH environment variable.\"\"\"\n         % dirname)\n",
        "CUT_5": "\"\"\"\n        Get filename to redirect server or transport logs to in\n        debugging mode.\n\n        Parameters\n        ----------\n        kind: str\n            It can be \"server\" or \"transport\".\n        \"\"\"\nif get_debug_level() == 0:\n    return None\nfname = '{0}_{1}_{2}.log'.format(kind, self.language, os.getpid())\nlocation = get_conf_path(osp.join('lsp_logs', fname))\nif not osp.exists(osp.dirname(location)):\n    os.makedirs(osp.dirname(location))\nreturn location\n"
    },
    {
        "functionName": "test_max_results",
        "className": null,
        "fileName": "/spyder/plugins/findinfiles/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test max results correspond to expected results.\"\"\"\nvalue = 2\nfindinfiles.set_max_results(value)\nfindinfiles.set_search_text('spam')\nfindinfiles.set_directory(osp.join(LOCATION, 'data'))\nfindinfiles.find()\nblocker = qtbot.waitSignal(findinfiles.sig_max_results_reached)\nblocker.wait()\nprint(len(findinfiles.result_browser.data), value)\nassert len(findinfiles.result_browser.data) == value\nfindinfiles.set_max_results(1000)\n",
        "CUT_1": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "self.value = value\n",
        "CUT_4": "self.value = value\n",
        "CUT_5": "return ','.join(value) if isinstance(value, list) else value\n"
    },
    {
        "functionName": "test_config_dialog",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/tests/test_variableexplorer_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpage = config_dialog.get_page()\nconfigpage.save_to_conf()\nassert configpage\npytest.mark.parametrize('config_dialog', [[None, [], [VariableExplorer]]],\n    indirect=True)",
        "CUT_1": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_2": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_3": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_4": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "test_get_settings",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/tests/test_variableexplorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "def mock_get_option(self, option):\n    if option == 'remote1':\n        return 'remote1val'\n    if option == 'remote2':\n        return 'remote2val'\n    if option == 'dataframe_format':\n        return '3d'\nmonkeypatch.setattr(VariableExplorer, 'CONF_SECTION', 'sect')\nmonkeypatch.setattr('spyder.plugins.variableexplorer.plugin.REMOTE_SETTINGS',\n    ['remote1', 'remote2'])\nmonkeypatch.setattr(VariableExplorer, 'get_option', mock_get_option)\napp = qapplication()\nsettings = VariableExplorer(None).get_settings()\nexpected = {'dataframe_format': '%3d', 'remote1': 'remote1val', 'remote2':\n    'remote2val'}\nassert settings == expected\n",
        "CUT_1": "\"\"\"Option has changed\"\"\"\nsetattr(self, to_text_string(option), value)\nself.shellwidget.set_namespace_view_settings()\nself.refresh_table()\n",
        "CUT_2": "\"\"\"Option has changed\"\"\"\nsetattr(self, to_text_string(option), value)\nself.shellwidget.set_namespace_view_settings()\nself.refresh_table()\n",
        "CUT_3": "\"\"\"\n        Retrieve all Variable Explorer configuration settings.\n        \n        Specifically, return the settings in CONF_SECTION with keys in \n        REMOTE_SETTINGS, and the setting 'dataframe_format'.\n        \n        Returns:\n            dict: settings\n        \"\"\"\nsettings = {}\nfor name in REMOTE_SETTINGS:\n    settings[name] = self.get_option(name)\nname = 'dataframe_format'\nsettings[name] = '%{0}'.format(self.get_option(name))\nreturn settings\n",
        "CUT_4": "\"\"\"\n        Retrieve all Variable Explorer configuration settings.\n        \n        Specifically, return the settings in CONF_SECTION with keys in \n        REMOTE_SETTINGS, and the setting 'dataframe_format'.\n        \n        Returns:\n            dict: settings\n        \"\"\"\nsettings = {}\nfor name in REMOTE_SETTINGS:\n    settings[name] = self.get_option(name)\nname = 'dataframe_format'\nsettings[name] = '%{0}'.format(self.get_option(name))\nreturn settings\n",
        "CUT_5": "if self.main.variableexplorer is not None:\n    self.main.variableexplorer.remove_shellwidget(id(client.shellwidget))\nself.sig_shellwidget_process_finished.emit(client.shellwidget)\n"
    },
    {
        "functionName": "mock_get_option",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/tests/test_variableexplorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if option == 'remote1':\n    return 'remote1val'\nif option == 'remote2':\n    return 'remote2val'\nif option == 'dataframe_format':\n    return '3d'\n",
        "CUT_1": "\"\"\"Return global font used in Spyder.\"\"\"\nreturn get_font(option=option)\n",
        "CUT_2": "\"\"\"Return global font used in Spyder.\"\"\"\nreturn get_font(option=option)\n",
        "CUT_3": "\"\"\"Get project configuration option.\"\"\"\nreturn self.config.get(section=section, option=option, default=default)\n",
        "CUT_4": "\"\"\"Get project configuration option.\"\"\"\nreturn self.config.get(section=section, option=option, default=default)\n",
        "CUT_5": "\"\"\"\n        Helper method to set/change options with option to emit signal.\n        \"\"\"\ntry:\n    action_name = 'toggle_{}_action'.format(option)\n    self._update_action_state(action_name, value)\nexcept SpyderAPIError:\n    pass\nself._check_options_dictionary_exist()\nif option in self.DEFAULT_OPTIONS:\n    self._options[option] = value\n    self.on_option_update(option, value)\n    if emit:\n        self.sig_option_changed.emit(option, value)\nelse:\n    raise SpyderAPIError(\n        'Option \"{}\" has not been defined in the widget DEFAULT_OPTIONS attribute!'\n        .format(option))\n"
    },
    {
        "functionName": "test_edit",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test subroutine\"\"\"\napp = qapplication()\ndlg = DataFrameEditor(parent=parent)\nif dlg.setup_and_check(data, title=title):\n    dlg.exec_()\n    return dlg.get_value()\nelse:\n    import sys\n    sys.exit(1)\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_5": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n"
    },
    {
        "functionName": "objectexplorer",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/objectexplorer/tests/test_objectexplorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up ObjectExplorer.\"\"\"\ndef create_objectexplorer(obj, **kwargs):\n    editor = ObjectExplorer(obj, **kwargs)\n    qtbot.addWidget(editor)\n    return editor\nreturn create_objectexplorer\npytest.fixture",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "if isinstance(obj, dict):\n    return obj\nd = dict()\nfor k in dir(obj):\n    if not k.startswith('_'):\n        d[k] = getattr(obj, k)\nreturn d\n",
        "CUT_5": "if isinstance(obj, dict):\n    return obj\nd = dict()\nfor k in dir(obj):\n    if not k.startswith('_'):\n        d[k] = getattr(obj, k)\nreturn d\n"
    },
    {
        "functionName": "create_objectexplorer",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/objectexplorer/tests/test_objectexplorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = ObjectExplorer(obj, **kwargs)\nqtbot.addWidget(editor)\nreturn editor\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n"
    },
    {
        "functionName": "test_objectexplorer",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/objectexplorer/tests/test_objectexplorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test to validate proper creation of the editor.\"\"\"\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n\n    def get_text(self):\n        return self.text\n\n    @property\n    def error_attribute(self):\n        raise AttributeError\nfoobar = Foobar()\neditor = objectexplorer(foobar, name='foobar', show_callable_attributes=\n    False, show_special_attributes=False)\nassert editor\nheader = editor.obj_tree.header()\nheader_model = header.model()\nassert not header.isSectionHidden(0)\nassert header_model.headerData(0, Qt.Horizontal, Qt.DisplayRole) == 'Name'\nassert not header.isSectionHidden(1)\nassert header_model.headerData(1, Qt.Horizontal, Qt.DisplayRole) == 'Type'\nassert not header.isSectionHidden(2)\nassert header_model.headerData(2, Qt.Horizontal, Qt.DisplayRole) == 'Size'\nassert not header.isSectionHidden(3)\nassert header_model.headerData(3, Qt.Horizontal, Qt.DisplayRole) == 'Value'\nassert not header.isSectionHidden(4)\nassert header_model.headerData(4, Qt.Horizontal, Qt.DisplayRole) == 'Callable'\nassert not header.isSectionHidden(5)\nassert header_model.headerData(5, Qt.Horizontal, Qt.DisplayRole) == 'Path'\nassert header.isSectionHidden(6)\nassert header_model.headerData(6, Qt.Horizontal, Qt.DisplayRole) == 'Id'\nassert header.isSectionHidden(7)\nassert header_model.headerData(7, Qt.Horizontal, Qt.DisplayRole) == 'Attribute'\nassert header.isSectionHidden(8)\nassert header_model.headerData(8, Qt.Horizontal, Qt.DisplayRole) == 'Routine'\nassert header.isSectionHidden(9)\nassert header_model.headerData(9, Qt.Horizontal, Qt.DisplayRole) == 'File'\nassert header.isSectionHidden(10)\nassert header_model.headerData(10, Qt.Horizontal, Qt.DisplayRole\n    ) == 'Source file'\nmodel = editor.obj_tree.model()\nassert model.rowCount() == 1\nassert model.columnCount() == 11\n",
        "CUT_1": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_2": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_3": "if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n    return self._attr_cols[section].name\nelse:\n    return None\n",
        "CUT_4": "if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n    return self._attr_cols[section].name\nelse:\n    return None\n",
        "CUT_5": "\"\"\"\n        Get the text to put in the header of the levels of the indexes.\n\n        By default it returns 'Index i', where i is the section in the index\n        \"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.model.header_shape[0] <= 1 and orientation == Qt.Horizontal:\n    if self.model.name(1, section):\n        return self.model.name(1, section)\n    return _('Index')\nelif self.model.header_shape[0] <= 1:\n    return None\nelif self.model.header_shape[1] <= 1 and orientation == Qt.Vertical:\n    return None\nreturn _('Index') + ' ' + to_text_string(section)\n"
    },
    {
        "functionName": "__init__",
        "className": "Foobar",
        "fileName": "/spyder/plugins/variableexplorer/widgets/objectexplorer/tests/test_objectexplorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "self.text = 'toto'\n",
        "CUT_1": "self.text = 'toto'\n",
        "CUT_2": "self.text = 'toto'\n",
        "CUT_3": "self.text = 'toto'\n",
        "CUT_4": "self.text = 'toto'\n",
        "CUT_5": "return self.text\n"
    },
    {
        "functionName": "get_text",
        "className": "Foobar",
        "fileName": "/spyder/plugins/variableexplorer/widgets/objectexplorer/tests/test_objectexplorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return self.text\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"Return modified text\"\"\"\nreturn self.text\n",
        "CUT_4": "\"\"\"Return modified text\"\"\"\nreturn self.text\n",
        "CUT_5": "\"\"\"Return line indentation (character number).\"\"\"\ntext = to_text_string(self.document().findBlockByNumber(block_nb).text())\ntext = text.replace('\\t', ' ' * self.tab_stop_width_spaces)\nreturn len(text) - len(text.lstrip())\n"
    },
    {
        "functionName": "error_attribute",
        "className": "Foobar",
        "fileName": "/spyder/plugins/variableexplorer/widgets/objectexplorer/tests/test_objectexplorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "raise AttributeError\nproperty",
        "CUT_1": "return False\nproperty",
        "CUT_2": "return False\nproperty",
        "CUT_3": "return len(self)\nproperty",
        "CUT_4": "return len(self)\nproperty",
        "CUT_5": "return self._placeholder\nproperty"
    },
    {
        "functionName": "test_objectexplorer_collection_types",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/objectexplorer/tests/test_objectexplorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test to validate proper handling of collection data types.\"\"\"\ntest, row_count = params\neditor = objectexplorer(test, name='variable', show_callable_attributes=\n    True, show_special_attributes=True)\nassert editor\nmodel = editor.obj_tree.model()\nassert model.rowCount() == 1\nexpected_output_range = list(range(min(row_count), max(row_count) + 1))\nassert model.rowCount(model.index(0, 0)) in expected_output_range\nassert model.columnCount() == 11\npytest.mark.parametrize('params', [('kjkj kj k j j kj k jkj', [71, 78]), ([\n    1, 3, 4, 'kjkj', None], [45, 46]), ({1, 2, 1, 3, None, 'A', 'B', 'C',\n    True, False}, [54, 55]), (1.2233, [57, 58]), (np.random.rand(10, 10), [\n    166, 162]), (datetime.date(1945, 5, 8), [43, 46])])",
        "CUT_1": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\napp = qapplication()\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n\n    def get_text(self):\n        return self.text\nfoobar = Foobar()\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8), 'foobar': foobar}\nObjectExplorer.create_explorer(example, 'Example', show_callable_attributes\n    =True, show_special_attributes=True)\n",
        "CUT_2": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\napp = qapplication()\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n\n    def get_text(self):\n        return self.text\nfoobar = Foobar()\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8), 'foobar': foobar}\nObjectExplorer.create_explorer(example, 'Example', show_callable_attributes\n    =True, show_special_attributes=True)\n",
        "CUT_3": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n",
        "CUT_4": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n",
        "CUT_5": "\"\"\"Set model data\"\"\"\nreturn False\n"
    },
    {
        "functionName": "test_objectexplorer_types",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/objectexplorer/tests/test_objectexplorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test to validate proper handling of data types inside an object.\"\"\"\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.list = [1, 3, 4, 'kjkj', None]\n        self.set = {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n        self.dict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]},\n        self.float = 1.2233,\n        self.array = np.random.rand(10, 10),\n        self.date = datetime.date(1945, 5, 8),\n        self.datetime = datetime.datetime(1945, 5, 8)\nfoo = Foobar()\nshow_callable, show_special, row_count = params\neditor = objectexplorer(foo, name='foo', show_callable_attributes=\n    show_callable, show_special_attributes=show_special)\nassert editor\nmodel = editor.obj_tree.model()\nassert model.rowCount() == 1\nassert model.rowCount(model.index(0, 0)) in row_count\nassert model.columnCount() == 11\npytest.mark.parametrize('params', [(True, True, [34, 26]), (False, False, [\n    8, 8])])",
        "CUT_1": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\napp = qapplication()\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n\n    def get_text(self):\n        return self.text\nfoobar = Foobar()\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8), 'foobar': foobar}\nObjectExplorer.create_explorer(example, 'Example', show_callable_attributes\n    =True, show_special_attributes=True)\n",
        "CUT_2": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\napp = qapplication()\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n\n    def get_text(self):\n        return self.text\nfoobar = Foobar()\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8), 'foobar': foobar}\nObjectExplorer.create_explorer(example, 'Example', show_callable_attributes\n    =True, show_special_attributes=True)\n",
        "CUT_3": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n",
        "CUT_4": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n",
        "CUT_5": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n"
    },
    {
        "functionName": "test_setup_sets_dataframe_format",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_namespacebrowser.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "browser = NamespaceBrowser(None)\nbrowser.set_shellwidget(Mock())\nbrowser.setup(exclude_private=True, exclude_uppercase=True,\n    exclude_capitalized=True, exclude_unsupported=False,\n    exclude_callables_and_modules=True, minmax=False, dataframe_format='%10.5f'\n    )\nassert browser.editor.source_model.dataframe_format == '%10.5f'\n",
        "CUT_1": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_2": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_3": "\"\"\"\n        Setup the namespace browser with provided settings.\n\n        Args:\n            dataframe_format (string): default floating-point format for \n                DataFrame editor\n        \"\"\"\nassert self.shellwidget is not None\nself.check_all = check_all\nself.exclude_private = exclude_private\nself.exclude_uppercase = exclude_uppercase\nself.exclude_capitalized = exclude_capitalized\nself.exclude_unsupported = exclude_unsupported\nself.exclude_callables_and_modules = exclude_callables_and_modules\nself.excluded_names = excluded_names\nself.minmax = minmax\nself.dataframe_format = dataframe_format\nself.show_callable_attributes = show_callable_attributes\nself.show_special_attributes = show_special_attributes\nif self.editor is not None:\n    self.editor.setup_menu(minmax)\n    self.editor.set_dataframe_format(dataframe_format)\n    self.exclude_private_action.setChecked(exclude_private)\n    self.exclude_uppercase_action.setChecked(exclude_uppercase)\n    self.exclude_capitalized_action.setChecked(exclude_capitalized)\n    self.exclude_unsupported_action.setChecked(exclude_unsupported)\n    self.exclude_callables_and_modules_action.setChecked(\n        exclude_callables_and_modules)\n    self.refresh_table()\n    return\nself.editor = RemoteCollectionsEditorTableView(self, data=None, minmax=\n    minmax, shellwidget=self.shellwidget, dataframe_format=dataframe_format,\n    show_callable_attributes=show_callable_attributes,\n    show_special_attributes=show_special_attributes)\nself.editor.sig_option_changed.connect(self.sig_option_changed.emit)\nself.editor.sig_files_dropped.connect(self.import_data)\nself.editor.sig_free_memory.connect(self.sig_free_memory.emit)\nself.setup_option_actions(exclude_private, exclude_uppercase,\n    exclude_capitalized, exclude_unsupported, exclude_callables_and_modules)\nself.tools_layout = QHBoxLayout()\ntoolbar = self.setup_toolbar()\nfor widget in toolbar:\n    self.tools_layout.addWidget(widget)\nself.tools_layout.addStretch()\nself.loading_widget = create_waitspinner(size=16, parent=self)\nself.editor.sig_open_editor.connect(self.loading_widget.start)\nself.editor.sig_editor_shown.connect(self.loading_widget.stop)\nself.tools_layout.addWidget(self.loading_widget)\nself.setup_options_button()\nlayout = create_plugin_layout(self.tools_layout, self.editor)\nfinder_layout = QHBoxLayout()\nclose_button = create_toolbutton(self, triggered=self.show_finder, icon=ima\n    .icon('DialogCloseButton'))\ntext_finder = NamespacesBrowserFinder(self.editor, callback=self.editor.\n    set_regex, main=self, regex_base=VALID_VARIABLE_CHARS)\nself.editor.finder = text_finder\nfinder_layout.addWidget(close_button)\nfinder_layout.addWidget(text_finder)\nfinder_layout.setContentsMargins(0, 0, 0, 0)\nself.finder = QWidget(self)\nself.finder.text_finder = text_finder\nself.finder.setLayout(finder_layout)\nself.finder.setVisible(False)\nlayout.addWidget(self.finder)\nself.setLayout(layout)\nself.shortcuts = self.create_shortcuts()\nself.sig_option_changed.connect(self.option_changed)\n",
        "CUT_4": "\"\"\"\n        Setup the namespace browser with provided settings.\n\n        Args:\n            dataframe_format (string): default floating-point format for \n                DataFrame editor\n        \"\"\"\nassert self.shellwidget is not None\nself.check_all = check_all\nself.exclude_private = exclude_private\nself.exclude_uppercase = exclude_uppercase\nself.exclude_capitalized = exclude_capitalized\nself.exclude_unsupported = exclude_unsupported\nself.exclude_callables_and_modules = exclude_callables_and_modules\nself.excluded_names = excluded_names\nself.minmax = minmax\nself.dataframe_format = dataframe_format\nself.show_callable_attributes = show_callable_attributes\nself.show_special_attributes = show_special_attributes\nif self.editor is not None:\n    self.editor.setup_menu(minmax)\n    self.editor.set_dataframe_format(dataframe_format)\n    self.exclude_private_action.setChecked(exclude_private)\n    self.exclude_uppercase_action.setChecked(exclude_uppercase)\n    self.exclude_capitalized_action.setChecked(exclude_capitalized)\n    self.exclude_unsupported_action.setChecked(exclude_unsupported)\n    self.exclude_callables_and_modules_action.setChecked(\n        exclude_callables_and_modules)\n    self.refresh_table()\n    return\nself.editor = RemoteCollectionsEditorTableView(self, data=None, minmax=\n    minmax, shellwidget=self.shellwidget, dataframe_format=dataframe_format,\n    show_callable_attributes=show_callable_attributes,\n    show_special_attributes=show_special_attributes)\nself.editor.sig_option_changed.connect(self.sig_option_changed.emit)\nself.editor.sig_files_dropped.connect(self.import_data)\nself.editor.sig_free_memory.connect(self.sig_free_memory.emit)\nself.setup_option_actions(exclude_private, exclude_uppercase,\n    exclude_capitalized, exclude_unsupported, exclude_callables_and_modules)\nself.tools_layout = QHBoxLayout()\ntoolbar = self.setup_toolbar()\nfor widget in toolbar:\n    self.tools_layout.addWidget(widget)\nself.tools_layout.addStretch()\nself.loading_widget = create_waitspinner(size=16, parent=self)\nself.editor.sig_open_editor.connect(self.loading_widget.start)\nself.editor.sig_editor_shown.connect(self.loading_widget.stop)\nself.tools_layout.addWidget(self.loading_widget)\nself.setup_options_button()\nlayout = create_plugin_layout(self.tools_layout, self.editor)\nfinder_layout = QHBoxLayout()\nclose_button = create_toolbutton(self, triggered=self.show_finder, icon=ima\n    .icon('DialogCloseButton'))\ntext_finder = NamespacesBrowserFinder(self.editor, callback=self.editor.\n    set_regex, main=self, regex_base=VALID_VARIABLE_CHARS)\nself.editor.finder = text_finder\nfinder_layout.addWidget(close_button)\nfinder_layout.addWidget(text_finder)\nfinder_layout.setContentsMargins(0, 0, 0, 0)\nself.finder = QWidget(self)\nself.finder.text_finder = text_finder\nself.finder.setLayout(finder_layout)\nself.finder.setVisible(False)\nlayout.addWidget(self.finder)\nself.setLayout(layout)\nself.shortcuts = self.create_shortcuts()\nself.sig_option_changed.connect(self.option_changed)\n",
        "CUT_5": "\"\"\"Get dataframe_format from source model.\"\"\"\nreturn self.sourceModel().dataframe_format\nproperty"
    },
    {
        "functionName": "test_automatic_column_width",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_namespacebrowser.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "browser = NamespaceBrowser(None)\nbrowser.set_shellwidget(Mock())\nbrowser.setup(exclude_private=True, exclude_uppercase=True,\n    exclude_capitalized=True, exclude_unsupported=False,\n    exclude_callables_and_modules=True, minmax=False)\ncol_width = [browser.editor.columnWidth(i) for i in range(4)]\nbrowser.set_data({'a_variable': {'type': 'int', 'size': 1, 'color':\n    '#0000ff', 'view': '1'}})\nnew_col_width = [browser.editor.columnWidth(i) for i in range(4)]\nassert browser.editor.automatic_column_width\nassert col_width != new_col_width\nbrowser.editor.horizontalHeader()._handle_section_is_pressed = True\nbrowser.editor.setColumnWidth(0, 100)\nassert browser.editor.automatic_column_width == False\nbrowser.set_data({'a_lengthy_variable_name_which_should_change_width': {\n    'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '1'}})\nassert browser.editor.columnWidth(0) == 100\npytest.mark.skipif(sys.platform.startswith('linux') and PY2, reason=\n    'Sometimes fails on Linux and Python 2')",
        "CUT_1": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_2": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Open Spyder Google Group in a web browser.\"\"\"\nurl = QUrl(__forum_url__)\nQDesktopServices.openUrl(url)\nSlot()"
    },
    {
        "functionName": "test_sort_by_column",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_namespacebrowser.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that clicking the header view the namespacebrowser is sorted.\n    Regression test for spyder-ide/spyder#9835 .\n    \"\"\"\nbrowser = NamespaceBrowser(None)\nqtbot.addWidget(browser)\nbrowser.set_shellwidget(Mock())\nbrowser.setup(exclude_private=True, exclude_uppercase=True,\n    exclude_capitalized=True, exclude_unsupported=False,\n    exclude_callables_and_modules=True, minmax=False)\nbrowser.set_data({'a_variable': {'type': 'int', 'size': 1, 'color':\n    '#0000ff', 'view': '1'}, 'b_variable': {'type': 'int', 'size': 1,\n    'color': '#0000ff', 'view': '2'}})\nheader = browser.editor.horizontalHeader()\nassert header.sectionsClickable()\nmodel = browser.editor.model\nassert model.rowCount() == 2\nassert model.columnCount() == 5\nassert data_table(model, 2, 4) == [['a_variable', 'b_variable'], ['int',\n    'int'], [1, 1], ['1', '2']]\nwith qtbot.waitSignal(header.sectionClicked):\n    browser.show()\n    qtbot.mouseClick(header.viewport(), Qt.LeftButton, pos=QPoint(1, 1))\nassert data_table(model, 2, 4) == [['b_variable', 'a_variable'], ['int',\n    'int'], [1, 1], ['2', '1']]\n",
        "CUT_1": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_2": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_3": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_4": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_5": "\"\"\"\n        Get the data for the header.\n\n        This is used when a header has levels.\n        \"\"\"\nif not index.isValid() or index.row() >= self._shape[0] or index.column(\n    ) >= self._shape[1]:\n    return None\nrow, col = (index.row(), index.column()) if self.axis == 0 else (index.\n    column(), index.row())\nif role != Qt.DisplayRole:\n    return None\nif self.axis == 0 and self._shape[0] <= 1:\n    return None\nheader = self.model.header(self.axis, col, row)\nif not is_type_text_string(header):\n    header = to_text_string(header)\nreturn header\n"
    },
    {
        "functionName": "test_keys_sorted_and_sort_with_large_rows",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_namespacebrowser.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that keys are sorted and sorting works as expected when\n    there's a large number of rows.\n\n    This is a regression test for issue spyder-ide/spyder#10702\n    \"\"\"\nbrowser = NamespaceBrowser(None)\nqtbot.addWidget(browser)\nbrowser.set_shellwidget(Mock())\nbrowser.setup(exclude_private=True, exclude_uppercase=True,\n    exclude_capitalized=True, exclude_unsupported=False,\n    exclude_callables_and_modules=True, minmax=False)\nvariables = {}\nvariables['i'] = {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '1'}\nfor i in range(100):\n    if i < 10:\n        var = 'd_0' + str(i)\n    else:\n        var = 'd_' + str(i)\n    variables[var] = {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '1'\n        }\nbrowser.set_data(variables)\nmodel = browser.editor.model\nassert model.rowCount() == ROWS_TO_LOAD\nassert model.canFetchMore(QModelIndex())\nassert data(model, 49, 0) == 'd_49'\nheader = browser.editor.horizontalHeader()\nwith qtbot.waitSignal(header.sectionClicked):\n    qtbot.mouseClick(header.viewport(), Qt.LeftButton, pos=QPoint(1, 1))\nassert data(model, 0, 0) == 'i'\n",
        "CUT_1": "\"\"\"Set model data\"\"\"\nreturn False\n",
        "CUT_2": "\"\"\"Set model data\"\"\"\nreturn False\n",
        "CUT_3": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_4": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_5": "\"\"\"\n        Header constructor.\n\n        The 'model' is the QAbstractTableModel of the dataframe, the 'axis' is\n        to acknowledge if is for the header (horizontal - 0) or for the\n        index (vertical - 1) and the palette is the set of colors to use.\n        \"\"\"\nsuper(DataFrameHeaderModel, self).__init__()\nself.model = model\nself.axis = axis\nself._palette = palette\nself.total_rows = self.model.shape[0]\nself.total_cols = self.model.shape[1]\nsize = self.total_rows * self.total_cols\nif size > LARGE_SIZE:\n    self.rows_loaded = ROWS_TO_LOAD\n    self.cols_loaded = COLS_TO_LOAD\nelse:\n    if self.total_cols > LARGE_COLS:\n        self.cols_loaded = COLS_TO_LOAD\n    else:\n        self.cols_loaded = self.total_cols\n    if self.total_rows > LARGE_NROWS:\n        self.rows_loaded = ROWS_TO_LOAD\n    else:\n        self.rows_loaded = self.total_rows\nif self.axis == 0:\n    self.total_cols = self.model.shape[1]\n    self._shape = self.model.header_shape[0], self.model.shape[1]\nelse:\n    self.total_rows = self.model.shape[0]\n    self._shape = self.model.shape[0], self.model.header_shape[1]\n"
    },
    {
        "functionName": "test_filtering_with_large_rows",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_namespacebrowser.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that filtering works when there's a large number of rows.\n    \"\"\"\nbrowser = NamespaceBrowser(None)\nqtbot.addWidget(browser)\nbrowser.set_shellwidget(Mock())\nbrowser.setup(exclude_private=True, exclude_uppercase=True,\n    exclude_capitalized=True, exclude_unsupported=False,\n    exclude_callables_and_modules=True, minmax=False)\nvariables = {}\nfor i in range(200):\n    letter = string.ascii_lowercase[i // 10]\n    var = letter + str(i)\n    variables[var] = {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '1'\n        }\nbrowser.set_data(variables)\nmodel = browser.editor.model\nassert model.rowCount() == ROWS_TO_LOAD\nassert model.canFetchMore(QModelIndex())\nassert data(model, 49, 0) == 'e49'\nqtbot.keyClicks(browser.finder.text_finder, 't19')\nassert model.rowCount() == 10\nfor i in range(10):\n    assert data(model, i, 0) == 't19{}'.format(i)\nbrowser.show_finder(set_visible=False)\nnew_variables = variables.copy()\nnew_variables['z'] = {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '1'\n    }\nbrowser.process_remote_view(new_variables)\nqtbot.keyClicks(browser.finder.text_finder, 'z')\nassert model.rowCount() == 1\n",
        "CUT_1": "\"\"\"Set model data\"\"\"\nreturn False\n",
        "CUT_2": "\"\"\"Set model data\"\"\"\nreturn False\n",
        "CUT_3": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_4": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_5": "if language in self.models:\n    model = self.models[language]\n    model.delete_queue = list(model.snippets)\n    self.load_snippets(language, model, defaults)\n"
    },
    {
        "functionName": "launch_arrayeditor",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Helper routine to launch an arrayeditor and return its result.\"\"\"\ndlg = ArrayEditor()\nassert dlg.setup_and_check(data, title, xlabels=xlabels, ylabels=ylabels)\ndlg.show()\ndlg.accept()\nreturn dlg.get_value()\n",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_4": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_5": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n"
    },
    {
        "functionName": "setup_arrayeditor",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Setups an arrayeditor.\"\"\"\ndlg = ArrayEditor()\ndlg.setup_and_check(data, title, xlabels=xlabels, ylabels=ylabels)\ndlg.show()\nqbot.addWidget(dlg)\nreturn dlg\n",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_4": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_5": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n"
    },
    {
        "functionName": "test_object_arrays",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that object arrays are working properly.\"\"\"\narr = np.array(['a', 1, [2]], dtype=object)\nassert_array_equal(arr, launch_arrayeditor(arr, 'object array'))\n",
        "CUT_1": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_2": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_3": "\"\"\"Load dictionary from .spydata file\"\"\"\nfilename = osp.abspath(filename)\nold_cwd = getcwd()\ntmp_folder = tempfile.mkdtemp()\nos.chdir(tmp_folder)\ndata = None\nerror_message = None\ntry:\n    with tarfile.open(filename, 'r') as tar:\n        tar.extractall()\n    pickle_filename = glob.glob('*.pickle')[0]\n    with open(pickle_filename, 'rb') as fdesc:\n        data = pickle.loads(fdesc.read())\n    saved_arrays = {}\n    if load_array is not None:\n        try:\n            saved_arrays = data.pop('__saved_arrays__')\n            for (name, index), fname in list(saved_arrays.items()):\n                arr = np.load(osp.join(tmp_folder, fname))\n                if index is None:\n                    data[name] = arr\n                elif isinstance(data[name], dict):\n                    data[name][index] = arr\n                else:\n                    data[name].insert(index, arr)\n        except KeyError:\n            pass\nexcept (AttributeError, EOFError, ValueError) as error:\n    error_message = to_text_string(error)\nfinally:\n    os.chdir(old_cwd)\n    try:\n        shutil.rmtree(tmp_folder)\n    except OSError as error:\n        error_message = to_text_string(error)\nreturn data, error_message\n",
        "CUT_4": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_5": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n"
    },
    {
        "functionName": "test_object_arrays_display",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that value_to_display is being used to display the values of\n    object arrays.\n    \"\"\"\narr = np.array([[np.array([1, 2])], 2], dtype=object)\ndlg = setup_arrayeditor(qtbot, arr)\nidx = dlg.arraywidget.model.index(0, 0)\nassert '[Numpy array]' == dlg.arraywidget.model.data(idx)\n",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "self.arraywidget = self.stack.widget(index)\nself.arraywidget.model.dataChanged.connect(self.save_and_close_enable)\n",
        "CUT_3": "self.arraywidget = self.stack.widget(index)\nself.arraywidget.model.dataChanged.connect(self.save_and_close_enable)\n",
        "CUT_4": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_5": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n"
    },
    {
        "functionName": "test_attribute_errors",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Verify that we don't get a AttributeError for certain structured arrays.\n\n    Fixes spyder-ide/spyder#11216 .\n    \"\"\"\nfrom scipy.io import loadmat\ndata = loadmat(os.path.join(HERE, 'issue_11216.mat'))\ndlg = setup_arrayeditor(qtbot, data['S'])\ncontents = dlg.arraywidget.model.get_value(dlg.arraywidget.model.index(0, 0))\nassert_array_equal(contents, data['S'][0][0][0])\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_3": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n"
    },
    {
        "functionName": "test_type_errors",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Verify that we don't get a TypeError for certain structured arrays.\n\n    Fixes spyder-ide/spyder#5254.\n    \"\"\"\narr = np.ones(2, dtype=[('X', 'f8', (2, 10)), ('S', 'S10')])\ndlg = setup_arrayeditor(qtbot, arr)\nqtbot.keyClick(dlg.arraywidget.view, Qt.Key_Down, modifier=Qt.ShiftModifier)\ncontents = dlg.arraywidget.model.get_value(dlg.arraywidget.model.index(0, 0))\nassert_array_equal(contents, np.ones(10))\n",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_3": "self.arraywidget = self.stack.widget(index)\nself.arraywidget.model.dataChanged.connect(self.save_and_close_enable)\n",
        "CUT_4": "self.arraywidget = self.stack.widget(index)\nself.arraywidget.model.dataChanged.connect(self.save_and_close_enable)\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n"
    },
    {
        "functionName": "test_arrayeditor_format",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Changes the format of the array and validates its selected content.\"\"\"\narr = np.array([1, 2, 3], dtype=np.float32)\ndlg = setup_arrayeditor(qtbot, arr, 'test array float32')\nqtbot.keyClick(dlg.arraywidget.view, Qt.Key_Down, modifier=Qt.ShiftModifier)\nqtbot.keyClick(dlg.arraywidget.view, Qt.Key_Down, modifier=Qt.ShiftModifier)\ncontents = dlg.arraywidget.view._sel_to_text(dlg.arraywidget.view.\n    selectedIndexes())\nassert contents == '1\\n2\\n'\ndlg.arraywidget.view.model().set_format('%.18e')\nassert dlg.arraywidget.view.model().get_format() == '%.18e'\nqtbot.keyClick(dlg.arraywidget.view, Qt.Key_Down, modifier=Qt.ShiftModifier)\nqtbot.keyClick(dlg.arraywidget.view, Qt.Key_Down, modifier=Qt.ShiftModifier)\ncontents = dlg.arraywidget.view._sel_to_text(dlg.arraywidget.view.\n    selectedIndexes())\nassert contents == \"\"\"1.000000000000000000e+00\n2.000000000000000000e+00\n\"\"\"\n",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "self.arraywidget = self.stack.widget(index)\nself.arraywidget.model.dataChanged.connect(self.save_and_close_enable)\n",
        "CUT_3": "self.arraywidget = self.stack.widget(index)\nself.arraywidget.model.dataChanged.connect(self.save_and_close_enable)\n",
        "CUT_4": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_5": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n"
    },
    {
        "functionName": "test_arrayeditor_with_inf_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"See: spyder-ide/spyder#8093\"\"\"\narr = np.array([np.inf])\nres = launch_arrayeditor(arr, 'inf array')\nassert len(recwarn) == 0\nassert arr == res\n",
        "CUT_1": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_2": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_3": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_4": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_5": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n"
    },
    {
        "functionName": "test_arrayeditor_with_string_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.array(['kjrekrjkejr'])\nassert arr == launch_arrayeditor(arr, 'string array')\n",
        "CUT_1": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_2": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_3": "\"\"\"Load dictionary from .spydata file\"\"\"\nfilename = osp.abspath(filename)\nold_cwd = getcwd()\ntmp_folder = tempfile.mkdtemp()\nos.chdir(tmp_folder)\ndata = None\nerror_message = None\ntry:\n    with tarfile.open(filename, 'r') as tar:\n        tar.extractall()\n    pickle_filename = glob.glob('*.pickle')[0]\n    with open(pickle_filename, 'rb') as fdesc:\n        data = pickle.loads(fdesc.read())\n    saved_arrays = {}\n    if load_array is not None:\n        try:\n            saved_arrays = data.pop('__saved_arrays__')\n            for (name, index), fname in list(saved_arrays.items()):\n                arr = np.load(osp.join(tmp_folder, fname))\n                if index is None:\n                    data[name] = arr\n                elif isinstance(data[name], dict):\n                    data[name][index] = arr\n                else:\n                    data[name].insert(index, arr)\n        except KeyError:\n            pass\nexcept (AttributeError, EOFError, ValueError) as error:\n    error_message = to_text_string(error)\nfinally:\n    os.chdir(old_cwd)\n    try:\n        shutil.rmtree(tmp_folder)\n    except OSError as error:\n        error_message = to_text_string(error)\nreturn data, error_message\n",
        "CUT_4": "\"\"\"Return array's shape\"\"\"\nraise NotImplementedError\n",
        "CUT_5": "\"\"\"Return array's shape\"\"\"\nraise NotImplementedError\n"
    },
    {
        "functionName": "test_arrayeditor_with_unicode_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.array(['\u00f1\u00f1\u00f1\u00e9\u00e1\u00ed\u00f3'])\nassert arr == launch_arrayeditor(arr, 'unicode array')\n",
        "CUT_1": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_2": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_3": "\"\"\"Load dictionary from .spydata file\"\"\"\nfilename = osp.abspath(filename)\nold_cwd = getcwd()\ntmp_folder = tempfile.mkdtemp()\nos.chdir(tmp_folder)\ndata = None\nerror_message = None\ntry:\n    with tarfile.open(filename, 'r') as tar:\n        tar.extractall()\n    pickle_filename = glob.glob('*.pickle')[0]\n    with open(pickle_filename, 'rb') as fdesc:\n        data = pickle.loads(fdesc.read())\n    saved_arrays = {}\n    if load_array is not None:\n        try:\n            saved_arrays = data.pop('__saved_arrays__')\n            for (name, index), fname in list(saved_arrays.items()):\n                arr = np.load(osp.join(tmp_folder, fname))\n                if index is None:\n                    data[name] = arr\n                elif isinstance(data[name], dict):\n                    data[name][index] = arr\n                else:\n                    data[name].insert(index, arr)\n        except KeyError:\n            pass\nexcept (AttributeError, EOFError, ValueError) as error:\n    error_message = to_text_string(error)\nfinally:\n    os.chdir(old_cwd)\n    try:\n        shutil.rmtree(tmp_folder)\n    except OSError as error:\n        error_message = to_text_string(error)\nreturn data, error_message\n",
        "CUT_4": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_5": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n"
    },
    {
        "functionName": "test_arrayeditor_with_masked_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.ma.array([[1, 0], [1, 0]], mask=[[True, False], [False, False]])\nassert_array_equal(arr, launch_arrayeditor(arr, 'masked array'))\n",
        "CUT_1": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_2": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_3": "\"\"\"Load dictionary from .spydata file\"\"\"\nfilename = osp.abspath(filename)\nold_cwd = getcwd()\ntmp_folder = tempfile.mkdtemp()\nos.chdir(tmp_folder)\ndata = None\nerror_message = None\ntry:\n    with tarfile.open(filename, 'r') as tar:\n        tar.extractall()\n    pickle_filename = glob.glob('*.pickle')[0]\n    with open(pickle_filename, 'rb') as fdesc:\n        data = pickle.loads(fdesc.read())\n    saved_arrays = {}\n    if load_array is not None:\n        try:\n            saved_arrays = data.pop('__saved_arrays__')\n            for (name, index), fname in list(saved_arrays.items()):\n                arr = np.load(osp.join(tmp_folder, fname))\n                if index is None:\n                    data[name] = arr\n                elif isinstance(data[name], dict):\n                    data[name][index] = arr\n                else:\n                    data[name].insert(index, arr)\n        except KeyError:\n            pass\nexcept (AttributeError, EOFError, ValueError) as error:\n    error_message = to_text_string(error)\nfinally:\n    os.chdir(old_cwd)\n    try:\n        shutil.rmtree(tmp_folder)\n    except OSError as error:\n        error_message = to_text_string(error)\nreturn data, error_message\n",
        "CUT_4": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_5": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n"
    },
    {
        "functionName": "test_arrayeditor_with_record_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.zeros((2, 2), {'names': ('red', 'green', 'blue'), 'formats': (np.\n    float32, np.float32, np.float32)})\nassert_array_equal(arr, launch_arrayeditor(arr, 'record array'))\n",
        "CUT_1": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_2": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_3": "QAbstractTableModel.__init__(self)\nself.dialog = parent\nself.changes = {}\nself.xlabels = xlabels\nself.ylabels = ylabels\nself.readonly = readonly\nself.test_array = np.array([0], dtype=data.dtype)\nif data.dtype in (np.complex64, np.complex128):\n    self.color_func = np.abs\nelse:\n    self.color_func = np.real\nhuerange = [0.66, 0.99]\nself.sat = 0.7\nself.val = 1.0\nself.alp = 0.6\nself._data = data\nself._format = format\nself.total_rows = self._data.shape[0]\nself.total_cols = self._data.shape[1]\nsize = self.total_rows * self.total_cols\ntry:\n    self.vmin = np.nanmin(self.color_func(data))\n    self.vmax = np.nanmax(self.color_func(data))\n    if self.vmax == self.vmin:\n        self.vmin -= 1\n    self.hue0 = huerange[0]\n    self.dhue = huerange[1] - huerange[0]\n    self.bgcolor_enabled = True\nexcept (AttributeError, TypeError, ValueError):\n    self.vmin = None\n    self.vmax = None\n    self.hue0 = None\n    self.dhue = None\n    self.bgcolor_enabled = False\nself.has_inf = False\nif data.dtype.kind in ['f', 'c']:\n    self.has_inf = np.any(np.isinf(data))\nif self._data.dtype.name == 'object' or self.has_inf:\n    self.bgcolor_enabled = False\nif size > LARGE_SIZE:\n    self.rows_loaded = self.ROWS_TO_LOAD\n    self.cols_loaded = self.COLS_TO_LOAD\nelse:\n    if self.total_rows > LARGE_NROWS:\n        self.rows_loaded = self.ROWS_TO_LOAD\n    else:\n        self.rows_loaded = self.total_rows\n    if self.total_cols > LARGE_COLS:\n        self.cols_loaded = self.COLS_TO_LOAD\n    else:\n        self.cols_loaded = self.total_cols\n",
        "CUT_4": "QAbstractTableModel.__init__(self)\nself.dialog = parent\nself.changes = {}\nself.xlabels = xlabels\nself.ylabels = ylabels\nself.readonly = readonly\nself.test_array = np.array([0], dtype=data.dtype)\nif data.dtype in (np.complex64, np.complex128):\n    self.color_func = np.abs\nelse:\n    self.color_func = np.real\nhuerange = [0.66, 0.99]\nself.sat = 0.7\nself.val = 1.0\nself.alp = 0.6\nself._data = data\nself._format = format\nself.total_rows = self._data.shape[0]\nself.total_cols = self._data.shape[1]\nsize = self.total_rows * self.total_cols\ntry:\n    self.vmin = np.nanmin(self.color_func(data))\n    self.vmax = np.nanmax(self.color_func(data))\n    if self.vmax == self.vmin:\n        self.vmin -= 1\n    self.hue0 = huerange[0]\n    self.dhue = huerange[1] - huerange[0]\n    self.bgcolor_enabled = True\nexcept (AttributeError, TypeError, ValueError):\n    self.vmin = None\n    self.vmax = None\n    self.hue0 = None\n    self.dhue = None\n    self.bgcolor_enabled = False\nself.has_inf = False\nif data.dtype.kind in ['f', 'c']:\n    self.has_inf = np.any(np.isinf(data))\nif self._data.dtype.name == 'object' or self.has_inf:\n    self.bgcolor_enabled = False\nif size > LARGE_SIZE:\n    self.rows_loaded = self.ROWS_TO_LOAD\n    self.cols_loaded = self.COLS_TO_LOAD\nelse:\n    if self.total_rows > LARGE_NROWS:\n        self.rows_loaded = self.ROWS_TO_LOAD\n    else:\n        self.rows_loaded = self.total_rows\n    if self.total_cols > LARGE_COLS:\n        self.cols_loaded = self.COLS_TO_LOAD\n    else:\n        self.cols_loaded = self.total_cols\n",
        "CUT_5": "\"\"\"Return NumPy data type associated to obj\n    Return None if NumPy is not available\n    or if obj is not a NumPy array or scalar\"\"\"\nif ndarray is not FakeObject:\n    import numpy as np\n    if isinstance(obj, np.generic) or isinstance(obj, np.ndarray):\n        try:\n            return obj.dtype.type\n        except (AttributeError, RuntimeError):\n            return\n"
    },
    {
        "functionName": "test_arrayeditor_with_record_array_with_titles",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.array([(0, 0.0), (0, 0.0), (0, 0.0)], dtype=[(('title 1', 'x'),\n    '|i1'), (('title 2', 'y'), '>f4')])\nassert_array_equal(arr, launch_arrayeditor(arr, 'record array with titles'))\npytest.mark.skipif(not os.name == 'nt', reason=\n    'It segfaults sometimes on Linux')",
        "CUT_1": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_2": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_3": "\"\"\"Load dictionary from .spydata file\"\"\"\nfilename = osp.abspath(filename)\nold_cwd = getcwd()\ntmp_folder = tempfile.mkdtemp()\nos.chdir(tmp_folder)\ndata = None\nerror_message = None\ntry:\n    with tarfile.open(filename, 'r') as tar:\n        tar.extractall()\n    pickle_filename = glob.glob('*.pickle')[0]\n    with open(pickle_filename, 'rb') as fdesc:\n        data = pickle.loads(fdesc.read())\n    saved_arrays = {}\n    if load_array is not None:\n        try:\n            saved_arrays = data.pop('__saved_arrays__')\n            for (name, index), fname in list(saved_arrays.items()):\n                arr = np.load(osp.join(tmp_folder, fname))\n                if index is None:\n                    data[name] = arr\n                elif isinstance(data[name], dict):\n                    data[name][index] = arr\n                else:\n                    data[name].insert(index, arr)\n        except KeyError:\n            pass\nexcept (AttributeError, EOFError, ValueError) as error:\n    error_message = to_text_string(error)\nfinally:\n    os.chdir(old_cwd)\n    try:\n        shutil.rmtree(tmp_folder)\n    except OSError as error:\n        error_message = to_text_string(error)\nreturn data, error_message\n",
        "CUT_4": "\"\"\"Return widget title\"\"\"\ntitle = _('Editor')\nreturn title\n",
        "CUT_5": "\"\"\"Return widget title\"\"\"\ntitle = _('Editor')\nreturn title\n"
    },
    {
        "functionName": "test_arrayeditor_with_float_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.random.rand(5, 5)\nassert_array_equal(arr, launch_arrayeditor(arr, 'float array', xlabels=['a',\n    'b', 'c', 'd', 'e']))\n",
        "CUT_1": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_2": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_3": "\"\"\"Load dictionary from .spydata file\"\"\"\nfilename = osp.abspath(filename)\nold_cwd = getcwd()\ntmp_folder = tempfile.mkdtemp()\nos.chdir(tmp_folder)\ndata = None\nerror_message = None\ntry:\n    with tarfile.open(filename, 'r') as tar:\n        tar.extractall()\n    pickle_filename = glob.glob('*.pickle')[0]\n    with open(pickle_filename, 'rb') as fdesc:\n        data = pickle.loads(fdesc.read())\n    saved_arrays = {}\n    if load_array is not None:\n        try:\n            saved_arrays = data.pop('__saved_arrays__')\n            for (name, index), fname in list(saved_arrays.items()):\n                arr = np.load(osp.join(tmp_folder, fname))\n                if index is None:\n                    data[name] = arr\n                elif isinstance(data[name], dict):\n                    data[name][index] = arr\n                else:\n                    data[name].insert(index, arr)\n        except KeyError:\n            pass\nexcept (AttributeError, EOFError, ValueError) as error:\n    error_message = to_text_string(error)\nfinally:\n    os.chdir(old_cwd)\n    try:\n        shutil.rmtree(tmp_folder)\n    except OSError as error:\n        error_message = to_text_string(error)\nreturn data, error_message\n",
        "CUT_4": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_5": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n"
    },
    {
        "functionName": "test_arrayeditor_with_complex_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.round(np.random.rand(5, 5) * 10) + np.round(np.random.rand(5, 5) * 10\n    ) * 1.0j\nassert_array_equal(arr, launch_arrayeditor(arr, 'complex array', xlabels=np\n    .linspace(-12, 12, 5), ylabels=np.linspace(-12, 12, 5)))\n",
        "CUT_1": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_2": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_3": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n",
        "CUT_4": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n",
        "CUT_5": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\napp = qapplication()\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n\n    def get_text(self):\n        return self.text\nfoobar = Foobar()\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8), 'foobar': foobar}\nObjectExplorer.create_explorer(example, 'Example', show_callable_attributes\n    =True, show_special_attributes=True)\n"
    },
    {
        "functionName": "test_arrayeditor_with_bool_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr_in = np.array([True, False, True])\narr_out = launch_arrayeditor(arr_in, 'bool array')\nassert arr_in is arr_out\n",
        "CUT_1": "\"\"\"Return True if variable is a numpy array\"\"\"\nraise NotImplementedError\n",
        "CUT_2": "\"\"\"Return True if variable is a numpy array\"\"\"\nraise NotImplementedError\n",
        "CUT_3": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_4": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_5": "\"\"\"Return array's shape\"\"\"\nraise NotImplementedError\n"
    },
    {
        "functionName": "test_arrayeditor_with_int8_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.array([1, 2, 3], dtype='int8')\nassert_array_equal(arr, launch_arrayeditor(arr, 'int array'))\n",
        "CUT_1": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_2": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_3": "\"\"\"Load dictionary from .spydata file\"\"\"\nfilename = osp.abspath(filename)\nold_cwd = getcwd()\ntmp_folder = tempfile.mkdtemp()\nos.chdir(tmp_folder)\ndata = None\nerror_message = None\ntry:\n    with tarfile.open(filename, 'r') as tar:\n        tar.extractall()\n    pickle_filename = glob.glob('*.pickle')[0]\n    with open(pickle_filename, 'rb') as fdesc:\n        data = pickle.loads(fdesc.read())\n    saved_arrays = {}\n    if load_array is not None:\n        try:\n            saved_arrays = data.pop('__saved_arrays__')\n            for (name, index), fname in list(saved_arrays.items()):\n                arr = np.load(osp.join(tmp_folder, fname))\n                if index is None:\n                    data[name] = arr\n                elif isinstance(data[name], dict):\n                    data[name][index] = arr\n                else:\n                    data[name].insert(index, arr)\n        except KeyError:\n            pass\nexcept (AttributeError, EOFError, ValueError) as error:\n    error_message = to_text_string(error)\nfinally:\n    os.chdir(old_cwd)\n    try:\n        shutil.rmtree(tmp_folder)\n    except OSError as error:\n        error_message = to_text_string(error)\nreturn data, error_message\n",
        "CUT_4": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_5": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n"
    },
    {
        "functionName": "test_arrayeditor_with_float16_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.zeros((5, 5), dtype=np.float16)\nassert_array_equal(arr, launch_arrayeditor(arr, 'float16 array'))\n",
        "CUT_1": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_2": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_3": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_4": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_5": "\"\"\"Load dictionary from .spydata file\"\"\"\nfilename = osp.abspath(filename)\nold_cwd = getcwd()\ntmp_folder = tempfile.mkdtemp()\nos.chdir(tmp_folder)\ndata = None\nerror_message = None\ntry:\n    with tarfile.open(filename, 'r') as tar:\n        tar.extractall()\n    pickle_filename = glob.glob('*.pickle')[0]\n    with open(pickle_filename, 'rb') as fdesc:\n        data = pickle.loads(fdesc.read())\n    saved_arrays = {}\n    if load_array is not None:\n        try:\n            saved_arrays = data.pop('__saved_arrays__')\n            for (name, index), fname in list(saved_arrays.items()):\n                arr = np.load(osp.join(tmp_folder, fname))\n                if index is None:\n                    data[name] = arr\n                elif isinstance(data[name], dict):\n                    data[name][index] = arr\n                else:\n                    data[name].insert(index, arr)\n        except KeyError:\n            pass\nexcept (AttributeError, EOFError, ValueError) as error:\n    error_message = to_text_string(error)\nfinally:\n    os.chdir(old_cwd)\n    try:\n        shutil.rmtree(tmp_folder)\n    except OSError as error:\n        error_message = to_text_string(error)\nreturn data, error_message\n"
    },
    {
        "functionName": "test_arrayeditor_with_3d_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.zeros((3, 3, 4))\narr[0, 0, 0] = 1\narr[0, 0, 1] = 2\narr[0, 0, 2] = 3\nassert_array_equal(arr, launch_arrayeditor(arr, '3D array'))\n",
        "CUT_1": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_2": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_3": "\"\"\"Load dictionary from .spydata file\"\"\"\nfilename = osp.abspath(filename)\nold_cwd = getcwd()\ntmp_folder = tempfile.mkdtemp()\nos.chdir(tmp_folder)\ndata = None\nerror_message = None\ntry:\n    with tarfile.open(filename, 'r') as tar:\n        tar.extractall()\n    pickle_filename = glob.glob('*.pickle')[0]\n    with open(pickle_filename, 'rb') as fdesc:\n        data = pickle.loads(fdesc.read())\n    saved_arrays = {}\n    if load_array is not None:\n        try:\n            saved_arrays = data.pop('__saved_arrays__')\n            for (name, index), fname in list(saved_arrays.items()):\n                arr = np.load(osp.join(tmp_folder, fname))\n                if index is None:\n                    data[name] = arr\n                elif isinstance(data[name], dict):\n                    data[name][index] = arr\n                else:\n                    data[name].insert(index, arr)\n        except KeyError:\n            pass\nexcept (AttributeError, EOFError, ValueError) as error:\n    error_message = to_text_string(error)\nfinally:\n    os.chdir(old_cwd)\n    try:\n        shutil.rmtree(tmp_folder)\n    except OSError as error:\n        error_message = to_text_string(error)\nreturn data, error_message\n",
        "CUT_4": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_5": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n"
    },
    {
        "functionName": "test_arrayeditor_with_empty_3d_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.zeros((0, 10, 2))\nassert_array_equal(arr, launch_arrayeditor(arr, '3D array'))\narr = np.zeros((1, 10, 2))\nassert_array_equal(arr, launch_arrayeditor(arr, '3D array'))\n",
        "CUT_1": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_2": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    try:\n        data = dicomio.read_file(filename, force=True)\n    except TypeError:\n        data = dicomio.read_file(filename)\n    arr = data.pixel_array\n    return {name: arr}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_3": "\"\"\"Load dictionary from .spydata file\"\"\"\nfilename = osp.abspath(filename)\nold_cwd = getcwd()\ntmp_folder = tempfile.mkdtemp()\nos.chdir(tmp_folder)\ndata = None\nerror_message = None\ntry:\n    with tarfile.open(filename, 'r') as tar:\n        tar.extractall()\n    pickle_filename = glob.glob('*.pickle')[0]\n    with open(pickle_filename, 'rb') as fdesc:\n        data = pickle.loads(fdesc.read())\n    saved_arrays = {}\n    if load_array is not None:\n        try:\n            saved_arrays = data.pop('__saved_arrays__')\n            for (name, index), fname in list(saved_arrays.items()):\n                arr = np.load(osp.join(tmp_folder, fname))\n                if index is None:\n                    data[name] = arr\n                elif isinstance(data[name], dict):\n                    data[name][index] = arr\n                else:\n                    data[name].insert(index, arr)\n        except KeyError:\n            pass\nexcept (AttributeError, EOFError, ValueError) as error:\n    error_message = to_text_string(error)\nfinally:\n    os.chdir(old_cwd)\n    try:\n        shutil.rmtree(tmp_folder)\n    except OSError as error:\n        error_message = to_text_string(error)\nreturn data, error_message\n",
        "CUT_4": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_5": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n"
    },
    {
        "functionName": "test_arrayeditor_edit_1d_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "exp_arr = np.array([1, 0, 2, 3, 4])\narr = np.arange(0, 5)\ndlg = ArrayEditor()\nassert dlg.setup_and_check(arr, '1D array', xlabels=None, ylabels=None)\ndlg.show()\nqtbot.waitForWindowShown(dlg)\nview = dlg.arraywidget.view\nqtbot.keyPress(view, Qt.Key_Down)\nqtbot.keyPress(view, Qt.Key_Up)\nqtbot.keyClicks(view, '1')\nqtbot.keyPress(view, Qt.Key_Down)\nqtbot.keyClicks(view, '0')\nqtbot.keyPress(view, Qt.Key_Down)\nqtbot.keyPress(view, Qt.Key_Return)\nassert np.sum(exp_arr == dlg.get_value()) == 5\n",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_3": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_4": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_5": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n"
    },
    {
        "functionName": "test_arrayeditor_edit_2d_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "arr = np.ones((3, 3))\ndiff_arr = arr.copy()\ndlg = ArrayEditor()\nassert dlg.setup_and_check(arr, '2D array', xlabels=None, ylabels=None)\ndlg.show()\nqtbot.waitForWindowShown(dlg)\nview = dlg.arraywidget.view\nqtbot.keyPress(view, Qt.Key_Down)\nqtbot.keyPress(view, Qt.Key_Right)\nqtbot.keyClicks(view, '3')\nqtbot.keyPress(view, Qt.Key_Down)\nqtbot.keyPress(view, Qt.Key_Right)\nqtbot.keyClicks(view, '0')\nqtbot.keyPress(view, Qt.Key_Left)\nqtbot.keyPress(view, Qt.Key_Return)\nassert np.sum(diff_arr != dlg.get_value()) == 2\npytest.mark.skipif(sys.platform == 'darwin', reason='It fails on macOS')",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_3": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_4": "\"\"\"Set the current namespace view.\"\"\"\nif self.namespacebrowser is not None:\n    self.namespacebrowser.process_remote_view(view)\n",
        "CUT_5": "\"\"\"Set the current namespace view.\"\"\"\nif self.namespacebrowser is not None:\n    self.namespacebrowser.process_remote_view(view)\n"
    },
    {
        "functionName": "test_arrayeditor_edit_complex_array",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"See: spyder-ide/spyder#7848\"\"\"\ncnum = -1 + 0.5j\narr = (np.random.random((10, 10)) - 0.5) * cnum\ndlg = ArrayEditor()\nassert dlg.setup_and_check(arr, '2D complex array', xlabels=None, ylabels=None)\ndlg.show()\nqtbot.waitForWindowShown(dlg)\nview = dlg.arraywidget.view\nqtbot.keyPress(view, Qt.Key_Down)\nqtbot.wait(300)\ncell_editor = view.viewport().focusWidget()\nqtbot.keyClicks(cell_editor, str(cnum))\nqtbot.keyPress(cell_editor, Qt.Key_Return)\ndlg.accept()\npytest.mark.skipif(sys.platform.startswith('linux'), reason=\n    'Sometimes fails on Linux ')pytest.mark.slow",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n"
    },
    {
        "functionName": "test_arraymodel_set_data_overflow",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that entry of an overflowing integer is caught and handled properly.\n\n    Unit regression test for spyder-ide/spyder#6114.\n    \"\"\"\nMockQMessageBox = Mock()\nattr_to_patch = (\n    'spyder.plugins.variableexplorer.widgets.arrayeditor.QMessageBox')\nmonkeypatch.setattr(attr_to_patch, MockQMessageBox)\nif not os.name == 'nt':\n    int32_bit_exponent = 66\nelse:\n    int32_bit_exponent = 34\ntest_parameters = [(1, np.int32, int32_bit_exponent), (2, np.int64, 66)]\nfor idx, int_type, bit_exponent in test_parameters:\n    test_array = np.array([[5], [6], [7], [3], [4]], dtype=int_type)\n    model = ArrayModel(test_array.copy())\n    index = model.createIndex(0, 2)\n    assert not model.setData(index, str(int(2 ** bit_exponent)))\n    MockQMessageBox.critical.assert_called_with(ANY, 'Error', ANY)\n    assert MockQMessageBox.critical.call_count == idx\n    assert np.sum(test_array == model._data) == len(test_array)\n",
        "CUT_1": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_2": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_3": "QAbstractTableModel.__init__(self)\nself.dialog = parent\nself.changes = {}\nself.xlabels = xlabels\nself.ylabels = ylabels\nself.readonly = readonly\nself.test_array = np.array([0], dtype=data.dtype)\nif data.dtype in (np.complex64, np.complex128):\n    self.color_func = np.abs\nelse:\n    self.color_func = np.real\nhuerange = [0.66, 0.99]\nself.sat = 0.7\nself.val = 1.0\nself.alp = 0.6\nself._data = data\nself._format = format\nself.total_rows = self._data.shape[0]\nself.total_cols = self._data.shape[1]\nsize = self.total_rows * self.total_cols\ntry:\n    self.vmin = np.nanmin(self.color_func(data))\n    self.vmax = np.nanmax(self.color_func(data))\n    if self.vmax == self.vmin:\n        self.vmin -= 1\n    self.hue0 = huerange[0]\n    self.dhue = huerange[1] - huerange[0]\n    self.bgcolor_enabled = True\nexcept (AttributeError, TypeError, ValueError):\n    self.vmin = None\n    self.vmax = None\n    self.hue0 = None\n    self.dhue = None\n    self.bgcolor_enabled = False\nself.has_inf = False\nif data.dtype.kind in ['f', 'c']:\n    self.has_inf = np.any(np.isinf(data))\nif self._data.dtype.name == 'object' or self.has_inf:\n    self.bgcolor_enabled = False\nif size > LARGE_SIZE:\n    self.rows_loaded = self.ROWS_TO_LOAD\n    self.cols_loaded = self.COLS_TO_LOAD\nelse:\n    if self.total_rows > LARGE_NROWS:\n        self.rows_loaded = self.ROWS_TO_LOAD\n    else:\n        self.rows_loaded = self.total_rows\n    if self.total_cols > LARGE_COLS:\n        self.cols_loaded = self.COLS_TO_LOAD\n    else:\n        self.cols_loaded = self.total_cols\n",
        "CUT_4": "QAbstractTableModel.__init__(self)\nself.dialog = parent\nself.changes = {}\nself.xlabels = xlabels\nself.ylabels = ylabels\nself.readonly = readonly\nself.test_array = np.array([0], dtype=data.dtype)\nif data.dtype in (np.complex64, np.complex128):\n    self.color_func = np.abs\nelse:\n    self.color_func = np.real\nhuerange = [0.66, 0.99]\nself.sat = 0.7\nself.val = 1.0\nself.alp = 0.6\nself._data = data\nself._format = format\nself.total_rows = self._data.shape[0]\nself.total_cols = self._data.shape[1]\nsize = self.total_rows * self.total_cols\ntry:\n    self.vmin = np.nanmin(self.color_func(data))\n    self.vmax = np.nanmax(self.color_func(data))\n    if self.vmax == self.vmin:\n        self.vmin -= 1\n    self.hue0 = huerange[0]\n    self.dhue = huerange[1] - huerange[0]\n    self.bgcolor_enabled = True\nexcept (AttributeError, TypeError, ValueError):\n    self.vmin = None\n    self.vmax = None\n    self.hue0 = None\n    self.dhue = None\n    self.bgcolor_enabled = False\nself.has_inf = False\nif data.dtype.kind in ['f', 'c']:\n    self.has_inf = np.any(np.isinf(data))\nif self._data.dtype.name == 'object' or self.has_inf:\n    self.bgcolor_enabled = False\nif size > LARGE_SIZE:\n    self.rows_loaded = self.ROWS_TO_LOAD\n    self.cols_loaded = self.COLS_TO_LOAD\nelse:\n    if self.total_rows > LARGE_NROWS:\n        self.rows_loaded = self.ROWS_TO_LOAD\n    else:\n        self.rows_loaded = self.total_rows\n    if self.total_cols > LARGE_COLS:\n        self.cols_loaded = self.COLS_TO_LOAD\n    else:\n        self.cols_loaded = self.total_cols\n",
        "CUT_5": "\"\"\"Save all items expanded state\"\"\"\nmodel = self.model()\nif model is not None:\n    self.__expanded_state = []\n    for idx in model.persistentIndexList():\n        if self.isExpanded(idx):\n            self.__expanded_state.append(self.get_filename(idx))\n"
    },
    {
        "functionName": "test_arrayeditor_edit_overflow",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_arrayeditor.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that entry of an overflowing integer is caught and handled properly.\n\n    Integration regression test for spyder-ide/spyder#6114.\n    \"\"\"\nMockQMessageBox = Mock()\nattr_to_patch = (\n    'spyder.plugins.variableexplorer.widgets.arrayeditor.QMessageBox')\nmonkeypatch.setattr(attr_to_patch, MockQMessageBox)\nif not os.name == 'nt':\n    int32_bit_exponent = 66\nelse:\n    int32_bit_exponent = 34\ntest_parameters = [(1, np.int32, int32_bit_exponent), (2, np.int64, 66)]\nexpected_array = np.array([5, 6, 7, 3, 4])\nfor idx, int_type, bit_exponent in test_parameters:\n    test_array = np.arange(0, 5).astype(int_type)\n    dialog = ArrayEditor()\n    assert dialog.setup_and_check(test_array, '1D array', xlabels=None,\n        ylabels=None)\n    dialog.show()\n    qtbot.waitForWindowShown(dialog)\n    view = dialog.arraywidget.view\n    qtbot.keyClick(view, Qt.Key_Down)\n    qtbot.keyClick(view, Qt.Key_Up)\n    qtbot.keyClicks(view, '5')\n    qtbot.keyClick(view, Qt.Key_Down)\n    qtbot.keyClick(view, Qt.Key_Space)\n    qtbot.keyClicks(view.focusWidget(), str(int(2 ** bit_exponent)))\n    qtbot.keyClick(view.focusWidget(), Qt.Key_Down)\n    MockQMessageBox.critical.assert_called_with(ANY, 'Error', ANY)\n    assert MockQMessageBox.critical.call_count == idx\n    qtbot.keyClicks(view, '7')\n    qtbot.keyClick(view, Qt.Key_Up)\n    qtbot.keyClicks(view, '6')\n    qtbot.keyClick(view, Qt.Key_Down)\n    qtbot.wait(200)\n    dialog.accept()\n    qtbot.wait(500)\n    assert np.sum(expected_array == dialog.get_value()) == len(expected_array)\npytest.mark.skipif(sys.platform == 'darwin', reason='It fails on macOS')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"\n        Return the namespace view\n\n        This is a dictionary with the following structure\n\n        {'a': {'color': '#800000', 'size': 1, 'type': 'str', 'view': '1'}}\n\n        Here:\n        * 'a' is the variable name\n        * 'color' is the color used to show it\n        * 'size' and 'type' are self-evident\n        * and'view' is its value or the text shown in the last column\n        \"\"\"\nfrom spyder_kernels.utils.nsview import make_remote_view\nsettings = self.namespace_view_settings\nif settings:\n    ns = self._get_current_namespace()\n    view = make_remote_view(ns, settings, EXCLUDED_NAMES)\n    return view\nelse:\n    return None\n",
        "CUT_5": "\"\"\"Set the current namespace view.\"\"\"\nif self.namespacebrowser is not None:\n    self.namespacebrowser.process_remote_view(view)\n"
    },
    {
        "functionName": "colorclose",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Compares HSV values which are stored as 16-bit integers.\n    \"\"\"\nhsva_actual = color.getHsvF()\nreturn all(abs(a - b) <= 2 ** -16 for a, b in zip(hsva_actual, hsva_expected))\n",
        "CUT_1": "super().__init__(parent, title=title or '')\nself._icon_size = QSize(16, 16)\nself.setObjectName('main_widget_toolbar_{}'.format(str(uuid.uuid4())[:8]))\nself.setFloatable(False)\nself.setMovable(False)\nself.setContextMenuPolicy(Qt.PreventContextMenu)\nself.setIconSize(self._icon_size)\nself._setup_style()\nself._filter = ToolTipFilter()\n",
        "CUT_2": "super().__init__(parent, title=title or '')\nself._icon_size = QSize(16, 16)\nself.setObjectName('main_widget_toolbar_{}'.format(str(uuid.uuid4())[:8]))\nself.setFloatable(False)\nself.setMovable(False)\nself.setContextMenuPolicy(Qt.PreventContextMenu)\nself.setIconSize(self._icon_size)\nself._setup_style()\nself._filter = ToolTipFilter()\n",
        "CUT_3": "\"\"\"Sets the foreground color.\n        :param color: Color\n        :type color: QtGui.QColor\n        \"\"\"\nself.format.setForeground(color)\n",
        "CUT_4": "\"\"\"Sets the foreground color.\n        :param color: Color\n        :type color: QtGui.QColor\n        \"\"\"\nself.format.setForeground(color)\n",
        "CUT_5": "color = text_to_qcolor(text)\nif color.isValid():\n    self.colorbtn.color = color\n"
    },
    {
        "functionName": "data",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return dfm.data(dfm.createIndex(i, j))\n",
        "CUT_1": "try:\n    return self.createIndex(self.keys.index(key), 0)\nexcept (RuntimeError, ValueError):\n    return QModelIndex()\n",
        "CUT_2": "try:\n    return self.createIndex(self.keys.index(key), 0)\nexcept (RuntimeError, ValueError):\n    return QModelIndex()\n",
        "CUT_3": "\"\"\"The model index that point to the inspectedItem.\"\"\"\nif self.inspectedNodeIsVisible:\n    return self.createIndex(0, 0, self._inspected_item)\nelse:\n    return self.rootIndex()\n",
        "CUT_4": "\"\"\"The model index that point to the inspectedItem.\"\"\"\nif self.inspectedNodeIsVisible:\n    return self.createIndex(0, 0, self._inspected_item)\nelse:\n    return self.rootIndex()\n",
        "CUT_5": "if self.data:\n    return self.data[self.get_stack_index()]\n"
    },
    {
        "functionName": "bgcolor",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return dfm.get_bgcolor(dfm.createIndex(i, j))\n",
        "CUT_1": "try:\n    return self.createIndex(self.keys.index(key), 0)\nexcept (RuntimeError, ValueError):\n    return QModelIndex()\n",
        "CUT_2": "try:\n    return self.createIndex(self.keys.index(key), 0)\nexcept (RuntimeError, ValueError):\n    return QModelIndex()\n",
        "CUT_3": "\"\"\"The model index that point to the inspectedItem.\"\"\"\nif self.inspectedNodeIsVisible:\n    return self.createIndex(0, 0, self._inspected_item)\nelse:\n    return self.rootIndex()\n",
        "CUT_4": "\"\"\"The model index that point to the inspectedItem.\"\"\"\nif self.inspectedNodeIsVisible:\n    return self.createIndex(0, 0, self._inspected_item)\nelse:\n    return self.rootIndex()\n",
        "CUT_5": "return (a > b) - (a < b)\n"
    },
    {
        "functionName": "data_header",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return dfh.data(dfh.createIndex(i, j), role)\n",
        "CUT_1": "try:\n    return self.createIndex(self.keys.index(key), 0)\nexcept (RuntimeError, ValueError):\n    return QModelIndex()\n",
        "CUT_2": "try:\n    return self.createIndex(self.keys.index(key), 0)\nexcept (RuntimeError, ValueError):\n    return QModelIndex()\n",
        "CUT_3": "\"\"\"The model index that point to the inspectedItem.\"\"\"\nif self.inspectedNodeIsVisible:\n    return self.createIndex(0, 0, self._inspected_item)\nelse:\n    return self.rootIndex()\n",
        "CUT_4": "\"\"\"The model index that point to the inspectedItem.\"\"\"\nif self.inspectedNodeIsVisible:\n    return self.createIndex(0, 0, self._inspected_item)\nelse:\n    return self.rootIndex()\n",
        "CUT_5": "\"\"\"Get the information of the levels.\"\"\"\nif not index.isValid():\n    return None\nif role == Qt.FontRole:\n    return self._font\nlabel = ''\nif index.column() == self.model.header_shape[1] - 1:\n    label = str(self.model.name(0, index.row()))\nelif index.row() == self.model.header_shape[0] - 1:\n    label = str(self.model.name(1, index.column()))\nif role == Qt.DisplayRole and label:\n    return label\nelif role == Qt.ForegroundRole:\n    return self._foreground\nelif role == Qt.BackgroundRole:\n    return self._background\nelif role == Qt.BackgroundRole:\n    return self._palette.window()\nreturn None\n"
    },
    {
        "functionName": "data_index",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return dfi.data(dfi.createIndex(i, j), role)\n",
        "CUT_1": "try:\n    return self.createIndex(self.keys.index(key), 0)\nexcept (RuntimeError, ValueError):\n    return QModelIndex()\n",
        "CUT_2": "try:\n    return self.createIndex(self.keys.index(key), 0)\nexcept (RuntimeError, ValueError):\n    return QModelIndex()\n",
        "CUT_3": "\"\"\"The model index that point to the inspectedItem.\"\"\"\nif self.inspectedNodeIsVisible:\n    return self.createIndex(0, 0, self._inspected_item)\nelse:\n    return self.rootIndex()\n",
        "CUT_4": "\"\"\"The model index that point to the inspectedItem.\"\"\"\nif self.inspectedNodeIsVisible:\n    return self.createIndex(0, 0, self._inspected_item)\nelse:\n    return self.rootIndex()\n",
        "CUT_5": "\"\"\"Get the information of the levels.\"\"\"\nif not index.isValid():\n    return None\nif role == Qt.FontRole:\n    return self._font\nlabel = ''\nif index.column() == self.model.header_shape[1] - 1:\n    label = str(self.model.name(0, index.row()))\nelif index.row() == self.model.header_shape[0] - 1:\n    label = str(self.model.name(1, index.column()))\nif role == Qt.DisplayRole and label:\n    return label\nelif role == Qt.ForegroundRole:\n    return self._foreground\nelif role == Qt.BackgroundRole:\n    return self._background\nelif role == Qt.BackgroundRole:\n    return self._palette.window()\nreturn None\n"
    },
    {
        "functionName": "generate_pandas_indexes",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\" Creates a dictionnary of many possible pandas indexes \"\"\"\nreturn {'Index': Index(list('ABCDEFGHIJKLMNOPQRST')), 'RangeIndex':\n    RangeIndex(0, 20), 'Float64Index': Index([(i / 10) for i in range(20)]),\n    'DatetimeIndex': date_range(start='2017-01-01', periods=20, freq='D'),\n    'MultiIndex': MultiIndex.from_product([list('ABCDEFGHIJ'), ('foo',\n    'bar')], names=['first', 'second']), 'CategoricalIndex':\n    CategoricalIndex(list('abcaadaccbbacabacccb'), categories=['a', 'b', 'c'])}\n",
        "CUT_1": "\"\"\"\n        Get the current history list.\n\n        Returns\n        -------\n        list\n            List of string paths.\n        \"\"\"\nreturn [str(self.pathedit.itemText(index)) for index in range(self.pathedit\n    .count())]\n",
        "CUT_2": "\"\"\"\n        Get the current history list.\n\n        Returns\n        -------\n        list\n            List of string paths.\n        \"\"\"\nreturn [str(self.pathedit.itemText(index)) for index in range(self.pathedit\n    .count())]\n",
        "CUT_3": "\"\"\"Set the current index of this combo box.\"\"\"\nif index is not None:\n    index = min(index, self.count() - 1)\n    index = CWD if index in [CLEAR_LIST, SELECT_OTHER] else index\nelse:\n    index = CWD\nself.setCurrentIndex(index)\n",
        "CUT_4": "\"\"\"Set the current index of this combo box.\"\"\"\nif index is not None:\n    index = min(index, self.count() - 1)\n    index = CWD if index in [CLEAR_LIST, SELECT_OTHER] else index\nelse:\n    index = CWD\nself.setCurrentIndex(index)\n",
        "CUT_5": "\"\"\"Parse to a given type\"\"\"\nindexes = self.selectedIndexes()\nif not indexes:\n    return\nfor index in indexes:\n    self.model().parse_data_type(index, **kwargs)\nSlot()"
    },
    {
        "functionName": "test_dataframe_to_type",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Regression test for spyder-ide/spyder#12296\"\"\"\nd = {'col1': [1, 2], 'col2': [3, 4]}\ndf = DataFrame(data=d)\neditor = DataFrameEditor()\nassert editor.setup_and_check(df, 'Test DataFrame To action')\neditor.show()\nqtbot.waitForWindowShown(editor)\nassert not editor.btn_save_and_close.isEnabled()\nview = editor.dataTable\nview.setCurrentIndex(view.model().index(0, 0))\nview.menu.show()\nqtbot.keyPress(view.menu, Qt.Key_Down)\nqtbot.keyPress(view.menu, Qt.Key_Down)\nqtbot.keyPress(view.menu, Qt.Key_Return)\nassert editor.btn_save_and_close.isEnabled()\n",
        "CUT_1": "\"\"\"Switch to editor view of the help viewer.\"\"\"\nself.source_combo.setCurrentIndex(1)\n",
        "CUT_2": "\"\"\"Switch to editor view of the help viewer.\"\"\"\nself.source_combo.setCurrentIndex(1)\n",
        "CUT_3": "\"\"\"Set the current namespace view.\"\"\"\nif self.namespacebrowser is not None:\n    self.namespacebrowser.process_remote_view(view)\n",
        "CUT_4": "\"\"\"Set the current namespace view.\"\"\"\nif self.namespacebrowser is not None:\n    self.namespacebrowser.process_remote_view(view)\n",
        "CUT_5": "\"\"\"\n        Return the namespace view\n\n        This is a dictionary with the following structure\n\n        {'a': {'color': '#800000', 'size': 1, 'type': 'str', 'view': '1'}}\n\n        Here:\n        * 'a' is the variable name\n        * 'color' is the color used to show it\n        * 'size' and 'type' are self-evident\n        * and'view' is its value or the text shown in the last column\n        \"\"\"\nfrom spyder_kernels.utils.nsview import make_remote_view\nsettings = self.namespace_view_settings\nif settings:\n    ns = self._get_current_namespace()\n    view = make_remote_view(ns, settings, EXCLUDED_NAMES)\n    return view\nelse:\n    return None\n"
    },
    {
        "functionName": "test_dataframe_datetimeindex",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Regression test for spyder-ide/spyder#11129 .\"\"\"\nds = Series(numpy.arange(10), index=date_range('2019-01-01', periods=10))\neditor = DataFrameEditor(None)\neditor.setup_and_check(ds)\nindex = editor.table_index.model()\nassert data_index(index, 0, 0) == '2019-01-01 00:00:00'\nassert data_index(index, 9, 0) == '2019-01-10 00:00:00'\n",
        "CUT_1": "if index.isValid():\n    return index.model().get_value(index)\n",
        "CUT_2": "if index.isValid():\n    return index.model().get_value(index)\n",
        "CUT_3": "\"\"\"Set current filename and return the associated editor instance.\"\"\"\nindex = self.has_filename(filename)\nif index is not None:\n    if focus:\n        self.set_stack_index(index)\n    editor = self.data[index].editor\n    if focus:\n        editor.setFocus()\n    else:\n        self.stack_history.remove_and_append(index)\n    return editor\n",
        "CUT_4": "\"\"\"Set current filename and return the associated editor instance.\"\"\"\nindex = self.has_filename(filename)\nif index is not None:\n    if focus:\n        self.set_stack_index(index)\n    editor = self.data[index].editor\n    if focus:\n        editor.setFocus()\n    else:\n        self.stack_history.remove_and_append(index)\n    return editor\n",
        "CUT_5": "finfo.editor.oe_proxy = None\nindex = 0 if add_where == 'start' else len(self.data)\nself.data.insert(index, finfo)\nindex = self.data.index(finfo)\neditor = finfo.editor\nself.tabs.insertTab(index, editor, self.get_tab_text(index))\nself.set_stack_title(index, False)\nif set_current:\n    self.set_stack_index(index)\n    self.current_changed(index)\nself.update_actions()\n"
    },
    {
        "functionName": "test_dataframe_simpleindex",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test to validate proper creation and handling of a simpleindex.\"\"\"\ndf = DataFrame(numpy.random.randn(6, 6))\neditor = DataFrameEditor(None)\neditor.setup_and_check(df)\nheader = editor.table_header.model()\nassert header.headerData(0, Qt.Horizontal, Qt.DisplayRole) == '0'\nassert header.headerData(1, Qt.Horizontal, Qt.DisplayRole) == '1'\nassert header.headerData(5, Qt.Horizontal, Qt.DisplayRole) == '5'\n",
        "CUT_1": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_2": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_3": "if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n    return self._attr_cols[section].name\nelse:\n    return None\n",
        "CUT_4": "if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n    return self._attr_cols[section].name\nelse:\n    return None\n",
        "CUT_5": "\"\"\"\n        Get the text to put in the header of the levels of the indexes.\n\n        By default it returns 'Index i', where i is the section in the index\n        \"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.model.header_shape[0] <= 1 and orientation == Qt.Horizontal:\n    if self.model.name(1, section):\n        return self.model.name(1, section)\n    return _('Index')\nelif self.model.header_shape[0] <= 1:\n    return None\nelif self.model.header_shape[1] <= 1 and orientation == Qt.Vertical:\n    return None\nreturn _('Index') + ' ' + to_text_string(section)\n"
    },
    {
        "functionName": "test_dataframe_simpleindex_custom_columns",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test to validate proper creation and handling of custom simpleindex.\"\"\"\ndf = DataFrame(numpy.random.randn(10, 5), columns=['a', 'b', 'c', 'd', 'e'])\neditor = DataFrameEditor(None)\neditor.setup_and_check(df)\nheader = editor.table_header.model()\nassert header.headerData(0, Qt.Horizontal, Qt.DisplayRole) == 'a'\nassert header.headerData(1, Qt.Horizontal, Qt.DisplayRole) == 'b'\nassert header.headerData(4, Qt.Horizontal, Qt.DisplayRole) == 'e'\n",
        "CUT_1": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_2": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_3": "if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n    return self._attr_cols[section].name\nelse:\n    return None\n",
        "CUT_4": "if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n    return self._attr_cols[section].name\nelse:\n    return None\n",
        "CUT_5": "\"\"\"\n        Get the text to put in the header of the levels of the indexes.\n\n        By default it returns 'Index i', where i is the section in the index\n        \"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.model.header_shape[0] <= 1 and orientation == Qt.Horizontal:\n    if self.model.name(1, section):\n        return self.model.name(1, section)\n    return _('Index')\nelif self.model.header_shape[0] <= 1:\n    return None\nelif self.model.header_shape[1] <= 1 and orientation == Qt.Vertical:\n    return None\nreturn _('Index') + ' ' + to_text_string(section)\n"
    },
    {
        "functionName": "test_dataframe_multiindex",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test to validate proper creation and handling of a multiindex.\"\"\"\narrays = [numpy.array(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux',\n    'qux']), numpy.array(['one', 'two', 'one', 'two', 'one', 'two', 'one',\n    'two'])]\ntuples = list(zip(*arrays))\nindex = MultiIndex.from_tuples(tuples, names=['first', 'second'])\ndf = DataFrame(numpy.random.randn(6, 6), index=index[:6], columns=index[:6])\neditor = DataFrameEditor(None)\neditor.setup_and_check(df)\nheader = editor.table_header.model()\nassert header.headerData(0, Qt.Horizontal, Qt.DisplayRole) == 0\nassert data_header(header, 0, 0) == 'bar'\nassert data_header(header, 1, 0) == 'one'\nassert data_header(header, 0, 1) == 'bar'\nassert data_header(header, 1, 1) == 'two'\nassert data_header(header, 0, 2) == 'baz'\nassert data_header(header, 1, 2) == 'one'\nassert data_header(header, 0, 3) == 'baz'\nassert data_header(header, 1, 3) == 'two'\nassert data_header(header, 0, 4) == 'foo'\nassert data_header(header, 1, 4) == 'one'\nassert data_header(header, 0, 5) == 'foo'\nassert data_header(header, 1, 5) == 'two'\n",
        "CUT_1": "\"\"\"\n        Get the data for the header.\n\n        This is used when a header has levels.\n        \"\"\"\nif not index.isValid() or index.row() >= self._shape[0] or index.column(\n    ) >= self._shape[1]:\n    return None\nrow, col = (index.row(), index.column()) if self.axis == 0 else (index.\n    column(), index.row())\nif role != Qt.DisplayRole:\n    return None\nif self.axis == 0 and self._shape[0] <= 1:\n    return None\nheader = self.model.header(self.axis, col, row)\nif not is_type_text_string(header):\n    header = to_text_string(header)\nreturn header\n",
        "CUT_2": "\"\"\"\n        Get the data for the header.\n\n        This is used when a header has levels.\n        \"\"\"\nif not index.isValid() or index.row() >= self._shape[0] or index.column(\n    ) >= self._shape[1]:\n    return None\nrow, col = (index.row(), index.column()) if self.axis == 0 else (index.\n    column(), index.row())\nif role != Qt.DisplayRole:\n    return None\nif self.axis == 0 and self._shape[0] <= 1:\n    return None\nheader = self.model.header(self.axis, col, row)\nif not is_type_text_string(header):\n    header = to_text_string(header)\nreturn header\n",
        "CUT_3": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_4": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_5": "\"\"\"Override Qt method.\"\"\"\nheader = self.header()\nheader.setSortIndicatorShown(True)\nQTreeView.sortByColumn(self, column, order)\nheader.setSortIndicator(0, order)\nself._last_column = column\nself._last_order = not self._last_order\n"
    },
    {
        "functionName": "test_header_bom",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test for BOM data in the headers.\"\"\"\ndf = read_csv(os.path.join(FILES_PATH, 'issue_2514.csv'))\neditor = DataFrameEditor(None)\neditor.setup_and_check(df)\nheader = editor.table_header.model()\nassert header.headerData(0, Qt.Horizontal, Qt.DisplayRole) == 'Date (MMM-YY)'\n",
        "CUT_1": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_2": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_3": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_4": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_5": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n"
    },
    {
        "functionName": "test_header_encoding",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test for header encoding handling.\"\"\"\ndf = read_csv(os.path.join(FILES_PATH, 'issue_3896.csv'))\neditor = DataFrameEditor(None)\neditor.setup_and_check(df)\nheader = editor.table_header.model()\nassert header.headerData(0, Qt.Horizontal, Qt.DisplayRole) == 'Unnamed: 0'\nassert 'Unieke_Idcode' in header.headerData(1, Qt.Horizontal, Qt.DisplayRole)\nassert header.headerData(2, Qt.Horizontal, Qt.DisplayRole) == 'a'\nassert header.headerData(3, Qt.Horizontal, Qt.DisplayRole) == 'b'\nassert header.headerData(4, Qt.Horizontal, Qt.DisplayRole) == 'c'\nassert header.headerData(5, Qt.Horizontal, Qt.DisplayRole) == 'd'\npytest.mark.skipif(is_module_installed('pandas', '<0.19'), reason=\n    \"It doesn't work for Pandas 0.19-\")",
        "CUT_1": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_2": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_3": "if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n    return self._attr_cols[section].name\nelse:\n    return None\n",
        "CUT_4": "if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n    return self._attr_cols[section].name\nelse:\n    return None\n",
        "CUT_5": "\"\"\"\n        Get the text to put in the header of the levels of the indexes.\n\n        By default it returns 'Index i', where i is the section in the index\n        \"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.model.header_shape[0] <= 1 and orientation == Qt.Horizontal:\n    if self.model.name(1, section):\n        return self.model.name(1, section)\n    return _('Index')\nelif self.model.header_shape[0] <= 1:\n    return None\nelif self.model.header_shape[1] <= 1 and orientation == Qt.Vertical:\n    return None\nreturn _('Index') + ' ' + to_text_string(section)\n"
    },
    {
        "functionName": "test_dataframemodel_basic",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame({'colA': [1, 3], 'colB': ['c', 'a']})\ndfm = DataFrameModel(df)\nassert dfm.rowCount() == 2\nassert dfm.columnCount() == 2\nassert data(dfm, 0, 0) == '1'\nassert data(dfm, 0, 1) == 'c'\nassert data(dfm, 1, 0) == '3'\nassert data(dfm, 1, 1) == 'a'\n",
        "CUT_1": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_2": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_3": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_4": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_5": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n"
    },
    {
        "functionName": "test_dataframemodel_sort",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Validate the data in the model.\"\"\"\ndf = DataFrame({'colA': [1, 3], 'colB': ['c', 'a']})\ndfm = DataFrameModel(df)\ndfm.sort(1)\nassert data(dfm, 0, 0) == '3'\nassert data(dfm, 1, 0) == '1'\nassert data(dfm, 0, 1) == 'a'\nassert data(dfm, 1, 1) == 'c'\n",
        "CUT_1": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_2": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_3": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_4": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_5": "\"\"\"\n        Set breakpoint data on widget.\n\n        Parameters\n        ----------\n        data: dict, optional\n            Breakpoint data to use. If None, data from the configuration\n            will be loaded. Default is None.\n        \"\"\"\nif data is None:\n    data = self._load_data()\nself.get_widget().set_data(data)\n"
    },
    {
        "functionName": "test_dataframemodel_sort_is_stable",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Validate the sort function.\"\"\"\ndf = DataFrame([[2, 14], [2, 13], [2, 16], [1, 3], [2, 9], [1, 15], [1, 17],\n    [2, 2], [2, 10], [1, 6], [2, 5], [2, 8], [1, 11], [1, 1], [1, 12], [1, \n    4], [2, 7]])\ndfm = DataFrameModel(df)\ndfm.sort(1)\ndfm.sort(0)\ncol2 = [data(dfm, i, 1) for i in range(len(df))]\nassert col2 == [str(x) for x in [1, 3, 4, 6, 11, 12, 15, 17, 2, 5, 7, 8, 9,\n    10, 13, 14, 16]]\n",
        "CUT_1": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_2": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_3": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_4": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_5": "\"\"\"Return the shape of the dataframe.\"\"\"\nreturn self.df.shape\nproperty"
    },
    {
        "functionName": "test_dataframemodel_max_min_col_update",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame([[1, 2.0], [2, 2.5], [3, 9.0]])\ndfm = DataFrameModel(df)\nassert dfm.max_min_col == [[3, 1], [9.0, 2.0]]\n",
        "CUT_1": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_2": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_3": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_4": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_5": "\"\"\"Return the shape of the dataframe.\"\"\"\nreturn self.df.shape\nproperty"
    },
    {
        "functionName": "test_dataframemodel_max_min_col_update_constant",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame([[1, 2.0], [1, 2.0], [1, 2.0]])\ndfm = DataFrameModel(df)\nassert dfm.max_min_col == [[1, 0], [2.0, 1.0]]\n",
        "CUT_1": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_2": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_3": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_4": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_5": "\"\"\"Return the shape of the dataframe.\"\"\"\nreturn self.df.shape\nproperty"
    },
    {
        "functionName": "test_dataframemodel_with_timezone_aware_timestamps",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame([x] for x in date_range('20150101', periods=5, tz='UTC'))\ndfm = DataFrameModel(df)\nassert dfm.max_min_col == [None]\n",
        "CUT_1": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_2": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_3": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_4": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_5": "\"\"\"Return the shape of the dataframe.\"\"\"\nreturn self.df.shape\nproperty"
    },
    {
        "functionName": "test_dataframemodel_with_categories",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame({'id': [1, 2, 3, 4, 5, 6], 'raw_grade': ['a', 'b', 'b', 'a',\n    'a', 'e']})\ndf['grade'] = df['raw_grade'].astype('category')\ndfm = DataFrameModel(df)\nassert dfm.max_min_col == [[6, 1], None, None]\n",
        "CUT_1": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_2": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_3": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_4": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_5": "\"\"\"Return the value of the DataFrame.\"\"\"\ntry:\n    value = self.df.iat[row, column]\nexcept OutOfBoundsDatetime:\n    value = self.df.iloc[:, (column)].astype(str).iat[row]\nexcept:\n    value = self.df.iloc[row, column]\nreturn value\n"
    },
    {
        "functionName": "test_dataframemodel_get_bgcolor_with_numbers",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame([[0, 10], [1, 20], [2, 40]])\ndfm = DataFrameModel(df)\nh0 = dataframeeditor.BACKGROUND_NUMBER_MINHUE\ndh = dataframeeditor.BACKGROUND_NUMBER_HUERANGE\ns = dataframeeditor.BACKGROUND_NUMBER_SATURATION\nv = dataframeeditor.BACKGROUND_NUMBER_VALUE\na = dataframeeditor.BACKGROUND_NUMBER_ALPHA\nassert colorclose(bgcolor(dfm, 0, 0), (h0 + dh, s, v, a))\nassert colorclose(bgcolor(dfm, 1, 0), (h0 + 1 / 2 * dh, s, v, a))\nassert colorclose(bgcolor(dfm, 2, 0), (h0, s, v, a))\nassert colorclose(bgcolor(dfm, 0, 1), (h0 + dh, s, v, a))\nassert colorclose(bgcolor(dfm, 1, 1), (h0 + 2 / 3 * dh, s, v, a))\nassert colorclose(bgcolor(dfm, 2, 1), (h0, s, v, a))\n",
        "CUT_1": "\"\"\"\n        This is implementet so column min/max is only active when bgcolor is\n        \"\"\"\nself.dataModel.bgcolor(state)\nself.bgcolor_global.setEnabled(not self.is_series and state > 0)\n",
        "CUT_2": "\"\"\"\n        This is implementet so column min/max is only active when bgcolor is\n        \"\"\"\nself.dataModel.bgcolor(state)\nself.bgcolor_global.setEnabled(not self.is_series and state > 0)\n",
        "CUT_3": "QWidget.__init__(self, parent)\nself.data = data\nself.old_data_shape = None\nif len(self.data.shape) == 1:\n    self.old_data_shape = self.data.shape\n    self.data.shape = self.data.shape[0], 1\nelif len(self.data.shape) == 0:\n    self.old_data_shape = self.data.shape\n    self.data.shape = 1, 1\nformat = SUPPORTED_FORMATS.get(data.dtype.name, '%s')\nself.model = ArrayModel(self.data, format=format, xlabels=xlabels, ylabels=\n    ylabels, readonly=readonly, parent=self)\nself.view = ArrayView(self, self.model, data.dtype, data.shape)\nbtn_layout = QHBoxLayout()\nbtn_layout.setAlignment(Qt.AlignLeft)\nbtn = QPushButton(_('Format'))\nbtn.setEnabled(is_float(data.dtype))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.change_format)\nbtn = QPushButton(_('Resize'))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.view.resize_to_contents)\nbgcolor = QCheckBox(_('Background color'))\nbgcolor.setChecked(self.model.bgcolor_enabled)\nbgcolor.setEnabled(self.model.bgcolor_enabled)\nbgcolor.stateChanged.connect(self.model.bgcolor)\nbtn_layout.addWidget(bgcolor)\nlayout = QVBoxLayout()\nlayout.addWidget(self.view)\nlayout.addLayout(btn_layout)\nself.setLayout(layout)\n",
        "CUT_4": "QWidget.__init__(self, parent)\nself.data = data\nself.old_data_shape = None\nif len(self.data.shape) == 1:\n    self.old_data_shape = self.data.shape\n    self.data.shape = self.data.shape[0], 1\nelif len(self.data.shape) == 0:\n    self.old_data_shape = self.data.shape\n    self.data.shape = 1, 1\nformat = SUPPORTED_FORMATS.get(data.dtype.name, '%s')\nself.model = ArrayModel(self.data, format=format, xlabels=xlabels, ylabels=\n    ylabels, readonly=readonly, parent=self)\nself.view = ArrayView(self, self.model, data.dtype, data.shape)\nbtn_layout = QHBoxLayout()\nbtn_layout.setAlignment(Qt.AlignLeft)\nbtn = QPushButton(_('Format'))\nbtn.setEnabled(is_float(data.dtype))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.change_format)\nbtn = QPushButton(_('Resize'))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.view.resize_to_contents)\nbgcolor = QCheckBox(_('Background color'))\nbgcolor.setChecked(self.model.bgcolor_enabled)\nbgcolor.setEnabled(self.model.bgcolor_enabled)\nbgcolor.stateChanged.connect(self.model.bgcolor)\nbtn_layout.addWidget(bgcolor)\nlayout = QVBoxLayout()\nlayout.addWidget(self.view)\nlayout.addLayout(btn_layout)\nself.setLayout(layout)\n",
        "CUT_5": "\"\"\"\n        Setup DataFrameEditor:\n        return False if data is not supported, True otherwise.\n        Supported types for data are DataFrame, Series and Index.\n        \"\"\"\nself._selection_rec = False\nself._model = None\nself.layout = QGridLayout()\nself.layout.setSpacing(0)\nself.layout.setContentsMargins(0, 0, 0, 0)\nself.setLayout(self.layout)\nself.setWindowIcon(ima.icon('arredit'))\nif title:\n    title = to_text_string(title) + ' - %s' % data.__class__.__name__\nelse:\n    title = _('%s editor') % data.__class__.__name__\nif isinstance(data, Series):\n    self.is_series = True\n    data = data.to_frame()\nelif isinstance(data, Index):\n    data = DataFrame(data)\nself.setWindowTitle(title)\nself.hscroll = QScrollBar(Qt.Horizontal)\nself.vscroll = QScrollBar(Qt.Vertical)\nself.create_table_level()\nself.create_table_header()\nself.create_table_index()\nself.dataModel = DataFrameModel(data, parent=self)\nself.dataModel.dataChanged.connect(self.save_and_close_enable)\nself.create_data_table()\nself.layout.addWidget(self.hscroll, 2, 0, 1, 2)\nself.layout.addWidget(self.vscroll, 0, 2, 2, 1)\nself._autosized_cols = set()\nself._max_autosize_ms = 300\nself.dataTable.installEventFilter(self)\navg_width = self.fontMetrics().averageCharWidth()\nself.min_trunc = avg_width * 12\nself.max_width = avg_width * 64\nself.setLayout(self.layout)\nself.setWindowFlags(Qt.Window)\nbtn_layout = QHBoxLayout()\nbtn = QPushButton(_('Format'))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.change_format)\nbtn = QPushButton(_('Resize'))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.resize_to_contents)\nbgcolor = QCheckBox(_('Background color'))\nbgcolor.setChecked(self.dataModel.bgcolor_enabled)\nbgcolor.setEnabled(self.dataModel.bgcolor_enabled)\nbgcolor.stateChanged.connect(self.change_bgcolor_enable)\nbtn_layout.addWidget(bgcolor)\nself.bgcolor_global = QCheckBox(_('Column min/max'))\nself.bgcolor_global.setChecked(self.dataModel.colum_avg_enabled)\nself.bgcolor_global.setEnabled(not self.is_series and self.dataModel.\n    bgcolor_enabled)\nself.bgcolor_global.stateChanged.connect(self.dataModel.colum_avg)\nbtn_layout.addWidget(self.bgcolor_global)\nbtn_layout.addStretch()\nself.btn_save_and_close = QPushButton(_('Save and Close'))\nself.btn_save_and_close.setDisabled(True)\nself.btn_save_and_close.clicked.connect(self.accept)\nbtn_layout.addWidget(self.btn_save_and_close)\nself.btn_close = QPushButton(_('Close'))\nself.btn_close.setAutoDefault(True)\nself.btn_close.setDefault(True)\nself.btn_close.clicked.connect(self.reject)\nbtn_layout.addWidget(self.btn_close)\nbtn_layout.setContentsMargins(4, 4, 4, 4)\nself.layout.addLayout(btn_layout, 4, 0, 1, 2)\nself.setModel(self.dataModel)\nself.resizeColumnsToContents()\nreturn True\n"
    },
    {
        "functionName": "test_dataframemodel_get_bgcolor_with_numbers_using_global_max",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame([[0, 10], [1, 20], [2, 40]])\ndfm = DataFrameModel(df)\ndfm.colum_avg(0)\nh0 = dataframeeditor.BACKGROUND_NUMBER_MINHUE\ndh = dataframeeditor.BACKGROUND_NUMBER_HUERANGE\ns = dataframeeditor.BACKGROUND_NUMBER_SATURATION\nv = dataframeeditor.BACKGROUND_NUMBER_VALUE\na = dataframeeditor.BACKGROUND_NUMBER_ALPHA\nassert colorclose(bgcolor(dfm, 0, 0), (h0 + dh, s, v, a))\nassert colorclose(bgcolor(dfm, 1, 0), (h0 + 39 / 40 * dh, s, v, a))\nassert colorclose(bgcolor(dfm, 2, 0), (h0 + 38 / 40 * dh, s, v, a))\nassert colorclose(bgcolor(dfm, 0, 1), (h0 + 30 / 40 * dh, s, v, a))\nassert colorclose(bgcolor(dfm, 1, 1), (h0 + 20 / 40 * dh, s, v, a))\nassert colorclose(bgcolor(dfm, 2, 1), (h0, s, v, a))\n",
        "CUT_1": "\"\"\"\n        This is implementet so column min/max is only active when bgcolor is\n        \"\"\"\nself.dataModel.bgcolor(state)\nself.bgcolor_global.setEnabled(not self.is_series and state > 0)\n",
        "CUT_2": "\"\"\"\n        This is implementet so column min/max is only active when bgcolor is\n        \"\"\"\nself.dataModel.bgcolor(state)\nself.bgcolor_global.setEnabled(not self.is_series and state > 0)\n",
        "CUT_3": "QWidget.__init__(self, parent)\nself.data = data\nself.old_data_shape = None\nif len(self.data.shape) == 1:\n    self.old_data_shape = self.data.shape\n    self.data.shape = self.data.shape[0], 1\nelif len(self.data.shape) == 0:\n    self.old_data_shape = self.data.shape\n    self.data.shape = 1, 1\nformat = SUPPORTED_FORMATS.get(data.dtype.name, '%s')\nself.model = ArrayModel(self.data, format=format, xlabels=xlabels, ylabels=\n    ylabels, readonly=readonly, parent=self)\nself.view = ArrayView(self, self.model, data.dtype, data.shape)\nbtn_layout = QHBoxLayout()\nbtn_layout.setAlignment(Qt.AlignLeft)\nbtn = QPushButton(_('Format'))\nbtn.setEnabled(is_float(data.dtype))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.change_format)\nbtn = QPushButton(_('Resize'))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.view.resize_to_contents)\nbgcolor = QCheckBox(_('Background color'))\nbgcolor.setChecked(self.model.bgcolor_enabled)\nbgcolor.setEnabled(self.model.bgcolor_enabled)\nbgcolor.stateChanged.connect(self.model.bgcolor)\nbtn_layout.addWidget(bgcolor)\nlayout = QVBoxLayout()\nlayout.addWidget(self.view)\nlayout.addLayout(btn_layout)\nself.setLayout(layout)\n",
        "CUT_4": "QWidget.__init__(self, parent)\nself.data = data\nself.old_data_shape = None\nif len(self.data.shape) == 1:\n    self.old_data_shape = self.data.shape\n    self.data.shape = self.data.shape[0], 1\nelif len(self.data.shape) == 0:\n    self.old_data_shape = self.data.shape\n    self.data.shape = 1, 1\nformat = SUPPORTED_FORMATS.get(data.dtype.name, '%s')\nself.model = ArrayModel(self.data, format=format, xlabels=xlabels, ylabels=\n    ylabels, readonly=readonly, parent=self)\nself.view = ArrayView(self, self.model, data.dtype, data.shape)\nbtn_layout = QHBoxLayout()\nbtn_layout.setAlignment(Qt.AlignLeft)\nbtn = QPushButton(_('Format'))\nbtn.setEnabled(is_float(data.dtype))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.change_format)\nbtn = QPushButton(_('Resize'))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.view.resize_to_contents)\nbgcolor = QCheckBox(_('Background color'))\nbgcolor.setChecked(self.model.bgcolor_enabled)\nbgcolor.setEnabled(self.model.bgcolor_enabled)\nbgcolor.stateChanged.connect(self.model.bgcolor)\nbtn_layout.addWidget(bgcolor)\nlayout = QVBoxLayout()\nlayout.addWidget(self.view)\nlayout.addLayout(btn_layout)\nself.setLayout(layout)\n",
        "CUT_5": "\"\"\"\n        Setup DataFrameEditor:\n        return False if data is not supported, True otherwise.\n        Supported types for data are DataFrame, Series and Index.\n        \"\"\"\nself._selection_rec = False\nself._model = None\nself.layout = QGridLayout()\nself.layout.setSpacing(0)\nself.layout.setContentsMargins(0, 0, 0, 0)\nself.setLayout(self.layout)\nself.setWindowIcon(ima.icon('arredit'))\nif title:\n    title = to_text_string(title) + ' - %s' % data.__class__.__name__\nelse:\n    title = _('%s editor') % data.__class__.__name__\nif isinstance(data, Series):\n    self.is_series = True\n    data = data.to_frame()\nelif isinstance(data, Index):\n    data = DataFrame(data)\nself.setWindowTitle(title)\nself.hscroll = QScrollBar(Qt.Horizontal)\nself.vscroll = QScrollBar(Qt.Vertical)\nself.create_table_level()\nself.create_table_header()\nself.create_table_index()\nself.dataModel = DataFrameModel(data, parent=self)\nself.dataModel.dataChanged.connect(self.save_and_close_enable)\nself.create_data_table()\nself.layout.addWidget(self.hscroll, 2, 0, 1, 2)\nself.layout.addWidget(self.vscroll, 0, 2, 2, 1)\nself._autosized_cols = set()\nself._max_autosize_ms = 300\nself.dataTable.installEventFilter(self)\navg_width = self.fontMetrics().averageCharWidth()\nself.min_trunc = avg_width * 12\nself.max_width = avg_width * 64\nself.setLayout(self.layout)\nself.setWindowFlags(Qt.Window)\nbtn_layout = QHBoxLayout()\nbtn = QPushButton(_('Format'))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.change_format)\nbtn = QPushButton(_('Resize'))\nbtn_layout.addWidget(btn)\nbtn.clicked.connect(self.resize_to_contents)\nbgcolor = QCheckBox(_('Background color'))\nbgcolor.setChecked(self.dataModel.bgcolor_enabled)\nbgcolor.setEnabled(self.dataModel.bgcolor_enabled)\nbgcolor.stateChanged.connect(self.change_bgcolor_enable)\nbtn_layout.addWidget(bgcolor)\nself.bgcolor_global = QCheckBox(_('Column min/max'))\nself.bgcolor_global.setChecked(self.dataModel.colum_avg_enabled)\nself.bgcolor_global.setEnabled(not self.is_series and self.dataModel.\n    bgcolor_enabled)\nself.bgcolor_global.stateChanged.connect(self.dataModel.colum_avg)\nbtn_layout.addWidget(self.bgcolor_global)\nbtn_layout.addStretch()\nself.btn_save_and_close = QPushButton(_('Save and Close'))\nself.btn_save_and_close.setDisabled(True)\nself.btn_save_and_close.clicked.connect(self.accept)\nbtn_layout.addWidget(self.btn_save_and_close)\nself.btn_close = QPushButton(_('Close'))\nself.btn_close.setAutoDefault(True)\nself.btn_close.setDefault(True)\nself.btn_close.clicked.connect(self.reject)\nbtn_layout.addWidget(self.btn_close)\nbtn_layout.setContentsMargins(4, 4, 4, 4)\nself.layout.addLayout(btn_layout, 4, 0, 1, 2)\nself.setModel(self.dataModel)\nself.resizeColumnsToContents()\nreturn True\n"
    },
    {
        "functionName": "test_dataframemodel_get_bgcolor_with_string",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Validate the color of the cell when a string is the data.\"\"\"\ndf = DataFrame([['xxx']])\ndfm = DataFrameModel(df)\nh, s, v, dummy = QColor(dataframeeditor.BACKGROUND_NONNUMBER_COLOR).getHsvF()\na = dataframeeditor.BACKGROUND_STRING_ALPHA\nassert colorclose(bgcolor(dfm, 0, 0), (h, s, v, a))\n",
        "CUT_1": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_2": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_3": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_4": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_5": "\"\"\"Return the shape of the dataframe.\"\"\"\nreturn self.df.shape\nproperty"
    },
    {
        "functionName": "test_dataframemodel_get_bgcolor_with_object",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame([[None]])\ndfm = DataFrameModel(df)\nh, s, v, dummy = QColor(dataframeeditor.BACKGROUND_NONNUMBER_COLOR).getHsvF()\na = dataframeeditor.BACKGROUND_MISC_ALPHA\nassert colorclose(bgcolor(dfm, 0, 0), (h, s, v, a))\n",
        "CUT_1": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_2": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_3": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_4": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_5": "\"\"\"Return the shape of the dataframe.\"\"\"\nreturn self.df.shape\nproperty"
    },
    {
        "functionName": "test_dataframemodel_get_bgcolor_with_missings",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that df bg colors are correct for missing values of various types.\n\n    The types `bool`, `object`, `datetime`, and `timedelta` are omitted,\n    because missings have no different background there yet.\n    \"\"\"\ndf = DataFrame({'int': [1, None], 'float': [0.1, None], 'complex': [1.0j,\n    None], 'string': ['a', None]})\ndf['category'] = df['string'].astype('category')\ndfm = DataFrameModel(df)\nh, s, v, __ = QColor(dataframeeditor.BACKGROUND_NONNUMBER_COLOR).getHsvF()\nalpha = dataframeeditor.BACKGROUND_MISC_ALPHA\nfor idx, column in enumerate(df.columns):\n    assert not colorclose(bgcolor(dfm, 0, idx), (h, s, v, alpha)\n        ), 'Wrong bg color for value of type ' + column\n    assert colorclose(bgcolor(dfm, 1, idx), (h, s, v, alpha)\n        ), 'Wrong bg color for missing of type ' + column\n",
        "CUT_1": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_2": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_3": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_4": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_5": "\"\"\"Return the value of the DataFrame.\"\"\"\ntry:\n    value = self.df.iat[row, column]\nexcept OutOfBoundsDatetime:\n    value = self.df.iloc[:, (column)].astype(str).iat[row]\nexcept:\n    value = self.df.iloc[row, column]\nreturn value\n"
    },
    {
        "functionName": "test_dataframemodel_with_format_percent_d_and_nan",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test DataFrameModel with format `%d` and dataframe containing NaN\n\n    Regression test for spyder-ide/spyder#4139.\n    \"\"\"\nnp_array = numpy.zeros(2)\nnp_array[1] = numpy.nan\ndataframe = DataFrame(np_array)\ndfm = DataFrameModel(dataframe, format='%d')\nassert data(dfm, 0, 0) == '0'\nassert data(dfm, 1, 0) == 'nan'\n",
        "CUT_1": "\"\"\"Return True if variable is a DataFrame\"\"\"\ntry:\n    from pandas import DataFrame\n    return isinstance(var, DataFrame)\nexcept:\n    return False\n",
        "CUT_2": "\"\"\"DataFrame editor test\"\"\"\nfrom numpy import nan\nfrom pandas.util.testing import assert_frame_equal, assert_series_equal\ndf1 = DataFrame([[True, 'bool'], [1 + 1.0j, 'complex'], ['test', 'string'],\n    [1.11, 'float'], [1, 'int'], [np.random.rand(3, 3), 'Unkown type'], [\n    'Large value', 100], ['\u00e1\u00e9\u00ed', 'unicode']], index=['a', 'b', nan, nan,\n    nan, 'c', 'Test global max', 'd'], columns=[nan, 'Type'])\nout = test_edit(df1)\nassert_frame_equal(df1, out)\nresult = Series([True, 'bool'], index=[nan, 'Type'], name='a')\nout = test_edit(df1.iloc[0])\nassert_series_equal(result, out)\ndf1 = DataFrame(np.random.rand(100100, 10))\nout = test_edit(df1)\nassert_frame_equal(out, df1)\nseries = Series(np.arange(10), name=0)\nout = test_edit(series)\nassert_series_equal(series, out)\n",
        "CUT_3": "\"\"\"DataFrame editor test\"\"\"\nfrom numpy import nan\nfrom pandas.util.testing import assert_frame_equal, assert_series_equal\ndf1 = DataFrame([[True, 'bool'], [1 + 1.0j, 'complex'], ['test', 'string'],\n    [1.11, 'float'], [1, 'int'], [np.random.rand(3, 3), 'Unkown type'], [\n    'Large value', 100], ['\u00e1\u00e9\u00ed', 'unicode']], index=['a', 'b', nan, nan,\n    nan, 'c', 'Test global max', 'd'], columns=[nan, 'Type'])\nout = test_edit(df1)\nassert_frame_equal(df1, out)\nresult = Series([True, 'bool'], index=[nan, 'Type'], name='a')\nout = test_edit(df1.iloc[0])\nassert_series_equal(result, out)\ndf1 = DataFrame(np.random.rand(100100, 10))\nout = test_edit(df1)\nassert_frame_equal(out, df1)\nseries = Series(np.arange(10), name=0)\nout = test_edit(series)\nassert_series_equal(series, out)\n",
        "CUT_4": "\"\"\"Get the model of the dataframe.\"\"\"\nreturn self._model\n",
        "CUT_5": "\"\"\"Get the model of the dataframe.\"\"\"\nreturn self._model\n"
    },
    {
        "functionName": "test_change_format_emits_signal",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "mockQInputDialog = Mock()\nmockQInputDialog.getText = lambda parent, title, label, mode, text: ('%10.3e',\n    True)\nmonkeypatch.setattr(\n    'spyder.plugins.variableexplorer.widgets.dataframeeditor.QInputDialog',\n    mockQInputDialog)\ndf = DataFrame([[0]])\neditor = DataFrameEditor(None)\neditor.setup_and_check(df)\nwith qtbot.waitSignal(editor.sig_option_changed) as blocker:\n    editor.change_format()\nassert blocker.args == ['dataframe_format', '%10.3e']\n",
        "CUT_1": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_2": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_3": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_change_format_with_format_not_starting_with_percent",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "mockQInputDialog = Mock()\nmockQInputDialog.getText = lambda parent, title, label, mode, text: ('xxx%f',\n    True)\nmonkeypatch.setattr(\n    'spyder.plugins.variableexplorer.widgets.dataframeeditor.QInputDialog',\n    mockQInputDialog)\nmonkeypatch.setattr(\n    'spyder.plugins.variableexplorer.widgets.dataframeeditor.QMessageBox.critical'\n    , Mock())\ndf = DataFrame([[0]])\neditor = DataFrameEditor(None)\neditor.setup_and_check(df)\nwith qtbot.assertNotEmitted(editor.sig_option_changed):\n    editor.change_format()\n",
        "CUT_1": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_2": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture",
        "CUT_3": "return Mock()\n",
        "CUT_4": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_5": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n"
    },
    {
        "functionName": "test_dataframeeditor_with_various_indexes",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "for rng_name, rng in generate_pandas_indexes().items():\n    editor = DataFrameEditor(None)\n    editor.setup_and_check(rng)\n    dfm = editor.dataModel\n    assert dfm.rowCount() == 20\n    assert dfm.columnCount() == 1\n    header = editor.table_header.model()\n    assert header.headerData(0, Qt.Horizontal, Qt.DisplayRole) == '0'\n    if rng_name == 'Index':\n        assert data(dfm, 0, 0) == 'A'\n        assert data(dfm, 1, 0) == 'B'\n        assert data(dfm, 2, 0) == 'C'\n        assert data(dfm, 19, 0) == 'T'\n    elif rng_name == 'RangeIndex':\n        assert data(dfm, 0, 0) == '0'\n        assert data(dfm, 1, 0) == '1'\n        assert data(dfm, 2, 0) == '2'\n        assert data(dfm, 19, 0) == '19'\n    elif rng_name == 'Float64Index':\n        assert data(dfm, 0, 0) == '0'\n        assert data(dfm, 1, 0) == '0.1'\n        assert data(dfm, 2, 0) == '0.2'\n        assert data(dfm, 19, 0) == '1.9'\n    elif rng_name == 'DatetimeIndex':\n        assert data(dfm, 0, 0) == '2017-01-01 00:00:00'\n        assert data(dfm, 1, 0) == '2017-01-02 00:00:00'\n        assert data(dfm, 2, 0) == '2017-01-03 00:00:00'\n        assert data(dfm, 19, 0) == '2017-01-20 00:00:00'\n    elif rng_name == 'MultiIndex':\n        assert data(dfm, 0, 0) == \"('A', 'foo')\"\n        assert data(dfm, 1, 0) == \"('A', 'bar')\"\n        assert data(dfm, 2, 0) == \"('B', 'foo')\"\n        assert data(dfm, 19, 0) == \"('J', 'bar')\"\n    elif rng_name == 'CategoricalIndex':\n        assert data(dfm, 0, 0) == 'a'\n        assert data(dfm, 1, 0) == 'b'\n        assert data(dfm, 2, 0) == 'c'\n        assert data(dfm, 19, 0) == 'b'\n",
        "CUT_1": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_2": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_3": "\"\"\"\n        Set breakpoint data on widget.\n\n        Parameters\n        ----------\n        data: dict, optional\n            Breakpoint data to use. If None, data from the configuration\n            will be loaded. Default is None.\n        \"\"\"\nif data is None:\n    data = self._load_data()\nself.get_widget().set_data(data)\n",
        "CUT_4": "\"\"\"\n        Set breakpoint data on widget.\n\n        Parameters\n        ----------\n        data: dict, optional\n            Breakpoint data to use. If None, data from the configuration\n            will be loaded. Default is None.\n        \"\"\"\nif data is None:\n    data = self._load_data()\nself.get_widget().set_data(data)\n",
        "CUT_5": "if self.data:\n    return self.data[self.get_stack_index()]\n"
    },
    {
        "functionName": "test_dataframeeditor_with_OutOfBoundsDatetime",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame([{'DATETIME': datetime.strptime('9999-1-1T00:00',\n    '%Y-%m-%dT%H:%M')}])\nmodel = DataFrameModel(df)\ntry:\n    model.get_value(0, 0)\nexcept Exception:\n    assert False\n",
        "CUT_1": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_2": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_3": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_4": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_5": "\"\"\"Return the value of the DataFrame.\"\"\"\ntry:\n    value = self.df.iat[row, column]\nexcept OutOfBoundsDatetime:\n    value = self.df.iloc[:, (column)].astype(str).iat[row]\nexcept:\n    value = self.df.iloc[row, column]\nreturn value\n"
    },
    {
        "functionName": "test_sort_dataframe_with_duplicate_column",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame({'A': [1, 3, 2], 'B': [4, 6, 5]})\ndf = concat((df, df.A), axis=1)\neditor = DataFrameEditor(None)\neditor.setup_and_check(df)\ndfm = editor.dataModel\nQTimer.singleShot(1000, lambda : close_message_box(qtbot))\neditor.dataModel.sort(0)\nassert [data(dfm, row, 0) for row in range(len(df))] == ['1', '3', '2']\nassert [data(dfm, row, 1) for row in range(len(df))] == ['4', '6', '5']\neditor.dataModel.sort(1)\nassert [data(dfm, row, 0) for row in range(len(df))] == ['1', '2', '3']\nassert [data(dfm, row, 1) for row in range(len(df))] == ['4', '5', '6']\npytest.mark.skipif(not os.name == 'nt', reason='It segfaults too much on Linux'\n    )",
        "CUT_1": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_2": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_3": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_4": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_5": "\"\"\"Return the value of the DataFrame.\"\"\"\ntry:\n    value = self.df.iat[row, column]\nexcept OutOfBoundsDatetime:\n    value = self.df.iloc[:, (column)].astype(str).iat[row]\nexcept:\n    value = self.df.iloc[row, column]\nreturn value\n"
    },
    {
        "functionName": "test_sort_dataframe_with_category_dtypes",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = DataFrame({'A': [1, 2, 3, 4], 'B': ['a', 'b', 'c', 'd']})\ndf = df.astype(dtype={'B': 'category'})\ndf_cols = df.dtypes\neditor = DataFrameEditor(None)\neditor.setup_and_check(df_cols)\ndfm = editor.dataModel\nQTimer.singleShot(1000, lambda : close_message_box(qtbot))\neditor.dataModel.sort(0)\nassert data(dfm, 0, 0) == 'int64'\nassert data(dfm, 1, 0) == 'category'\npytest.mark.skipif(not os.name == 'nt', reason='It segfaults too much on Linux'\n    )",
        "CUT_1": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_2": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_3": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_4": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_5": "\"\"\"Return the value of the DataFrame.\"\"\"\ntry:\n    value = self.df.iat[row, column]\nexcept OutOfBoundsDatetime:\n    value = self.df.iloc[:, (column)].astype(str).iat[row]\nexcept:\n    value = self.df.iloc[row, column]\nreturn value\n"
    },
    {
        "functionName": "test_dataframemodel_set_data_overflow",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that entry of an overflowing integer is caught and handled properly.\n\n    Unit regression test for spyder-ide/spyder#6114.\n    \"\"\"\nMockQMessageBox = Mock()\nattr_to_patch = ('spyder.plugins.variableexplorer.widgets' +\n    '.dataframeeditor.QMessageBox')\nmonkeypatch.setattr(attr_to_patch, MockQMessageBox)\nif not os.name == 'nt':\n    int32_bit_exponent = 66\nelse:\n    int32_bit_exponent = 34\ntest_parameters = [(1, numpy.int32, int32_bit_exponent), (2, numpy.int64, 66)]\nfor idx, int_type, bit_exponent in test_parameters:\n    test_df = DataFrame(numpy.arange(7, 11), dtype=int_type)\n    model = DataFrameModel(test_df.copy())\n    index = model.createIndex(2, 0)\n    assert not model.setData(index, str(int(2 ** bit_exponent)))\n    MockQMessageBox.critical.assert_called_with(ANY, 'Error', ANY)\n    assert MockQMessageBox.critical.call_count == idx\n    try:\n        assert numpy.sum(test_df[0].values == model.df.values) == len(test_df)\n    except AttributeError:\n        assert numpy.sum(test_df[0].as_matrix() == model.df.as_matrix()\n            ) == len(test_df)\n",
        "CUT_1": "\"\"\"Return True if variable is a NumPy array\"\"\"\ntry:\n    import numpy\n    return isinstance(var, numpy.ndarray)\nexcept:\n    return False\n",
        "CUT_2": "\"\"\"Save all items expanded state\"\"\"\nmodel = self.model()\nif model is not None:\n    self.__expanded_state = []\n    for idx in model.persistentIndexList():\n        if self.isExpanded(idx):\n            self.__expanded_state.append(self.get_filename(idx))\n",
        "CUT_3": "\"\"\"Save all items expanded state\"\"\"\nmodel = self.model()\nif model is not None:\n    self.__expanded_state = []\n    for idx in model.persistentIndexList():\n        if self.isExpanded(idx):\n            self.__expanded_state.append(self.get_filename(idx))\n",
        "CUT_4": "\"\"\"Return NumPy data type associated to obj\n    Return None if NumPy is not available\n    or if obj is not a NumPy array or scalar\"\"\"\nif ndarray is not FakeObject:\n    import numpy as np\n    if isinstance(obj, np.generic) or isinstance(obj, np.ndarray):\n        try:\n            return obj.dtype.type\n        except (AttributeError, RuntimeError):\n            return\n",
        "CUT_5": "\"\"\"Return True if variable is a numpy array\"\"\"\nraise NotImplementedError\n"
    },
    {
        "functionName": "test_dataframeeditor_edit_overflow",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that entry of an overflowing integer is caught and handled properly.\n\n    Integration regression test for spyder-ide/spyder#6114.\n    \"\"\"\nMockQMessageBox = Mock()\nattr_to_patch = ('spyder.plugins.variableexplorer.widgets' +\n    '.dataframeeditor.QMessageBox')\nmonkeypatch.setattr(attr_to_patch, MockQMessageBox)\nif not os.name == 'nt':\n    int32_bit_exponent = 66\nelse:\n    int32_bit_exponent = 34\ntest_parameters = [(1, numpy.int32, int32_bit_exponent), (2, numpy.int64, 66)]\nexpected_df = DataFrame([5, 6, 7, 3, 4])\nfor idx, int_type, bit_exponet in test_parameters:\n    test_df = DataFrame(numpy.arange(0, 5), dtype=int_type)\n    dialog = DataFrameEditor()\n    assert dialog.setup_and_check(test_df, 'Test Dataframe')\n    dialog.show()\n    qtbot.waitForWindowShown(dialog)\n    view = dialog.dataTable\n    qtbot.keyClick(view, Qt.Key_Right)\n    qtbot.keyClicks(view, '5')\n    qtbot.keyClick(view, Qt.Key_Down)\n    qtbot.keyClick(view, Qt.Key_Space)\n    qtbot.keyClick(view.focusWidget(), Qt.Key_Backspace)\n    qtbot.keyClicks(view.focusWidget(), str(int(2 ** bit_exponet)))\n    qtbot.keyClick(view.focusWidget(), Qt.Key_Down)\n    MockQMessageBox.critical.assert_called_with(ANY, 'Error', ANY)\n    assert MockQMessageBox.critical.call_count == idx\n    qtbot.keyClicks(view, '7')\n    qtbot.keyClick(view, Qt.Key_Up)\n    qtbot.keyClicks(view, '6')\n    qtbot.keyClick(view, Qt.Key_Down)\n    qtbot.wait(200)\n    dialog.accept()\n    qtbot.wait(500)\n    try:\n        assert numpy.sum(expected_df[0].values == dialog.get_value().values\n            ) == len(expected_df)\n    except AttributeError:\n        assert numpy.sum(expected_df[0].as_matrix() == dialog.get_value().\n            as_matrix()) == len(expected_df)\npytest.mark.no_xvfbpytest.mark.skipif(sys.platform == 'darwin', reason='It fails on macOS')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"\n        Return the namespace view\n\n        This is a dictionary with the following structure\n\n        {'a': {'color': '#800000', 'size': 1, 'type': 'str', 'view': '1'}}\n\n        Here:\n        * 'a' is the variable name\n        * 'color' is the color used to show it\n        * 'size' and 'type' are self-evident\n        * and'view' is its value or the text shown in the last column\n        \"\"\"\nfrom spyder_kernels.utils.nsview import make_remote_view\nsettings = self.namespace_view_settings\nif settings:\n    ns = self._get_current_namespace()\n    view = make_remote_view(ns, settings, EXCLUDED_NAMES)\n    return view\nelse:\n    return None\n",
        "CUT_5": "\"\"\"Set the current namespace view.\"\"\"\nif self.namespacebrowser is not None:\n    self.namespacebrowser.process_remote_view(view)\n"
    },
    {
        "functionName": "test_dataframemodel_set_data_complex",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that editing complex dtypes is handled gracefully in df editor.\n\n    Unit regression test for spyder-ide/spyder#6115.\n    \"\"\"\nMockQMessageBox = Mock()\nattr_to_patch = ('spyder.plugins.variableexplorer.widgets' +\n    '.dataframeeditor.QMessageBox')\nmonkeypatch.setattr(attr_to_patch, MockQMessageBox)\ntest_params = [(1, numpy.complex128), (2, numpy.complex64), (3, complex)]\nfor count, complex_type in test_params:\n    test_df = DataFrame(numpy.arange(10, 15), dtype=complex_type)\n    model = DataFrameModel(test_df.copy())\n    index = model.createIndex(2, 0)\n    assert not model.setData(index, '42')\n    MockQMessageBox.critical.assert_called_with(ANY, 'Error', ANY)\n    assert MockQMessageBox.critical.call_count == count\n    try:\n        assert numpy.sum(test_df[0].values == model.df.values) == len(test_df)\n    except AttributeError:\n        assert numpy.sum(test_df[0].as_matrix() == model.df.as_matrix()\n            ) == len(test_df)\n",
        "CUT_1": "\"\"\"Return True if variable is a NumPy array\"\"\"\ntry:\n    import numpy\n    return isinstance(var, numpy.ndarray)\nexcept:\n    return False\n",
        "CUT_2": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_3": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_4": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_5": "\"\"\"Return data\"\"\"\nreturn self.df\n"
    },
    {
        "functionName": "test_dataframeeditor_edit_complex",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that editing complex dtypes is handled gracefully in df editor.\n\n    Integration regression test for spyder-ide/spyder#6115.\n    \"\"\"\nMockQMessageBox = Mock()\nattr_to_patch = ('spyder.plugins.variableexplorer.widgets' +\n    '.dataframeeditor.QMessageBox')\nmonkeypatch.setattr(attr_to_patch, MockQMessageBox)\ntest_params = [(1, numpy.complex128), (2, numpy.complex64), (3, complex)]\nfor count, complex_type in test_params:\n    test_df = DataFrame(numpy.arange(10, 15), dtype=complex_type)\n    dialog = DataFrameEditor()\n    assert dialog.setup_and_check(test_df, 'Test Dataframe')\n    dialog.show()\n    qtbot.waitForWindowShown(dialog)\n    view = dialog.dataTable\n    qtbot.keyClick(view, Qt.Key_Right)\n    qtbot.keyClick(view, Qt.Key_Down)\n    qtbot.keyClick(view, Qt.Key_Space)\n    qtbot.keyClick(view.focusWidget(), Qt.Key_Backspace)\n    qtbot.keyClicks(view.focusWidget(), '42')\n    qtbot.keyClick(view.focusWidget(), Qt.Key_Down)\n    MockQMessageBox.critical.assert_called_with(ANY, 'Error', ANY)\n    assert MockQMessageBox.critical.call_count == count * 2 - 1\n    qtbot.keyClick(view, Qt.Key_Down)\n    qtbot.keyClick(view, '1')\n    qtbot.keyClick(view.focusWidget(), Qt.Key_Down)\n    MockQMessageBox.critical.assert_called_with(ANY, 'Error',\n        'Editing dtype {0!s} not yet supported.'.format(type(test_df.iloc[1,\n        0]).__name__))\n    assert MockQMessageBox.critical.call_count == count * 2\n    qtbot.wait(200)\n    dialog.accept()\n    qtbot.wait(500)\n    try:\n        assert numpy.sum(test_df[0].values == dialog.get_value().values\n            ) == len(test_df)\n    except AttributeError:\n        assert numpy.sum(test_df[0].as_matrix() == dialog.get_value().\n            as_matrix()) == len(test_df)\npytest.mark.no_xvfbpytest.mark.skipif(sys.platform == 'darwin', reason='It fails on macOS')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"\n        Return the namespace view\n\n        This is a dictionary with the following structure\n\n        {'a': {'color': '#800000', 'size': 1, 'type': 'str', 'view': '1'}}\n\n        Here:\n        * 'a' is the variable name\n        * 'color' is the color used to show it\n        * 'size' and 'type' are self-evident\n        * and'view' is its value or the text shown in the last column\n        \"\"\"\nfrom spyder_kernels.utils.nsview import make_remote_view\nsettings = self.namespace_view_settings\nif settings:\n    ns = self._get_current_namespace()\n    view = make_remote_view(ns, settings, EXCLUDED_NAMES)\n    return view\nelse:\n    return None\n",
        "CUT_5": "\"\"\"Set the current namespace view.\"\"\"\nif self.namespacebrowser is not None:\n    self.namespacebrowser.process_remote_view(view)\n"
    },
    {
        "functionName": "test_dataframemodel_set_data_bool",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that bools are editible in df and false-y strs are detected.\"\"\"\nMockQMessageBox = Mock()\nattr_to_patch = ('spyder.plugins.variableexplorer.widgets' +\n    '.dataframeeditor.QMessageBox')\nmonkeypatch.setattr(attr_to_patch, MockQMessageBox)\ntest_params = [numpy.bool_, numpy.bool, bool]\ntest_strs = ['foo', 'false', 'f', '0', '0.', '0.0', '', ' ']\nexpected_df = DataFrame([1, 0, 0, 0, 0, 0, 0, 0, 0], dtype=bool)\nfor bool_type in test_params:\n    test_df = DataFrame([0, 1, 1, 1, 1, 1, 1, 1, 0], dtype=bool_type)\n    model = DataFrameModel(test_df.copy())\n    for idx, test_str in enumerate(test_strs):\n        assert model.setData(model.createIndex(idx, 0), test_str)\n        assert not MockQMessageBox.critical.called\n    try:\n        assert numpy.sum(expected_df[0].values == model.df.values[:, (0)]\n            ) == len(expected_df)\n    except AttributeError:\n        assert numpy.sum(expected_df[0].as_matrix() == model.df.as_matrix()\n            [:, (0)]) == len(expected_df)\n",
        "CUT_1": "\"\"\"Return True if variable is a NumPy array\"\"\"\ntry:\n    import numpy\n    return isinstance(var, numpy.ndarray)\nexcept:\n    return False\n",
        "CUT_2": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_3": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_4": "\"\"\"Save all items expanded state\"\"\"\nmodel = self.model()\nif model is not None:\n    self.__expanded_state = []\n    for idx in model.persistentIndexList():\n        if self.isExpanded(idx):\n            self.__expanded_state.append(self.get_filename(idx))\n",
        "CUT_5": "\"\"\"Save all items expanded state\"\"\"\nmodel = self.model()\nif model is not None:\n    self.__expanded_state = []\n    for idx in model.persistentIndexList():\n        if self.isExpanded(idx):\n            self.__expanded_state.append(self.get_filename(idx))\n"
    },
    {
        "functionName": "test_dataframeeditor_edit_bool",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that bools are editible in df and false-y strs are detected.\"\"\"\nMockQMessageBox = Mock()\nattr_to_patch = ('spyder.plugins.variableexplorer.widgets' +\n    '.dataframeeditor.QMessageBox')\nmonkeypatch.setattr(attr_to_patch, MockQMessageBox)\ntest_params = [numpy.bool_, numpy.bool, bool]\ntest_strs = ['foo', 'false', 'f', '0', '0.', '0.0', '', ' ']\nexpected_df = DataFrame([1, 0, 0, 0, 0, 0, 0, 0, 0], dtype=bool)\nfor bool_type in test_params:\n    test_df = DataFrame([0, 1, 1, 1, 1, 1, 1, 1, 0], dtype=bool_type)\n    dialog = DataFrameEditor()\n    assert dialog.setup_and_check(test_df, 'Test Dataframe')\n    dialog.show()\n    qtbot.waitForWindowShown(dialog)\n    view = dialog.dataTable\n    qtbot.keyClick(view, Qt.Key_Right)\n    for test_str in test_strs:\n        qtbot.keyClick(view, Qt.Key_Space)\n        qtbot.keyClick(view.focusWidget(), Qt.Key_Backspace)\n        qtbot.keyClicks(view.focusWidget(), test_str)\n        qtbot.keyClick(view.focusWidget(), Qt.Key_Down)\n        assert not MockQMessageBox.critical.called\n    qtbot.wait(200)\n    dialog.accept()\n    qtbot.wait(500)\n    try:\n        assert numpy.sum(expected_df[0].values == dialog.get_value().values\n            [:, (0)]) == len(expected_df)\n    except AttributeError:\n        assert numpy.sum(expected_df[0].as_matrix() == dialog.get_value().\n            as_matrix()[:, (0)]) == len(expected_df)\npytest.mark.no_xvfbpytest.mark.skipif(sys.platform == 'darwin', reason='It fails on macOS')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_5": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()"
    },
    {
        "functionName": "test_non_ascii_index",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that there are no errors when displaying a dataframe with\n    a non-ascii index and header.\n    \"\"\"\ndf = read_csv(os.path.join(FILES_PATH, 'issue_5833.csv'), index_col=0)\neditor = DataFrameEditor(None)\neditor.setup_and_check(df)\nindex = editor.table_index.model()\nheader = editor.table_header.model()\ndfm = editor.model()\nassert header.headerData(0, Qt.Horizontal, Qt.DisplayRole) == '\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435'\nassert data_index(index, 0, 0) == '\u043f\u0440\u0438\u043c\u0435\u0440'\nassert data(dfm, 0, 0) == '\u0444\u0430\u0439\u043b\u0430'\n",
        "CUT_1": "\"\"\"Set editor widget's data\"\"\"\ntext = from_qvariant(index.model().data(index, Qt.DisplayRole), str)\neditor.setText(text)\n",
        "CUT_2": "\"\"\"Set editor widget's data\"\"\"\ntext = from_qvariant(index.model().data(index, Qt.DisplayRole), str)\neditor.setText(text)\n",
        "CUT_3": "\"\"\"\n        Get the data for the header.\n\n        This is used when a header has levels.\n        \"\"\"\nif not index.isValid() or index.row() >= self._shape[0] or index.column(\n    ) >= self._shape[1]:\n    return None\nrow, col = (index.row(), index.column()) if self.axis == 0 else (index.\n    column(), index.row())\nif role != Qt.DisplayRole:\n    return None\nif self.axis == 0 and self._shape[0] <= 1:\n    return None\nheader = self.model.header(self.axis, col, row)\nif not is_type_text_string(header):\n    header = to_text_string(header)\nreturn header\n",
        "CUT_4": "\"\"\"\n        Get the data for the header.\n\n        This is used when a header has levels.\n        \"\"\"\nif not index.isValid() or index.row() >= self._shape[0] or index.column(\n    ) >= self._shape[1]:\n    return None\nrow, col = (index.row(), index.column()) if self.axis == 0 else (index.\n    column(), index.row())\nif role != Qt.DisplayRole:\n    return None\nif self.axis == 0 and self._shape[0] <= 1:\n    return None\nheader = self.model.header(self.axis, col, row)\nif not is_type_text_string(header):\n    header = to_text_string(header)\nreturn header\n",
        "CUT_5": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n"
    },
    {
        "functionName": "test_no_convert_strings_to_unicode",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that we don't apply any conversion to strings in headers,\n    indexes or data.\n    \"\"\"\ndf = read_csv(os.path.join(FILES_PATH, 'issue_5833.csv'), index_col=0,\n    encoding='koi8_r')\neditor = DataFrameEditor(None)\neditor.setup_and_check(df)\nindex = editor.table_index.model()\nheader = editor.table_header.model()\ndfm = editor.model()\nassert header.headerData(0, Qt.Horizontal, Qt.DisplayRole) != '\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435'\nassert data_index(index, 0, 0) != '\u043f\u0440\u0438\u043c\u0435\u0440'\nassert data(dfm, 0, 0) != '\u0444\u0430\u0439\u043b\u0430'\n",
        "CUT_1": "\"\"\"Set editor widget's data\"\"\"\ntext = from_qvariant(index.model().data(index, Qt.DisplayRole), str)\neditor.setText(text)\n",
        "CUT_2": "\"\"\"Set editor widget's data\"\"\"\ntext = from_qvariant(index.model().data(index, Qt.DisplayRole), str)\neditor.setText(text)\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Return data\"\"\"\nreturn self.df\n"
    },
    {
        "functionName": "importwizard",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_importwizard.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up ImportWizard.\"\"\"\ntext = \"\"\"17/11/1976\t1.34\n14/05/09\t3.14\"\"\"\nimportwizard = ImportWizard(None, text)\nqtbot.addWidget(importwizard)\nreturn importwizard\npytest.fixture",
        "CUT_1": "\"\"\"Test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ndialog = ImportWizard(None, text)\nif dialog.exec_():\n    print(dialog.get_data())\n",
        "CUT_2": "\"\"\"Test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ndialog = ImportWizard(None, text)\nif dialog.exec_():\n    print(dialog.get_data())\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Import data from string\"\"\"\ndata = self.source_model.get_data()\nif not hasattr(data, 'keys'):\n    return\neditor = ImportWizard(self, text, title=title, contents_title=_(\n    'Clipboard contents'), varname=fix_reference_name('data', blacklist=\n    list(data.keys())))\nif editor.exec_():\n    var_name, clip_data = editor.get_data()\n    self.new_value(var_name, clip_data)\n",
        "CUT_5": "\"\"\"Import data from string\"\"\"\ndata = self.source_model.get_data()\nif not hasattr(data, 'keys'):\n    return\neditor = ImportWizard(self, text, title=title, contents_title=_(\n    'Clipboard contents'), varname=fix_reference_name('data', blacklist=\n    list(data.keys())))\nif editor.exec_():\n    var_name, clip_data = editor.get_data()\n    self.new_value(var_name, clip_data)\n"
    },
    {
        "functionName": "test_importwizard",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_importwizard.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run ImportWizard dialog.\"\"\"\nimportwizard.show()\nassert importwizard\n",
        "CUT_1": "\"\"\"Test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ndialog = ImportWizard(None, text)\nif dialog.exec_():\n    print(dialog.get_data())\n",
        "CUT_2": "\"\"\"Test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ndialog = ImportWizard(None, text)\nif dialog.exec_():\n    print(dialog.get_data())\n",
        "CUT_3": "\"\"\"Import data from string\"\"\"\ndata = self.source_model.get_data()\nif not hasattr(data, 'keys'):\n    return\neditor = ImportWizard(self, text, title=title, contents_title=_(\n    'Clipboard contents'), varname=fix_reference_name('data', blacklist=\n    list(data.keys())))\nif editor.exec_():\n    var_name, clip_data = editor.get_data()\n    self.new_value(var_name, clip_data)\n",
        "CUT_4": "\"\"\"Import data from string\"\"\"\ndata = self.source_model.get_data()\nif not hasattr(data, 'keys'):\n    return\neditor = ImportWizard(self, text, title=title, contents_title=_(\n    'Clipboard contents'), varname=fix_reference_name('data', blacklist=\n    list(data.keys())))\nif editor.exec_():\n    var_name, clip_data = editor.get_data()\n    self.new_value(var_name, clip_data)\n",
        "CUT_5": "return _('Run')\n"
    },
    {
        "functionName": "texteditor",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_texteditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up TextEditor.\"\"\"\ndef create_texteditor(text, **kwargs):\n    editor = TextEditor(text, **kwargs)\n    qtbot.addWidget(editor)\n    return editor\nreturn create_texteditor\npytest.fixture",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture",
        "CUT_5": "\"\"\"CodeEditor instance with ability to mock the completions response.\n\n    Returns a tuple of (editor, mock_response). Tests using this fixture should\n    set `mock_response.side_effect = lambda lang, method, params: {}`.\n    \"\"\"\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.show()\nmock_response = Mock()\ndef perform_request(lang, method, params):\n    resp = mock_response(lang, method, params)\n    print('DEBUG {}'.format(resp))\n    if resp is not None:\n        editor.handle_response(method, resp)\neditor.sig_perform_completion_request.connect(perform_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\neditor.completions_available = True\nqtbot_module.wait(2000)\ndef teardown():\n    editor.hide()\n    editor.completion_widget.hide()\nrequest.addfinalizer(teardown)\nreturn editor, mock_response\npytest.fixture"
    },
    {
        "functionName": "create_texteditor",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_texteditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = TextEditor(text, **kwargs)\nqtbot.addWidget(editor)\nreturn editor\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n"
    },
    {
        "functionName": "test_texteditor",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_texteditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run TextEditor dialog.\"\"\"\neditor = texteditor(TEXT)\neditor.show()\nassert editor\ndlg_text = editor.get_value()\nassert TEXT == dlg_text\n",
        "CUT_1": "\"\"\"Text editor demo\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ntext = \"\"\"01234567890123456789012345678901234567890123456789012345678901234567890123456789\ndedekdh elkd ezd ekjd lekdj elkdfjelfjk e\"\"\"\ndialog = TextEditor(text)\ndialog.exec_()\ndlg_text = dialog.get_value()\nassert text == dlg_text\n",
        "CUT_2": "\"\"\"Text editor demo\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ntext = \"\"\"01234567890123456789012345678901234567890123456789012345678901234567890123456789\ndedekdh elkd ezd ekjd lekdj elkdfjelfjk e\"\"\"\ndialog = TextEditor(text)\ndialog.exec_()\ndlg_text = dialog.get_value()\nassert text == dlg_text\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_texteditor_setup_and_check",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_texteditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "import string\ndig_its = string.digits\ntranslate_digits = string.maketrans(dig_its, len(dig_its) * ' ')\neditor = texteditor(None)\nassert not editor.setup_and_check(translate_digits)\npytest.mark.skipif(PY3, reason='It makes no sense in Python 3')",
        "CUT_1": "return str(string)\n",
        "CUT_2": "return str(string)\n",
        "CUT_3": "\"\"\"\n    Return a unicode version of string decoded using the file system encoding.\n    \"\"\"\nif not is_string(string):\n    string = to_text_string(string.toUtf8(), 'utf-8')\nelif is_binary_string(string):\n    try:\n        unic = string.decode(FS_ENCODING)\n    except (UnicodeError, TypeError):\n        pass\n    else:\n        return unic\nreturn string\n",
        "CUT_4": "\"\"\"\n    Return a unicode version of string decoded using the file system encoding.\n    \"\"\"\nif not is_string(string):\n    string = to_text_string(string.toUtf8(), 'utf-8')\nelif is_binary_string(string):\n    try:\n        unic = string.decode(FS_ENCODING)\n    except (UnicodeError, TypeError):\n        pass\n    else:\n        return unic\nreturn string\n",
        "CUT_5": "\"\"\"Check if string can be a variable name.\"\"\"\nreturn re.match(tokenize.Name + '\\\\Z', string) is not None\n"
    },
    {
        "functionName": "test_title",
        "className": null,
        "fileName": "/spyder/plugins/variableexplorer/widgets/tests/test_texteditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = texteditor(TEXT, title=title)\neditor.show()\ndlg_title = editor.windowTitle()\nassert title in dlg_title\npytest.mark.parametrize('title', ['\u00f1', 'r'])",
        "CUT_1": "\"\"\"Return widget title\"\"\"\ntitle = _('Editor')\nreturn title\n",
        "CUT_2": "\"\"\"Return widget title\"\"\"\ntitle = _('Editor')\nreturn title\n",
        "CUT_3": "self.title = text\n",
        "CUT_4": "self.title = text\n",
        "CUT_5": "\"\"\"Get model title\"\"\"\nreturn self.editor.source_model.title\n"
    },
    {
        "functionName": "__init__",
        "className": "MainWindowMock",
        "fileName": "/spyder/plugins/pylint/tests/test_pylint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "super(MainWindowMock, self).__init__(None)\nself.editor = Mock()\nself.editor.sig_editor_focus_changed = self.sig_editor_focus_changed\nself.projects = MagicMock()\n",
        "CUT_1": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_2": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "return Mock()\n",
        "CUT_5": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture"
    },
    {
        "functionName": "pylintrc_search_paths",
        "className": null,
        "fileName": "/spyder/plugins/pylint/tests/test_pylint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Construct temporary .pylintrc search paths.\"\"\"\nsearch_paths = {dir_name: str(tmp_path_factory.mktemp(dir_name)) for\n    dir_name in DIR_LIST}\nreturn search_paths\npytest.fixture",
        "CUT_1": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_2": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_3": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_4": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "pylint_test_script",
        "className": null,
        "fileName": "/spyder/plugins/pylint/tests/test_pylint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Write a script for testing Pylint to a temporary directory.\"\"\"\nscript_path = osp.join(pylintrc_search_paths[SCRIPT_DIR], 'test_script.py')\nwith open(script_path, mode='w', encoding='utf-8', newline='\\n'\n    ) as script_file:\n    script_file.write(PYLINT_TEST_SCRIPT)\nreturn script_path\npytest.fixture",
        "CUT_1": "\"\"\"\n    Return path for bash/batch conda activation script to run spyder-kernels.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nscripts_folder_path = os.path.join(os.path.dirname(HERE), 'scripts')\nif os.name == 'nt':\n    script = 'conda-activate.bat'\nelse:\n    script = 'conda-activate.sh'\nscript_path = os.path.join(scripts_folder_path, script)\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_2": "\"\"\"\n    Return path for bash/batch conda activation script to run spyder-kernels.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nscripts_folder_path = os.path.join(os.path.dirname(HERE), 'scripts')\nif os.name == 'nt':\n    script = 'conda-activate.bat'\nelse:\n    script = 'conda-activate.sh'\nscript_path = os.path.join(scripts_folder_path, script)\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_3": "\"\"\"\n    Return full path to conda activation script.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nif os.name == 'nt':\n    activate = 'Scripts/activate'\nelse:\n    activate = 'bin/activate'\nscript_path = os.path.join(get_conda_root_prefix(pyexec, quote=False), activate\n    ).replace('\\\\', '/')\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_4": "\"\"\"\n    Return full path to conda activation script.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nif os.name == 'nt':\n    activate = 'Scripts/activate'\nelse:\n    activate = 'bin/activate'\nscript_path = os.path.join(get_conda_root_prefix(pyexec, quote=False), activate\n    ).replace('\\\\', '/')\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_5": "\"\"\"\n    Write 'lines' to file ('filename') assuming 'encoding'\n    Return (eventually new) encoding\n    \"\"\"\nreturn write(os.linesep.join(lines), filename, encoding, mode)\n"
    },
    {
        "functionName": "pylint_test_scripts",
        "className": null,
        "fileName": "/spyder/plugins/pylint/tests/test_pylint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "def _pylint_test_scripts(filenames):\n    \"\"\"Write scripts for testing Pylint to a temporary directory.\"\"\"\n    script_paths = []\n    for filename in filenames:\n        script_path = osp.join(pylintrc_search_paths[SCRIPT_DIR], filename)\n        with open(script_path, mode='w', encoding='utf-8', newline='\\n'\n            ) as script_file:\n            script_file.write(PYLINT_TEST_SCRIPT)\n        script_paths.append(script_path)\n    return script_paths\nreturn _pylint_test_scripts\npytest.fixture",
        "CUT_1": "\"\"\"\n    Return full path to conda activation script.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nif os.name == 'nt':\n    activate = 'Scripts/activate'\nelse:\n    activate = 'bin/activate'\nscript_path = os.path.join(get_conda_root_prefix(pyexec, quote=False), activate\n    ).replace('\\\\', '/')\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_2": "\"\"\"\n    Return full path to conda activation script.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nif os.name == 'nt':\n    activate = 'Scripts/activate'\nelse:\n    activate = 'bin/activate'\nscript_path = os.path.join(get_conda_root_prefix(pyexec, quote=False), activate\n    ).replace('\\\\', '/')\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_3": "\"\"\"\n    Return path for bash/batch conda activation script to run spyder-kernels.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nscripts_folder_path = os.path.join(os.path.dirname(HERE), 'scripts')\nif os.name == 'nt':\n    script = 'conda-activate.bat'\nelse:\n    script = 'conda-activate.sh'\nscript_path = os.path.join(scripts_folder_path, script)\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_4": "\"\"\"\n    Return path for bash/batch conda activation script to run spyder-kernels.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nscripts_folder_path = os.path.join(os.path.dirname(HERE), 'scripts')\nif os.name == 'nt':\n    script = 'conda-activate.bat'\nelse:\n    script = 'conda-activate.sh'\nscript_path = os.path.join(scripts_folder_path, script)\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_5": "\"\"\"\n    Write 'lines' to file ('filename') assuming 'encoding'\n    Return (eventually new) encoding\n    \"\"\"\nreturn write(os.linesep.join(lines), filename, encoding, mode)\n"
    },
    {
        "functionName": "_pylint_test_scripts",
        "className": null,
        "fileName": "/spyder/plugins/pylint/tests/test_pylint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Write scripts for testing Pylint to a temporary directory.\"\"\"\nscript_paths = []\nfor filename in filenames:\n    script_path = osp.join(pylintrc_search_paths[SCRIPT_DIR], filename)\n    with open(script_path, mode='w', encoding='utf-8', newline='\\n'\n        ) as script_file:\n        script_file.write(PYLINT_TEST_SCRIPT)\n    script_paths.append(script_path)\nreturn script_paths\n",
        "CUT_1": "\"\"\"\n    Return full path to conda activation script.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nif os.name == 'nt':\n    activate = 'Scripts/activate'\nelse:\n    activate = 'bin/activate'\nscript_path = os.path.join(get_conda_root_prefix(pyexec, quote=False), activate\n    ).replace('\\\\', '/')\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_2": "\"\"\"\n    Return full path to conda activation script.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nif os.name == 'nt':\n    activate = 'Scripts/activate'\nelse:\n    activate = 'bin/activate'\nscript_path = os.path.join(get_conda_root_prefix(pyexec, quote=False), activate\n    ).replace('\\\\', '/')\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_3": "\"\"\"\n    Return path for bash/batch conda activation script to run spyder-kernels.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nscripts_folder_path = os.path.join(os.path.dirname(HERE), 'scripts')\nif os.name == 'nt':\n    script = 'conda-activate.bat'\nelse:\n    script = 'conda-activate.sh'\nscript_path = os.path.join(scripts_folder_path, script)\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_4": "\"\"\"\n    Return path for bash/batch conda activation script to run spyder-kernels.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nscripts_folder_path = os.path.join(os.path.dirname(HERE), 'scripts')\nif os.name == 'nt':\n    script = 'conda-activate.bat'\nelse:\n    script = 'conda-activate.sh'\nscript_path = os.path.join(scripts_folder_path, script)\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_5": "\"\"\"\n    Write 'lines' to file ('filename') assuming 'encoding'\n    Return (eventually new) encoding\n    \"\"\"\nreturn write(os.linesep.join(lines), filename, encoding, mode)\n"
    },
    {
        "functionName": "pylintrc_files",
        "className": null,
        "fileName": "/spyder/plugins/pylint/tests/test_pylint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Store test .pylintrc files at the paths and determine the result.\"\"\"\nsearch_paths = pylintrc_search_paths\npylintrc_locations = request.param\nbad_names = [ALL_DIR]\nfor search_path_name, search_path in search_paths.items():\n    if search_path_name in pylintrc_locations:\n        expected_path = osp.join(search_path, PYLINTRC_FILENAME)\n        bad_names += [search_path_name]\n        break\nelse:\n    expected_path = None\n    bad_names = [NO_DIR]\nfor location in pylintrc_locations:\n    pylintrc_test_contents = PYLINTRC_TEST_CONTENTS.format(bad_names=', '.\n        join([location, ALL_DIR]))\n    pylintrc_path = osp.join(search_paths[location], PYLINTRC_FILENAME)\n    with open(pylintrc_path, mode='w', encoding='utf-8', newline='\\n'\n        ) as rc_file:\n        rc_file.write(pylintrc_test_contents)\nreturn search_paths, expected_path, bad_names\npytest.fixture(params=[[], [SCRIPT_DIR], [WORKING_DIR], [PROJECT_DIR], [\n    HOME_DIR], [SCRIPT_DIR, HOME_DIR], [WORKING_DIR, PROJECT_DIR], [\n    SCRIPT_DIR, PROJECT_DIR], [PROJECT_DIR, HOME_DIR], [SCRIPT_DIR,\n    WORKING_DIR, PROJECT_DIR, HOME_DIR]], ids=['None', 'Script', 'Working',\n    'Project', 'Home', 'Script & Home', 'Working & Project',\n    'Script & Working', 'Project & Home', 'All'])",
        "CUT_1": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_2": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_3": "\"\"\"Return the files that can update system configuration defaults.\"\"\"\nCONDA_PREFIX = os.environ.get('CONDA_PREFIX', None)\nif os.name == 'nt':\n    SEARCH_PATH = 'C:/ProgramData/spyder',\nelse:\n    SEARCH_PATH = '/etc/spyder', '/usr/local/etc/spyder'\nif CONDA_PREFIX is not None:\n    CONDA_PREFIX = CONDA_PREFIX.replace('\\\\', '/')\n    SEARCH_PATH += '{}/etc/spyder'.format(CONDA_PREFIX),\nif running_under_pytest():\n    search_paths = []\n    tmpfolder = str(tempfile.gettempdir())\n    for i in range(3):\n        path = os.path.join(tmpfolder, 'site-config-' + str(i))\n        if not os.path.isdir(path):\n            os.makedirs(path)\n        search_paths.append(path)\n    SEARCH_PATH = tuple(search_paths)\nreturn SEARCH_PATH\n",
        "CUT_4": "\"\"\"Return the files that can update system configuration defaults.\"\"\"\nCONDA_PREFIX = os.environ.get('CONDA_PREFIX', None)\nif os.name == 'nt':\n    SEARCH_PATH = 'C:/ProgramData/spyder',\nelse:\n    SEARCH_PATH = '/etc/spyder', '/usr/local/etc/spyder'\nif CONDA_PREFIX is not None:\n    CONDA_PREFIX = CONDA_PREFIX.replace('\\\\', '/')\n    SEARCH_PATH += '{}/etc/spyder'.format(CONDA_PREFIX),\nif running_under_pytest():\n    search_paths = []\n    tmpfolder = str(tempfile.gettempdir())\n    for i in range(3):\n        path = os.path.join(tmpfolder, 'site-config-' + str(i))\n        if not os.path.isdir(path):\n            os.makedirs(path)\n        search_paths.append(path)\n    SEARCH_PATH = tuple(search_paths)\nreturn SEARCH_PATH\n",
        "CUT_5": "\"\"\"Get the path to the highest pylintrc file on a set of search paths.\"\"\"\ncurrent_cwd = os.getcwd()\npylintrc_path = None\nif home_path is None:\n    home_path = osp.expanduser('~')\ntry:\n    pylintrc_paths = [_find_pylintrc_path(path) for path in search_paths if\n        path]\n    pylintrc_path_home = _find_pylintrc_path(home_path)\n    for pylintrc_path in pylintrc_paths:\n        if pylintrc_path is not None and pylintrc_path != pylintrc_path_home:\n            break\nfinally:\n    os.chdir(current_cwd)\nreturn pylintrc_path\n"
    },
    {
        "functionName": "test_get_pylintrc_path",
        "className": null,
        "fileName": "/spyder/plugins/pylint/tests/test_pylint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that get_pylintrc_path finds the expected one in the hiearchy.\"\"\"\nsearch_paths, expected_path, __ = pylintrc_files\nmocker.patch('pylint.config.os.path.expanduser', return_value=search_paths[\n    HOME_DIR])\nactual_path = get_pylintrc_path(search_paths=list(search_paths.values()),\n    home_path=search_paths[HOME_DIR])\nassert actual_path == expected_path\n",
        "CUT_1": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_2": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_3": "\"\"\"Return the files that can update system configuration defaults.\"\"\"\nCONDA_PREFIX = os.environ.get('CONDA_PREFIX', None)\nif os.name == 'nt':\n    SEARCH_PATH = 'C:/ProgramData/spyder',\nelse:\n    SEARCH_PATH = '/etc/spyder', '/usr/local/etc/spyder'\nif CONDA_PREFIX is not None:\n    CONDA_PREFIX = CONDA_PREFIX.replace('\\\\', '/')\n    SEARCH_PATH += '{}/etc/spyder'.format(CONDA_PREFIX),\nif running_under_pytest():\n    search_paths = []\n    tmpfolder = str(tempfile.gettempdir())\n    for i in range(3):\n        path = os.path.join(tmpfolder, 'site-config-' + str(i))\n        if not os.path.isdir(path):\n            os.makedirs(path)\n        search_paths.append(path)\n    SEARCH_PATH = tuple(search_paths)\nreturn SEARCH_PATH\n",
        "CUT_4": "\"\"\"Return the files that can update system configuration defaults.\"\"\"\nCONDA_PREFIX = os.environ.get('CONDA_PREFIX', None)\nif os.name == 'nt':\n    SEARCH_PATH = 'C:/ProgramData/spyder',\nelse:\n    SEARCH_PATH = '/etc/spyder', '/usr/local/etc/spyder'\nif CONDA_PREFIX is not None:\n    CONDA_PREFIX = CONDA_PREFIX.replace('\\\\', '/')\n    SEARCH_PATH += '{}/etc/spyder'.format(CONDA_PREFIX),\nif running_under_pytest():\n    search_paths = []\n    tmpfolder = str(tempfile.gettempdir())\n    for i in range(3):\n        path = os.path.join(tmpfolder, 'site-config-' + str(i))\n        if not os.path.isdir(path):\n            os.makedirs(path)\n        search_paths.append(path)\n    SEARCH_PATH = tuple(search_paths)\nreturn SEARCH_PATH\n",
        "CUT_5": "\"\"\"Get the path to the highest pylintrc file on a set of search paths.\"\"\"\ncurrent_cwd = os.getcwd()\npylintrc_path = None\nif home_path is None:\n    home_path = osp.expanduser('~')\ntry:\n    pylintrc_paths = [_find_pylintrc_path(path) for path in search_paths if\n        path]\n    pylintrc_path_home = _find_pylintrc_path(home_path)\n    for pylintrc_path in pylintrc_paths:\n        if pylintrc_path is not None and pylintrc_path != pylintrc_path_home:\n            break\nfinally:\n    os.chdir(current_cwd)\nreturn pylintrc_path\n"
    },
    {
        "functionName": "test_pylint_widget_noproject",
        "className": null,
        "fileName": "/spyder/plugins/pylint/tests/test_pylint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that pylint works without errors with no project open.\"\"\"\nmain_window = MainWindowMock()\nmain_window.projects.get_active_project_path = mocker.MagicMock(return_value\n    =None)\npylint_sw = Pylint(parent=main_window)\npylint_widget = PylintWidget(parent=pylint_sw)\npylint_widget.analyze(filename=pylint_test_script)\nqtbot.waitUntil(lambda : pylint_widget.get_data(pylint_test_script)[1] is not\n    None, timeout=5000)\npylint_data = pylint_widget.get_data(filename=pylint_test_script)\nprint(pylint_data)\nassert pylint_data\nassert pylint_data[0] is not None\nassert pylint_data[1] is not None\n",
        "CUT_1": "\"\"\"Return if filename is in the editor stack.\n\n        Args:\n            filename: Name of the file to search for.  If filename is None,\n                then checks if any file is open.\n\n        Returns:\n            True: If filename is None and a file is open.\n            False: If filename is None and no files are open.\n            None: If filename is not None and the file isn't found.\n            integer: Index of file name in editor stack.\n        \"\"\"\nif filename is None:\n    return len(self.data) > 0\nelse:\n    return self.has_filename(filename)\n",
        "CUT_2": "\"\"\"Return if filename is in the editor stack.\n\n        Args:\n            filename: Name of the file to search for.  If filename is None,\n                then checks if any file is open.\n\n        Returns:\n            True: If filename is None and a file is open.\n            False: If filename is None and no files are open.\n            None: If filename is not None and the file isn't found.\n            integer: Index of file name in editor stack.\n        \"\"\"\nif filename is None:\n    return len(self.data) > 0\nelse:\n    return self.has_filename(filename)\n",
        "CUT_3": "\"\"\"Reimplement analyze method\"\"\"\nif self.dockwidget:\n    self.switch_to_plugin()\nself.pylint.analyze(filename)\n",
        "CUT_4": "\"\"\"Reimplement analyze method\"\"\"\nif self.dockwidget:\n    self.switch_to_plugin()\nself.pylint.analyze(filename)\n",
        "CUT_5": "\"\"\"Refresh pylint widget\"\"\"\nself.pylint.remove_obsolete_items()\n"
    },
    {
        "functionName": "test_pylint_widget_pylintrc",
        "className": null,
        "fileName": "/spyder/plugins/pylint/tests/test_pylint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that entire pylint widget gets results depending on pylintrc.\"\"\"\nsearch_paths, __, bad_names = pylintrc_files\nmocker.patch('pylint.config.os.path.expanduser', return_value=search_paths[\n    HOME_DIR])\nmocker.patch('spyder.plugins.pylint.widgets.pylintgui.getcwd_or_home',\n    return_value=search_paths[WORKING_DIR])\nmocker.patch('spyder.plugins.pylint.widgets.pylintgui.osp.expanduser',\n    return_value=search_paths[HOME_DIR])\nmain_window = MainWindowMock()\nmain_window.projects.get_active_project_path = mocker.MagicMock(return_value\n    =search_paths[PROJECT_DIR])\npylint_sw = Pylint(parent=main_window)\npylint_widget = PylintWidget(parent=pylint_sw)\npylint_widget.analyze(filename=pylint_test_script)\nqtbot.waitUntil(lambda : pylint_widget.get_data(pylint_test_script)[1] is not\n    None, timeout=5000)\npylint_data = pylint_widget.get_data(filename=pylint_test_script)\nprint(pylint_data)\nassert pylint_data\nconventions = pylint_data[1][3]['C:']\nassert conventions\nassert len(conventions) == len(bad_names)\nassert all([(sum([(bad_name in message[2]) for message in conventions]) == \n    1) for bad_name in bad_names])\n",
        "CUT_1": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_2": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_3": "\"\"\"Refresh pylint widget\"\"\"\nself.pylint.remove_obsolete_items()\n",
        "CUT_4": "\"\"\"Refresh pylint widget\"\"\"\nself.pylint.remove_obsolete_items()\n",
        "CUT_5": "\"\"\"Get current filename in combobox.\"\"\"\nreturn self.pylint.get_filename()\n"
    },
    {
        "functionName": "test_pylint_max_history_conf",
        "className": null,
        "fileName": "/spyder/plugins/pylint/tests/test_pylint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Regression test for checking max_entries configuration.\n\n    For further information see spyder-ide/spyder#12884\n    \"\"\"\nmain_window = MainWindowMock()\nmain_window.projects.get_active_project_path = mocker.MagicMock(return_value\n    =None)\npylint_sw = Pylint(parent=main_window)\npylint_widget = PylintWidget(parent=pylint_sw)\npylint_widget.filecombo.clear()\nscript_0, script_1, script_2 = pylint_test_scripts(['test_script_{}.py'.\n    format(n) for n in range(3)])\npylint_widget.parent.set_option('max_entries', 2)\npylint_widget.change_history_limit(2)\nassert pylint_widget.parent.get_option('max_entries') == 2\npylint_widget.set_filename(filename=script_0)\nassert pylint_widget.filecombo.count() == 1\npylint_widget.set_filename(filename=script_1)\npylint_widget.set_filename(filename=script_2)\nassert pylint_widget.filecombo.count() == 2\nassert 'test_script_2.py' in pylint_widget.curr_filenames[0]\nassert 'test_script_1.py' in pylint_widget.curr_filenames[1]\npylint_widget.parent.set_option('max_entries', 1)\npylint_widget.change_history_limit(1)\nassert pylint_widget.filecombo.count() == 1\nassert 'test_script_2.py' in pylint_widget.curr_filenames[0]\n",
        "CUT_1": "\"\"\"Set filename without performing code analysis.\"\"\"\nfilename = str(filename)\nif self.get_filename() == filename:\n    return\nself.kill_if_running()\nindex, _data = self.get_data(filename)\nis_parent = self.parent is not None\nif filename not in self.curr_filenames:\n    self.filecombo.insertItem(0, filename)\n    self.curr_filenames.insert(0, filename)\n    self.filecombo.setCurrentIndex(0)\nelse:\n    try:\n        index = self.filecombo.findText(filename)\n        self.filecombo.removeItem(index)\n        self.curr_filenames.pop(index)\n    except IndexError:\n        self.curr_filenames.remove(filename)\n    self.filecombo.insertItem(0, filename)\n    self.curr_filenames.insert(0, filename)\n    self.filecombo.setCurrentIndex(0)\nnum_elements = self.filecombo.count()\nif is_parent:\n    if num_elements > self.parent.get_option('max_entries'):\n        self.filecombo.removeItem(num_elements - 1)\nself.filecombo.selected()\nSlot(str)",
        "CUT_2": "\"\"\"Set filename without performing code analysis.\"\"\"\nfilename = str(filename)\nif self.get_filename() == filename:\n    return\nself.kill_if_running()\nindex, _data = self.get_data(filename)\nis_parent = self.parent is not None\nif filename not in self.curr_filenames:\n    self.filecombo.insertItem(0, filename)\n    self.curr_filenames.insert(0, filename)\n    self.filecombo.setCurrentIndex(0)\nelse:\n    try:\n        index = self.filecombo.findText(filename)\n        self.filecombo.removeItem(index)\n        self.curr_filenames.pop(index)\n    except IndexError:\n        self.curr_filenames.remove(filename)\n    self.filecombo.insertItem(0, filename)\n    self.curr_filenames.insert(0, filename)\n    self.filecombo.setCurrentIndex(0)\nnum_elements = self.filecombo.count()\nif is_parent:\n    if num_elements > self.parent.get_option('max_entries'):\n        self.filecombo.removeItem(num_elements - 1)\nself.filecombo.selected()\nSlot(str)",
        "CUT_3": "\"\"\"Apply configuration file's plugin settings\"\"\"\nself.pylint.change_history_limit(self.get_option('max_entries'))\n",
        "CUT_4": "\"\"\"Apply configuration file's plugin settings\"\"\"\nself.pylint.change_history_limit(self.get_option('max_entries'))\n",
        "CUT_5": "\"\"\"Set history limit.\"\"\"\nself.set_option('max_entries', value)\nself.pylint.change_history_limit(value)\n"
    },
    {
        "functionName": "__init__",
        "className": "MainWindowMock",
        "fileName": "/spyder/plugins/pylint/tests/test_pylint_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "super().__init__(None)\nself.editor = Mock()\nself.editor.sig_editor_focus_changed = self.sig_editor_focus_changed\nself.projects = Mock()\n",
        "CUT_1": "return Mock()\n",
        "CUT_2": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture"
    },
    {
        "functionName": "test_config_dialog",
        "className": null,
        "fileName": "/spyder/plugins/pylint/tests/test_pylint_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpage = config_dialog.get_page()\nconfigpage.save_to_conf()\nassert configpage\npytest.mark.parametrize('config_dialog', [[MainWindowMock, [], [Pylint]]],\n    indirect=True)",
        "CUT_1": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_2": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_3": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_4": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "projects",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Projects plugin fixture.\"\"\"\nclass EditorMock(object):\n\n    def get_open_filenames(self):\n        return []\n\n    def __getattr__(self, attr):\n        return Mock()\nclass MainWindowMock(object):\n    editor = EditorMock()\n\n    def __getattr__(self, attr):\n        if attr == 'ipyconsole':\n            return None\n        else:\n            return Mock()\nprojects = Projects(parent=None)\nprojects._setup()\nprojects.shortcut = None\nmocker.patch.object(spyder.plugins.base.SpyderDockWidget,\n    'install_tab_event_filter')\nprojects._create_dockwidget()\nprojects.main = MainWindowMock()\nqtbot.addWidget(projects)\nprojects.show()\nreturn projects\npytest.fixture",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "get_open_filenames",
        "className": "EditorMock",
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return []\n",
        "CUT_1": "return 2\n",
        "CUT_2": "return 2\n",
        "CUT_3": "return ''\n",
        "CUT_4": "return 2\n",
        "CUT_5": "return (a > b) - (a < b)\n"
    },
    {
        "functionName": "__getattr__",
        "className": "EditorMock",
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return Mock()\n",
        "CUT_1": "return Mock()\n",
        "CUT_2": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_3": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_4": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_5": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "__getattr__",
        "className": "MainWindowMock",
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if attr == 'ipyconsole':\n    return None\nelse:\n    return Mock()\n",
        "CUT_1": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n",
        "CUT_2": "return Mock()\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture"
    },
    {
        "functionName": "create_projects",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create a Projects plugin fixture\"\"\"\ndef _create_projects(path, files):\n    \"\"\"\n        Using the Projects plugin fixture, open a project at the\n        specified path, and mock the opening of the specified files\n        in the Editor.\n        \"\"\"\n    projects.open_project(path=path)\n    mocker.patch.object(projects.main.editor, 'get_open_filenames',\n        return_value=files)\n    return projects\nreturn _create_projects\npytest.fixture",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "\"\"\"\n        Get root path to pass to the LSP servers.\n\n        This can be the current project path or the output of\n        getcwd_or_home (except for Python, see below).\n        \"\"\"\npath = None\nif self.main and self.main.projects:\n    path = self.main.projects.get_active_project_path()\nif not path:\n    path = osp.join(get_conf_path(), 'lsp_paths', 'root_path')\n    if not osp.exists(path):\n        os.makedirs(path)\nreturn path\n"
    },
    {
        "functionName": "_create_projects",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n        Using the Projects plugin fixture, open a project at the\n        specified path, and mock the opening of the specified files\n        in the Editor.\n        \"\"\"\nprojects.open_project(path=path)\nmocker.patch.object(projects.main.editor, 'get_open_filenames',\n    return_value=files)\nreturn projects\n",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "test_open_project",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that we can create a project in a given directory.\"\"\"\npath = to_text_string(tmpdir.mkdir(test_directory))\nprojects.open_project(path=path)\nassert projects.is_valid_project(path)\nprojects.close_project()\npytest.mark.parametrize('test_directory', ['\u6e2c\u8a66', '\u0627\u062e\u062a\u0628\u0627\u0631', 'test_dir'])",
        "CUT_1": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_2": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_3": "self.projects = projects\n",
        "CUT_4": "self.projects = projects\n",
        "CUT_5": "\"\"\"\n        Get root path to pass to the LSP servers.\n\n        This can be the current project path or the output of\n        getcwd_or_home (except for Python, see below).\n        \"\"\"\npath = None\nif self.main and self.main.projects:\n    path = self.main.projects.get_active_project_path()\nif not path:\n    path = osp.join(get_conf_path(), 'lsp_paths', 'root_path')\n    if not osp.exists(path):\n        os.makedirs(path)\nreturn path\n"
    },
    {
        "functionName": "test_delete_project",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that we can delete a project.\"\"\"\npath = to_text_string(tmpdir.mkdir(test_directory))\nprojects.open_project(path=path)\nassert projects.is_valid_project(path)\nassert osp.exists(osp.join(path, '.spyproject'))\nmocker.patch.object(QMessageBox, 'warning', return_value=QMessageBox.Yes)\nprojects.delete_project()\nassert not projects.is_valid_project(path)\nassert not osp.exists(osp.join(path, '.spyproject'))\npytest.mark.parametrize('test_directory', ['\u6e2c\u8a66', '\u0627\u062e\u062a\u0628\u0627\u0631', 'test_dir'])",
        "CUT_1": "\"\"\"\n        Get root path to pass to the LSP servers.\n\n        This can be the current project path or the output of\n        getcwd_or_home (except for Python, see below).\n        \"\"\"\npath = None\nif self.main and self.main.projects:\n    path = self.main.projects.get_active_project_path()\nif not path:\n    path = osp.join(get_conf_path(), 'lsp_paths', 'root_path')\n    if not osp.exists(path):\n        os.makedirs(path)\nreturn path\n",
        "CUT_2": "\"\"\"\n        Get root path to pass to the LSP servers.\n\n        This can be the current project path or the output of\n        getcwd_or_home (except for Python, see below).\n        \"\"\"\npath = None\nif self.main and self.main.projects:\n    path = self.main.projects.get_active_project_path()\nif not path:\n    path = osp.join(get_conf_path(), 'lsp_paths', 'root_path')\n    if not osp.exists(path):\n        os.makedirs(path)\nreturn path\n",
        "CUT_3": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_4": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_5": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n"
    },
    {
        "functionName": "test_close_project_sets_visible_config",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that when project is closed, the config option\n    visible_if_project_open is set to the correct value.\"\"\"\nprojects.set_option('visible_if_project_open', not value)\nprojects.open_project(path=to_text_string(tmpdir))\nif value:\n    projects.show_explorer()\nelse:\n    projects.dockwidget.close()\nprojects.close_project()\nassert projects.get_option('visible_if_project_open') == value\npytest.mark.parametrize('value', [True, False])",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_4": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_5": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "test_closing_plugin_sets_visible_config",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that closing_plugin() sets config option visible_if_project_open\n    if a project is open.\"\"\"\nprojects.set_option('visible_if_project_open', not value)\nprojects.closing_plugin()\nassert projects.get_option('visible_if_project_open') == (not value)\nprojects.open_project(path=to_text_string(tmpdir))\nif value:\n    projects.show_explorer()\nelse:\n    projects.dockwidget.close()\nprojects.close_project()\nassert projects.get_option('visible_if_project_open') == value\npytest.mark.parametrize('value', [True, False])",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n"
    },
    {
        "functionName": "test_open_project_uses_visible_config",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that when a project is opened, the project explorer is only opened\n    if the config option visible_if_project_open is set.\"\"\"\nprojects.set_option('visible_if_project_open', value)\nprojects.open_project(path=to_text_string(tmpdir))\nassert projects.dockwidget.isVisible() == value\npytest.mark.parametrize('value', [True, False])",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "\"\"\"\n        Save configuration: opened projects & tree widget state.\n\n        Also save whether dock widget is visible if a project is open.\n        \"\"\"\nself.set_option('recent_projects', self.recent_projects)\nself.set_option('expanded_state', self.explorer.treewidget.get_expanded_state()\n    )\nself.set_option('scrollbar_position', self.explorer.treewidget.\n    get_scrollbar_position())\nif self.current_active_project and self.dockwidget:\n    self.set_option('visible_if_project_open', self.dockwidget.isVisible())\n",
        "CUT_4": "\"\"\"\n        Save configuration: opened projects & tree widget state.\n\n        Also save whether dock widget is visible if a project is open.\n        \"\"\"\nself.set_option('recent_projects', self.recent_projects)\nself.set_option('expanded_state', self.explorer.treewidget.get_expanded_state()\n    )\nself.set_option('scrollbar_position', self.explorer.treewidget.\n    get_scrollbar_position())\nif self.current_active_project and self.dockwidget:\n    self.set_option('visible_if_project_open', self.dockwidget.isVisible())\n",
        "CUT_5": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n"
    },
    {
        "functionName": "test_switch_to_plugin",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that switch_to_plugin always shows the plugin if a project is\n    opened, regardless of the config option visible_if_project_open.\n    Regression test for spyder-ide/spyder#12491.\"\"\"\nprojects.set_option('visible_if_project_open', value)\nprojects.open_project(path=to_text_string(tmpdir))\nprojects.switch_to_plugin()\nassert projects.dockwidget.isVisible()\npytest.mark.parametrize('value', [True, False])",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_4": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_5": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "test_set_get_project_filenames_when_closing_no_files",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the currently opened files in the Editor are saved and loaded\n    correctly to and from the project config when the project is closed and\n    then reopened.\n\n    Regression test for spyder-ide/spyder#10045.\n    \"\"\"\npath = to_text_string(tmpdir.mkdir('project1'))\nopened_files = [os.path.join(path, file) for file in ['file1', 'file2',\n    'file3']]\nprojects = create_projects(path, opened_files)\nassert projects.get_project_filenames() == []\nprojects.close_project()\nprojects.open_project(path=path)\nassert opened_files\n",
        "CUT_1": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_2": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_3": "\"\"\"\n        Get root path to pass to the LSP servers.\n\n        This can be the current project path or the output of\n        getcwd_or_home (except for Python, see below).\n        \"\"\"\npath = None\nif self.main and self.main.projects:\n    path = self.main.projects.get_active_project_path()\nif not path:\n    path = osp.join(get_conf_path(), 'lsp_paths', 'root_path')\n    if not osp.exists(path):\n        os.makedirs(path)\nreturn path\n",
        "CUT_4": "\"\"\"\n        Get root path to pass to the LSP servers.\n\n        This can be the current project path or the output of\n        getcwd_or_home (except for Python, see below).\n        \"\"\"\npath = None\nif self.main and self.main.projects:\n    path = self.main.projects.get_active_project_path()\nif not path:\n    path = osp.join(get_conf_path(), 'lsp_paths', 'root_path')\n    if not osp.exists(path):\n        os.makedirs(path)\nreturn path\n",
        "CUT_5": "self.projects = projects\n"
    },
    {
        "functionName": "test_set_get_project_filenames_when_closing",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the currently opened files in the Editor are saved and loaded\n    correctly to and from the project config when the project is closed and\n    then reopened.\n\n    Regression test for spyder-ide/spyder#8375.\n    Updated for spyder-ide/spyder#10045.\n    \"\"\"\ndir_object = tmpdir.mkdir('project1')\npath = to_text_string(dir_object)\nopened_files = []\nfor file in ['file1', 'file2', 'file3']:\n    file_object = dir_object.join(file)\n    file_object.write(file)\n    opened_files.append(to_text_string(file_object))\nprojects = create_projects(path, opened_files)\nassert projects.get_project_filenames() == []\nprojects.close_project()\nprojects.open_project(path=path)\nassert projects.get_project_filenames() == opened_files\n",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_4": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n",
        "CUT_5": "\"\"\"\n        Get root path to pass to the LSP servers.\n\n        This can be the current project path or the output of\n        getcwd_or_home (except for Python, see below).\n        \"\"\"\npath = None\nif self.main and self.main.projects:\n    path = self.main.projects.get_active_project_path()\nif not path:\n    path = osp.join(get_conf_path(), 'lsp_paths', 'root_path')\n    if not osp.exists(path):\n        os.makedirs(path)\nreturn path\n"
    },
    {
        "functionName": "test_set_get_project_filenames_when_switching",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that files in the Editor are loaded and saved correctly when\n    switching projects.\n\n    Updated for spyder-ide/spyder#10045.\n    \"\"\"\ndir_object1 = tmpdir.mkdir('project1')\npath1 = to_text_string(dir_object1)\npath2 = to_text_string(tmpdir.mkdir('project2'))\nopened_files = []\nfor file in ['file1', 'file2', 'file3']:\n    file_object = dir_object1.join(file)\n    file_object.write(file)\n    opened_files.append(to_text_string(file_object))\nprojects = create_projects(path1, opened_files)\nassert projects.get_project_filenames() == []\nprojects.open_project(path=path2)\nassert projects.get_project_filenames() == []\nprojects.close_project()\nprojects.open_project(path=path1)\nassert projects.get_project_filenames() == opened_files\n",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "\"\"\"Handle an invalid active project.\"\"\"\ntry:\n    path = self.projects.get_active_project_path()\nexcept AttributeError:\n    return\nif bool(path):\n    if not self.projects.is_valid_project(path):\n        if path:\n            QMessageBox.critical(self, _('Error'), _(\n                '<b>{}</b> is no longer a valid Spyder project! Since it is the current active project, it will be closed automatically.'\n                ).format(path))\n        self.projects.close_project()\n"
    },
    {
        "functionName": "test_recent_projects_menu_action",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the actions of the submenu 'Recent Projects' in the 'Projects'\n    main menu are working as expected.\n\n    Regression test for spyder-ide/spyder#8450.\n    \"\"\"\nrecent_projects_len = len(projects.recent_projects)\npath0 = to_text_string(tmpdir.mkdir('project0'))\npath1 = to_text_string(tmpdir.mkdir('project1'))\npath2 = to_text_string(tmpdir.mkdir('project2'))\nprojects.open_project(path=path0)\nprojects.open_project(path=path1)\nprojects.open_project(path=path2)\nassert len(projects.recent_projects_actions) == recent_projects_len + 3 + 3\nassert projects.get_active_project().root_path == path2\nprojects.recent_projects_actions[1].trigger()\nassert projects.get_active_project().root_path == path1\nprojects.recent_projects_actions[2].trigger()\nassert projects.get_active_project().root_path == path0\n",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "test_project_explorer_tree_root",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the root item of the project explorer tree widget is set\n    correctly when switching projects.\n\n    Regression test for spyder-ide/spyder#8455.\n    \"\"\"\nqtbot.addWidget(projects.explorer)\nprojects.show_explorer()\nppath1 = to_text_string(tmpdir.mkdir('\u6e2c\u8a66'))\nppath2 = to_text_string(tmpdir.mkdir('\u00ef\u00e8\u00f4 \u00e9\u00e0\u00f1').mkdir('\u0627\u062e\u062a\u0628\u0627\u0631'))\nif os.name == 'nt':\n    import win32file\n    ppath1 = win32file.GetLongPathName(ppath1)\n    ppath2 = win32file.GetLongPathName(ppath2)\nfor ppath in [ppath1, ppath2]:\n    projects.open_project(path=ppath)\n    projects.update_explorer()\n    assert projects.get_active_project_path() == ppath\n    assert projects.explorer.treewidget.root_path == osp.dirname(ppath)\n    assert projects.explorer.treewidget.rootIndex().data() == osp.basename(osp\n        .dirname(ppath))\n    topleft_index = projects.explorer.treewidget.indexAt(projects.explorer.\n        treewidget.rect().topLeft())\n    assert topleft_index.data() == osp.basename(ppath)\n",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "\"\"\"\n        Synchronize Spyder's path list with PYTHONPATH environment variable\n        Only apply to: current user, on Windows platforms.\n        \"\"\"\nanswer = QMessageBox.question(self, _('Synchronize'), _(\n    \"This will synchronize Spyder's path list with <b>PYTHONPATH</b> environment variable for the current user, allowing you to run your Python modules outside Spyder without having to configure sys.path. <br>Do you want to clear contents of PYTHONPATH before adding Spyder's path list?\"\n    ), QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)\nif answer == QMessageBox.Cancel:\n    return\nelif answer == QMessageBox.Yes:\n    remove = True\nelse:\n    remove = False\nfrom spyder.utils.environ import get_user_env, listdict2envdict, set_user_env\nenv = get_user_env()\nactive_path = tuple(k for k, v in self.get_path_dict(True).items() if v)\nif remove:\n    ppath = active_path\nelse:\n    ppath = env.get('PYTHONPATH', [])\n    if not isinstance(ppath, list):\n        ppath = [ppath]\n    ppath = tuple(p for p in ppath if p not in active_path)\n    ppath = ppath + active_path\nenv['PYTHONPATH'] = list(ppath)\nset_user_env(listdict2envdict(env), parent=self)\nSlot()",
        "CUT_4": "\"\"\"\n        Synchronize Spyder's path list with PYTHONPATH environment variable\n        Only apply to: current user, on Windows platforms.\n        \"\"\"\nanswer = QMessageBox.question(self, _('Synchronize'), _(\n    \"This will synchronize Spyder's path list with <b>PYTHONPATH</b> environment variable for the current user, allowing you to run your Python modules outside Spyder without having to configure sys.path. <br>Do you want to clear contents of PYTHONPATH before adding Spyder's path list?\"\n    ), QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)\nif answer == QMessageBox.Cancel:\n    return\nelif answer == QMessageBox.Yes:\n    remove = True\nelse:\n    remove = False\nfrom spyder.utils.environ import get_user_env, listdict2envdict, set_user_env\nenv = get_user_env()\nactive_path = tuple(k for k, v in self.get_path_dict(True).items() if v)\nif remove:\n    ppath = active_path\nelse:\n    ppath = env.get('PYTHONPATH', [])\n    if not isinstance(ppath, list):\n        ppath = [ppath]\n    ppath = tuple(p for p in ppath if p not in active_path)\n    ppath = ppath + active_path\nenv['PYTHONPATH'] = list(ppath)\nset_user_env(listdict2envdict(env), parent=self)\nSlot()",
        "CUT_5": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "test_filesystem_notifications",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that filesystem notifications are emitted when creating,\n    deleting and moving files and directories.\n    \"\"\"\nproject_root = tmpdir.mkdir('project0')\nfolder0 = project_root.mkdir('folder0')\nfolder1 = project_root.mkdir('folder1')\nfile0 = project_root.join('file0')\nfile1 = folder0.join('file1')\nfile2 = folder0.join('file2')\nfile3 = folder1.join('file3')\nfile0.write('')\nfile1.write('')\nfile3.write('ab')\nprojects.open_project(path=to_text_string(project_root))\nfs_handler = projects.watcher.event_handler\nwith qtbot.waitSignal(fs_handler.sig_file_created, timeout=30000) as blocker:\n    file2.write('')\nfile_created, is_dir = blocker.args\nassert file_created == to_text_string(file2)\nassert not is_dir\nwith qtbot.waitSignal(fs_handler.sig_file_created, timeout=3000) as blocker:\n    folder2 = project_root.mkdir('folder2')\nfolder_created, is_dir = blocker.args\nassert folder_created == osp.join(to_text_string(project_root), 'folder2')\nnew_file = osp.join(to_text_string(folder0), 'new_file')\nwith qtbot.waitSignal(fs_handler.sig_file_moved, timeout=3000) as blocker:\n    shutil.move(to_text_string(file1), new_file)\noriginal_file, file_moved, is_dir = blocker.args\nassert original_file == to_text_string(file1)\nassert file_moved == new_file\nassert not is_dir\nnew_folder = osp.join(to_text_string(project_root), 'new_folder')\nwith qtbot.waitSignal(fs_handler.sig_file_moved, timeout=3000) as blocker:\n    shutil.move(to_text_string(folder2), new_folder)\noriginal_folder, folder_moved, is_dir = blocker.args\nassert original_folder == to_text_string(folder2)\nassert folder_moved == new_folder\nassert is_dir\nwith qtbot.waitSignal(fs_handler.sig_file_deleted, timeout=3000) as blocker:\n    os.remove(to_text_string(file0))\ndeleted_file, is_dir = blocker.args\nassert deleted_file == to_text_string(file0)\nassert not is_dir\nassert not osp.exists(to_text_string(file0))\nwith qtbot.waitSignal(fs_handler.sig_file_deleted, timeout=3000) as blocker:\n    shutil.rmtree(to_text_string(folder0))\ndeleted_folder, is_dir = blocker.args\nassert to_text_string(folder0) in deleted_folder\nif not sys.platform == 'darwin':\n    with qtbot.waitSignal(fs_handler.sig_file_modified, timeout=3000\n        ) as blocker:\n        file3.write('abc')\n    modified_file, is_dir = blocker.args\n    assert modified_file in to_text_string(file3)\n",
        "CUT_1": "return 'directory' if is_dir else 'file'\n",
        "CUT_2": "return 'directory' if is_dir else 'file'\n",
        "CUT_3": "src_path = event.src_path\nis_dir = event.is_directory\nlogger.info('Created {0}: {1}'.format(self.fmt_is_dir(is_dir), src_path))\nself.sig_file_created.emit(src_path, is_dir)\n",
        "CUT_4": "src_path = event.src_path\nis_dir = event.is_directory\nlogger.info('Created {0}: {1}'.format(self.fmt_is_dir(is_dir), src_path))\nself.sig_file_created.emit(src_path, is_dir)\n",
        "CUT_5": "src_path = event.src_path\nis_dir = event.is_directory\nlogger.info('Deleted {0}: {1}'.format(self.fmt_is_dir(is_dir), src_path))\nself.sig_file_deleted.emit(src_path, is_dir)\n"
    },
    {
        "functionName": "test_loaded_and_closed_signals",
        "className": null,
        "fileName": "/spyder/plugins/projects/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that loaded and closed signals are emitted when switching\n    projects.\n    \"\"\"\ndir_object1 = tmpdir.mkdir('project1')\npath1 = to_text_string(dir_object1)\npath2 = to_text_string(tmpdir.mkdir('project2'))\nmocker.patch.object(ProjectDialog, 'exec_', return_value=True)\nopened_files = []\nfor file in ['file1', 'file2', 'file3']:\n    file_object = dir_object1.join(file)\n    file_object.write(file)\n    opened_files.append(to_text_string(file_object))\nprojects = create_projects(path1, opened_files)\nwith qtbot.waitSignals([projects.sig_project_loaded, projects.\n    sig_project_closed]):\n    projects.open_project(path=path2)\nwith qtbot.waitSignal(projects.sig_project_closed):\n    projects.create_new_project()\n",
        "CUT_1": "self.projects = projects\n",
        "CUT_2": "self.projects = projects\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_5": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "test_load_cookiecutter_project_config",
        "className": null,
        "fileName": "/spyder/plugins/projects/utils/tests/test_cookie.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "settings = {'opt_1': 'value', 'opt_2': '{{ cookiecutter.opt_1 }}'}\ntemp_path = tempfile.mkdtemp(suffix='-some-cookiecutter')\ntemp_cookie_path = os.path.join(temp_path, 'cookiecutter.json')\nwith open(temp_cookie_path, 'w') as fh:\n    fh.write(json.dumps(settings, sort_keys=True))\nsets, pre_gen_code = load_cookiecutter_project(temp_path)\nassert settings == sets\nassert pre_gen_code is None\nshutil.rmtree(temp_path)\n",
        "CUT_1": "\"\"\"\n    Load a cookicutter options and pre-hook script.\n    \"\"\"\noptions = None\npre_gen_code = None\ncookiepath = os.path.join(project_path, 'cookiecutter.json')\npre_gen_path = os.path.join(project_path, 'hooks', 'pre_gen_project.py')\nif os.path.isdir(project_path):\n    if os.path.isfile(cookiepath):\n        with open(cookiepath, 'r') as fh:\n            options = json.loads(fh.read())\n    if os.path.isfile(pre_gen_path):\n        with open(pre_gen_path, 'r') as fh:\n            pre_gen_code = fh.read()\nreturn options, pre_gen_code\n",
        "CUT_2": "\"\"\"\n    Load a cookicutter options and pre-hook script.\n    \"\"\"\noptions = None\npre_gen_code = None\ncookiepath = os.path.join(project_path, 'cookiecutter.json')\npre_gen_path = os.path.join(project_path, 'hooks', 'pre_gen_project.py')\nif os.path.isdir(project_path):\n    if os.path.isfile(cookiepath):\n        with open(cookiepath, 'r') as fh:\n            options = json.loads(fh.read())\n    if os.path.isfile(pre_gen_path):\n        with open(pre_gen_path, 'r') as fh:\n            pre_gen_code = fh.read()\nreturn options, pre_gen_code\n",
        "CUT_3": "\"\"\"\n        Set the cookiecutter pregeneration code.\n        \"\"\"\nself._pre_gen_code = pre_gen_code\n",
        "CUT_4": "\"\"\"\n        Set the cookiecutter pregeneration code.\n        \"\"\"\nself._pre_gen_code = pre_gen_code\n",
        "CUT_5": "\"\"\"\n        Set the cookiecutter pregeneration code.\n        \"\"\"\nself._widget.set_pre_gen_code(pre_gen_code)\n"
    },
    {
        "functionName": "test_load_cookiecutter_project_hooks",
        "className": null,
        "fileName": "/spyder/plugins/projects/utils/tests/test_cookie.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "settings = {'opt_1': 'value', 'opt_2': '{{ cookiecutter.opt_1 }}'}\npre_gen_code = \"\"\"import sys\n\nprint('test!')\nsys.exit(1)\n\"\"\"\ntemp_path = tempfile.mkdtemp(suffix='-some-cookiecutter')\ntemp_cookie_path = os.path.join(temp_path, 'cookiecutter.json')\ntemp_hooks_path = os.path.join(temp_path, 'hooks')\ntemp_hooks_pre_path = os.path.join(temp_hooks_path, 'pre_gen_project.py')\nos.makedirs(temp_hooks_path)\nwith open(temp_cookie_path, 'w') as fh:\n    fh.write(json.dumps(settings, sort_keys=True))\nwith open(temp_hooks_pre_path, 'w') as fh:\n    fh.write(pre_gen_code)\nsets, pre_gen_code = load_cookiecutter_project(temp_path)\nassert settings == sets\nassert pre_gen_code == pre_gen_code\nshutil.rmtree(temp_path)\n",
        "CUT_1": "\"\"\"\n    Load a cookicutter options and pre-hook script.\n    \"\"\"\noptions = None\npre_gen_code = None\ncookiepath = os.path.join(project_path, 'cookiecutter.json')\npre_gen_path = os.path.join(project_path, 'hooks', 'pre_gen_project.py')\nif os.path.isdir(project_path):\n    if os.path.isfile(cookiepath):\n        with open(cookiepath, 'r') as fh:\n            options = json.loads(fh.read())\n    if os.path.isfile(pre_gen_path):\n        with open(pre_gen_path, 'r') as fh:\n            pre_gen_code = fh.read()\nreturn options, pre_gen_code\n",
        "CUT_2": "\"\"\"\n    Load a cookicutter options and pre-hook script.\n    \"\"\"\noptions = None\npre_gen_code = None\ncookiepath = os.path.join(project_path, 'cookiecutter.json')\npre_gen_path = os.path.join(project_path, 'hooks', 'pre_gen_project.py')\nif os.path.isdir(project_path):\n    if os.path.isfile(cookiepath):\n        with open(cookiepath, 'r') as fh:\n            options = json.loads(fh.read())\n    if os.path.isfile(pre_gen_path):\n        with open(pre_gen_path, 'r') as fh:\n            pre_gen_code = fh.read()\nreturn options, pre_gen_code\n",
        "CUT_3": "\"\"\"\n        Set the cookiecutter pregeneration code.\n        \"\"\"\nself._pre_gen_code = pre_gen_code\n",
        "CUT_4": "\"\"\"\n        Set the cookiecutter pregeneration code.\n        \"\"\"\nself._pre_gen_code = pre_gen_code\n",
        "CUT_5": "\"\"\"\n        Set the cookiecutter pregeneration code.\n        \"\"\"\nself._widget.set_pre_gen_code(pre_gen_code)\n"
    },
    {
        "functionName": "test_generate_cookiecutter_project_defaults",
        "className": null,
        "fileName": "/spyder/plugins/projects/utils/tests/test_cookie.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "settings = {'repo_name': 'value'}\ntemp_path = tempfile.mkdtemp(suffix='-some-cookiecutter')\ntemp_path_created = tempfile.mkdtemp(suffix='-created-project')\ntemp_cookie_path = os.path.join(temp_path, 'cookiecutter.json')\ntemp_project_path = os.path.join(temp_path, '{{cookiecutter.repo_name}}')\nos.makedirs(temp_project_path)\nwith open(temp_cookie_path, 'w') as fh:\n    fh.write(json.dumps(settings, sort_keys=True))\nstatus, result = generate_cookiecutter_project(temp_path, temp_path_created)\nassert 'value' in result\nassert status is True\nshutil.rmtree(temp_path)\n",
        "CUT_1": "\"\"\"\n    Load a cookicutter options and pre-hook script.\n    \"\"\"\noptions = None\npre_gen_code = None\ncookiepath = os.path.join(project_path, 'cookiecutter.json')\npre_gen_path = os.path.join(project_path, 'hooks', 'pre_gen_project.py')\nif os.path.isdir(project_path):\n    if os.path.isfile(cookiepath):\n        with open(cookiepath, 'r') as fh:\n            options = json.loads(fh.read())\n    if os.path.isfile(pre_gen_path):\n        with open(pre_gen_path, 'r') as fh:\n            pre_gen_code = fh.read()\nreturn options, pre_gen_code\n",
        "CUT_2": "\"\"\"\n    Load a cookicutter options and pre-hook script.\n    \"\"\"\noptions = None\npre_gen_code = None\ncookiepath = os.path.join(project_path, 'cookiecutter.json')\npre_gen_path = os.path.join(project_path, 'hooks', 'pre_gen_project.py')\nif os.path.isdir(project_path):\n    if os.path.isfile(cookiepath):\n        with open(cookiepath, 'r') as fh:\n            options = json.loads(fh.read())\n    if os.path.isfile(pre_gen_path):\n        with open(pre_gen_path, 'r') as fh:\n            pre_gen_code = fh.read()\nreturn options, pre_gen_code\n",
        "CUT_3": "\"\"\"\n    Generate a cookicutter project programmatically.\n    \"\"\"\nstatus = True\ntry:\n    result = cookiecutter(cookiecutter_path, output_dir=output_path,\n        overwrite_if_exists=True, extra_context=extra_content, no_input=True)\nexcept Exception as err:\n    result = err\n    status = False\nreturn status, result\n",
        "CUT_4": "\"\"\"\n    Generate a cookicutter project programmatically.\n    \"\"\"\nstatus = True\ntry:\n    result = cookiecutter(cookiecutter_path, output_dir=output_path,\n        overwrite_if_exists=True, extra_context=extra_content, no_input=True)\nexcept Exception as err:\n    result = err\n    status = False\nreturn status, result\n",
        "CUT_5": "\"\"\"\n        Save history to a text file in the Spyder configuration directory.\n        \"\"\"\ndata = '\\n'.join(self.get_widget().get_history())\nwith open(self.LOG_PATH, 'w') as fh:\n    fh.write(data)\n"
    },
    {
        "functionName": "test_generate_cookiecutter_project_extra_content",
        "className": null,
        "fileName": "/spyder/plugins/projects/utils/tests/test_cookie.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "settings = {'repo_name': 'value'}\ntemp_path = tempfile.mkdtemp(suffix='-some-cookiecutter')\ntemp_path_created = tempfile.mkdtemp(suffix='-created-project')\ntemp_cookie_path = os.path.join(temp_path, 'cookiecutter.json')\ntemp_project_path = os.path.join(temp_path, '{{cookiecutter.repo_name}}')\nos.makedirs(temp_project_path)\nwith open(temp_cookie_path, 'w') as fh:\n    fh.write(json.dumps(settings, sort_keys=True))\nstatus, result = generate_cookiecutter_project(temp_path, temp_path_created,\n    {'repo_name': 'boom'})\nassert 'boom' in result\nassert status is True\nshutil.rmtree(temp_path)\n",
        "CUT_1": "\"\"\"\n    Load a cookicutter options and pre-hook script.\n    \"\"\"\noptions = None\npre_gen_code = None\ncookiepath = os.path.join(project_path, 'cookiecutter.json')\npre_gen_path = os.path.join(project_path, 'hooks', 'pre_gen_project.py')\nif os.path.isdir(project_path):\n    if os.path.isfile(cookiepath):\n        with open(cookiepath, 'r') as fh:\n            options = json.loads(fh.read())\n    if os.path.isfile(pre_gen_path):\n        with open(pre_gen_path, 'r') as fh:\n            pre_gen_code = fh.read()\nreturn options, pre_gen_code\n",
        "CUT_2": "\"\"\"\n    Load a cookicutter options and pre-hook script.\n    \"\"\"\noptions = None\npre_gen_code = None\ncookiepath = os.path.join(project_path, 'cookiecutter.json')\npre_gen_path = os.path.join(project_path, 'hooks', 'pre_gen_project.py')\nif os.path.isdir(project_path):\n    if os.path.isfile(cookiepath):\n        with open(cookiepath, 'r') as fh:\n            options = json.loads(fh.read())\n    if os.path.isfile(pre_gen_path):\n        with open(pre_gen_path, 'r') as fh:\n            pre_gen_code = fh.read()\nreturn options, pre_gen_code\n",
        "CUT_3": "\"\"\"\n    Generate a cookicutter project programmatically.\n    \"\"\"\nstatus = True\ntry:\n    result = cookiecutter(cookiecutter_path, output_dir=output_path,\n        overwrite_if_exists=True, extra_context=extra_content, no_input=True)\nexcept Exception as err:\n    result = err\n    status = False\nreturn status, result\n",
        "CUT_4": "\"\"\"\n    Generate a cookicutter project programmatically.\n    \"\"\"\nstatus = True\ntry:\n    result = cookiecutter(cookiecutter_path, output_dir=output_path,\n        overwrite_if_exists=True, extra_context=extra_content, no_input=True)\nexcept Exception as err:\n    result = err\n    status = False\nreturn status, result\n",
        "CUT_5": "\"\"\"\n        Save history to a text file in the Spyder configuration directory.\n        \"\"\"\ndata = '\\n'.join(self.get_widget().get_history())\nwith open(self.LOG_PATH, 'w') as fh:\n    fh.write(data)\n"
    },
    {
        "functionName": "test_generate_cookiecutter_project_exception",
        "className": null,
        "fileName": "/spyder/plugins/projects/utils/tests/test_cookie.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "settings = {'repo_name': 'value'}\ntemp_path = tempfile.mkdtemp(suffix='-some-invalid-cookiecutter')\ntemp_path_created = tempfile.mkdtemp(suffix='-created-project')\ntemp_cookie_path = os.path.join(temp_path, 'cookiecutter.json')\ntemp_project_path = os.path.join(temp_path,\n    '{{cookiecutter.not_foun_variable}}')\nos.makedirs(temp_project_path)\nwith open(temp_cookie_path, 'w') as fh:\n    fh.write(json.dumps(settings, sort_keys=True))\nstatus, __ = generate_cookiecutter_project(temp_path, temp_path_created)\nassert status is False\n",
        "CUT_1": "\"\"\"\n    Load a cookicutter options and pre-hook script.\n    \"\"\"\noptions = None\npre_gen_code = None\ncookiepath = os.path.join(project_path, 'cookiecutter.json')\npre_gen_path = os.path.join(project_path, 'hooks', 'pre_gen_project.py')\nif os.path.isdir(project_path):\n    if os.path.isfile(cookiepath):\n        with open(cookiepath, 'r') as fh:\n            options = json.loads(fh.read())\n    if os.path.isfile(pre_gen_path):\n        with open(pre_gen_path, 'r') as fh:\n            pre_gen_code = fh.read()\nreturn options, pre_gen_code\n",
        "CUT_2": "\"\"\"\n    Load a cookicutter options and pre-hook script.\n    \"\"\"\noptions = None\npre_gen_code = None\ncookiepath = os.path.join(project_path, 'cookiecutter.json')\npre_gen_path = os.path.join(project_path, 'hooks', 'pre_gen_project.py')\nif os.path.isdir(project_path):\n    if os.path.isfile(cookiepath):\n        with open(cookiepath, 'r') as fh:\n            options = json.loads(fh.read())\n    if os.path.isfile(pre_gen_path):\n        with open(pre_gen_path, 'r') as fh:\n            pre_gen_code = fh.read()\nreturn options, pre_gen_code\n",
        "CUT_3": "\"\"\"\n        Save history to a text file in the Spyder configuration directory.\n        \"\"\"\ndata = '\\n'.join(self.get_widget().get_history())\nwith open(self.LOG_PATH, 'w') as fh:\n    fh.write(data)\n",
        "CUT_4": "\"\"\"\n        Save history to a text file in the Spyder configuration directory.\n        \"\"\"\ndata = '\\n'.join(self.get_widget().get_history())\nwith open(self.LOG_PATH, 'w') as fh:\n    fh.write(data)\n",
        "CUT_5": "os.remove(os.path.join(filename, 'symlink'))\nos.rmdir(filename)\n"
    },
    {
        "functionName": "project_explorer",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_project_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Setup Project Explorer widget.\"\"\"\ndirectory = request.node.get_closest_marker('change_directory')\nif directory:\n    project_dir = to_text_string(tmpdir.mkdir('project'))\nelse:\n    project_dir = None\nproject_explorer = ProjectExplorerTest(directory=project_dir)\nqtbot.addWidget(project_explorer)\nreturn project_explorer\npytest.fixture",
        "CUT_1": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_2": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_3": "\"\"\"\n        Select working directory.\n\n        Parameters\n        ----------\n        directory: str, optional\n            The directory to change to.\n\n        Notes\n        -----\n        If directory is None, a get directorty dialog will be used.\n        \"\"\"\nif directory is None:\n    self.sig_redirect_stdio_requested.emit(False)\n    directory = getexistingdirectory(self, _('Select directory'),\n        getcwd_or_home())\n    self.sig_redirect_stdio_requested.emit(True)\nif directory:\n    self.chdir(directory)\nSlot()",
        "CUT_4": "\"\"\"\n        Select working directory.\n\n        Parameters\n        ----------\n        directory: str, optional\n            The directory to change to.\n\n        Notes\n        -----\n        If directory is None, a get directorty dialog will be used.\n        \"\"\"\nif directory is None:\n    self.sig_redirect_stdio_requested.emit(False)\n    directory = getexistingdirectory(self, _('Select directory'),\n        getcwd_or_home())\n    self.sig_redirect_stdio_requested.emit(True)\nif directory:\n    self.chdir(directory)\nSlot()",
        "CUT_5": "\"\"\"Select directory\"\"\"\nself.sig_redirect_stdio_requested.emit(False)\ndirectory = getexistingdirectory(self, _('Select directory'), self.path)\nif directory:\n    directory = to_unicode_from_fs(osp.abspath(directory))\nself.sig_redirect_stdio_requested.emit(True)\nreturn directory\nSlot()"
    },
    {
        "functionName": "test_change_directory_in_project_explorer",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_project_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test changing a file from directory in the Project explorer.\"\"\"\nproject = project_explorer\nproject_dir = project.directory\nproject_dir_tmp = osp.join(project_dir, '\u6e2c\u8a66')\nproject_file = osp.join(project_dir, 'script.py')\nos.mkdir(project_dir_tmp)\nopen(project_file, 'w').close()\nproject.explorer.treewidget.move(fnames=[osp.join(project_dir, 'script.py')\n    ], directory=project_dir_tmp)\nassert osp.isfile(osp.join(project_dir_tmp, 'script.py'))\npytest.mark.change_directory",
        "CUT_1": "\"\"\"\n    Generates a Sphinx configuration in `directory`.\n\n    Parameters\n    ----------\n    directory : str\n        Base directory to use\n    \"\"\"\nconf = osp.join(get_module_source_path('spyder.plugins.help.utils'), 'conf.py')\nlayout = osp.join(osp.join(CONFDIR_PATH, 'templates'), 'layout.html')\nos.makedirs(osp.join(directory, 'templates'))\nos.makedirs(osp.join(directory, 'static'))\nshutil.copy(conf, directory)\nshutil.copy(layout, osp.join(directory, 'templates'))\nopen(osp.join(directory, '__init__.py'), 'w').write('')\nopen(osp.join(directory, 'static', 'empty'), 'w').write('')\n",
        "CUT_2": "\"\"\"\n    Generates a Sphinx configuration in `directory`.\n\n    Parameters\n    ----------\n    directory : str\n        Base directory to use\n    \"\"\"\nconf = osp.join(get_module_source_path('spyder.plugins.help.utils'), 'conf.py')\nlayout = osp.join(osp.join(CONFDIR_PATH, 'templates'), 'layout.html')\nos.makedirs(osp.join(directory, 'templates'))\nos.makedirs(osp.join(directory, 'static'))\nshutil.copy(conf, directory)\nshutil.copy(layout, osp.join(directory, 'templates'))\nopen(osp.join(directory, '__init__.py'), 'w').write('')\nopen(osp.join(directory, 'static', 'empty'), 'w').write('')\n",
        "CUT_3": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_4": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_5": "\"\"\"A project directory with dirs and files for testing.\"\"\"\nproject_dir = to_text_string(tmpdir.mkdir('project'))\ndestination_dir = to_text_string(tmpdir.mkdir('destination'))\ntop_folder = osp.join(project_dir, 'top_folder_in_proj')\nif not osp.exists(top_folder):\n    os.mkdir(top_folder)\nlist_paths = []\nfor item in request.param:\n    if osp.splitext(item)[1]:\n        if osp.split(item)[0]:\n            dirs, fname = osp.split(item)\n            dirpath = osp.join(top_folder, dirs)\n            if not osp.exists(dirpath):\n                os.makedirs(dirpath)\n                item_path = osp.join(dirpath, fname)\n        else:\n            item_path = osp.join(top_folder, item)\n    else:\n        dirpath = osp.join(top_folder, item)\n        if not osp.exists(dirpath):\n            os.makedirs(dirpath)\n            item_path = dirpath\n    if not osp.isdir(item_path):\n        with open(item_path, 'w') as fh:\n            fh.write('File Path:\\n' + str(item_path).replace(os.sep, '/'))\n    list_paths.append(item_path)\nreturn list_paths, project_dir, destination_dir, top_folder\npytest.fixture(params=[['script.py', 'dir1/dir2/dir3/dir4'], ['script.py',\n    'script1.py', 'testdir/dir1/script2.py'], [\n    'subdir/innerdir/dir3/text.txt', 'dir1/dir2/dir3',\n    'dir1/dir2/dir3/file.txt', 'dir1/dir2/dir3/dir4/python.py']])"
    },
    {
        "functionName": "test_project_explorer",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_project_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run project explorer.\"\"\"\nproject = project_explorer\nproject.resize(250, 480)\nproject.show()\nassert project\n",
        "CUT_1": "\"\"\"\n        Return available registered project types.\n\n        Returns\n        -------\n        dict\n            Project types dictionary. Keys are project type IDs and values\n            are project type classes.\n        \"\"\"\nreturn self._project_types\n",
        "CUT_2": "\"\"\"\n        Return available registered project types.\n\n        Returns\n        -------\n        dict\n            Project types dictionary. Keys are project type IDs and values\n            are project type classes.\n        \"\"\"\nreturn self._project_types\n",
        "CUT_3": "\"\"\"Return widget title\"\"\"\nreturn _('Project')\n",
        "CUT_4": "\"\"\"Return widget title\"\"\"\nreturn _('Project')\n",
        "CUT_5": "\"\"\"\n        Sets the project path and disables the project search in the combobox\n        if the value of path is None.\n        \"\"\"\nif path is None:\n    self.project_path = None\n    self.model().item(PROJECT, 0).setEnabled(False)\n    if self.currentIndex() == PROJECT:\n        self.setCurrentIndex(CWD)\nelse:\n    path = osp.abspath(path)\n    self.project_path = path\n    self.model().item(PROJECT, 0).setEnabled(True)\n"
    },
    {
        "functionName": "coookie_widget",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up CookieCutter Widget.\"\"\"\nwidget = CookiecutterWidget(None)\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_cookiecutter_widget_empty",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert len(coookie_widget._widgets) == 0\nassert len(coookie_widget.get_values()) == 3\ncoookie_widget.setup({})\nassert len(coookie_widget._widgets) == 0\nassert len(coookie_widget.get_values()) == 3\n",
        "CUT_1": "\"\"\"\n        Return a widget by unique id..\n        \"\"\"\nif widget_id in self._widgets:\n    return self._widgets[widget_id]\n",
        "CUT_2": "\"\"\"\n        Return a widget by unique id..\n        \"\"\"\nif widget_id in self._widgets:\n    return self._widgets[widget_id]\n",
        "CUT_3": "return len(self)\nproperty",
        "CUT_4": "return len(self)\nproperty",
        "CUT_5": "return len(self.history)\n"
    },
    {
        "functionName": "test_cookiecutter_widget_checkbox_yes",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coookie_widget.setup({option: value})\nlabel, widget = coookie_widget._widgets[option]\nassert len(coookie_widget._widgets) == 1\nassert label == option.capitalize()\nassert widget.isChecked()\nassert widget.get_value() == value\npytest.mark.parametrize('option,value', [('opt', 'y'), ('opt', 'yes'), (\n    'opt', 'true'), ('opt', 'YES'), ('opt', 'True')])",
        "CUT_1": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_2": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_3": "\"\"\"\n        Draw the fold indicator/trigger (arrow).\n\n        :param top: Top position\n        :param mouse_over: Whether the mouse is over the indicator\n        :param collapsed: Whether the trigger is collapsed or not.\n        :param painter: QPainter\n        \"\"\"\nrect = QRect(0, top, self.sizeHint().width(), self.sizeHint().height())\nif self._native_icons:\n    opt = QStyleOptionViewItem()\n    opt.rect = rect\n    opt.state = QStyle.State_Active | QStyle.State_Item | QStyle.State_Children\n    if not collapsed:\n        opt.state |= QStyle.State_Open\n    if mouse_over:\n        opt.state |= (QStyle.State_MouseOver | QStyle.State_Enabled |\n            QStyle.State_Selected)\n        opt.palette.setBrush(QPalette.Window, self.palette().highlight())\n    opt.rect.translate(-2, 0)\n    self.style().drawPrimitive(QStyle.PE_IndicatorBranch, opt, painter, self)\nelse:\n    index = 0\n    if not collapsed:\n        index = 2\n    if mouse_over:\n        index += 1\n    ima.icon(self._indicators_icons[index]).paint(painter, rect)\n",
        "CUT_4": "\"\"\"\n        Draw the fold indicator/trigger (arrow).\n\n        :param top: Top position\n        :param mouse_over: Whether the mouse is over the indicator\n        :param collapsed: Whether the trigger is collapsed or not.\n        :param painter: QPainter\n        \"\"\"\nrect = QRect(0, top, self.sizeHint().width(), self.sizeHint().height())\nif self._native_icons:\n    opt = QStyleOptionViewItem()\n    opt.rect = rect\n    opt.state = QStyle.State_Active | QStyle.State_Item | QStyle.State_Children\n    if not collapsed:\n        opt.state |= QStyle.State_Open\n    if mouse_over:\n        opt.state |= (QStyle.State_MouseOver | QStyle.State_Enabled |\n            QStyle.State_Selected)\n        opt.palette.setBrush(QPalette.Window, self.palette().highlight())\n    opt.rect.translate(-2, 0)\n    self.style().drawPrimitive(QStyle.PE_IndicatorBranch, opt, painter, self)\nelse:\n    index = 0\n    if not collapsed:\n        index = 2\n    if mouse_over:\n        index += 1\n    ima.icon(self._indicators_icons[index]).paint(painter, rect)\n",
        "CUT_5": "\"\"\"\n        Create a form field.\n        \"\"\"\nlabel = ' '.join(setting.split('_')).capitalize()\nif isinstance(value, (list, dict)):\n    widget = self._create_combobox(setting, label, value)\nelif isinstance(value, str):\n    if value.lower() in ['y', 'yes', 'true', 'n', 'no', 'false']:\n        widget = self._create_checkbox(setting, label, default=value)\n    else:\n        default = None if self._is_jinja(setting) else value\n        widget = self._create_textbox(setting, label, default=default)\nelse:\n    raise Exception(\"Cookiecutter option '{}'cannot be processed\".format(\n        setting))\nself._widgets[setting] = label, widget\nreturn label, widget\n"
    },
    {
        "functionName": "test_cookiecutter_widget_checkbox_no",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coookie_widget.setup({option: value})\nlabel, widget = coookie_widget._widgets[option]\nassert len(coookie_widget._widgets) == 1\nassert label == option.capitalize()\nassert not widget.isChecked()\nassert widget.get_value() == value\npytest.mark.parametrize('option,value', [('opt', 'n'), ('opt', 'no'), (\n    'opt', 'false'), ('opt', 'NO'), ('opt', 'False')])",
        "CUT_1": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_2": "\"\"\"Load settings from configuration file.\"\"\"\nfor checkbox, (sec, option, default) in list(self.checkboxes.items()):\n    checkbox.setChecked(self.get_option(option, default, section=sec))\n    checkbox.clicked.connect(lambda _, opt=option: self.has_been_modified(opt))\nfor radiobutton, (sec, option, default) in list(self.radiobuttons.items()):\n    radiobutton.setChecked(self.get_option(option, default, section=sec))\n    radiobutton.toggled.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if radiobutton.restart_required:\n        self.restart_options[option] = radiobutton.label_text\nfor lineedit, (sec, option, default) in list(self.lineedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(lineedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    lineedit.setText(data)\n    lineedit.textChanged.connect(lambda _, opt=option: self.\n        has_been_modified(opt))\n    if lineedit.restart_required:\n        self.restart_options[option] = lineedit.label_text\nfor textedit, (sec, option, default) in list(self.textedits.items()):\n    data = self.get_option(option, default, section=sec)\n    if getattr(textedit, 'content_type', None) == list:\n        data = ', '.join(data)\n    elif getattr(textedit, 'content_type', None) == dict:\n        data = to_text_string(data)\n    textedit.setPlainText(data)\n    textedit.textChanged.connect(lambda opt=option: self.has_been_modified(opt)\n        )\n    if textedit.restart_required:\n        self.restart_options[option] = textedit.label_text\nfor spinbox, (sec, option, default) in list(self.spinboxes.items()):\n    spinbox.setValue(self.get_option(option, default, section=sec))\n    spinbox.valueChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor combobox, (sec, option, default) in list(self.comboboxes.items()):\n    value = self.get_option(option, default, section=sec)\n    for index in range(combobox.count()):\n        data = from_qvariant(combobox.itemData(index), to_text_string)\n        if to_text_string(data) == to_text_string(value):\n            break\n    else:\n        if combobox.count() == 0:\n            index = None\n    if index:\n        combobox.setCurrentIndex(index)\n    combobox.currentIndexChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if combobox.restart_required:\n        self.restart_options[option] = combobox.label_text\nfor (fontbox, sizebox), option in list(self.fontboxes.items()):\n    rich_font = True if 'rich' in option.lower() else False\n    font = self.get_font(rich_font)\n    fontbox.setCurrentFont(font)\n    sizebox.setValue(font.pointSize())\n    if option is None:\n        property = 'plugin_font'\n    else:\n        property = option\n    fontbox.currentIndexChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\n    sizebox.valueChanged.connect(lambda _foo, opt=property: self.\n        has_been_modified(opt))\nfor clayout, (sec, option, default) in list(self.coloredits.items()):\n    property = to_qvariant(option)\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    edit.setText(self.get_option(option, default, section=sec))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\nfor (clayout, cb_bold, cb_italic), (sec, option, default) in list(self.\n    scedits.items()):\n    edit = clayout.lineedit\n    btn = clayout.colorbtn\n    options = self.get_option(option, default, section=sec)\n    if options:\n        color, bold, italic = options\n        edit.setText(color)\n        cb_bold.setChecked(bold)\n        cb_italic.setChecked(italic)\n    edit.textChanged.connect(lambda _foo, opt=option: self.\n        has_been_modified(opt))\n    if not API == 'pyside':\n        btn.clicked.connect(lambda _foo, opt=option: self.has_been_modified\n            (opt))\n        cb_bold.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n        cb_italic.clicked.connect(lambda _foo, opt=option: self.\n            has_been_modified(opt))\n    else:\n        btn.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_bold.clicked.connect(lambda opt=option: self.has_been_modified(opt))\n        cb_italic.clicked.connect(lambda opt=option: self.has_been_modified\n            (opt))\n",
        "CUT_3": "\"\"\"\n        Draw the fold indicator/trigger (arrow).\n\n        :param top: Top position\n        :param mouse_over: Whether the mouse is over the indicator\n        :param collapsed: Whether the trigger is collapsed or not.\n        :param painter: QPainter\n        \"\"\"\nrect = QRect(0, top, self.sizeHint().width(), self.sizeHint().height())\nif self._native_icons:\n    opt = QStyleOptionViewItem()\n    opt.rect = rect\n    opt.state = QStyle.State_Active | QStyle.State_Item | QStyle.State_Children\n    if not collapsed:\n        opt.state |= QStyle.State_Open\n    if mouse_over:\n        opt.state |= (QStyle.State_MouseOver | QStyle.State_Enabled |\n            QStyle.State_Selected)\n        opt.palette.setBrush(QPalette.Window, self.palette().highlight())\n    opt.rect.translate(-2, 0)\n    self.style().drawPrimitive(QStyle.PE_IndicatorBranch, opt, painter, self)\nelse:\n    index = 0\n    if not collapsed:\n        index = 2\n    if mouse_over:\n        index += 1\n    ima.icon(self._indicators_icons[index]).paint(painter, rect)\n",
        "CUT_4": "\"\"\"\n        Draw the fold indicator/trigger (arrow).\n\n        :param top: Top position\n        :param mouse_over: Whether the mouse is over the indicator\n        :param collapsed: Whether the trigger is collapsed or not.\n        :param painter: QPainter\n        \"\"\"\nrect = QRect(0, top, self.sizeHint().width(), self.sizeHint().height())\nif self._native_icons:\n    opt = QStyleOptionViewItem()\n    opt.rect = rect\n    opt.state = QStyle.State_Active | QStyle.State_Item | QStyle.State_Children\n    if not collapsed:\n        opt.state |= QStyle.State_Open\n    if mouse_over:\n        opt.state |= (QStyle.State_MouseOver | QStyle.State_Enabled |\n            QStyle.State_Selected)\n        opt.palette.setBrush(QPalette.Window, self.palette().highlight())\n    opt.rect.translate(-2, 0)\n    self.style().drawPrimitive(QStyle.PE_IndicatorBranch, opt, painter, self)\nelse:\n    index = 0\n    if not collapsed:\n        index = 2\n    if mouse_over:\n        index += 1\n    ima.icon(self._indicators_icons[index]).paint(painter, rect)\n",
        "CUT_5": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n"
    },
    {
        "functionName": "test_cookiecutter_widget_list",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coookie_widget.setup({option: value})\nlabel, widget = coookie_widget._widgets[option]\nassert len(coookie_widget._widgets) == 1\nassert label == option.capitalize()\nassert widget.get_value() == value[0]\npytest.mark.parametrize('option,value', [('opt', ['1', '2', '3'])])",
        "CUT_1": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n",
        "CUT_2": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n",
        "CUT_3": "\"\"\"\n        Helper method to set/change options with option to emit signal.\n        \"\"\"\ntry:\n    action_name = 'toggle_{}_action'.format(option)\n    self._update_action_state(action_name, value)\nexcept SpyderAPIError:\n    pass\nself._check_options_dictionary_exist()\nif option in self.DEFAULT_OPTIONS:\n    self._options[option] = value\n    self.on_option_update(option, value)\n    if emit:\n        self.sig_option_changed.emit(option, value)\nelse:\n    raise SpyderAPIError(\n        'Option \"{}\" has not been defined in the widget DEFAULT_OPTIONS attribute!'\n        .format(option))\n",
        "CUT_4": "\"\"\"\n        Helper method to set/change options with option to emit signal.\n        \"\"\"\ntry:\n    action_name = 'toggle_{}_action'.format(option)\n    self._update_action_state(action_name, value)\nexcept SpyderAPIError:\n    pass\nself._check_options_dictionary_exist()\nif option in self.DEFAULT_OPTIONS:\n    self._options[option] = value\n    self.on_option_update(option, value)\n    if emit:\n        self.sig_option_changed.emit(option, value)\nelse:\n    raise SpyderAPIError(\n        'Option \"{}\" has not been defined in the widget DEFAULT_OPTIONS attribute!'\n        .format(option))\n",
        "CUT_5": "\"\"\"Setup the figure browser with provided options.\"\"\"\nself.splitter.setContentsMargins(0, 0, 0, 0)\nfor option, value in options.items():\n    if option == 'auto_fit_plotting':\n        self.change_auto_fit_plotting(value)\n    elif option == 'mute_inline_plotting':\n        self.mute_inline_plotting = value\n    elif option == 'show_plot_outline':\n        self.show_fig_outline_in_viewer(value)\n    elif option == 'save_dir':\n        self.thumbnails_sb.save_dir = value\n"
    },
    {
        "functionName": "test_cookiecutter_widget_dict",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coookie_widget.setup({option: value})\nlabel, widget = coookie_widget._widgets[option]\nassert len(coookie_widget._widgets) == 1\nassert label == option.capitalize()\nassert widget.get_value() == {'1': value['1']}\npytest.mark.parametrize('option,value', [('opt', {'1': [1, 2], '2': [3, 4]})])",
        "CUT_1": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n",
        "CUT_2": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n",
        "CUT_3": "\"\"\"\n        Helper method to set/change options with option to emit signal.\n        \"\"\"\ntry:\n    action_name = 'toggle_{}_action'.format(option)\n    self._update_action_state(action_name, value)\nexcept SpyderAPIError:\n    pass\nself._check_options_dictionary_exist()\nif option in self.DEFAULT_OPTIONS:\n    self._options[option] = value\n    self.on_option_update(option, value)\n    if emit:\n        self.sig_option_changed.emit(option, value)\nelse:\n    raise SpyderAPIError(\n        'Option \"{}\" has not been defined in the widget DEFAULT_OPTIONS attribute!'\n        .format(option))\n",
        "CUT_4": "\"\"\"\n        Helper method to set/change options with option to emit signal.\n        \"\"\"\ntry:\n    action_name = 'toggle_{}_action'.format(option)\n    self._update_action_state(action_name, value)\nexcept SpyderAPIError:\n    pass\nself._check_options_dictionary_exist()\nif option in self.DEFAULT_OPTIONS:\n    self._options[option] = value\n    self.on_option_update(option, value)\n    if emit:\n        self.sig_option_changed.emit(option, value)\nelse:\n    raise SpyderAPIError(\n        'Option \"{}\" has not been defined in the widget DEFAULT_OPTIONS attribute!'\n        .format(option))\n",
        "CUT_5": "\"\"\"Setup the figure browser with provided options.\"\"\"\nself.splitter.setContentsMargins(0, 0, 0, 0)\nfor option, value in options.items():\n    if option == 'auto_fit_plotting':\n        self.change_auto_fit_plotting(value)\n    elif option == 'mute_inline_plotting':\n        self.mute_inline_plotting = value\n    elif option == 'show_plot_outline':\n        self.show_fig_outline_in_viewer(value)\n    elif option == 'save_dir':\n        self.thumbnails_sb.save_dir = value\n"
    },
    {
        "functionName": "test_cookiecutter_widget_private_variables",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coookie_widget.setup({option: value})\nassert len(coookie_widget._widgets) == 0\nassert len(coookie_widget.get_values()) == 4\npytest.mark.parametrize('option,value', [('_nope', 'nothing'), ('__nope_2',\n    'nothing')])",
        "CUT_1": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n",
        "CUT_2": "\"\"\"Set project configuration option.\"\"\"\nself.config.set(section=section, option=option, value=value)\n",
        "CUT_3": "\"\"\"Setup the figure browser with provided options.\"\"\"\nself.splitter.setContentsMargins(0, 0, 0, 0)\nfor option, value in options.items():\n    if option == 'auto_fit_plotting':\n        self.change_auto_fit_plotting(value)\n    elif option == 'mute_inline_plotting':\n        self.mute_inline_plotting = value\n    elif option == 'show_plot_outline':\n        self.show_fig_outline_in_viewer(value)\n    elif option == 'save_dir':\n        self.thumbnails_sb.save_dir = value\n",
        "CUT_4": "\"\"\"Setup the figure browser with provided options.\"\"\"\nself.splitter.setContentsMargins(0, 0, 0, 0)\nfor option, value in options.items():\n    if option == 'auto_fit_plotting':\n        self.change_auto_fit_plotting(value)\n    elif option == 'mute_inline_plotting':\n        self.mute_inline_plotting = value\n    elif option == 'show_plot_outline':\n        self.show_fig_outline_in_viewer(value)\n    elif option == 'save_dir':\n        self.thumbnails_sb.save_dir = value\n",
        "CUT_5": "\"\"\"\n        Helper method to set/change options with option to emit signal.\n        \"\"\"\ntry:\n    action_name = 'toggle_{}_action'.format(option)\n    self._update_action_state(action_name, value)\nexcept SpyderAPIError:\n    pass\nself._check_options_dictionary_exist()\nif option in self.DEFAULT_OPTIONS:\n    self._options[option] = value\n    self.on_option_update(option, value)\n    if emit:\n        self.sig_option_changed.emit(option, value)\nelse:\n    raise SpyderAPIError(\n        'Option \"{}\" has not been defined in the widget DEFAULT_OPTIONS attribute!'\n        .format(option))\n"
    },
    {
        "functionName": "test_cookiecutter_widget_render",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coookie_widget.setup({'opt_1': 'test', 'opt_2': '{{ cookiecutter.opt_1 }}'})\nows = coookie_widget._widgets\nassert ows['opt_2'][1].get_value() == ows['opt_1'][1].get_value()\n",
        "CUT_1": "return conv_func(dialog.get_value())\n",
        "CUT_2": "return conv_func(dialog.get_value())\n",
        "CUT_3": "if index.isValid():\n    return index.model().get_value(index)\n",
        "CUT_4": "if index.isValid():\n    return index.model().get_value(index)\n",
        "CUT_5": "\"\"\"Get the value of a variable\"\"\"\nvalue = self.shellwidget.get_value(name)\nreturn value\n"
    },
    {
        "functionName": "test_cookiecutter_widget_no_render",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coookie_widget.setup({'opt_1': 'test', 'opt_2': '{{ cookiecutter.opt_1 }}',\n    '_opt_3': '{{ cookiecutter.opt_1 }}', '__opt_4':\n    '{{ cookiecutter.opt_1 }}'})\nows = coookie_widget.get_values()\nassert ows['_opt_3'] == ows['_opt_3']\nassert ows['__opt_4'] == ows['__opt_4']\n",
        "CUT_1": "\"\"\"\n        Set the cookiecutter pregeneration code.\n        \"\"\"\nself._pre_gen_code = pre_gen_code\n",
        "CUT_2": "\"\"\"\n        Set the cookiecutter pregeneration code.\n        \"\"\"\nself._pre_gen_code = pre_gen_code\n",
        "CUT_3": "\"\"\"\n        Set the cookiecutter pregeneration code.\n        \"\"\"\nself._widget.set_pre_gen_code(pre_gen_code)\n",
        "CUT_4": "\"\"\"\n        Set the cookiecutter pregeneration code.\n        \"\"\"\nself._widget.set_pre_gen_code(pre_gen_code)\n",
        "CUT_5": "\"\"\"\n        Render text that contains Jinja2 expressions and set their values.\n        \"\"\"\ncookiecutter_settings = self.get_values()\nfor setting, value in self._rendered_settings.items():\n    if not setting.startswith(('__', '_')):\n        template = Template(value)\n        val = template.render(cookiecutter=Namespace(**cookiecutter_settings))\n        __, widget = self._widgets[setting]\n        widget.set_value(val)\n"
    },
    {
        "functionName": "test_cookiecutter_widget_validate_passes",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coookie_widget.setup({'opt_1': 'test'})\ncoookie_widget.set_pre_gen_code(\"\"\"\nimport sys\nsys.exit(0)\n\"\"\")\nwith qtbot.waitSignal(coookie_widget.sig_validated) as blocker:\n    coookie_widget.validate()\nassert blocker.args == [0, '']\n",
        "CUT_1": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n",
        "CUT_2": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n",
        "CUT_3": "\"\"\"Return sys.path contents.\"\"\"\nreturn sys.path[:]\n",
        "CUT_4": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_5": "import sys\nfrom spyder.config.manager import CONF\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nwidget = FindInFiles(None, CONF)\nwidget.show()\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_cookiecutter_widget_validate_fails",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_qcookiecutter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coookie_widget.setup({'opt_1': 'test'})\ncoookie_widget.set_pre_gen_code(\n    \"\"\"\nimport sys\nprint('ERROR!')  # spyder: test-skip\nsys.exit(1)\n\"\"\")\nwith qtbot.waitSignal(coookie_widget.sig_validated) as blocker:\n    coookie_widget.validate()\nassert blocker.args == [1, 'ERROR! ']\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\nfrom spyder.config.base import get_module_path\nspyder_dir = get_module_path('spyder')\napp = qapplication(test_time=8)\ntest = EditorPluginExample()\ntest.resize(900, 700)\ntest.show()\nimport time\nt0 = time.time()\ntest.load(osp.join(spyder_dir, 'widgets', 'collectionseditor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'editor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'explorer', 'widgets', 'explorer.py')\n    )\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'codeeditor.py')\n    )\nprint('Elapsed time: %.3f s' % (time.time() - t0))\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "projects_dialog",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_projectdialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up ProjectDialog.\"\"\"\ndlg = ProjectDialog(None, {'Empty project': EmptyProject})\nqtbot.addWidget(dlg)\nreturn dlg\npytest.fixture",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_3": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_4": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n"
    },
    {
        "functionName": "test_project_dialog",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_projectdialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run project dialog.\"\"\"\nprojects_dialog.show()\nassert projects_dialog\n",
        "CUT_1": "return _('Run')\n",
        "CUT_2": "return _('Run')\n",
        "CUT_3": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_4": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_5": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n"
    },
    {
        "functionName": "test_projectdialog_location",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_projectdialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that select_location normalizes delimiters and updates the path.\"\"\"\ndlg = ProjectDialog(None, {'Empty project': EmptyProject})\nmock_getexistingdirectory = Mock()\nmonkeypatch.setattr('spyder.plugins.projects.widgets.projectdialog' +\n    '.getexistingdirectory', mock_getexistingdirectory)\nmock_getexistingdirectory.return_value = 'c:\\\\a/b\\\\\\\\c/d'\ndlg.select_location()\nassert dlg.location == 'c:\\\\a\\\\b\\\\c\\\\d'\nmock_getexistingdirectory.return_value = 'c:\\\\\\\\a//b\\\\\\\\c//d'\ndlg.select_location()\nassert dlg.location == 'c:\\\\a\\\\b\\\\c\\\\d'\nmock_getexistingdirectory.return_value = 'c:\\\\a\\\\b\\\\c/d'\ndlg.select_location()\nassert dlg.location == 'c:\\\\a\\\\b\\\\c\\\\d'\nmock_getexistingdirectory.return_value = 'c:/a/b/c\\\\d'\ndlg.select_location()\nassert dlg.location == 'c:\\\\a\\\\b\\\\c\\\\d'\nmock_getexistingdirectory.return_value = 'c:\\\\\\\\a\\\\\\\\b\\\\\\\\c//d'\ndlg.select_location()\nassert dlg.location == 'c:\\\\a\\\\b\\\\c\\\\d'\nmock_getexistingdirectory.return_value = 'c:\\\\AaA/bBB1\\\\\\\\c-C/d2D'\ndlg.select_location()\nassert dlg.location == 'c:\\\\AaA\\\\bBB1\\\\c-C\\\\d2D'\nmock_getexistingdirectory.return_value = 'c:\\\\\\\\a_a_1//Bbbb\\\\2345//d-6D'\ndlg.select_location()\nassert dlg.location == 'c:\\\\a_a_1\\\\Bbbb\\\\2345\\\\d-6D'\npytest.mark.skipif(os.name != 'nt', reason='Specific to Windows platform')",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_3": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n"
    },
    {
        "functionName": "project_test",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_project.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Fixture for create a temporary project.\n\n    Returns:\n        project_dir: fixture of temporary project dir.\n        project: EmptyProject object.\n    \"\"\"\nproject_dir = tmpdir_factory.mktemp('test_project')\nproject = EmptyProject(str(project_dir), None)\nreturn project_dir, project\npytest.fixture(scope='session')",
        "CUT_1": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_2": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_3": "\"\"\"\n        Load a project type class from the config project folder directly.\n\n        Notes\n        -----\n        This is done directly, since using the EmptyProject would rewrite the\n        value in the constructor. If the project found has not been registered\n        as a valid project type, the EmptyProject type will be returned.\n\n        Returns\n        -------\n        spyder.plugins.projects.api.BaseProjectType\n            Loaded project type class.\n        \"\"\"\nfpath = osp.join(path, get_project_config_folder(), 'config', WORKSPACE +\n    '.ini')\nproject_type_id = EmptyProject.ID\nif osp.isfile(fpath):\n    config = configparser.ConfigParser()\n    config.read(fpath)\n    project_type_id = config[WORKSPACE].get('project_type', EmptyProject.ID)\nEmptyProject._PARENT_PLUGIN = self\nproject_types = self.get_project_types()\nproject_type_class = project_types.get(project_type_id, EmptyProject)\nreturn project_type_class\n",
        "CUT_4": "\"\"\"\n        Load a project type class from the config project folder directly.\n\n        Notes\n        -----\n        This is done directly, since using the EmptyProject would rewrite the\n        value in the constructor. If the project found has not been registered\n        as a valid project type, the EmptyProject type will be returned.\n\n        Returns\n        -------\n        spyder.plugins.projects.api.BaseProjectType\n            Loaded project type class.\n        \"\"\"\nfpath = osp.join(path, get_project_config_folder(), 'config', WORKSPACE +\n    '.ini')\nproject_type_id = EmptyProject.ID\nif osp.isfile(fpath):\n    config = configparser.ConfigParser()\n    config.read(fpath)\n    project_type_id = config[WORKSPACE].get('project_type', EmptyProject.ID)\nEmptyProject._PARENT_PLUGIN = self\nproject_types = self.get_project_types()\nproject_type_class = project_types.get(project_type_id, EmptyProject)\nreturn project_type_class\n",
        "CUT_5": "\"\"\"\n        Return available registered project types.\n\n        Returns\n        -------\n        dict\n            Project types dictionary. Keys are project type IDs and values\n            are project type classes.\n        \"\"\"\nreturn self._project_types\n"
    },
    {
        "functionName": "test_empty_project",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_project.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test creation of an Empy project, and its configuration files.\"\"\"\nproject_dir, project = project_test\nassert project.root_path == str(project_dir)\nqtbot.wait(3000)\nfor filename in [WORKSPACE, CODESTYLE, ENCODING, VCS]:\n    config_path = os.path.join(project.root_path, '.spyproject', 'config')\n    files = os.listdir(config_path)\n    assert filename + '.ini' in files\n",
        "CUT_1": "\"\"\"Create a new project.\"\"\"\nproject_types = self.get_project_types()\nif project_type_id in project_types:\n    project_type_class = project_types[project_type_id]\n    project = project_type_class(root_path=root_path, parent_plugin=\n        project_type_class._PARENT_PLUGIN)\n    created_succesfully, message = project.create_project()\n    if not created_succesfully:\n        QMessageBox.warning(self, 'Project creation', message)\n        shutil.rmtree(root_path, ignore_errors=True)\n        return\n    self.sig_project_created.emit(root_path, project_type_id, packages)\n    self.open_project(path=root_path, project=project)\nelif not running_under_pytest():\n    QMessageBox.critical(self, _('Error'), _(\n        '<b>{}</b> is not a registered Spyder project type!').format(\n        project_type))\n",
        "CUT_2": "\"\"\"Create a new project.\"\"\"\nproject_types = self.get_project_types()\nif project_type_id in project_types:\n    project_type_class = project_types[project_type_id]\n    project = project_type_class(root_path=root_path, parent_plugin=\n        project_type_class._PARENT_PLUGIN)\n    created_succesfully, message = project.create_project()\n    if not created_succesfully:\n        QMessageBox.warning(self, 'Project creation', message)\n        shutil.rmtree(root_path, ignore_errors=True)\n        return\n    self.sig_project_created.emit(root_path, project_type_id, packages)\n    self.open_project(path=root_path, project=project)\nelif not running_under_pytest():\n    QMessageBox.critical(self, _('Error'), _(\n        '<b>{}</b> is not a registered Spyder project type!').format(\n        project_type))\n",
        "CUT_3": "\"\"\"\n        Set the current active project root path.\n\n        Parameters\n        ----------\n        root_path: str or None, optional\n            Path to current project root path. Default is None.\n        \"\"\"\nself.current_project_path = root_path\n",
        "CUT_4": "\"\"\"\n        Set the current active project root path.\n\n        Parameters\n        ----------\n        root_path: str or None, optional\n            Path to current project root path. Default is None.\n        \"\"\"\nself.current_project_path = root_path\n",
        "CUT_5": "\"\"\"Return the default project configuration folder.\"\"\"\nreturn '.spyproject'\n"
    },
    {
        "functionName": "test_set_load_recent_files",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_project.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test saving and loading files from the configuration.\n\n    Saving/loading should preserved the order, and remove duplicates.\n    \"\"\"\nproject_dir, project = project_test\nfiles_paths = []\nfor f in ['a.py', 'b.py', 'c.py']:\n    file_ = project_dir.join(f)\n    file_.write('# Some dummy content')\n    files_paths.append(str(file_))\nproject.set_recent_files(files_paths[:])\nassert project.get_recent_files() == files_paths\nfiles_paths_duplicate = files_paths + [files_paths[0]]\nassert len(files_paths_duplicate) == len(files_paths) + 1\nproject.set_recent_files(files_paths_duplicate[:])\nassert project.get_recent_files() == files_paths\n",
        "CUT_1": "\"\"\"\n        Return available registered project types.\n\n        Returns\n        -------\n        dict\n            Project types dictionary. Keys are project type IDs and values\n            are project type classes.\n        \"\"\"\nreturn self._project_types\n",
        "CUT_2": "\"\"\"\n        Return available registered project types.\n\n        Returns\n        -------\n        dict\n            Project types dictionary. Keys are project type IDs and values\n            are project type classes.\n        \"\"\"\nreturn self._project_types\n",
        "CUT_3": "\"\"\"Return widget title\"\"\"\nreturn _('Project')\n",
        "CUT_4": "\"\"\"Return widget title\"\"\"\nreturn _('Project')\n",
        "CUT_5": "\"\"\"\n        Sets the project path and disables the project search in the combobox\n        if the value of path is None.\n        \"\"\"\nif path is None:\n    self.project_path = None\n    self.model().item(PROJECT, 0).setEnabled(False)\n    if self.currentIndex() == PROJECT:\n        self.setCurrentIndex(CWD)\nelse:\n    path = osp.abspath(path)\n    self.project_path = path\n    self.model().item(PROJECT, 0).setEnabled(True)\n"
    },
    {
        "functionName": "project",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_configdialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up ProjectPreferences.\"\"\"\nproject_dir = tempfile.mkdtemp() + osp.sep + '.spyproject'\nproject = EmptyProject(project_dir, None)\nreturn project\npytest.fixture",
        "CUT_1": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_2": "\"\"\"Get the path to the most proximate pylintrc config to the file.\"\"\"\nparent = self.parentWidget()\nif parent is not None:\n    project_dir = parent.main.projects.get_active_project_path()\nelse:\n    project_dir = None\nsearch_paths = [osp.dirname(filename), getcwd_or_home(), project_dir, osp.\n    expanduser('~')]\nreturn get_pylintrc_path(search_paths=search_paths)\n",
        "CUT_3": "\"\"\"Return the default project configuration folder.\"\"\"\nreturn '.spyproject'\n",
        "CUT_4": "\"\"\"Return the default project configuration folder.\"\"\"\nreturn '.spyproject'\n",
        "CUT_5": "\"\"\"\n        Load a project type class from the config project folder directly.\n\n        Notes\n        -----\n        This is done directly, since using the EmptyProject would rewrite the\n        value in the constructor. If the project found has not been registered\n        as a valid project type, the EmptyProject type will be returned.\n\n        Returns\n        -------\n        spyder.plugins.projects.api.BaseProjectType\n            Loaded project type class.\n        \"\"\"\nfpath = osp.join(path, get_project_config_folder(), 'config', WORKSPACE +\n    '.ini')\nproject_type_id = EmptyProject.ID\nif osp.isfile(fpath):\n    config = configparser.ConfigParser()\n    config.read(fpath)\n    project_type_id = config[WORKSPACE].get('project_type', EmptyProject.ID)\nEmptyProject._PARENT_PLUGIN = self\nproject_types = self.get_project_types()\nproject_type_class = project_types.get(project_type_id, EmptyProject)\nreturn project_type_class\n"
    },
    {
        "functionName": "test_projects_preferences",
        "className": null,
        "fileName": "/spyder/plugins/projects/widgets/tests/test_configdialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run Project Preferences.\"\"\"\nassert project\n",
        "CUT_1": "\"\"\"\n        Return available registered project types.\n\n        Returns\n        -------\n        dict\n            Project types dictionary. Keys are project type IDs and values\n            are project type classes.\n        \"\"\"\nreturn self._project_types\n",
        "CUT_2": "\"\"\"\n        Return available registered project types.\n\n        Returns\n        -------\n        dict\n            Project types dictionary. Keys are project type IDs and values\n            are project type classes.\n        \"\"\"\nreturn self._project_types\n",
        "CUT_3": "\"\"\"Return widget title\"\"\"\nreturn _('Project')\n",
        "CUT_4": "\"\"\"Return widget title\"\"\"\nreturn _('Project')\n",
        "CUT_5": "\"\"\"\n        Sets the project path and disables the project search in the combobox\n        if the value of path is None.\n        \"\"\"\nif path is None:\n    self.project_path = None\n    self.model().item(PROJECT, 0).setEnabled(False)\n    if self.currentIndex() == PROJECT:\n        self.setCurrentIndex(CWD)\nelse:\n    path = osp.abspath(path)\n    self.project_path = path\n    self.model().item(PROJECT, 0).setEnabled(True)\n"
    },
    {
        "functionName": "get_console_font_color",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "styles = create_style_class(syntax_style).styles\nfont_color = styles[Name]\nreturn font_color\n",
        "CUT_1": "\"\"\"Set the styles for this item.\"\"\"\nraise NotImplementedError\n",
        "CUT_2": "\"\"\"Set the styles for this item.\"\"\"\nraise NotImplementedError\n",
        "CUT_3": "\"\"\"Separator Item represented as <hr>.\"\"\"\nsuper(SwitcherSeparatorItem, self).__init__(parent=parent, styles=styles)\nself.setFlags(Qt.NoItemFlags)\nself._set_rendered_text()\n",
        "CUT_4": "\"\"\"Separator Item represented as <hr>.\"\"\"\nsuper(SwitcherSeparatorItem, self).__init__(parent=parent, styles=styles)\nself.setFlags(Qt.NoItemFlags)\nself._set_rendered_text()\n",
        "CUT_5": "\"\"\"Check if the font color used in the color scheme is dark.\"\"\"\ncolor_scheme = get_color_scheme(color_scheme)\nfont_color, fon_fw, fon_fs = color_scheme['normal']\nreturn dark_color(font_color)\n"
    },
    {
        "functionName": "get_console_background_color",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "background_color = style_sheet.split('background-color:')[1]\nbackground_color = background_color.split(';')[0]\nreturn background_color\n",
        "CUT_1": "return QColor(self.background_color)\n",
        "CUT_2": "return QColor(self.background_color)\n",
        "CUT_3": "\"\"\"Set color scheme of the console (foreground and background).\"\"\"\nself.ansi_handler.set_color_scheme(foreground_color, background_color)\nbackground_color = QColor(background_color)\nforeground_color = QColor(foreground_color)\nself.set_palette(background=background_color, foreground=foreground_color)\nself.set_pythonshell_font()\n",
        "CUT_4": "\"\"\"Set color scheme of the console (foreground and background).\"\"\"\nself.ansi_handler.set_color_scheme(foreground_color, background_color)\nbackground_color = QColor(background_color)\nforeground_color = QColor(foreground_color)\nself.set_palette(background=background_color, foreground=foreground_color)\nself.set_pythonshell_font()\n",
        "CUT_5": "super().__init__(parent)\nself.setAlignment(Qt.AlignCenter)\nself.viewport().setObjectName('figviewport')\nself.viewport().setStyleSheet('#figviewport {background-color:' + str(\n    background_color) + '}')\nself.setFrameStyle(0)\nself.background_color = background_color\nself._scalefactor = 0\nself._scalestep = 1.2\nself._sfmax = 10\nself._sfmin = -10\nself.setup_figcanvas()\nself.auto_fit_plotting = False\nself._ispanning = False\n"
    },
    {
        "functionName": "get_conda_test_env",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Return the full prefix path of the given `test_env_name`.\"\"\"\nif 'envs' in sys.prefix:\n    root_prefix = os.path.dirname(os.path.dirname(sys.prefix))\nelse:\n    root_prefix = sys.prefix\ntest_env_prefix = os.path.join(root_prefix, 'envs', test_env_name)\nif os.name == 'nt':\n    test_env_executable = os.path.join(test_env_prefix, 'python.exe')\nelse:\n    test_env_executable = os.path.join(test_env_prefix, 'bin', 'python')\nreturn test_env_executable\n",
        "CUT_1": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n",
        "CUT_2": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n",
        "CUT_3": "\"\"\"Given a path to a module, derive its dot-separated full name.\"\"\"\ndirectory = os.path.dirname(path)\nmodule_name, _ = os.path.splitext(os.path.basename(path))\nfull_name = [module_name]\nwhile os.path.exists(os.path.join(directory, '__init__.py')):\n    this_directory = os.path.basename(directory)\n    directory = os.path.dirname(directory)\n    full_name = [this_directory] + full_name\nreturn '.'.join(full_name)\n",
        "CUT_4": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_5": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n"
    },
    {
        "functionName": "ipyconsole",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"IPython console fixture.\"\"\"\nclass MainWindowMock(QMainWindow):\n\n    def get_spyder_pythonpath(self):\n        return CONF.get('main', 'spyder_pythonpath', [])\n\n    def __getattr__(self, attr):\n        if attr == 'consoles_menu_actions':\n            return []\n        else:\n            return Mock()\nCONF.set('ipython_console', 'pylab/backend', 0)\nuse_startup_wdir = request.node.get_closest_marker('use_startup_wdir')\nif use_startup_wdir:\n    new_wdir = osp.join(os.getcwd(), NEW_DIR)\n    if not osp.exists(new_wdir):\n        os.mkdir(new_wdir)\n    CONF.set('workingdir', 'console/use_fixed_directory', True)\n    CONF.set('workingdir', 'console/fixed_directory', new_wdir)\nelse:\n    CONF.set('workingdir', 'console/use_fixed_directory', False)\n    CONF.set('workingdir', 'console/fixed_directory', get_home_dir())\nnon_ascii_dir = request.node.get_closest_marker('non_ascii_dir')\nif non_ascii_dir:\n    test_dir = NON_ASCII_DIR\nelse:\n    test_dir = None\nno_stderr_file = request.node.get_closest_marker('no_stderr_file')\nif no_stderr_file:\n    test_no_stderr = True\nelse:\n    test_no_stderr = False\nauto_backend = request.node.get_closest_marker('auto_backend')\nif auto_backend:\n    CONF.set('ipython_console', 'pylab/backend', 1)\npylab_client = request.node.get_closest_marker('pylab_client')\nis_pylab = True if pylab_client else False\nsympy_client = request.node.get_closest_marker('sympy_client')\nis_sympy = True if sympy_client else False\ncython_client = request.node.get_closest_marker('cython_client')\nis_cython = True if cython_client else False\nexternal_interpreter = request.node.get_closest_marker('external_interpreter')\nif external_interpreter:\n    CONF.set('main_interpreter', 'default', False)\n    CONF.set('main_interpreter', 'executable', sys.executable)\nelse:\n    CONF.set('main_interpreter', 'default', True)\n    CONF.set('main_interpreter', 'executable', '')\ntest_environment_interpreter = request.node.get_closest_marker(\n    'test_environment_interpreter')\nif test_environment_interpreter:\n    CONF.set('main_interpreter', 'default', False)\n    CONF.set('main_interpreter', 'executable', get_conda_test_env())\nelse:\n    CONF.set('main_interpreter', 'default', True)\n    CONF.set('main_interpreter', 'executable', '')\nwindow = MainWindowMock()\nconsole = IPythonConsole(parent=window, testing=True, test_dir=test_dir,\n    test_no_stderr=test_no_stderr)\nconsole.dockwidget = Mock()\nconsole._toggle_view_action = Mock()\nconsole.create_new_client(is_pylab=is_pylab, is_sympy=is_sympy, is_cython=\n    is_cython)\nwindow.setCentralWidget(console)\nCONF.set('ipython_console', 'pdb_use_exclamation_mark', True)\nif not sys.platform == 'darwin':\n    qtbot.addWidget(window)\nwindow.resize(640, 480)\nwindow.show()\nyield console\nif request.node.rep_setup.passed:\n    if request.node.rep_call.failed:\n        print(console.get_current_shellwidget()._control.toPlainText())\n        client = console.get_current_client()\n        if client.info_page != client.blank_page:\n            print('info_page')\n            print(client.info_page)\nconsole.closing_plugin()\nconsole.close()\nwindow.close()\npytest.fixture",
        "CUT_1": "if CONF.get('main_interpreter', 'default'):\n    return sys.executable\nelse:\n    return CONF.get('main_interpreter', 'custom_interpreter')\n",
        "CUT_2": "if CONF.get('main_interpreter', 'default'):\n    return sys.executable\nelse:\n    return CONF.get('main_interpreter', 'custom_interpreter')\n",
        "CUT_3": "\"\"\"Open external console\"\"\"\nif systerm:\n    try:\n        if CONF.get('main_interpreter', 'default'):\n            executable = get_python_executable()\n        else:\n            executable = CONF.get('main_interpreter', 'executable')\n        programs.run_python_script_in_terminal(fname, wdir, args, interact,\n            debug, python_args, executable)\n    except NotImplementedError:\n        QMessageBox.critical(self, _('Run'), _(\n            'Running an external system terminal is not supported on platform %s.'\n            ) % os.name)\n",
        "CUT_4": "\"\"\"Open external console\"\"\"\nif systerm:\n    try:\n        if CONF.get('main_interpreter', 'default'):\n            executable = get_python_executable()\n        else:\n            executable = CONF.get('main_interpreter', 'executable')\n        programs.run_python_script_in_terminal(fname, wdir, args, interact,\n            debug, python_args, executable)\n    except NotImplementedError:\n        QMessageBox.critical(self, _('Run'), _(\n            'Running an external system terminal is not supported on platform %s.'\n            ) % os.name)\n",
        "CUT_5": "\"\"\"\n        Set the internal console shell.\n\n        Parameters\n        ----------\n        console: :py:class:spyder.plugins.console.plugin.Console\n            Console plugin.\n        \"\"\"\nself.internal_console = console\nself.internal_shell = console.get_widget().shell\n"
    },
    {
        "functionName": "get_spyder_pythonpath",
        "className": "MainWindowMock",
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return CONF.get('main', 'spyder_pythonpath', [])\n",
        "CUT_1": "\"\"\"Create a kernel spec for our own kernels\"\"\"\nCONF.set('main', 'spyder_pythonpath', self.main.get_spyder_pythonpath())\nreturn SpyderKernelSpec(is_cython=is_cython, is_pylab=is_pylab, is_sympy=\n    is_sympy)\n",
        "CUT_2": "\"\"\"Create a kernel spec for our own kernels\"\"\"\nCONF.set('main', 'spyder_pythonpath', self.main.get_spyder_pythonpath())\nreturn SpyderKernelSpec(is_cython=is_cython, is_pylab=is_pylab, is_sympy=\n    is_sympy)\n",
        "CUT_3": "self.args = options.get('args', '')\nself.args_enabled = options.get('args/enabled', False)\nself.current = options.get('current', CONF.get('run',\n    CURRENT_INTERPRETER_OPTION, True))\nself.systerm = options.get('systerm', CONF.get('run',\n    SYSTERM_INTERPRETER_OPTION, False))\nself.interact = options.get('interact', CONF.get('run', 'interact', False))\nself.post_mortem = options.get('post_mortem', CONF.get('run', 'post_mortem',\n    False))\nself.python_args = options.get('python_args', '')\nself.python_args_enabled = options.get('python_args/enabled', False)\nself.clear_namespace = options.get('clear_namespace', CONF.get('run',\n    'clear_namespace', False))\nself.console_namespace = options.get('console_namespace', CONF.get('run',\n    'console_namespace', False))\nself.file_dir = options.get('file_dir', CONF.get('run',\n    WDIR_USE_SCRIPT_DIR_OPTION, True))\nself.cw_dir = options.get('cw_dir', CONF.get('run', WDIR_USE_CWD_DIR_OPTION,\n    False))\nself.fixed_dir = options.get('fixed_dir', CONF.get('run',\n    WDIR_USE_FIXED_DIR_OPTION, False))\nself.dir = options.get('dir', '')\n",
        "CUT_4": "self.args = options.get('args', '')\nself.args_enabled = options.get('args/enabled', False)\nself.current = options.get('current', CONF.get('run',\n    CURRENT_INTERPRETER_OPTION, True))\nself.systerm = options.get('systerm', CONF.get('run',\n    SYSTERM_INTERPRETER_OPTION, False))\nself.interact = options.get('interact', CONF.get('run', 'interact', False))\nself.post_mortem = options.get('post_mortem', CONF.get('run', 'post_mortem',\n    False))\nself.python_args = options.get('python_args', '')\nself.python_args_enabled = options.get('python_args/enabled', False)\nself.clear_namespace = options.get('clear_namespace', CONF.get('run',\n    'clear_namespace', False))\nself.console_namespace = options.get('console_namespace', CONF.get('run',\n    'console_namespace', False))\nself.file_dir = options.get('file_dir', CONF.get('run',\n    WDIR_USE_SCRIPT_DIR_OPTION, True))\nself.cw_dir = options.get('cw_dir', CONF.get('run', WDIR_USE_CWD_DIR_OPTION,\n    False))\nself.fixed_dir = options.get('fixed_dir', CONF.get('run',\n    WDIR_USE_FIXED_DIR_OPTION, False))\nself.dir = options.get('dir', '')\n",
        "CUT_5": "\"\"\"Get pdb settings\"\"\"\nreturn {'breakpoints': CONF.get('run', 'breakpoints', {}), 'pdb_ignore_lib':\n    CONF.get('ipython_console', 'pdb_ignore_lib'), 'pdb_execute_events':\n    CONF.get('ipython_console', 'pdb_execute_events'),\n    'pdb_use_exclamation_mark': self.is_pdb_using_exclamantion_mark(),\n    'pdb_stop_first_line': CONF.get('ipython_console', 'pdb_stop_first_line')}\n"
    },
    {
        "functionName": "__getattr__",
        "className": "MainWindowMock",
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if attr == 'consoles_menu_actions':\n    return []\nelse:\n    return Mock()\n",
        "CUT_1": "return Mock()\n",
        "CUT_2": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_3": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_4": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n",
        "CUT_5": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture"
    },
    {
        "functionName": "test_banners",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that console banners are generated correctly.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\ncontrol = shell._control\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ntext = control.toPlainText().splitlines()\npy_ver = sys.version.splitlines()[0].strip()\nassert py_ver in text[0]\nassert 'license' in text[1]\nassert '' == text[2]\nassert ipy_release.version in text[3]\nshort_banner = shell.short_banner()\npy_ver = sys.version.split(' ')[0]\nexpected = 'Python %s -- IPython %s' % (py_ver, ipy_release.version)\nassert expected == short_banner\npytest.mark.external_interpreter",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_get_calltips",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that calltips show the documentation.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\ncontrol = shell._control\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import numpy as np')\nwith qtbot.waitSignal(shell.kernel_client.shell_channel.message_received):\n    qtbot.keyClicks(control, 'np.' + function + '(')\nqtbot.waitUntil(lambda : control.calltip_widget.isVisible())\nassert control.calltip_widget.isVisible()\ncontrol.calltip_widget.hide()\nfor element in signature:\n    assert element in control.calltip_widget.text()\nfor element in documentation:\n    assert element in control.calltip_widget.text()\npytest.mark.parametrize('function,signature,documentation', [('arange', [\n    'start', 'stop'], [\n    'Return evenly spaced values within a given interval.<br>',\n    '<br>Python built-in `range` function, but returns an ndarray ...']), (\n    'vectorize', ['pyfunc', 'otype', 'signature'], [\n    'Generalized function class.<br>',\n    'Define a vectorized function which takes a nested sequence ...']), (\n    'absolute', ['x', '/', 'out'], ['Parameters<br>', 'x : array_like ...'])])pytest.mark.skipif(not os.name == 'nt', reason=\n    'Times out on macOS and fails on Linux')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Show calltip.\n\n        Calltips look like tooltips but will not disappear if mouse hovers\n        them. They are useful for displaying signature information on methods\n        and functions.\n        \"\"\"\npoint = self._calculate_position()\nsignature = signature.strip()\ninspect_word = None\nlanguage = getattr(self, 'language', language).lower()\nif language == 'python' and signature:\n    inspect_word = signature.split('(')[0]\n    check_doc = ' '\n    if documentation:\n        check_doc.join(documentation.split()).replace('\\\\*', '*')\n    check_sig = ' '.join(signature.split())\n    if check_doc == check_sig:\n        signature = documentation\n        documentation = ''\nif documentation:\n    documentation = documentation.replace('\\\\*', '*')\n    if signature.strip():\n        documentation = documentation.replace(signature + '\\n', '')\nres = self._check_signature_and_format(signature, parameter, inspect_word=\n    inspect_word, language=language, max_width=max_width)\nnew_signature, text, inspect_word = res\ntext = self._format_text(signature=new_signature, inspect_word=inspect_word,\n    display_link=False, text=documentation, max_lines=max_lines, max_width=\n    max_width, text_new_line=text_new_line)\nself._update_stylesheet(self.calltip_widget)\nself.calltip_widget.show_tip(point, text, [])\nself.calltip_widget.show()\n"
    },
    {
        "functionName": "test_auto_backend",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the automatic backend is working correctly.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%matplotlib qt5')\ncontrol = ipyconsole.get_focus_widget()\nassert 'NOTE' not in control.toPlainText()\nassert 'Error' not in control.toPlainText()\npytest.mark.auto_backendpytest.mark.skipif(os.name == 'nt', reason='It times out sometimes on Windows')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_pylab_client",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the Pylab console is working correctly.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('e')\ncontrol = ipyconsole.get_focus_widget()\nassert 'Error' not in control.toPlainText()\nshell.reset_namespace()\nqtbot.wait(1000)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('e')\ncontrol = ipyconsole.get_focus_widget()\nassert 'Error' not in control.toPlainText()\npytest.mark.pylab_client",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_sympy_client",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the SymPy console is working correctly.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('x')\ncontrol = ipyconsole.get_focus_widget()\nassert 'NameError' not in control.toPlainText()\nshell.reset_namespace()\nqtbot.wait(1000)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('x')\ncontrol = ipyconsole.get_focus_widget()\nassert 'NameError' not in control.toPlainText()\npytest.mark.sympy_clientpytest.mark.xfail('1.0' < sympy.__version__ < '1.2', reason=\n    'A bug with sympy 1.1.1 and IPython-Qtconsole')",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_cython_client",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the Cython console is working correctly.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%%cython\\ncdef int ctest(int x, int y):\\n    return x + y')\ncontrol = ipyconsole.get_focus_widget()\nassert 'Error' not in control.toPlainText()\nshell.reset_namespace()\nqtbot.wait(1000)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%%cython\\ncdef int ctest(int x, int y):\\n    return x + y')\ncontrol = ipyconsole.get_focus_widget()\nassert 'Error' not in control.toPlainText()\npytest.mark.cython_clientpytest.mark.skipif(not sys.platform.startswith('linux') or LooseVersion(\n    ipy_release.version) == LooseVersion('7.11.0'), reason=\n    'It only works reliably on Linux and fails for IPython 7.11.0')",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_tab_rename_for_slaves",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test slave clients are renamed correctly.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncf = ipyconsole.get_current_client().connection_file\nipyconsole._create_client_for_kernel(cf, None, None, None)\nqtbot.waitUntil(lambda : len(ipyconsole.get_clients()) == 2)\nipyconsole.rename_tabs_after_change('foo')\nassert 'foo' in ipyconsole.get_clients()[0].get_name()\nassert 'foo' in ipyconsole.get_clients()[1].get_name()\n",
        "CUT_1": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_changed.connect(self.set_shellwidget)\nipyconsole.sig_shellwidget_process_started.connect(self.add_shellwidget)\nipyconsole.sig_shellwidget_process_finished.connect(self.remove_shellwidget)\nself.get_widget().sig_figure_loaded.connect(lambda : self.switch_to_plugin(\n    force_focus=False))\n",
        "CUT_2": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_changed.connect(self.set_shellwidget)\nipyconsole.sig_shellwidget_process_started.connect(self.add_shellwidget)\nipyconsole.sig_shellwidget_process_finished.connect(self.remove_shellwidget)\nself.get_widget().sig_figure_loaded.connect(lambda : self.switch_to_plugin(\n    force_focus=False))\n",
        "CUT_3": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_id_changed.disconnect(self.set_shellwidget_from_id)\nipyconsole.sig_shellwidget_process_started.disconnect(self.add_shellwidget)\nipyconsole.sig_shellwidget_id_process_finished.disconnect(self.\n    remove_shellwidget_from_id)\n",
        "CUT_4": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_id_changed.disconnect(self.set_shellwidget_from_id)\nipyconsole.sig_shellwidget_process_started.disconnect(self.add_shellwidget)\nipyconsole.sig_shellwidget_id_process_finished.disconnect(self.\n    remove_shellwidget_from_id)\n",
        "CUT_5": "\"\"\"Restart consoles when closing, opening and switching projects\"\"\"\nif self.main.ipyconsole is not None:\n    self.main.ipyconsole.restart()\n"
    },
    {
        "functionName": "test_no_repeated_tabs_name",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that tabs can't have repeated given names.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nipyconsole.rename_tabs_after_change('foo')\nipyconsole.create_new_client()\nipyconsole.rename_tabs_after_change('foo')\nclient_name = ipyconsole.get_current_client().get_name()\nassert '2' in client_name\n",
        "CUT_1": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_id_changed.disconnect(self.set_shellwidget_from_id)\nipyconsole.sig_shellwidget_process_started.disconnect(self.add_shellwidget)\nipyconsole.sig_shellwidget_id_process_finished.disconnect(self.\n    remove_shellwidget_from_id)\n",
        "CUT_2": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_id_changed.disconnect(self.set_shellwidget_from_id)\nipyconsole.sig_shellwidget_process_started.disconnect(self.add_shellwidget)\nipyconsole.sig_shellwidget_id_process_finished.disconnect(self.\n    remove_shellwidget_from_id)\n",
        "CUT_3": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_changed.connect(self.set_shellwidget)\nipyconsole.sig_shellwidget_process_started.connect(self.add_shellwidget)\nipyconsole.sig_shellwidget_process_finished.connect(self.remove_shellwidget)\nself.get_widget().sig_figure_loaded.connect(lambda : self.switch_to_plugin(\n    force_focus=False))\n",
        "CUT_4": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_changed.connect(self.set_shellwidget)\nipyconsole.sig_shellwidget_process_started.connect(self.add_shellwidget)\nipyconsole.sig_shellwidget_process_finished.connect(self.remove_shellwidget)\nself.get_widget().sig_figure_loaded.connect(lambda : self.switch_to_plugin(\n    force_focus=False))\n",
        "CUT_5": "\"\"\"Restart consoles when closing, opening and switching projects\"\"\"\nif self.main.ipyconsole is not None:\n    self.main.ipyconsole.restart()\n"
    },
    {
        "functionName": "test_tabs_preserve_name_after_move",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that tabs preserve their names after they are moved.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nipyconsole.create_new_client()\nipyconsole.tabwidget.tabBar().moveTab(0, 1)\nclient_name = ipyconsole.get_clients()[0].get_name()\nassert '2' in client_name\n",
        "CUT_1": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_id_changed.disconnect(self.set_shellwidget_from_id)\nipyconsole.sig_shellwidget_process_started.disconnect(self.add_shellwidget)\nipyconsole.sig_shellwidget_id_process_finished.disconnect(self.\n    remove_shellwidget_from_id)\n",
        "CUT_2": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_id_changed.disconnect(self.set_shellwidget_from_id)\nipyconsole.sig_shellwidget_process_started.disconnect(self.add_shellwidget)\nipyconsole.sig_shellwidget_id_process_finished.disconnect(self.\n    remove_shellwidget_from_id)\n",
        "CUT_3": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_changed.connect(self.set_shellwidget)\nipyconsole.sig_shellwidget_process_started.connect(self.add_shellwidget)\nipyconsole.sig_shellwidget_process_finished.connect(self.remove_shellwidget)\nself.get_widget().sig_figure_loaded.connect(lambda : self.switch_to_plugin(\n    force_focus=False))\n",
        "CUT_4": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_changed.connect(self.set_shellwidget)\nipyconsole.sig_shellwidget_process_started.connect(self.add_shellwidget)\nipyconsole.sig_shellwidget_process_finished.connect(self.remove_shellwidget)\nself.get_widget().sig_figure_loaded.connect(lambda : self.switch_to_plugin(\n    force_focus=False))\n",
        "CUT_5": "\"\"\"Restart consoles when closing, opening and switching projects\"\"\"\nif self.main.ipyconsole is not None:\n    self.main.ipyconsole.restart()\n"
    },
    {
        "functionName": "test_conf_env_vars",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that kernels have env vars set by our kernel spec.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\"import os; a = os.environ.get('SPY_SYMPY_O')\")\nassert shell.get_value('a') == 'False'\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_no_stderr_file",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that consoles can run without an stderr.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 1')\nassert shell.get_value('a') == 1\npytest.mark.no_stderr_file",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_non_ascii_stderr_file",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the creation of a console with a stderr file in a non-ascii dir.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 1')\nassert shell.get_value('a') == 1\npytest.mark.non_ascii_dirpytest.mark.skipif(os.name == 'nt', reason='It fails on Windows')",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_console_import_namespace",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test an import of the form 'from foo import *'.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('from numpy import *')\nassert shell.get_value('e') == 2.718281828459045\npytest.mark.skipif(PY2 and sys.platform == 'darwin', reason=\n    'It hangs frequently on Python 2.7 and macOS')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_console_disambiguation",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test the disambiguation of dedicated consoles.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ndir_b = osp.join(TEMP_DIRECTORY, 'a', 'b')\nfilename_b = osp.join(dir_b, 'c.py')\nif not osp.isdir(dir_b):\n    os.makedirs(dir_b)\nif not osp.isfile(filename_b):\n    file_c = open(filename_b, 'w+')\n    file_c.close()\ndir_d = osp.join(TEMP_DIRECTORY, 'a', 'd')\nfilename_d = osp.join(dir_d, 'c.py')\nif not osp.isdir(dir_d):\n    os.makedirs(dir_d)\nif not osp.isfile(filename_d):\n    file_e = open(filename_d, 'w+')\n    file_e.close()\nipyconsole.create_client_for_file(filename_b)\nclient = ipyconsole.get_current_client()\nassert client.get_name() == 'c.py/A'\nipyconsole.create_client_for_file(filename_d)\nclient = ipyconsole.get_current_client()\nassert client.get_name() == 'c.py - d/A'\nipyconsole.tabwidget.setCurrentIndex(1)\nclient = ipyconsole.get_current_client()\nassert client.get_name() == 'c.py - b/A'\n",
        "CUT_1": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_2": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_3": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_4": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_5": "\"\"\"Restart kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.restart_kernel()\n"
    },
    {
        "functionName": "test_console_coloring",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that console gets the same coloring present in the Editor.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nconfig_options = ipyconsole.config_options()\nsyntax_style = config_options.JupyterWidget.syntax_style\nstyle_sheet = config_options.JupyterWidget.style_sheet\nconsole_font_color = get_console_font_color(syntax_style)\nconsole_background_color = get_console_background_color(style_sheet)\nselected_color_scheme = CONF.get('appearance', 'selected')\ncolor_scheme = get_color_scheme(selected_color_scheme)\neditor_background_color = color_scheme['background']\neditor_font_color = color_scheme['normal'][0]\nconsole_background_color = console_background_color.replace(\"'\", '')\neditor_background_color = editor_background_color.replace(\"'\", '')\nconsole_font_color = console_font_color.replace(\"'\", '')\neditor_font_color = editor_font_color.replace(\"'\", '')\nassert console_background_color.strip() == editor_background_color.strip()\nassert console_font_color.strip() == editor_font_color.strip()\n",
        "CUT_1": "\"\"\"\n        Generate a Trailets Config instance for shell widgets using our\n        config system\n\n        This lets us create each widget with its own config\n        \"\"\"\ntry:\n    full_cfg = load_pyconfig_files(['jupyter_qtconsole_config.py'],\n        jupyter_config_dir())\n    cfg = Config({'JupyterWidget': full_cfg.JupyterWidget})\nexcept:\n    cfg = Config()\nspy_cfg = Config()\nspy_cfg.JupyterWidget.kind = 'rich'\ncompletion_type_o = self.get_option('completion_type')\ncompletions = {(0): 'droplist', (1): 'ncurses', (2): 'plain'}\nspy_cfg.JupyterWidget.gui_completion = completions[completion_type_o]\ncalltips_o = self.get_option('show_calltips')\nspy_cfg.JupyterWidget.enable_calltips = calltips_o\nbuffer_size_o = self.get_option('buffer_size')\nspy_cfg.JupyterWidget.buffer_size = buffer_size_o\nin_prompt_o = self.get_option('in_prompt')\nout_prompt_o = self.get_option('out_prompt')\nif in_prompt_o:\n    spy_cfg.JupyterWidget.in_prompt = in_prompt_o\nif out_prompt_o:\n    spy_cfg.JupyterWidget.out_prompt = out_prompt_o\ncolor_scheme = CONF.get('appearance', 'selected')\nstyle_sheet = create_qss_style(color_scheme)[0]\nspy_cfg.JupyterWidget.style_sheet = style_sheet\nspy_cfg.JupyterWidget.syntax_style = color_scheme\ncfg._merge(spy_cfg)\nreturn cfg\n",
        "CUT_2": "\"\"\"\n        Generate a Trailets Config instance for shell widgets using our\n        config system\n\n        This lets us create each widget with its own config\n        \"\"\"\ntry:\n    full_cfg = load_pyconfig_files(['jupyter_qtconsole_config.py'],\n        jupyter_config_dir())\n    cfg = Config({'JupyterWidget': full_cfg.JupyterWidget})\nexcept:\n    cfg = Config()\nspy_cfg = Config()\nspy_cfg.JupyterWidget.kind = 'rich'\ncompletion_type_o = self.get_option('completion_type')\ncompletions = {(0): 'droplist', (1): 'ncurses', (2): 'plain'}\nspy_cfg.JupyterWidget.gui_completion = completions[completion_type_o]\ncalltips_o = self.get_option('show_calltips')\nspy_cfg.JupyterWidget.enable_calltips = calltips_o\nbuffer_size_o = self.get_option('buffer_size')\nspy_cfg.JupyterWidget.buffer_size = buffer_size_o\nin_prompt_o = self.get_option('in_prompt')\nout_prompt_o = self.get_option('out_prompt')\nif in_prompt_o:\n    spy_cfg.JupyterWidget.in_prompt = in_prompt_o\nif out_prompt_o:\n    spy_cfg.JupyterWidget.out_prompt = out_prompt_o\ncolor_scheme = CONF.get('appearance', 'selected')\nstyle_sheet = create_qss_style(color_scheme)[0]\nspy_cfg.JupyterWidget.style_sheet = style_sheet\nspy_cfg.JupyterWidget.syntax_style = color_scheme\ncfg._merge(spy_cfg)\nreturn cfg\n",
        "CUT_3": "if is_text_string(color_scheme):\n    self.color_scheme = get_color_scheme(color_scheme)\nelse:\n    self.color_scheme = color_scheme\nself.setup_formats()\nself.rehighlight()\n",
        "CUT_4": "if is_text_string(color_scheme):\n    self.color_scheme = get_color_scheme(color_scheme)\nelse:\n    self.color_scheme = color_scheme\nself.setup_formats()\nself.rehighlight()\n",
        "CUT_5": "return [s.strip() for s in string.split(',') if s.strip()]\n"
    },
    {
        "functionName": "test_set_cwd",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test kernel when changing cwd.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nsavetemp = shell._cwd\ntempdir = to_text_string(tmpdir.mkdir(\"queen's\"))\nshell.set_cwd(tempdir)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import os; cwd = os.getcwd()')\nassert shell.get_value('cwd') == tempdir\nshell.set_cwd(savetemp)\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_get_cwd",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test current working directory.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nsavetemp = shell._cwd\ntempdir = to_text_string(tmpdir.mkdir(\"queen's\"))\nassert shell._cwd != tempdir\nif os.name == 'nt':\n    tempdir = tempdir.replace('\\\\', '\\\\\\\\')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\"import os; os.chdir(u'''{}''')\".format(tempdir))\nwith qtbot.waitSignal(shell.sig_change_cwd):\n    shell.update_cwd()\nif os.name == 'nt':\n    tempdir = tempdir.replace('\\\\\\\\', '\\\\')\nassert shell._cwd == tempdir\nshell.set_cwd(savetemp)\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_request_env",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that getting env vars from the kernel is working as expected.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\"import os; os.environ['FOO'] = 'bar'\")\nwith qtbot.waitSignal(shell.sig_show_env) as blocker:\n    shell.request_env()\nenv_contents = blocker.args[0]\nassert env_contents['FOO'] == 'bar'\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_request_syspath",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that getting sys.path contents from the kernel is working as\n    expected.\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    tmp_dir = to_text_string(tmpdir)\n    shell.execute(\"import sys; sys.path.append('%s')\" % tmp_dir)\nwith qtbot.waitSignal(shell.sig_show_syspath) as blocker:\n    shell.request_syspath()\nsyspath_contents = blocker.args[0]\nassert tmp_dir in syspath_contents\npytest.mark.skipif(os.name == 'nt', reason=\n    'Fails due to differences in path handling')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_save_history_dbg",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that browsing command history is working while debugging.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('1/0')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, 'aa = 10')\n    qtbot.keyClick(control, Qt.Key_Enter)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClicks(control, '!u')\n    qtbot.keyClick(control, Qt.Key_Enter)\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nshell.reset(clear=True)\nqtbot.waitUntil(lambda : shell.is_waiting_pdb_input())\nassert shell.is_waiting_pdb_input()\nqtbot.keyClick(control, Qt.Key_Up)\nassert 'aa = 10' in control.toPlainText()\nipyconsole.create_new_client()\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('1/0')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug')\nqtbot.keyClick(control, Qt.Key_Up)\nassert 'aa = 10' in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nshell._pdb_history.append(\"\"\"if True:\n    print(1)\"\"\")\nshell._pdb_history.append('print(2)')\nshell._pdb_history.append(\"\"\"if True:\n    print(10)\"\"\")\nshell._pdb_history_index = len(shell._pdb_history)\nqtbot.keyClick(control, Qt.Key_Up)\nassert '...:     print(10)' in control.toPlainText()\nshell._control.set_cursor_position(shell._control.get_position('eof') - 25)\nqtbot.keyClick(control, Qt.Key_Up)\nassert '...:     print(1)' in control.toPlainText()\npytest.mark.skipif(os.name == 'nt', reason=\"It doesn't work on Windows\")",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_dbg_input",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that spyder doesn't send pdb commands to unrelated input calls.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\"%debug print('Hello', input('name'))\")\nshell.pdb_execute('!n')\nqtbot.wait(100)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == 'name')\nshell.pdb_execute('!n')\nshell.pdb_execute('aa = 10')\nqtbot.wait(500)\nassert control.toPlainText().split()[-1] == 'name'\nshell.kernel_client.input('test')\nqtbot.waitUntil(lambda : 'Hello test' in control.toPlainText())\npytest.mark.skipif(PY2 or IPython.version_info < (7, 17), reason=\n    'insert is not the same in py2')",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_unicode_vars",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the Variable Explorer Works with unicode variables.\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('\u0434 = 10')\nassert shell.get_value('\u0434') == 10\nshell.set_value('\u0434', 20)\nqtbot.waitUntil(lambda : shell.get_value('\u0434') == 20)\nassert shell.get_value('\u0434') == 20\npytest.mark.skipif(PY2, reason=\"It doesn't work on PY2\")",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_read_stderr",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test the read operation of the stderr file of the kernel\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nclient = ipyconsole.get_current_client()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontent = 'Test text'\nstderr_file = client.stderr_file\ncodecs.open(stderr_file, 'w', 'cp437').write(content)\nassert content == client._read_stderr()\n",
        "CUT_1": "\"\"\"Filename to save kernel stderr output.\"\"\"\nstderr_file = None\nif self.connection_file is not None:\n    stderr_file = self.kernel_id + '.stderr'\n    if self.stderr_dir is not None:\n        stderr_file = osp.join(self.stderr_dir, stderr_file)\n    else:\n        try:\n            stderr_file = osp.join(get_temp_dir(), stderr_file)\n        except (IOError, OSError):\n            stderr_file = None\nreturn stderr_file\nproperty",
        "CUT_2": "\"\"\"Filename to save kernel stderr output.\"\"\"\nstderr_file = None\nif self.connection_file is not None:\n    stderr_file = self.kernel_id + '.stderr'\n    if self.stderr_dir is not None:\n        stderr_file = osp.join(self.stderr_dir, stderr_file)\n    else:\n        try:\n            stderr_file = osp.join(get_temp_dir(), stderr_file)\n        except (IOError, OSError):\n            stderr_file = None\nreturn stderr_file\nproperty",
        "CUT_3": "\"\"\"Remove stderr_file associated with the client.\"\"\"\ntry:\n    self.stderr_handle.close()\n    os.remove(self.stderr_file)\nexcept Exception:\n    pass\n",
        "CUT_4": "\"\"\"Remove stderr_file associated with the client.\"\"\"\ntry:\n    self.stderr_handle.close()\n    os.remove(self.stderr_file)\nexcept Exception:\n    pass\n",
        "CUT_5": "\"\"\"Get handle to stderr_file.\"\"\"\nif self.stderr_file is not None:\n    try:\n        handle = codecs.open(self.stderr_file, 'w', encoding='utf-8')\n    except Exception:\n        handle = None\nelse:\n    handle = None\nreturn handle\nproperty"
    },
    {
        "functionName": "test_values_dbg",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that getting, setting, copying and removing values is working while\n    debugging.\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('1/0')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('aa = 10')\nassert 'aa = 10' in control.toPlainText()\nassert shell.get_value('aa') == 10\nshell.set_value('aa', 20)\nqtbot.waitUntil(lambda : shell.get_value('aa') == 20)\nassert shell.get_value('aa') == 20\nshell.copy_value('aa', 'bb')\nqtbot.waitUntil(lambda : shell.get_value('bb') == 20)\nassert shell.get_value('bb') == 20\nshell.remove_value('aa')\ndef is_defined(val):\n    try:\n        shell.get_value(val)\n        return True\n    except KeyError:\n        return False\nqtbot.waitUntil(lambda : not is_defined('aa'))\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('aa')\nassert \"*** NameError: name 'aa' is not defined\" in control.toPlainText()\npytest.mark.no_xvfbpytest.mark.skipif(os.environ.get('CI', None) is not None and os.name ==\n    'nt', reason='It times out on AppVeyor.')pytest.mark.skipif(PY2, reason='It times out in Python 2.')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "is_defined",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "try:\n    shell.get_value(val)\n    return True\nexcept KeyError:\n    return False\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"Cell content change\"\"\"\nif not index.isValid() or self.readonly:\n    return False\ni = index.row()\nj = index.column()\nvalue = from_qvariant(value, str)\ndtype = self._data.dtype.name\nif dtype == 'bool':\n    try:\n        val = bool(float(value))\n    except ValueError:\n        val = value.lower() == 'true'\nelif dtype.startswith('string') or dtype.startswith('bytes'):\n    val = to_binary_string(value, 'utf8')\nelif dtype.startswith('unicode') or dtype.startswith('str'):\n    val = to_text_string(value)\nelse:\n    if value.lower().startswith('e') or value.lower().endswith('e'):\n        return False\n    try:\n        val = complex(value)\n        if not val.imag:\n            val = val.real\n    except ValueError as e:\n        QMessageBox.critical(self.dialog, 'Error', 'Value error: %s' % str(e))\n        return False\ntry:\n    self.test_array[0] = val\nexcept OverflowError as e:\n    print('OverflowError: ' + str(e))\n    QMessageBox.critical(self.dialog, 'Error', 'Overflow error: %s' % str(e))\n    return False\nself.changes[i, j] = val\nself.dataChanged.emit(index, index)\nif not is_string(val):\n    val = self.color_func(val)\n    if val > self.vmax:\n        self.vmax = val\n    if val < self.vmin:\n        self.vmin = val\nreturn True\n",
        "CUT_4": "\"\"\"Cell content change\"\"\"\nif not index.isValid() or self.readonly:\n    return False\ni = index.row()\nj = index.column()\nvalue = from_qvariant(value, str)\ndtype = self._data.dtype.name\nif dtype == 'bool':\n    try:\n        val = bool(float(value))\n    except ValueError:\n        val = value.lower() == 'true'\nelif dtype.startswith('string') or dtype.startswith('bytes'):\n    val = to_binary_string(value, 'utf8')\nelif dtype.startswith('unicode') or dtype.startswith('str'):\n    val = to_text_string(value)\nelse:\n    if value.lower().startswith('e') or value.lower().endswith('e'):\n        return False\n    try:\n        val = complex(value)\n        if not val.imag:\n            val = val.real\n    except ValueError as e:\n        QMessageBox.critical(self.dialog, 'Error', 'Value error: %s' % str(e))\n        return False\ntry:\n    self.test_array[0] = val\nexcept OverflowError as e:\n    print('OverflowError: ' + str(e))\n    QMessageBox.critical(self.dialog, 'Error', 'Overflow error: %s' % str(e))\n    return False\nself.changes[i, j] = val\nself.dataChanged.emit(index, index)\nif not is_string(val):\n    val = self.color_func(val)\n    if val > self.vmax:\n        self.vmax = val\n    if val < self.vmin:\n        self.vmin = val\nreturn True\n",
        "CUT_5": "\"\"\"\n    Extract a value from a Matlab file\n\n    From the oct2py project, see\n    https://pythonhosted.org/oct2py/conversions.html\n    \"\"\"\nimport numpy as np\nif isinstance(val, list):\n    return [get_matlab_value(v) for v in val]\nif not isinstance(val, np.ndarray):\n    return val\nif hasattr(val, 'classname'):\n    out = dict()\n    for name in val.dtype.names:\n        out[name] = get_matlab_value(val[name].squeeze().tolist())\n    cls = type(val.classname, (object,), out)\n    return cls()\nelif val.dtype.names:\n    out = MatlabStruct()\n    for name in val.dtype.names:\n        out[name] = get_matlab_value(val[name].squeeze().tolist())\n    val = out\nelif val.dtype.kind == 'O':\n    val = val.squeeze().tolist()\n    if not isinstance(val, list):\n        val = [val]\n    val = get_matlab_value(val)\nelif val.size == 1:\n    val = val.item()\nelif val.size == 0:\n    if val.dtype.kind in 'US':\n        val = ''\n    else:\n        val = []\nreturn val\n"
    },
    {
        "functionName": "test_execute_events_dbg",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test execute events while debugging\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import matplotlib.pyplot as plt')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('1/0')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug')\nCONF.set('ipython_console', 'pdb_execute_events', True)\nshell.set_pdb_execute_events(True)\nqtbot.keyClicks(control, 'plt.plot(range(10))')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nassert shell._control.toHtml().count('img src') == 1\nCONF.set('ipython_console', 'pdb_execute_events', False)\nshell.set_pdb_execute_events(False)\nqtbot.keyClicks(control, 'plt.plot(range(10))')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nassert shell._control.toHtml().count('img src') == 1\nqtbot.keyClicks(control, 'plt.show()')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nassert shell._control.toHtml().count('img src') == 2\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_run_doctest",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that doctests can be run without problems\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncode = dedent(\n    \"\"\"\n    def add(x, y):\n        \"\"\\\"\n        >>> add(1, 2)\n        3\n        >>> add(5.1, 2.2)\n        7.3\n        \"\"\\\"\n        return x + y\n    \"\"\"\n    )\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(code)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import doctest')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('doctest.testmod()')\nassert 'TestResults(failed=0, attempted=2)' in shell._control.toPlainText()\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_mpl_backend_change",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that Matplotlib backend is changed correctly when\n    using the %matplotlib magic\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import matplotlib.pyplot as plt')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('plt.plot(range(10))')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%matplotlib tk')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('plt.plot(range(10))')\nassert shell._control.toHtml().count('img src') == 1\npytest.mark.skipif(os.name == 'nt' or PY2 and PYQT5, reason=\n    'It times out frequently')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_ctrl_c_dbg",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that Ctrl+C works while debugging\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('1/0')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug')\nqtbot.keyClick(control, Qt.Key_C, modifier=Qt.ControlModifier)\nqtbot.waitUntil(lambda : \n    'For copying text while debugging, use Ctrl+Shift+C' in control.\n    toPlainText(), timeout=2000)\nassert 'For copying text while debugging, use Ctrl+Shift+C' in control.toPlainText(\n    )\npytest.mark.skipif(os.environ.get('CI', None) is not None or PYQT5, reason=\n    'It fails frequently in PyQt5 and our CIs')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_clear_and_reset_magics_dbg",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that clear and reset magics are working while debugging\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('1/0')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug')\nshell.clear_console()\nqtbot.waitUntil(lambda : '\\nIPdb [2]: ' == control.toPlainText())\nqtbot.keyClicks(control, 'bb = 10')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nassert shell.get_value('bb') == 10\nshell.reset_namespace()\nqtbot.wait(1000)\nqtbot.keyClicks(control, 'bb')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nassert \"*** NameError: name 'bb' is not defined\" in control.toPlainText()\npytest.mark.skipif(os.name == 'nt', reason=\"It doesn't work on Windows\")",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_restart_kernel",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that kernel is restarted correctly\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 10')\nshell._prompt_html = None\nipyconsole.restart_kernel()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nassert 'Restarting kernel...' in shell._control.toPlainText()\nassert not shell.is_defined('a')\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_load_kernel_file_from_id",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that a new client is created using its id\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nclient = ipyconsole.get_current_client()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nconnection_file = osp.basename(client.connection_file)\nid_ = connection_file.split('kernel-')[-1].split('.json')[0]\nipyconsole._create_client_for_kernel(id_, None, None, None)\nqtbot.waitUntil(lambda : len(ipyconsole.get_clients()) == 2)\nnew_client = ipyconsole.get_clients()[1]\nassert new_client.id_ == dict(int_id='1', str_id='B')\n",
        "CUT_1": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_changed.connect(self.set_shellwidget)\nipyconsole.sig_shellwidget_process_started.connect(self.add_shellwidget)\nipyconsole.sig_shellwidget_process_finished.connect(self.remove_shellwidget)\nself.get_widget().sig_figure_loaded.connect(lambda : self.switch_to_plugin(\n    force_focus=False))\n",
        "CUT_2": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_changed.connect(self.set_shellwidget)\nipyconsole.sig_shellwidget_process_started.connect(self.add_shellwidget)\nipyconsole.sig_shellwidget_process_finished.connect(self.remove_shellwidget)\nself.get_widget().sig_figure_loaded.connect(lambda : self.switch_to_plugin(\n    force_focus=False))\n",
        "CUT_3": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_id_changed.disconnect(self.set_shellwidget_from_id)\nipyconsole.sig_shellwidget_process_started.disconnect(self.add_shellwidget)\nipyconsole.sig_shellwidget_id_process_finished.disconnect(self.\n    remove_shellwidget_from_id)\n",
        "CUT_4": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_id_changed.disconnect(self.set_shellwidget_from_id)\nipyconsole.sig_shellwidget_process_started.disconnect(self.add_shellwidget)\nipyconsole.sig_shellwidget_id_process_finished.disconnect(self.\n    remove_shellwidget_from_id)\n",
        "CUT_5": "\"\"\"Get kernel id\"\"\"\nif self.connection_file is not None:\n    json_file = osp.basename(self.connection_file)\n    return json_file.split('.json')[0]\nproperty"
    },
    {
        "functionName": "test_load_kernel_file_from_location",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that a new client is created using a connection file\n    placed in a different location from jupyter_runtime_dir\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nclient = ipyconsole.get_current_client()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nfname = osp.basename(client.connection_file)\nconnection_file = to_text_string(tmpdir.join(fname))\nshutil.copy2(client.connection_file, connection_file)\nipyconsole._create_client_for_kernel(connection_file, None, None, None)\nqtbot.waitUntil(lambda : len(ipyconsole.get_clients()) == 2)\nassert len(ipyconsole.get_clients()) == 2\n",
        "CUT_1": "\"\"\"Get kernel id\"\"\"\nif self.connection_file is not None:\n    json_file = osp.basename(self.connection_file)\n    return json_file.split('.json')[0]\nproperty",
        "CUT_2": "\"\"\"Get kernel id\"\"\"\nif self.connection_file is not None:\n    json_file = osp.basename(self.connection_file)\n    return json_file.split('.json')[0]\nproperty",
        "CUT_3": "\"\"\"\n        Get all other clients that are connected to the same kernel as `client`\n        \"\"\"\nrelated_clients = []\nfor cl in self.get_clients():\n    if cl.connection_file == client.connection_file and cl is not client:\n        related_clients.append(cl)\nreturn related_clients\n",
        "CUT_4": "\"\"\"\n        Get all other clients that are connected to the same kernel as `client`\n        \"\"\"\nrelated_clients = []\nfor cl in self.get_clients():\n    if cl.connection_file == client.connection_file and cl is not client:\n        related_clients.append(cl)\nreturn related_clients\n",
        "CUT_5": "try:\n    cf_path = osp.dirname(connection_file)\n    cf_filename = osp.basename(connection_file)\n    cf_path = cf_path if cf_path else None\n    connection_file = find_connection_file(filename=cf_filename, path=cf_path)\nexcept (IOError, UnboundLocalError):\n    QMessageBox.critical(self, _('IPython'), _(\n        'Unable to connect to <b>%s</b>') % connection_file)\n    return\nmaster_id = None\ngiven_name = None\nexternal_kernel = False\nslave_ord = ord('A') - 1\nkernel_manager = None\nfor cl in self.get_clients():\n    if connection_file in cl.connection_file:\n        if cl.get_kernel() is not None:\n            kernel_manager = cl.get_kernel()\n        connection_file = cl.connection_file\n        if master_id is None:\n            master_id = cl.id_['int_id']\n        given_name = cl.given_name\n        new_slave_ord = ord(cl.id_['str_id'])\n        if new_slave_ord > slave_ord:\n            slave_ord = new_slave_ord\nif master_id is None:\n    self.master_clients += 1\n    master_id = to_text_string(self.master_clients)\n    external_kernel = True\nclient_id = dict(int_id=master_id, str_id=chr(slave_ord + 1))\nshow_elapsed_time = self.get_option('show_elapsed_time')\nreset_warning = self.get_option('show_reset_namespace_warning')\nask_before_restart = self.get_option('ask_before_restart')\nclient = ClientWidget(self, id_=client_id, given_name=given_name,\n    history_filename=get_conf_path('history.py'), config_options=self.\n    config_options(), additional_options=self.additional_options(),\n    interpreter_versions=self.interpreter_versions(), connection_file=\n    connection_file, menu_actions=self.menu_actions, hostname=hostname,\n    external_kernel=external_kernel, slave=True, show_elapsed_time=\n    show_elapsed_time, reset_warning=reset_warning, ask_before_restart=\n    ask_before_restart, css_path=self.css_path)\nif self.test_dir is not None:\n    client.stderr_dir = self.test_dir\nkernel_client = QtKernelClient(connection_file=connection_file)\ntry:\n    kernel_client.load_connection_file()\nexcept Exception as e:\n    QMessageBox.critical(self, _('Connection error'), _(\n        \"\"\"An error occurred while trying to load the kernel connection file. The error was:\n\n\"\"\"\n        ) + to_text_string(e))\n    return\nif hostname is not None:\n    try:\n        connection_info = dict(ip=kernel_client.ip, shell_port=\n            kernel_client.shell_port, iopub_port=kernel_client.iopub_port,\n            stdin_port=kernel_client.stdin_port, hb_port=kernel_client.hb_port)\n        newports = self.tunnel_to_kernel(connection_info, hostname, sshkey,\n            password)\n        (kernel_client.shell_port, kernel_client.iopub_port, kernel_client.\n            stdin_port, kernel_client.hb_port) = newports\n    except Exception as e:\n        QMessageBox.critical(self, _('Connection error'), _(\n            \"\"\"Could not open ssh tunnel. The error was:\n\n\"\"\") +\n            to_text_string(e))\n        return\nkernel_client.start_channels()\nshellwidget = client.shellwidget\nshellwidget.set_kernel_client_and_manager(kernel_client, kernel_manager)\nshellwidget.sig_exception_occurred.connect(self.main.console.handle_exception)\nif external_kernel:\n    shellwidget.sig_is_spykernel.connect(self.connect_external_kernel)\n    shellwidget.is_spyder_kernel()\nif not external_kernel:\n    self.set_elapsed_time(client)\nself.add_tab(client, name=client.get_name())\nself.register_client(client)\n"
    },
    {
        "functionName": "test_load_kernel_file",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that a new client is created using the connection file\n    of an existing client\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nclient = ipyconsole.get_current_client()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nipyconsole._create_client_for_kernel(client.connection_file, None, None, None)\nqtbot.waitUntil(lambda : len(ipyconsole.get_clients()) == 2)\nnew_client = ipyconsole.get_clients()[1]\nnew_shell = new_client.shellwidget\nqtbot.waitUntil(lambda : new_shell._prompt_html is not None, timeout=\n    SHELL_TIMEOUT)\nwith qtbot.waitSignal(new_shell.executed):\n    new_shell.execute('a = 10')\nassert new_client.id_ == dict(int_id='1', str_id='B')\nassert shell.get_value('a') == new_shell.get_value('a')\n",
        "CUT_1": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_2": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_3": "\"\"\"Update path on consoles.\"\"\"\nfor client in self.get_clients():\n    shell = client.shellwidget\n    if shell is not None:\n        self.main.get_spyder_pythonpath()\n        shell.update_syspath(path_dict, new_path_dict)\n",
        "CUT_4": "\"\"\"Update path on consoles.\"\"\"\nfor client in self.get_clients():\n    shell = client.shellwidget\n    if shell is not None:\n        self.main.get_spyder_pythonpath()\n        shell.update_syspath(path_dict, new_path_dict)\n",
        "CUT_5": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n"
    },
    {
        "functionName": "test_sys_argv_clear",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that sys.argv is cleared up correctly\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import sys; A = sys.argv')\nargv = shell.get_value('A')\nassert argv == ['']\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_set_elapsed_time",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the IPython console elapsed timer is set correctly.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nclient = ipyconsole.get_current_client()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nclient.t0 -= 120\nwith qtbot.waitSignal(client.timer.timeout, timeout=5000):\n    ipyconsole.set_elapsed_time(client)\nassert '00:02:00' in client.time_label.text(\n    ) or '00:02:01' in client.time_label.text()\nwith qtbot.waitSignal(client.timer.timeout, timeout=5000):\n    pass\nassert '00:02:01' in client.time_label.text(\n    ) or '00:02:02' in client.time_label.text()\nclient.t0 += 2000\nwith qtbot.waitSignal(client.timer.timeout, timeout=5000):\n    pass\nassert '00:00:00' in client.time_label.text()\nclient.timer.timeout.disconnect(client.show_time)\npytest.mark.skipif(os.name == 'nt', reason='Fails on Windows')",
        "CUT_1": "\"\"\"Set elapsed time for slave clients.\"\"\"\nrelated_clients = self.get_related_clients(client)\nfor cl in related_clients:\n    if cl.timer is not None:\n        client.create_time_label()\n        client.t0 = cl.t0\n        client.timer.timeout.connect(client.show_time)\n        client.timer.start(1000)\n        break\n",
        "CUT_2": "\"\"\"Set elapsed time for slave clients.\"\"\"\nrelated_clients = self.get_related_clients(client)\nfor cl in related_clients:\n    if cl.timer is not None:\n        client.create_time_label()\n        client.t0 = cl.t0\n        client.timer.timeout.connect(client.show_time)\n        client.timer.start(1000)\n        break\n",
        "CUT_3": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_4": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_5": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n"
    },
    {
        "functionName": "test_stderr_file_is_removed_one_kernel",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that consoles removes stderr when client is closed.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nclient = ipyconsole.get_current_client()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nmonkeypatch.setattr(QMessageBox, 'question', classmethod(lambda *args:\n    QMessageBox.Yes))\nassert osp.exists(client.stderr_file)\nipyconsole.close_client(client=client)\nassert not osp.exists(client.stderr_file)\npytest.mark.skipif(os.name == 'nt', reason=\"Doesn't work on Windows\")",
        "CUT_1": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_2": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_3": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_4": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_5": "\"\"\"Restart kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.restart_kernel()\n"
    },
    {
        "functionName": "test_stderr_file_is_removed_two_kernels",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that console removes stderr when client and related clients\n    are closed.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nclient = ipyconsole.get_current_client()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nipyconsole._create_client_for_kernel(client.connection_file, None, None, None)\nassert len(ipyconsole.get_related_clients(client)) == 1\nother_client = ipyconsole.get_related_clients(client)[0]\nassert client.stderr_file == other_client.stderr_file\nmonkeypatch.setattr(QMessageBox, 'question', classmethod(lambda *args:\n    QMessageBox.Yes))\nassert osp.exists(client.stderr_file)\nipyconsole.close_client(client=client)\nassert not osp.exists(client.stderr_file)\npytest.mark.skipif(os.name == 'nt', reason=\"Doesn't work on Windows\")",
        "CUT_1": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_2": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_3": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_4": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_5": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n"
    },
    {
        "functionName": "test_stderr_file_remains_two_kernels",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that console doesn't remove stderr when a related client is not\n    closed.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nclient = ipyconsole.get_current_client()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nipyconsole._create_client_for_kernel(client.connection_file, None, None, None)\nassert len(ipyconsole.get_related_clients(client)) == 1\nother_client = ipyconsole.get_related_clients(client)[0]\nassert client.stderr_file == other_client.stderr_file\nmonkeypatch.setattr(QMessageBox, 'question', classmethod(lambda *args:\n    QMessageBox.No))\nassert osp.exists(client.stderr_file)\nipyconsole.close_client(client=client)\nassert osp.exists(client.stderr_file)\npytest.mark.skipif(os.name == 'nt', reason=\"Doesn't work on Windows\")",
        "CUT_1": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_2": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_3": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_4": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_5": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n"
    },
    {
        "functionName": "test_kernel_crash",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that we show an error message when a kernel crash occurs.\"\"\"\nipy_kernel_cfg = osp.join(get_ipython_dir(), 'profile_default',\n    'ipython_kernel_config.py')\nwith open(ipy_kernel_cfg, 'w') as f:\n    f.write('c.InteractiveShellApp.extra_extension = 1')\nipyconsole.create_new_client()\nqtbot.waitUntil(lambda : ipyconsole.get_clients()[-1].is_error_shown,\n    timeout=6000)\nerror_client = ipyconsole.get_clients()[-1]\nassert error_client.is_error_shown\nwebview = error_client.infowidget\nif WEBENGINE:\n    webpage = webview.page()\nelse:\n    webpage = webview.page().mainFrame()\nqtbot.waitUntil(lambda : check_text(webpage, 'Bad config encountered'),\n    timeout=6000)\nos.remove(ipy_kernel_cfg)\n",
        "CUT_1": "QWidget.__init__(self, parent)\nself.webview = FrameWebView(self)\nself.webview.setup()\nif WEBENGINE:\n    self.webview.web_widget.page().setBackgroundColor(QColor(MAIN_BG_COLOR))\nelse:\n    self.webview.web_widget.setStyleSheet('background:{}'.format(MAIN_BG_COLOR)\n        )\n    self.viewview.page().setLinkDelegationPolicy(QWebEnginePage.\n        DelegateAllLinks)\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview.web_widget)\nself.find_widget.hide()\nlayout = QVBoxLayout()\nlayout.setContentsMargins(0, 0, 0, 0)\nlayout.addWidget(self.webview)\nlayout.addWidget(self.find_widget)\nself.setLayout(layout)\nself.webview.linkClicked.connect(self.sig_link_clicked)\n",
        "CUT_2": "QWidget.__init__(self, parent)\nself.webview = FrameWebView(self)\nself.webview.setup()\nif WEBENGINE:\n    self.webview.web_widget.page().setBackgroundColor(QColor(MAIN_BG_COLOR))\nelse:\n    self.webview.web_widget.setStyleSheet('background:{}'.format(MAIN_BG_COLOR)\n        )\n    self.viewview.page().setLinkDelegationPolicy(QWebEnginePage.\n        DelegateAllLinks)\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview.web_widget)\nself.find_widget.hide()\nlayout = QVBoxLayout()\nlayout.setContentsMargins(0, 0, 0, 0)\nlayout.addWidget(self.webview)\nlayout.addWidget(self.find_widget)\nself.setLayout(layout)\nself.webview.linkClicked.connect(self.sig_link_clicked)\n",
        "CUT_3": "super().__init__(name, plugin, parent=parent, options=options)\nself._is_running = False\nself.home_url = None\nself.server = None\nself.label = QLabel(_('Package:'))\nself.url_combo = UrlComboBox(self)\nself.webview = WebView(self, handle_links=self.get_option('handle_links'))\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview)\nself.find_widget.hide()\nself.url_combo.setMaxCount(self.get_option('max_history_entries'))\ntip = _('Write a package name here, e.g. pandas')\nself.url_combo.lineEdit().setPlaceholderText(tip)\nself.url_combo.lineEdit().setToolTip(tip)\nself.webview.setup()\nself.webview.set_zoom_factor(self.get_option('zoom_factor'))\nspacing = 10\nlayout = QVBoxLayout()\nlayout.addWidget(self.webview)\nlayout.addSpacing(spacing)\nlayout.addWidget(self.find_widget)\nlayout.addSpacing(int(spacing / 2))\nself.setLayout(layout)\nself.url_combo.valid.connect(lambda x: self._handle_url_combo_activation())\nself.webview.loadStarted.connect(self._start)\nself.webview.loadFinished.connect(self._finish)\nself.webview.titleChanged.connect(self.setWindowTitle)\nself.webview.urlChanged.connect(self._change_url)\nif not WEBENGINE:\n    self.webview.iconChanged.connect(self._handle_icon_change)\n",
        "CUT_4": "super().__init__(name, plugin, parent=parent, options=options)\nself._is_running = False\nself.home_url = None\nself.server = None\nself.label = QLabel(_('Package:'))\nself.url_combo = UrlComboBox(self)\nself.webview = WebView(self, handle_links=self.get_option('handle_links'))\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview)\nself.find_widget.hide()\nself.url_combo.setMaxCount(self.get_option('max_history_entries'))\ntip = _('Write a package name here, e.g. pandas')\nself.url_combo.lineEdit().setPlaceholderText(tip)\nself.url_combo.lineEdit().setToolTip(tip)\nself.webview.setup()\nself.webview.set_zoom_factor(self.get_option('zoom_factor'))\nspacing = 10\nlayout = QVBoxLayout()\nlayout.addWidget(self.webview)\nlayout.addSpacing(spacing)\nlayout.addWidget(self.find_widget)\nlayout.addSpacing(int(spacing / 2))\nself.setLayout(layout)\nself.url_combo.valid.connect(lambda x: self._handle_url_combo_activation())\nself.webview.loadStarted.connect(self._start)\nself.webview.loadFinished.connect(self._finish)\nself.webview.titleChanged.connect(self.setWindowTitle)\nself.webview.urlChanged.connect(self._change_url)\nif not WEBENGINE:\n    self.webview.iconChanged.connect(self._handle_icon_change)\n",
        "CUT_5": "if not ok:\n    self.webview.setHtml(_('Unable to load page'))\n"
    },
    {
        "functionName": "test_remove_old_stderr_files",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that we are removing old stderr files.\"\"\"\ntmpdir = get_temp_dir()\nopen(osp.join(tmpdir, 'foo.stderr'), 'a').close()\nipyconsole._remove_old_stderr_files()\nassert not osp.isfile(osp.join(tmpdir, 'foo.stderr'))\npytest.mark.skipif(not os.name == 'nt', reason='Only works on Windows')",
        "CUT_1": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_2": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_3": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Get the contents of the stderr kernel file.\"\"\"\ntry:\n    stderr = self._read_stderr()\nexcept Exception:\n    stderr = None\nreturn stderr\n",
        "CUT_5": "\"\"\"Get the contents of the stderr kernel file.\"\"\"\ntry:\n    stderr = self._read_stderr()\nexcept Exception:\n    stderr = None\nreturn stderr\n"
    },
    {
        "functionName": "test_console_working_directory",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test for checking the working directory.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('import os; cwd = os.getcwd()')\ncurrent_wdir = shell.get_value('cwd')\nfolders = osp.split(current_wdir)\nassert folders[-1] == NEW_DIR\npytest.mark.use_startup_wdir",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_console_complete",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test for checking the working directory.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\ndef check_value(name, value):\n    try:\n        return shell.get_value(name) == value\n    except KeyError:\n        return False\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('cbs = 1')\nqtbot.waitUntil(lambda : check_value('cbs', 1))\nqtbot.wait(500)\nqtbot.keyClicks(control, 'cb')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == 'cbs',\n    timeout=6000)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('cbba = 1')\nqtbot.waitUntil(lambda : check_value('cbba', 1))\nqtbot.keyClicks(control, 'cb')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(shell._completion_widget.isVisible)\nassert control.toPlainText().split()[-1] == 'cb'\nqtbot.keyClick(shell._completion_widget, Qt.Key_Enter)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == 'cbba')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('1/0')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug')\nqtbot.keyClicks(control, 'ab')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == 'abs')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.keyClicks(control, 'print(ab')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == 'print(abs')\nqtbot.keyClicks(control, ')')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.keyClicks(control, 'baab = 10')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.wait(100)\nqtbot.waitUntil(lambda : check_value('baab', 10))\nqtbot.keyClicks(control, 'baa')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == 'baab')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.keyClicks(control, 'abba = 10')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.wait(100)\nqtbot.waitUntil(lambda : check_value('abba', 10))\nqtbot.keyClicks(control, 'ab')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(shell._completion_widget.isVisible)\nassert control.toPlainText().split()[-1] == 'ab'\nqtbot.keyClick(shell._completion_widget, Qt.Key_Enter)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == 'abba')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.keyClicks(control, 'class A(): baba = 1')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.wait(100)\nqtbot.waitUntil(lambda : shell.is_defined('A'))\nqtbot.keyClicks(control, 'a = A()')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.wait(100)\nqtbot.waitUntil(lambda : shell.is_defined('a'))\nqtbot.keyClicks(control, 'a.ba')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == 'a.baba')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.keyClicks(control, '!longl')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == '!longlist')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\ntest_file = tmpdir.join('test.py')\ntest_file.write('stuff\\n')\nqtbot.keyClicks(control, '!b ' + str(test_file) + ':1')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.keyClicks(control, '!ignore ')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == '1')\npytest.mark.skipif(not sys.platform.startswith('linux') or PY2, reason=\n    'It only works on Linux with python 3.')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "check_value",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "try:\n    return shell.get_value(name) == value\nexcept KeyError:\n    return False\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"Get the value of a variable\"\"\"\nvalue = self.shellwidget.get_value(name)\nreturn value\n",
        "CUT_4": "\"\"\"Get the value of a variable\"\"\"\nvalue = self.shellwidget.get_value(name)\nreturn value\n",
        "CUT_5": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n"
    },
    {
        "functionName": "test_pdb_multiline",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test entering a multiline statment into pdb\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug print()')\nassert '\\nIPdb [' in control.toPlainText()\nqtbot.keyClicks(control, 'if True:')\nqtbot.keyClick(control, Qt.Key_Enter)\nqtbot.wait(500)\nqtbot.keyClicks(control, 'bb = 10')\nqtbot.keyClick(control, Qt.Key_Enter)\nqtbot.wait(500)\nqtbot.keyClick(control, Qt.Key_Enter)\nqtbot.wait(500)\nassert shell.get_value('bb') == 10\nassert \"\"\"if True:\n   ...:     bb = 10\n\"\"\" in control.toPlainText()\npytest.mark.use_startup_wdir",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_pdb_ignore_lib",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that pdb can avoid closed files.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nCONF.set('ipython_console', 'pdb_ignore_lib', not show_lib)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug print()')\nqtbot.keyClicks(control, '!s')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nqtbot.wait(500)\nqtbot.keyClicks(control, '!q')\nwith qtbot.waitSignal(shell.executed):\n    qtbot.keyClick(control, Qt.Key_Enter)\nif show_lib:\n    assert 'iostream.py' in control.toPlainText()\nelse:\n    assert 'iostream.py' not in control.toPlainText()\nCONF.set('ipython_console', 'pdb_ignore_lib', True)\npytest.mark.parametrize('show_lib', [True, False])",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "return self.shell\n"
    },
    {
        "functionName": "test_calltip",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test Calltip.\n\n    See spyder-ide/spyder#10842\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = {\"a\": 1}')\nqtbot.keyClicks(control, 'a.keys(', delay=100)\nqtbot.wait(1000)\nassert control.calltip_widget.isVisible()\npytest.mark.skipif(sys.platform == 'darwin', reason='Times out on macOS')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n"
    },
    {
        "functionName": "test_conda_env_activation",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the conda environment associated with an external interpreter\n    is activated before a kernel is created for it.\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\"import os; conda_prefix = os.environ.get('CONDA_PREFIX')\")\nexpected_output = get_conda_test_env().replace('\\\\', '/')\nif is_conda_env(expected_output):\n    output = shell.get_value('conda_prefix').replace('\\\\', '/')\n    assert expected_output == output\npytest.mark.firstpytest.mark.test_environment_interpreter",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_kernel_kill",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the kernel correctly restarts after a kill.\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nqtbot.wait(3000)\ncrash_string = 'import os, signal; os.kill(os.getpid(), signal.SIGTERM)'\nold_open_comms = list(shell.spyder_kernel_comm._comms.keys())\nassert len(old_open_comms) == 1\nwith qtbot.waitSignal(shell.sig_prompt_ready, timeout=30000):\n    shell.execute(crash_string)\nassert crash_string in shell._control.toPlainText()\nassert 'Restarting kernel...' in shell._control.toPlainText()\nnew_open_comms = list(shell.spyder_kernel_comm._comms.keys())\nassert len(new_open_comms) == 1\nassert old_open_comms[0] != new_open_comms[0]\nqtbot.waitUntil(lambda : shell.spyder_kernel_comm._comms[new_open_comms[0]]\n    ['status'] == 'ready')\nassert shell.spyder_kernel_comm._comms[new_open_comms[0]]['status'] == 'ready'\npytest.mark.skipif(os.name == 'nt', reason='no SIGTERM on Windows')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_wrong_std_module",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that a file with the same name of a standard library module in\n    the current working directory doesn't break the console.\n    \"\"\"\nif spyder_pythonpath:\n    wrong_random_mod = tmpdir.join('random.py')\n    wrong_random_mod.write('')\n    wrong_random_mod = str(wrong_random_mod)\n    CONF.set('main', 'spyder_pythonpath', [str(tmpdir)])\nelse:\n    wrong_random_mod = osp.join(os.getcwd(), 'random.py')\n    with open(wrong_random_mod, 'w') as f:\n        f.write('')\nipyconsole.create_new_client()\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nif spyder_pythonpath:\n    check_sys_path = \"import sys; path_added = r'{}' in sys.path\".format(str\n        (tmpdir))\n    with qtbot.waitSignal(shell.sig_prompt_ready, timeout=30000):\n        shell.execute(check_sys_path)\n    assert shell.get_value('path_added')\nos.remove(wrong_random_mod)\nCONF.set('main', 'spyder_pythonpath', [])\npytest.mark.parametrize('spyder_pythonpath', [True, False])",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_kernel_restart_after_manual_restart_and_crash",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the kernel restarts correctly after being restarted\n    manually and then it crashes.\n\n    This is a regresion for spyder-ide/spyder#12972.\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nshell._prompt_html = None\nipyconsole.restart_kernel()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nqtbot.wait(3000)\ncrash_string = 'import os, signal; os.kill(os.getpid(), signal.SIGTERM)'\nwith qtbot.waitSignal(shell.sig_prompt_ready, timeout=30000):\n    shell.execute(crash_string)\nassert crash_string in shell._control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a = 10')\nassert shell.is_defined('a')\nopen_comms = list(shell.spyder_kernel_comm._comms.keys())\nqtbot.waitUntil(lambda : shell.spyder_kernel_comm._comms[open_comms[0]][\n    'status'] == 'ready')\npytest.mark.skipif(os.name == 'nt', reason='no SIGTERM on Windows')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_stderr_poll",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test if the content of stderr is printed to the console.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\nclient = ipyconsole.get_current_client()\nwith open(client.stderr_file, 'w') as f:\n    f.write('test_test')\nqtbot.wait(2000)\nassert 'test_test' in ipyconsole.get_focus_widget().toPlainText()\n",
        "CUT_1": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_2": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_3": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_changed.connect(self.set_shellwidget)\nipyconsole.sig_shellwidget_process_started.connect(self.add_shellwidget)\nipyconsole.sig_shellwidget_process_finished.connect(self.remove_shellwidget)\nself.get_widget().sig_figure_loaded.connect(lambda : self.switch_to_plugin(\n    force_focus=False))\n",
        "CUT_4": "ipyconsole = self.get_plugin(Plugins.IPythonConsole)\nipyconsole.sig_shellwidget_changed.connect(self.set_shellwidget)\nipyconsole.sig_shellwidget_process_started.connect(self.add_shellwidget)\nipyconsole.sig_shellwidget_process_finished.connect(self.remove_shellwidget)\nself.get_widget().sig_figure_loaded.connect(lambda : self.switch_to_plugin(\n    force_focus=False))\n",
        "CUT_5": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n"
    },
    {
        "functionName": "test_startup_code_pdb",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that startup code for pdb works.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\nCONF.set('ipython_console', 'startup/pdb_run_lines',\n    'abba = 12; print(\"Hello\")')\nshell.execute('%debug print()')\nqtbot.waitUntil(lambda : 'Hello' in control.toPlainText())\nassert shell.get_value('abba') == 12\nCONF.set('ipython_console', 'startup/pdb_run_lines', '')\npytest.mark.slowpytest.mark.use_startup_wdir",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_pdb_eventloop",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Check if pdb works with every backend. (only testing 3).\"\"\"\nif backend == 'tk' and (os.name == 'nt' or PY2):\n    return\nif backend == 'osx' and (sys.platform != 'darwin' or PY2):\n    return\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%matplotlib ' + backend)\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug print()')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute(\"print('Two: ' + str(1+1))\")\nassert 'Two: 2' in control.toPlainText()\npytest.mark.parametrize('backend', ['inline', 'qt5', 'tk', 'osx'])",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_pdb_without_comm",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Check if pdb works without comm.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('get_ipython().kernel.frontend_comm.close()')\nshell.execute('%debug print()')\nqtbot.waitUntil(lambda : shell._control.toPlainText().split()[-1] == 'ipdb>')\nqtbot.keyClicks(control, \"print('Two: ' + str(1+1))\")\nqtbot.keyClick(control, Qt.Key_Enter)\nqtbot.waitUntil(lambda : shell._control.toPlainText().split()[-1] == 'ipdb>')\nassert 'Two: 2' in control.toPlainText()\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_recursive_pdb",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Check commands and code are separted.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug print()')\nwith qtbot.waitSignal(shell.executed):\n    shell.pdb_execute('abab = 10')\nwith qtbot.waitSignal(shell.executed):\n    shell.pdb_execute('%debug print()')\nassert \"Please don't use '%debug'\" in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.pdb_execute('!debug print()')\nassert '(IPdb [1]):' in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.pdb_execute('!debug print()')\nassert '((IPdb [1])):' in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.pdb_execute('!quit')\nassert control.toPlainText().split()[-2:] == ['(IPdb', '[1]):']\nqtbot.keyClicks(control, 'aba')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == 'abab',\n    timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.pdb_execute('!quit')\nassert control.toPlainText().split()[-2:] == ['IPdb', '[1]:']\nqtbot.keyClicks(control, 'aba')\nqtbot.keyClick(control, Qt.Key_Tab)\nqtbot.waitUntil(lambda : control.toPlainText().split()[-1] == 'abab',\n    timeout=SHELL_TIMEOUT)\nwith qtbot.waitSignal(shell.executed):\n    shell.pdb_execute('!quit')\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('1 + 1')\nassert control.toPlainText().split()[-2:] == ['In', '[3]:']\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_stop_pdb",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test if we can stop pdb\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\nstop_button = ipyconsole.get_current_client().stop_button\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug print()')\nshell.execute('import time; time.sleep(10)')\nqtbot.wait(500)\nwith qtbot.waitSignal(shell.executed, timeout=1000):\n    qtbot.mouseClick(stop_button, Qt.LeftButton)\nassert 'KeyboardInterrupt' in control.toPlainText()\nassert 'IPdb [2]:' in control.toPlainText()\nassert 'In [2]:' not in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    qtbot.mouseClick(stop_button, Qt.LeftButton)\nassert 'In [2]:' in control.toPlainText()\npytest.mark.skipif(os.name == 'nt', reason=\"Doesn't work on windows\")",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_code_cache",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that code sent to execute is properly cached\n    and that the cache is empited on interrupt.\n    \"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\ncontrol.setFocus()\ndef check_value(name, value):\n    try:\n        return shell.get_value(name) == value\n    except KeyError:\n        return False\nshell.execute('import time; time.sleep(.5)')\nshell.execute('var = 142')\nqtbot.wait(500)\nqtbot.waitUntil(lambda : check_value('var', 142))\nassert shell.get_value('var') == 142\nshell.execute('import time; time.sleep(.5)')\nshell.execute('var = 1000')\nshell.interrupt_kernel()\nqtbot.wait(1000)\nassert shell.get_value('var') == 142\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug print()')\nassert 'IPdb [' in shell._control.toPlainText()\nshell.execute('time.sleep(.5)')\nshell.execute('var = 318')\nqtbot.wait(500)\nqtbot.waitUntil(lambda : check_value('var', 318))\nassert shell.get_value('var') == 318\nshell.execute('import time; time.sleep(.5)')\nshell.execute('var = 1000')\nshell.interrupt_kernel()\nqtbot.wait(1000)\nassert shell.get_value('var') == 318\npytest.mark.skipif(sys.platform == 'nt', reason='Times out on Windows')",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Execute lines and give focus to shell.\n        \"\"\"\nself.shell.execute_lines(to_text_string(lines))\nself.shell.setFocus()\n"
    },
    {
        "functionName": "test_pdb_code_and_cmd_separation",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipythonconsole.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Check commands and code are separted.\"\"\"\nshell = ipyconsole.get_current_shellwidget()\nqtbot.waitUntil(lambda : shell._prompt_html is not None, timeout=SHELL_TIMEOUT)\ncontrol = ipyconsole.get_focus_widget()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('%debug print()')\nassert 'Error' not in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('e')\nassert \"name 'e' is not defined\" in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('!n')\nassert '--Return--' in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('a')\nassert \"*** NameError: name 'a' is not defined\" not in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('abba')\nassert \"name 'abba' is not defined\" in control.toPlainText()\nwith qtbot.waitSignal(shell.executed):\n    shell.execute('!abba')\nassert \"Unknown command 'abba'\" in control.toPlainText()\npytest.mark.skipif(PY2, reason=\"Doesn't work on Python 2.7\")",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_config_dialog",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/tests/test_ipython_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpage = config_dialog.get_page()\nassert configpage\nconfigpage.save_to_conf()\npytest.mark.parametrize('config_dialog', [[MainWindowMock, [], [\n    IPythonConsole]]], indirect=True)",
        "CUT_1": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_2": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_3": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_4": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "kernel",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Console kernel fixture\"\"\"\nkernel = get_kernel()\nkernel.namespace_view_settings = {'check_all': False, 'exclude_private':\n    True, 'exclude_uppercase': True, 'exclude_capitalized': False,\n    'exclude_unsupported': False, 'exclude_callables_and_modules': True,\n    'excluded_names': ['nan', 'inf', 'infty', 'little_endian',\n    'colorbar_doc', 'typecodes', '__builtins__', '__main__', '__doc__',\n    'NaN', 'Inf', 'Infinity', 'sctypes', 'rcParams', 'rcParamsDefault',\n    'sctypeNA', 'typeNA', 'False_', 'True_'], 'minmax': False}\ndef reset_kernel():\n    kernel.do_execute('reset -f', True)\nrequest.addfinalizer(reset_kernel)\nreturn kernel\npytest.fixture",
        "CUT_1": "\"\"\"\n        Register Pdb session after reset.\n        \"\"\"\nsuper(SpyderPdb, self).reset()\nkernel = get_ipython().kernel\nkernel._register_pdb_session(self)\n",
        "CUT_2": "try:\n    sys.path.remove(osp.dirname(__file__))\nexcept ValueError:\n    pass\ntry:\n    locals().pop('__file__')\nexcept KeyError:\n    pass\n__doc__ = ''\n__name__ = '__main__'\nimport_spydercustomize()\nwhile '' in sys.path:\n    sys.path.remove('')\nfrom ipykernel.kernelapp import IPKernelApp\nfrom spyder_kernels.console.kernel import SpyderKernel\nclass SpyderKernelApp(IPKernelApp):\n\n    def init_pdb(self):\n        \"\"\"\n            This method was added in IPykernel 5.3.1 and it replaces\n            the debugger used by the kernel with a new class\n            introduced in IPython 7.15 during kernel's initialization.\n            Therefore, it doesn't allow us to use our debugger.\n            \"\"\"\n        pass\nkernel = SpyderKernelApp.instance()\nkernel.kernel_class = SpyderKernel\ntry:\n    kernel.config = kernel_config()\nexcept:\n    pass\nkernel.initialize()\nkernel.shell.register_magic_function(varexp)\nimport pdb\nkernel.shell.InteractiveTB.debugger_cls = pdb.Pdb\nkernel.start()\n",
        "CUT_3": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_4": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_5": "\"\"\"Determine if the kernel is from Spyder.\"\"\"\ncode = \"getattr(get_ipython().kernel, 'set_value', False)\"\nif self._reading:\n    return\nelse:\n    self.silent_exec_method(code)\n"
    },
    {
        "functionName": "reset_kernel",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "kernel.do_execute('reset -f', True)\n",
        "CUT_1": "\"\"\"\n        Register Pdb session after reset.\n        \"\"\"\nsuper(SpyderPdb, self).reset()\nkernel = get_ipython().kernel\nkernel._register_pdb_session(self)\n",
        "CUT_2": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_3": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_4": "try:\n    sys.path.remove(osp.dirname(__file__))\nexcept ValueError:\n    pass\ntry:\n    locals().pop('__file__')\nexcept KeyError:\n    pass\n__doc__ = ''\n__name__ = '__main__'\nimport_spydercustomize()\nwhile '' in sys.path:\n    sys.path.remove('')\nfrom ipykernel.kernelapp import IPKernelApp\nfrom spyder_kernels.console.kernel import SpyderKernel\nclass SpyderKernelApp(IPKernelApp):\n\n    def init_pdb(self):\n        \"\"\"\n            This method was added in IPykernel 5.3.1 and it replaces\n            the debugger used by the kernel with a new class\n            introduced in IPython 7.15 during kernel's initialization.\n            Therefore, it doesn't allow us to use our debugger.\n            \"\"\"\n        pass\nkernel = SpyderKernelApp.instance()\nkernel.kernel_class = SpyderKernel\ntry:\n    kernel.config = kernel_config()\nexcept:\n    pass\nkernel.initialize()\nkernel.shell.register_magic_function(varexp)\nimport pdb\nkernel.shell.InteractiveTB.debugger_cls = pdb.Pdb\nkernel.start()\n",
        "CUT_5": "\"\"\"Reset to default values of the shortcuts making a confirmation.\"\"\"\nif not force:\n    reset = QMessageBox.warning(self, _('Shortcuts reset'), _(\n        'Do you want to reset to default values?'), QMessageBox.Yes |\n        QMessageBox.No)\n    if reset == QMessageBox.No:\n        return\nself.plugin.reset_shortcuts()\nself.plugin.apply_shortcuts()\nself.table.load_shortcuts()\nself.load_from_conf()\nself.set_modified(False)\n"
    },
    {
        "functionName": "__init__",
        "className": "dummyComm",
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "self.other = None\nself.message_callback = None\nself.close_callback = None\nself.comm_id = 1\n",
        "CUT_1": "QWidget.__init__(self, parent)\nself.shellwidget = None\nself.is_visible = True\nself.setup_in_progress = None\nself.check_all = None\nself.exclude_private = None\nself.exclude_uppercase = None\nself.exclude_capitalized = None\nself.exclude_unsupported = None\nself.exclude_callables_and_modules = None\nself.excluded_names = None\nself.minmax = None\nself.dataframe_format = None\nself.show_callable_attributes = None\nself.show_special_attributes = None\nself.editor = None\nself.exclude_private_action = None\nself.exclude_uppercase_action = None\nself.exclude_capitalized_action = None\nself.exclude_unsupported_action = None\nself.exclude_callables_and_modules_action = None\nself.finder = None\nself.options_button = options_button\nself.actions = None\nself.plugin_actions = plugin_actions\nself.filename = None\n",
        "CUT_2": "QWidget.__init__(self, parent)\nself.shellwidget = None\nself.is_visible = True\nself.setup_in_progress = None\nself.check_all = None\nself.exclude_private = None\nself.exclude_uppercase = None\nself.exclude_capitalized = None\nself.exclude_unsupported = None\nself.exclude_callables_and_modules = None\nself.excluded_names = None\nself.minmax = None\nself.dataframe_format = None\nself.show_callable_attributes = None\nself.show_special_attributes = None\nself.editor = None\nself.exclude_private_action = None\nself.exclude_uppercase_action = None\nself.exclude_capitalized_action = None\nself.exclude_unsupported_action = None\nself.exclude_callables_and_modules_action = None\nself.finder = None\nself.options_button = options_button\nself.actions = None\nself.plugin_actions = plugin_actions\nself.filename = None\n",
        "CUT_3": "self.args = None\nself.args_enabled = None\nself.wdir = None\nself.wdir_enabled = None\nself.current = None\nself.systerm = None\nself.interact = None\nself.post_mortem = None\nself.python_args = None\nself.python_args_enabled = None\nself.clear_namespace = None\nself.console_namespace = None\nself.file_dir = None\nself.cw_dir = None\nself.fixed_dir = None\nself.dir = None\nself.set(CONF.get('run', 'defaultconfiguration', default={}))\n",
        "CUT_4": "self.args = None\nself.args_enabled = None\nself.wdir = None\nself.wdir_enabled = None\nself.current = None\nself.systerm = None\nself.interact = None\nself.post_mortem = None\nself.python_args = None\nself.python_args_enabled = None\nself.clear_namespace = None\nself.console_namespace = None\nself.file_dir = None\nself.cw_dir = None\nself.fixed_dir = None\nself.dir = None\nself.set(CONF.get('run', 'defaultconfiguration', default={}))\n",
        "CUT_5": "QTableView.__init__(self, parent)\nself.array_filename = None\nself.menu = None\nself.empty_ws_menu = None\nself.paste_action = None\nself.copy_action = None\nself.edit_action = None\nself.plot_action = None\nself.hist_action = None\nself.imshow_action = None\nself.save_array_action = None\nself.insert_action = None\nself.insert_action_above = None\nself.insert_action_below = None\nself.remove_action = None\nself.minmax_action = None\nself.rename_action = None\nself.duplicate_action = None\nself.last_regex = ''\nself.view_action = None\nself.delegate = None\nself.proxy_model = None\nself.source_model = None\nself.setAcceptDrops(True)\nself.automatic_column_width = True\nself.setHorizontalHeader(BaseHeaderView(parent=self))\nself.horizontalHeader().sig_user_resized_section.connect(self.\n    user_resize_columns)\n"
    },
    {
        "functionName": "close",
        "className": "dummyComm",
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "self.other.close_callback({'content': {'comm_id': self.comm_id}})\n",
        "CUT_1": "\"\"\"Close comm.\"\"\"\ncomm_id = msg['content']['comm_id']\ndel self._comms[comm_id]\n",
        "CUT_2": "\"\"\"Close the comm and notify the other side.\"\"\"\nid_list = self.get_comm_id_list(comm_id)\nfor comm_id in id_list:\n    self._comms[comm_id]['comm'].close()\n    del self._comms[comm_id]\n",
        "CUT_3": "\"\"\"Close comm.\"\"\"\ncomm_id = msg['content']['comm_id']\ncomm = self._comms[comm_id]['comm']\ncomm._closed = True\ndel self._comms[comm_id]\n",
        "CUT_4": "\"\"\"Call the frontend.\"\"\"\nif broadcast:\n    comm_id = None\nelse:\n    comm_id = self.frontend_comm.calling_comm_id\nreturn self.frontend_comm.remote_call(blocking=blocking, comm_id=comm_id,\n    callback=callback, timeout=timeout)\n",
        "CUT_5": "\"\"\"\n        Publish custom messages to the other side.\n\n        Parameters\n        ----------\n        spyder_msg_type: str\n            The spyder message type\n        content: dict\n            The (JSONable) content of the message\n        data: any\n            Any object that is serializable by cloudpickle (should be most\n            things). Will arrive as cloudpickled bytes in `.buffers[0]`.\n        comm_id: int\n            the comm to send to. If None sends to all comms.\n        \"\"\"\nif not self.is_open(comm_id):\n    raise CommError('The comm is not connected.')\nid_list = self.get_comm_id_list(comm_id)\nfor comm_id in id_list:\n    msg_dict = {'spyder_msg_type': spyder_msg_type, 'content': content,\n        'pickle_protocol': self._comms[comm_id]['pickle_protocol'],\n        'python_version': sys.version}\n    buffers = [cloudpickle.dumps(data, protocol=self._comms[comm_id][\n        'pickle_protocol'])]\n    self._comms[comm_id]['comm'].send(msg_dict, buffers=buffers)\n"
    },
    {
        "functionName": "send",
        "className": "dummyComm",
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "msg = {'buffers': buffers, 'content': {'data': msg_dict, 'comm_id': self.\n    comm_id}}\nself.other.message_callback(msg)\n",
        "CUT_1": "\"\"\"\n        Publish custom messages to the other side.\n\n        Parameters\n        ----------\n        spyder_msg_type: str\n            The spyder message type\n        content: dict\n            The (JSONable) content of the message\n        data: any\n            Any object that is serializable by cloudpickle (should be most\n            things). Will arrive as cloudpickled bytes in `.buffers[0]`.\n        comm_id: int\n            the comm to send to. If None sends to all comms.\n        \"\"\"\nif not self.is_open(comm_id):\n    raise CommError('The comm is not connected.')\nid_list = self.get_comm_id_list(comm_id)\nfor comm_id in id_list:\n    msg_dict = {'spyder_msg_type': spyder_msg_type, 'content': content,\n        'pickle_protocol': self._comms[comm_id]['pickle_protocol'],\n        'python_version': sys.version}\n    buffers = [cloudpickle.dumps(data, protocol=self._comms[comm_id][\n        'pickle_protocol'])]\n    self._comms[comm_id]['comm'].send(msg_dict, buffers=buffers)\n",
        "CUT_2": "\"\"\"Close comm.\"\"\"\ncomm_id = msg['content']['comm_id']\ndel self._comms[comm_id]\n",
        "CUT_3": "\"\"\"\n        Handle internal spyder messages.\n        \"\"\"\nself.calling_comm_id = msg['content']['comm_id']\nmsg_dict = msg['content']['data']\ntry:\n    if PY3:\n        buffer = cloudpickle.loads(msg['buffers'][0], encoding='latin-1')\n    else:\n        buffer = cloudpickle.loads(msg['buffers'][0])\nexcept Exception as e:\n    logger.debug('Exception in cloudpickle.loads : %s' % str(e))\n    buffer = CommsErrorWrapper(msg_dict['content']['call_name'], msg_dict[\n        'content']['call_id'])\n    msg_dict['content']['is_error'] = True\nspyder_msg_type = msg_dict['spyder_msg_type']\nif spyder_msg_type in self._message_handlers:\n    self._message_handlers[spyder_msg_type](msg_dict, buffer)\nelse:\n    logger.debug('No such spyder message type: %s' % spyder_msg_type)\n",
        "CUT_4": "\"\"\"Close comm.\"\"\"\ncomm_id = msg['content']['comm_id']\ncomm = self._comms[comm_id]['comm']\ncomm._closed = True\ndel self._comms[comm_id]\n",
        "CUT_5": "\"\"\"Close the comm and notify the other side.\"\"\"\nid_list = self.get_comm_id_list(comm_id)\nfor comm_id in id_list:\n    self._comms[comm_id]['comm'].close()\n    del self._comms[comm_id]\n"
    },
    {
        "functionName": "on_msg",
        "className": "dummyComm",
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "self.message_callback = callback\n",
        "CUT_1": "self.base.server_activate(self)\nif self.callback:\n    self.callback(self)\n",
        "CUT_2": "self.base.server_activate(self)\nif self.callback:\n    self.callback(self)\n",
        "CUT_3": "\"\"\"\n        Save help text.\n\n        Parameters\n        ----------\n        callback: callable\n            Method to call on save.\n        \"\"\"\nif self.source_is_console():\n    self._last_console_cb = callback\nelse:\n    self._last_editor_cb = callback\n",
        "CUT_4": "\"\"\"\n        Save help text.\n\n        Parameters\n        ----------\n        callback: callable\n            Method to call on save.\n        \"\"\"\nif self.source_is_console():\n    self._last_console_cb = callback\nelse:\n    self._last_editor_cb = callback\n",
        "CUT_5": "\"\"\"Call the callback with the result of is_complete.\"\"\"\nif self.is_waiting_pdb_input():\n    complete, indent = self._is_pdb_complete(source)\n    callback(complete, indent)\nelse:\n    return super(DebuggingWidget, self)._register_is_complete_callback(source,\n        callback)\n"
    },
    {
        "functionName": "on_close",
        "className": "dummyComm",
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "self.close_callback = callback\n",
        "CUT_1": "self.base.server_activate(self)\nif self.callback:\n    self.callback(self)\n",
        "CUT_2": "self.base.server_activate(self)\nif self.callback:\n    self.callback(self)\n",
        "CUT_3": "\"\"\"\n        Save help text.\n\n        Parameters\n        ----------\n        callback: callable\n            Method to call on save.\n        \"\"\"\nif self.source_is_console():\n    self._last_console_cb = callback\nelse:\n    self._last_editor_cb = callback\n",
        "CUT_4": "\"\"\"\n        Save help text.\n\n        Parameters\n        ----------\n        callback: callable\n            Method to call on save.\n        \"\"\"\nif self.source_is_console():\n    self._last_console_cb = callback\nelse:\n    self._last_editor_cb = callback\n",
        "CUT_5": "\"\"\"Call the callback with the result of is_complete.\"\"\"\nif self.is_waiting_pdb_input():\n    complete, indent = self._is_pdb_complete(source)\n    callback(complete, indent)\nelse:\n    return super(DebuggingWidget, self)._register_is_complete_callback(source,\n        callback)\n"
    },
    {
        "functionName": "comms",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Get the comms\"\"\"\ncommA = dummyComm()\ncommB = dummyComm()\ncommA.other = commB\ncommB.other = commA\nfrontend_comm = FrontendComm(kernel)\nkernel_comm = KernelComm()\ndef dummy_set_comm_port(port):\n    \"\"\"There is no port to set.\"\"\"\n    pass\nkernel_comm.register_call_handler('_set_comm_port', dummy_set_comm_port)\nclass DummyKernelClient:\n    comm_channel = 0\n    shell_channel = 0\nkernel_comm.kernel_client = DummyKernelClient()\nkernel_comm._register_comm(commA)\nfrontend_comm._comm_open(commB, {'content': {'data': {'pickle_protocol': 2}}})\nreturn kernel_comm, frontend_comm\npytest.fixture",
        "CUT_1": "super(KernelComm, self).__init__()\nself.comm_port = None\nself.kernel_client = None\nself.register_call_handler('_async_error', self._async_error)\nself.register_call_handler('_set_comm_port', self._set_comm_port)\n",
        "CUT_2": "super(KernelComm, self).__init__()\nself.comm_port = None\nself.kernel_client = None\nself.register_call_handler('_async_error', self._async_error)\nself.register_call_handler('_set_comm_port', self._set_comm_port)\n",
        "CUT_3": "\"\"\"Open comm through the kernel client.\"\"\"\nself.kernel_client = kernel_client\nself.kernel_client.comm_channel = None\nself._register_comm(kernel_client.comm_manager.new_comm(self._comm_name,\n    data={'pickle_protocol': pickle.HIGHEST_PROTOCOL}))\n",
        "CUT_4": "\"\"\"Open comm through the kernel client.\"\"\"\nself.kernel_client = kernel_client\nself.kernel_client.comm_channel = None\nself._register_comm(kernel_client.comm_manager.new_comm(self._comm_name,\n    data={'pickle_protocol': pickle.HIGHEST_PROTOCOL}))\n",
        "CUT_5": "\"\"\"Call the frontend.\"\"\"\nif broadcast:\n    comm_id = None\nelse:\n    comm_id = self.frontend_comm.calling_comm_id\nreturn self.frontend_comm.remote_call(blocking=blocking, comm_id=comm_id,\n    callback=callback, timeout=timeout)\n"
    },
    {
        "functionName": "dummy_set_comm_port",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"There is no port to set.\"\"\"\npass\n",
        "CUT_1": "\"\"\"Verify if `port` is available in `address`.\"\"\"\ns = socket.socket()\ns.settimeout(2)\nlogger.debug('Attempting to connect to {} on port {}'.format(address, port))\ntry:\n    s.connect((address, port))\n    logger.debug('Connected to {} on port {}'.format(address, port))\n    return True\nexcept socket.error as e:\n    logger.debug('Connection to {} on port {} failed: {}'.format(address,\n        port, e))\n    return False\nfinally:\n    s.close()\n",
        "CUT_2": "\"\"\"Verify if `port` is available in `address`.\"\"\"\ns = socket.socket()\ns.settimeout(2)\nlogger.debug('Attempting to connect to {} on port {}'.format(address, port))\ntry:\n    s.connect((address, port))\n    logger.debug('Connected to {} on port {}'.format(address, port))\n    return True\nexcept socket.error as e:\n    logger.debug('Connection to {} on port {} failed: {}'.format(address,\n        port, e))\n    return False\nfinally:\n    s.close()\n",
        "CUT_3": "pass\n",
        "CUT_4": "pass\n",
        "CUT_5": "pass\n"
    },
    {
        "functionName": "test_comm_base",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test basic message exchange.\"\"\"\ncommsend, commrecv = comms\nassert commsend.is_open()\nassert commrecv.is_open()\nreceived_messages = []\ndef handler(msg_dict, buffer):\n    received_messages.append((msg_dict, buffer))\ncommrecv._register_message_handler('test_message', handler)\ncommsend._send_message('test_message', content='content', data='data')\nassert len(received_messages) == 1\nassert received_messages[0][0]['spyder_msg_type'] == 'test_message'\nassert received_messages[0][0]['content'] == 'content'\nassert received_messages[0][1] == 'data'\ncommsend._send_message('test_message', content='content', data='data')\nassert len(received_messages) == 2\ncommrecv._register_message_handler('test_message', None)\ncommsend._send_message('test_message', content='content', data='data')\nassert len(received_messages) == 2\ncommsend.close()\nassert not commsend.is_open()\nassert not commrecv.is_open()\npytest.mark.skipif(os.name == 'nt', reason='Hangs on Windows')",
        "CUT_1": "\"\"\"\n        Handle internal spyder messages.\n        \"\"\"\nself.calling_comm_id = msg['content']['comm_id']\nmsg_dict = msg['content']['data']\ntry:\n    if PY3:\n        buffer = cloudpickle.loads(msg['buffers'][0], encoding='latin-1')\n    else:\n        buffer = cloudpickle.loads(msg['buffers'][0])\nexcept Exception as e:\n    logger.debug('Exception in cloudpickle.loads : %s' % str(e))\n    buffer = CommsErrorWrapper(msg_dict['content']['call_name'], msg_dict[\n        'content']['call_id'])\n    msg_dict['content']['is_error'] = True\nspyder_msg_type = msg_dict['spyder_msg_type']\nif spyder_msg_type in self._message_handlers:\n    self._message_handlers[spyder_msg_type](msg_dict, buffer)\nelse:\n    logger.debug('No such spyder message type: %s' % spyder_msg_type)\n",
        "CUT_2": "def create_file(name, content):\n    fn = os.path.join(workspace.root_path, name)\n    with open(fn, 'w') as f:\n        f.write(content)\n    workspace.put_document(uris.from_fs_path(fn), content)\nfor name, content in files.items():\n    create_file(name, content)\nreturn workspace\n",
        "CUT_3": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_4": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_5": "\"\"\"\n        A blocking call received a reply.\n        \"\"\"\ncontent = msg_dict['content']\ncall_id = content['call_id']\ncall_name = content['call_name']\nis_error = content['is_error']\nif call_id not in self._reply_waitlist:\n    if is_error:\n        return self._async_error(buffer)\n    else:\n        logger.debug('Got an unexpected reply {}, id:{}'.format(call_name,\n            call_id))\n    return\nblocking, callback = self._reply_waitlist.pop(call_id)\nif is_error and not blocking:\n    return self._async_error(buffer)\nif callback is not None and not is_error:\n    callback(buffer)\nif blocking:\n    self._reply_inbox[call_id] = {'is_error': is_error, 'value': buffer,\n        'content': content}\n"
    },
    {
        "functionName": "handler",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "received_messages.append((msg_dict, buffer))\n",
        "CUT_1": "\"\"\"Handle a remote call.\"\"\"\nmsg_dict = msg['content']\nself.on_incoming_call(msg_dict)\ntry:\n    return_value = self._remote_callback(msg_dict['call_name'], buffer[\n        'call_args'], buffer['call_kwargs'])\n    self._set_call_return_value(msg_dict, return_value)\nexcept Exception:\n    exc_infos = CommsErrorWrapper(msg_dict['call_name'], msg_dict['call_id'])\n    self._set_call_return_value(msg_dict, exc_infos, is_error=True)\n",
        "CUT_2": "\"\"\"\n        Handle internal spyder messages.\n        \"\"\"\nself.calling_comm_id = msg['content']['comm_id']\nmsg_dict = msg['content']['data']\ntry:\n    if PY3:\n        buffer = cloudpickle.loads(msg['buffers'][0], encoding='latin-1')\n    else:\n        buffer = cloudpickle.loads(msg['buffers'][0])\nexcept Exception as e:\n    logger.debug('Exception in cloudpickle.loads : %s' % str(e))\n    buffer = CommsErrorWrapper(msg_dict['content']['call_name'], msg_dict[\n        'content']['call_id'])\n    msg_dict['content']['is_error'] = True\nspyder_msg_type = msg_dict['spyder_msg_type']\nif spyder_msg_type in self._message_handlers:\n    self._message_handlers[spyder_msg_type](msg_dict, buffer)\nelse:\n    logger.debug('No such spyder message type: %s' % spyder_msg_type)\n",
        "CUT_3": "\"\"\"\n        A blocking call received a reply.\n        \"\"\"\nsuper(KernelComm, self)._handle_remote_call_reply(msg_dict, buffer)\nself._sig_got_reply.emit()\n",
        "CUT_4": "\"\"\"\n        A blocking call received a reply.\n        \"\"\"\nsuper(KernelComm, self)._handle_remote_call_reply(msg_dict, buffer)\nself._sig_got_reply.emit()\n",
        "CUT_5": "buffer = b''\nheaders = b''\ncontinue_reading = True\nwhile continue_reading:\n    try:\n        buffer += self.read_num_bytes(1)\n        if b'\\r\\n\\r\\n' in buffer:\n            split = buffer.split(b'\\r\\n\\r\\n')\n            if len(split) == 2:\n                headers, buffer = split\n                continue_reading = False\n    except socket.error as e:\n        logger.error(e)\n        raise e\nheaders = self.parse_headers(headers)\nlogger.debug(headers)\ncontent_length = int(headers[b'Content-Length'])\npending_bytes = content_length - len(buffer)\nwhile pending_bytes > 0:\n    logger.debug('Pending bytes...' + str(pending_bytes))\n    recv = self.read_num_bytes(min(1024, pending_bytes))\n    buffer += recv\n    pending_bytes -= len(recv)\nreturn self.encode_body(buffer, headers)\n"
    },
    {
        "functionName": "test_request",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/comms/tests/test_comms.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test if the requests are being replied to.\"\"\"\nkernel_comm, frontend_comm = comms\ndef handler(a, b):\n    return a + b\nkernel_comm.register_call_handler('test_request', handler)\nres = frontend_comm.remote_call(blocking=True).test_request('a', b='b')\nassert res == 'ab'\npytest.mark.skipif(os.name == 'nt', reason='Hangs on Windows')",
        "CUT_1": "\"\"\"Call the frontend.\"\"\"\nif broadcast:\n    comm_id = None\nelse:\n    comm_id = self.frontend_comm.calling_comm_id\nreturn self.frontend_comm.remote_call(blocking=blocking, comm_id=comm_id,\n    callback=callback, timeout=timeout)\n",
        "CUT_2": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_3": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_4": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_5": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n"
    },
    {
        "functionName": "test_dont_preserve_pypath",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/utils/tests/test_spyder_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that PYTHONPATH is not preserved in the env vars passed to the kernel\n    when an external interpreter is used or not.\n\n    Regression test for spyder-ide/spyder#8681.\n    \"\"\"\nCONF.set('main_interpreter', 'default', default_interpreter)\npypath = to_text_string(tmpdir.mkdir('test-pypath'))\nos.environ['PYTHONPATH'] = pypath\nkernel_spec = SpyderKernelSpec()\nassert pypath not in kernel_spec.env['PYTHONPATH']\nCONF.set('main_interpreter', 'default', True)\npytest.mark.parametrize('default_interpreter', [True, False])",
        "CUT_1": "\"\"\"\n    Add a PYTHONPATH entry to a list of enviroment variables.\n\n    This allows to extend the environment of an external process\n    created with QProcess with our additions to PYTHONPATH.\n\n    Parameters\n    ----------\n    env: list\n        List of environment variables in the format of\n        QProcessEnvironment.\n    pathlist: list\n        List of paths to add to PYTHONPATH\n    drop_env: bool\n        Whether to drop PYTHONPATH previously found in the environment.\n    \"\"\"\nassert isinstance(env, list)\nassert all([is_text_string(path) for path in env])\npypath = 'PYTHONPATH'\npathstr = os.pathsep.join(pathlist)\nif not drop_env:\n    for index, var in enumerate(env[:]):\n        if var.startswith(pypath + '='):\n            env[index] = var.replace(pypath + '=', pypath + '=' + pathstr +\n                os.pathsep)\nelse:\n    env.append(pypath + '=' + pathstr)\n",
        "CUT_2": "\"\"\"\n    Add a PYTHONPATH entry to a list of enviroment variables.\n\n    This allows to extend the environment of an external process\n    created with QProcess with our additions to PYTHONPATH.\n\n    Parameters\n    ----------\n    env: list\n        List of environment variables in the format of\n        QProcessEnvironment.\n    pathlist: list\n        List of paths to add to PYTHONPATH\n    drop_env: bool\n        Whether to drop PYTHONPATH previously found in the environment.\n    \"\"\"\nassert isinstance(env, list)\nassert all([is_text_string(path) for path in env])\npypath = 'PYTHONPATH'\npathstr = os.pathsep.join(pathlist)\nif not drop_env:\n    for index, var in enumerate(env[:]):\n        if var.startswith(pypath + '='):\n            env[index] = var.replace(pypath + '=', pypath + '=' + pathstr +\n                os.pathsep)\nelse:\n    env.append(pypath + '=' + pathstr)\n",
        "CUT_3": "pypath = os.environ.get('SPY_PYTHONPATH')\nif pypath:\n    pathlist = pypath.split(os.pathsep)\n    sys.path.extend(pathlist)\n",
        "CUT_4": "if CONF.get('main_interpreter', 'default'):\n    return sys.executable\nelse:\n    return CONF.get('main_interpreter', 'custom_interpreter')\n",
        "CUT_5": "if CONF.get('main_interpreter', 'default'):\n    return sys.executable\nelse:\n    return CONF.get('main_interpreter', 'custom_interpreter')\n"
    },
    {
        "functionName": "test_python_interpreter",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/utils/tests/test_spyder_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the validation of the python interpreter.\"\"\"\ninterpreter = str(tmpdir.mkdir('interpreter').join('python'))\nCONF.set('main_interpreter', 'default', False)\nCONF.set('main_interpreter', 'custom', True)\nCONF.set('main_interpreter', 'executable', interpreter)\nkernel_spec = SpyderKernelSpec()\nassert interpreter not in kernel_spec.argv\nassert CONF.get('main_interpreter', 'default')\nassert not CONF.get('main_interpreter', 'custom')\n",
        "CUT_1": "if CONF.get('main_interpreter', 'default'):\n    return sys.executable\nelse:\n    return CONF.get('main_interpreter', 'custom_interpreter')\n",
        "CUT_2": "if CONF.get('main_interpreter', 'default'):\n    return sys.executable\nelse:\n    return CONF.get('main_interpreter', 'custom_interpreter')\n",
        "CUT_3": "\"\"\"Open external console\"\"\"\nif systerm:\n    try:\n        if CONF.get('main_interpreter', 'default'):\n            executable = get_python_executable()\n        else:\n            executable = CONF.get('main_interpreter', 'executable')\n        programs.run_python_script_in_terminal(fname, wdir, args, interact,\n            debug, python_args, executable)\n    except NotImplementedError:\n        QMessageBox.critical(self, _('Run'), _(\n            'Running an external system terminal is not supported on platform %s.'\n            ) % os.name)\n",
        "CUT_4": "\"\"\"Open external console\"\"\"\nif systerm:\n    try:\n        if CONF.get('main_interpreter', 'default'):\n            executable = get_python_executable()\n        else:\n            executable = CONF.get('main_interpreter', 'executable')\n        programs.run_python_script_in_terminal(fname, wdir, args, interact,\n            debug, python_args, executable)\n    except NotImplementedError:\n        QMessageBox.critical(self, _('Run'), _(\n            'Running an external system terminal is not supported on platform %s.'\n            ) % os.name)\n",
        "CUT_5": "\"\"\"Exit interpreter\"\"\"\nself.interpreter.exit_flag = True\nif self.multithreaded:\n    self.interpreter.stdin_write.write(to_binary_string('\\n'))\nself.interpreter.restore_stds()\n"
    },
    {
        "functionName": "test_env_vars",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/utils/tests/test_spyder_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that we are correctly encoding env vars in our kernel spec\"\"\"\nenv_var = to_fs_from_unicode('\u00f1\u00f1\u00f1')\nCONF.set('main', 'spyder_pythonpath', [env_var])\nkernel_spec = SpyderKernelSpec()\nassert kernel_spec.env['PYTHONPATH'] != ''\nassert all([is_binary_string(v) for v in kernel_spec.env.values()])\nCONF.set('main', 'spyder_pythonpath', [])\npytest.mark.skipif(os.name != 'nt' or not PY2, reason=\n    'It only makes sense on Windows and Python 2')",
        "CUT_1": "\"\"\"Process conda environment information.\"\"\"\nout, err = self._get_interpreter_env_info()\nout = out or err\nout = out.split('\\n')[0]\nparts = out.split()\nif len(parts) >= 2:\n    out = ' '.join(parts[:2])\nif is_conda_env(pyexec=self._interpreter):\n    envs_folder = os.path.sep + 'envs' + os.path.sep\n    if envs_folder in self._interpreter:\n        if os.name == 'nt':\n            env = os.path.dirname(self._interpreter)\n        else:\n            env = os.path.dirname(os.path.dirname(self._interpreter))\n        env = os.path.basename(env)\n    else:\n        env = 'base'\n    env = 'conda: ' + env\nelif running_in_mac_app(self._interpreter):\n    env = 'internal'\nelse:\n    env = 'venv'\ntext = '{env} ({version})'.format(env=env, version=out)\nreturn text\n",
        "CUT_2": "\"\"\"Process conda environment information.\"\"\"\nout, err = self._get_interpreter_env_info()\nout = out or err\nout = out.split('\\n')[0]\nparts = out.split()\nif len(parts) >= 2:\n    out = ' '.join(parts[:2])\nif is_conda_env(pyexec=self._interpreter):\n    envs_folder = os.path.sep + 'envs' + os.path.sep\n    if envs_folder in self._interpreter:\n        if os.name == 'nt':\n            env = os.path.dirname(self._interpreter)\n        else:\n            env = os.path.dirname(os.path.dirname(self._interpreter))\n        env = os.path.basename(env)\n    else:\n        env = 'base'\n    env = 'conda: ' + env\nelif running_in_mac_app(self._interpreter):\n    env = 'internal'\nelse:\n    env = 'venv'\ntext = '{env} ({version})'.format(env=env, version=out)\nreturn text\n",
        "CUT_3": "\"\"\"Create a kernel spec for our own kernels\"\"\"\nCONF.set('main', 'spyder_pythonpath', self.main.get_spyder_pythonpath())\nreturn SpyderKernelSpec(is_cython=is_cython, is_pylab=is_pylab, is_sympy=\n    is_sympy)\n",
        "CUT_4": "\"\"\"Create a kernel spec for our own kernels\"\"\"\nCONF.set('main', 'spyder_pythonpath', self.main.get_spyder_pythonpath())\nreturn SpyderKernelSpec(is_cython=is_cython, is_pylab=is_pylab, is_sympy=\n    is_sympy)\n",
        "CUT_5": "\"\"\"\n    Add a PYTHONPATH entry to a list of enviroment variables.\n\n    This allows to extend the environment of an external process\n    created with QProcess with our additions to PYTHONPATH.\n\n    Parameters\n    ----------\n    env: list\n        List of environment variables in the format of\n        QProcessEnvironment.\n    pathlist: list\n        List of paths to add to PYTHONPATH\n    drop_env: bool\n        Whether to drop PYTHONPATH previously found in the environment.\n    \"\"\"\nassert isinstance(env, list)\nassert all([is_text_string(path) for path in env])\npypath = 'PYTHONPATH'\npathstr = os.pathsep.join(pathlist)\nif not drop_env:\n    for index, var in enumerate(env[:]):\n        if var.startswith(pypath + '='):\n            env[index] = var.replace(pypath + '=', pypath + '=' + pathstr +\n                os.pathsep)\nelse:\n    env.append(pypath + '=' + pathstr)\n"
    },
    {
        "functionName": "connection_dialog_factory",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/widgets/tests/test_kernelconnect.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up kernel connection dialog.\"\"\"\nclass DialogFactory(object):\n\n    def get_default_dialog(self):\n        dialog = KernelConnectionDialog()\n        request.addfinalizer(dialog.close)\n        return dialog\n\n    def submit_filled_dialog(self, use_keyfile, save_settings):\n        dlg = self.get_default_dialog()\n        dlg.cf.clear()\n        qtbot.keyClicks(dlg.cf, pytest.cf_path)\n        dlg.rm_group.setChecked(True)\n        dlg.hn.clear()\n        qtbot.keyClicks(dlg.hn, pytest.hn)\n        dlg.pn.clear()\n        qtbot.keyClicks(dlg.pn, str(pytest.pn))\n        dlg.un.clear()\n        qtbot.keyClicks(dlg.un, pytest.un)\n        if use_keyfile:\n            dlg.kf_radio.setChecked(True)\n            assert dlg.kf.isEnabled()\n            dlg.kf.clear()\n            qtbot.keyClicks(dlg.kf, pytest.kf)\n            dlg.kfp.clear()\n            qtbot.keyClicks(dlg.kfp, pytest.kfp)\n        else:\n            dlg.pw_radio.setChecked(True)\n            assert dlg.pw.isEnabled()\n            dlg.pw.clear()\n            qtbot.keyClicks(dlg.pw, pytest.pw)\n        dlg.save_layout.setChecked(save_settings)\n        return dlg\ndef teardown():\n    \"\"\"Clear existing-kernel config and keyring passwords.\"\"\"\n    CONF.remove_section('existing-kernel')\n    try:\n        import keyring\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase', '')\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', '')\n    except Exception:\n        pass\npytest.cf_path = 'cf_path'\npytest.un = 'test_username'\npytest.hn = 'test_hostname'\npytest.pn = 123\npytest.kf = 'test_kf'\npytest.kfp = 'test_kfp'\npytest.pw = 'test_pw'\nrequest.addfinalizer(teardown)\nreturn DialogFactory()\npytest.fixture",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_3": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_4": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n"
    },
    {
        "functionName": "get_default_dialog",
        "className": "DialogFactory",
        "fileName": "/spyder/plugins/ipythonconsole/widgets/tests/test_kernelconnect.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "dialog = KernelConnectionDialog()\nrequest.addfinalizer(dialog.close)\nreturn dialog\n",
        "CUT_1": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_3": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_4": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_5": "\"\"\"\n        Set maximum amount of results to add to the result browser.\n\n        Parameters\n        ----------\n        value: int, optional\n            Number of results. If None an input dialog will be used.\n            Default is None.\n        \"\"\"\nif value is None:\n    dialog = QInputDialog(self)\n    dialog.setModal(False)\n    dialog.setWindowTitle(self.get_name())\n    dialog.setLabelText(_('Set maximum number of results: '))\n    dialog.setInputMode(QInputDialog.IntInput)\n    dialog.setIntRange(1, 10000)\n    dialog.setIntStep(1)\n    dialog.setIntValue(self.get_option('max_results'))\n    dialog.intValueSelected.connect(lambda value: self.set_option(\n        'max_results', value))\n    dialog.show()\nelse:\n    self.set_option('max_results', value)\n"
    },
    {
        "functionName": "submit_filled_dialog",
        "className": "DialogFactory",
        "fileName": "/spyder/plugins/ipythonconsole/widgets/tests/test_kernelconnect.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "dlg = self.get_default_dialog()\ndlg.cf.clear()\nqtbot.keyClicks(dlg.cf, pytest.cf_path)\ndlg.rm_group.setChecked(True)\ndlg.hn.clear()\nqtbot.keyClicks(dlg.hn, pytest.hn)\ndlg.pn.clear()\nqtbot.keyClicks(dlg.pn, str(pytest.pn))\ndlg.un.clear()\nqtbot.keyClicks(dlg.un, pytest.un)\nif use_keyfile:\n    dlg.kf_radio.setChecked(True)\n    assert dlg.kf.isEnabled()\n    dlg.kf.clear()\n    qtbot.keyClicks(dlg.kf, pytest.kf)\n    dlg.kfp.clear()\n    qtbot.keyClicks(dlg.kfp, pytest.kfp)\nelse:\n    dlg.pw_radio.setChecked(True)\n    assert dlg.pw.isEnabled()\n    dlg.pw.clear()\n    qtbot.keyClicks(dlg.pw, pytest.pw)\ndlg.save_layout.setChecked(save_settings)\nreturn dlg\n",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"\n    Fixture that includes the general preferences options.\n\n    These options are the ones not tied to a specific plugin.\n    \"\"\"\ndlg = ConfigDialog()\ndlg.show()\nfrom spyder.preferences.maininterpreter import MainInterpreterConfigPage\nqtbot.addWidget(dlg)\nfor widget_class in [MainConfigPage, MainInterpreterConfigPage]:\n    widget = widget_class(dlg, main=MainWindowMock())\n    widget.initialize()\n    dlg.add_page(widget)\nreturn dlg\npytest.fixture",
        "CUT_3": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_4": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n"
    },
    {
        "functionName": "teardown",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/widgets/tests/test_kernelconnect.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Clear existing-kernel config and keyring passwords.\"\"\"\nCONF.remove_section('existing-kernel')\ntry:\n    import keyring\n    keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase', '')\n    keyring.set_password('spyder_remote_kernel', 'ssh_password', '')\nexcept Exception:\n    pass\n",
        "CUT_1": "\"\"\"Save user's kernel connection settings.\"\"\"\nif not self.save_layout.isChecked():\n    return\nis_ssh_key = bool(self.kf_radio.isChecked())\nconnection_settings = {'json_file_path': self.cf.text(), 'is_remote': self.\n    rm_group.isChecked(), 'username': self.un.text(), 'hostname': self.hn.\n    text(), 'port': self.pn.text(), 'is_ssh_keyfile': is_ssh_key,\n    'ssh_key_file_path': self.kf.text()}\nCONF.set('existing-kernel', 'settings', connection_settings)\ntry:\n    import keyring\n    if is_ssh_key:\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase',\n            self.kfp.text())\n    else:\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', self.\n            pw.text())\nexcept Exception:\n    pass\n",
        "CUT_2": "\"\"\"Save user's kernel connection settings.\"\"\"\nif not self.save_layout.isChecked():\n    return\nis_ssh_key = bool(self.kf_radio.isChecked())\nconnection_settings = {'json_file_path': self.cf.text(), 'is_remote': self.\n    rm_group.isChecked(), 'username': self.un.text(), 'hostname': self.hn.\n    text(), 'port': self.pn.text(), 'is_ssh_keyfile': is_ssh_key,\n    'ssh_key_file_path': self.kf.text()}\nCONF.set('existing-kernel', 'settings', connection_settings)\ntry:\n    import keyring\n    if is_ssh_key:\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase',\n            self.kfp.text())\n    else:\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', self.\n            pw.text())\nexcept Exception:\n    pass\n",
        "CUT_3": "\"\"\"Check if keyring is available for password storage.\"\"\"\ntry:\n    import keyring\n    return True\nexcept Exception:\n    return False\n",
        "CUT_4": "\"\"\"Check if keyring is available for password storage.\"\"\"\ntry:\n    import keyring\n    return True\nexcept Exception:\n    return False\n",
        "CUT_5": "\"\"\"Load the user's previously-saved kernel connection settings.\"\"\"\nexisting_kernel = CONF.get('existing-kernel', 'settings', {})\nconnection_file_path = existing_kernel.get('json_file_path', '')\nis_remote = existing_kernel.get('is_remote', False)\nusername = existing_kernel.get('username', '')\nhostname = existing_kernel.get('hostname', '')\nport = str(existing_kernel.get('port', 22))\nis_ssh_kf = existing_kernel.get('is_ssh_keyfile', False)\nssh_kf = existing_kernel.get('ssh_key_file_path', '')\nif connection_file_path != '':\n    self.cf.setText(connection_file_path)\nif username != '':\n    self.un.setText(username)\nif hostname != '':\n    self.hn.setText(hostname)\nif ssh_kf != '':\n    self.kf.setText(ssh_kf)\nself.rm_group.setChecked(is_remote)\nself.pn.setText(port)\nself.kf_radio.setChecked(is_ssh_kf)\nself.pw_radio.setChecked(not is_ssh_kf)\ntry:\n    import keyring\n    ssh_passphrase = keyring.get_password('spyder_remote_kernel',\n        'ssh_key_passphrase')\n    ssh_password = keyring.get_password('spyder_remote_kernel', 'ssh_password')\n    if ssh_passphrase:\n        self.kfp.setText(ssh_passphrase)\n    if ssh_password:\n        self.pw.setText(ssh_password)\nexcept Exception:\n    pass\n"
    },
    {
        "functionName": "test_connection_dialog_remembers_input_with_ssh_passphrase",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/widgets/tests/test_kernelconnect.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the dialog remembers the user's kernel connection\n    settings and ssh key passphrase when the user checks the\n    save checkbox.\n    \"\"\"\ndlg = connection_dialog_factory.submit_filled_dialog(use_keyfile=True,\n    save_settings=True)\nqtbot.mouseClick(dlg.accept_btns.button(QDialogButtonBox.Ok), Qt.LeftButton)\nnew_dlg = connection_dialog_factory.get_default_dialog()\nassert new_dlg.cf.text() == pytest.cf_path\nassert new_dlg.rm_group.isChecked()\nassert new_dlg.hn.text() == pytest.hn\nassert new_dlg.un.text() == pytest.un\nassert new_dlg.pn.text() == str(pytest.pn)\nassert new_dlg.kf.text() == pytest.kf\nif sys.platform == 'darwin' or not os.environ.get('CI') is not None:\n    assert new_dlg.kfp.text() == pytest.kfp\n",
        "CUT_1": "\"\"\"Save user's kernel connection settings.\"\"\"\nif not self.save_layout.isChecked():\n    return\nis_ssh_key = bool(self.kf_radio.isChecked())\nconnection_settings = {'json_file_path': self.cf.text(), 'is_remote': self.\n    rm_group.isChecked(), 'username': self.un.text(), 'hostname': self.hn.\n    text(), 'port': self.pn.text(), 'is_ssh_keyfile': is_ssh_key,\n    'ssh_key_file_path': self.kf.text()}\nCONF.set('existing-kernel', 'settings', connection_settings)\ntry:\n    import keyring\n    if is_ssh_key:\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase',\n            self.kfp.text())\n    else:\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', self.\n            pw.text())\nexcept Exception:\n    pass\n",
        "CUT_2": "\"\"\"Save user's kernel connection settings.\"\"\"\nif not self.save_layout.isChecked():\n    return\nis_ssh_key = bool(self.kf_radio.isChecked())\nconnection_settings = {'json_file_path': self.cf.text(), 'is_remote': self.\n    rm_group.isChecked(), 'username': self.un.text(), 'hostname': self.hn.\n    text(), 'port': self.pn.text(), 'is_ssh_keyfile': is_ssh_key,\n    'ssh_key_file_path': self.kf.text()}\nCONF.set('existing-kernel', 'settings', connection_settings)\ntry:\n    import keyring\n    if is_ssh_key:\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase',\n            self.kfp.text())\n    else:\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', self.\n            pw.text())\nexcept Exception:\n    pass\n",
        "CUT_3": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_4": "if not dialog:\n    dialog = KernelConnectionDialog(parent)\nresult = dialog.exec_()\nis_remote = bool(dialog.rm_group.isChecked())\naccepted = result == QDialog.Accepted\nif is_remote:\n\n    def falsy_to_none(arg):\n        return arg if arg else None\n    if dialog.hn.text() and dialog.un.text():\n        port = dialog.pn.text() if dialog.pn.text() else '22'\n        hostname = '{0}@{1}:{2}'.format(dialog.un.text(), dialog.hn.text(),\n            port)\n    else:\n        hostname = None\n    if dialog.pw_radio.isChecked():\n        password = falsy_to_none(dialog.pw.text())\n        keyfile = None\n    elif dialog.kf_radio.isChecked():\n        keyfile = falsy_to_none(dialog.kf.text())\n        password = falsy_to_none(dialog.kfp.text())\n    else:\n        keyfile = None\n        password = None\n    return dialog.cf.text(), hostname, keyfile, password, accepted\nelse:\n    path = dialog.cf.text()\n    _dir, filename = osp.dirname(path), osp.basename(path)\n    if _dir == '' and not filename.endswith('.json'):\n        path = osp.join(jupyter_runtime_dir(), 'kernel-' + path + '.json')\n    return path, None, None, None, accepted\nstaticmethod",
        "CUT_5": "if not dialog:\n    dialog = KernelConnectionDialog(parent)\nresult = dialog.exec_()\nis_remote = bool(dialog.rm_group.isChecked())\naccepted = result == QDialog.Accepted\nif is_remote:\n\n    def falsy_to_none(arg):\n        return arg if arg else None\n    if dialog.hn.text() and dialog.un.text():\n        port = dialog.pn.text() if dialog.pn.text() else '22'\n        hostname = '{0}@{1}:{2}'.format(dialog.un.text(), dialog.hn.text(),\n            port)\n    else:\n        hostname = None\n    if dialog.pw_radio.isChecked():\n        password = falsy_to_none(dialog.pw.text())\n        keyfile = None\n    elif dialog.kf_radio.isChecked():\n        keyfile = falsy_to_none(dialog.kf.text())\n        password = falsy_to_none(dialog.kfp.text())\n    else:\n        keyfile = None\n        password = None\n    return dialog.cf.text(), hostname, keyfile, password, accepted\nelse:\n    path = dialog.cf.text()\n    _dir, filename = osp.dirname(path), osp.basename(path)\n    if _dir == '' and not filename.endswith('.json'):\n        path = osp.join(jupyter_runtime_dir(), 'kernel-' + path + '.json')\n    return path, None, None, None, accepted\nstaticmethod"
    },
    {
        "functionName": "test_connection_dialog_doesnt_remember_input_with_ssh_passphrase",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/widgets/tests/test_kernelconnect.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the dialog doesn't remember the user's kernel\n    connection settings and ssh key passphrase when the user doesn't\n    check the save checkbox.\n    \"\"\"\ndlg = connection_dialog_factory.submit_filled_dialog(use_keyfile=True,\n    save_settings=False)\nqtbot.mouseClick(dlg.accept_btns.button(QDialogButtonBox.Ok), Qt.LeftButton)\nnew_dlg = connection_dialog_factory.get_default_dialog()\nassert new_dlg.cf.text() == ''\nassert not new_dlg.rm_group.isChecked()\nassert new_dlg.hn.text() == ''\nassert new_dlg.un.text() == ''\nassert new_dlg.pn.text() == '22'\nassert new_dlg.kf.text() == ''\nif sys.platform == 'darwin' or not os.environ.get('CI') is not None:\n    assert new_dlg.kfp.text() == ''\n",
        "CUT_1": "\"\"\"Save user's kernel connection settings.\"\"\"\nif not self.save_layout.isChecked():\n    return\nis_ssh_key = bool(self.kf_radio.isChecked())\nconnection_settings = {'json_file_path': self.cf.text(), 'is_remote': self.\n    rm_group.isChecked(), 'username': self.un.text(), 'hostname': self.hn.\n    text(), 'port': self.pn.text(), 'is_ssh_keyfile': is_ssh_key,\n    'ssh_key_file_path': self.kf.text()}\nCONF.set('existing-kernel', 'settings', connection_settings)\ntry:\n    import keyring\n    if is_ssh_key:\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase',\n            self.kfp.text())\n    else:\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', self.\n            pw.text())\nexcept Exception:\n    pass\n",
        "CUT_2": "\"\"\"Save user's kernel connection settings.\"\"\"\nif not self.save_layout.isChecked():\n    return\nis_ssh_key = bool(self.kf_radio.isChecked())\nconnection_settings = {'json_file_path': self.cf.text(), 'is_remote': self.\n    rm_group.isChecked(), 'username': self.un.text(), 'hostname': self.hn.\n    text(), 'port': self.pn.text(), 'is_ssh_keyfile': is_ssh_key,\n    'ssh_key_file_path': self.kf.text()}\nCONF.set('existing-kernel', 'settings', connection_settings)\ntry:\n    import keyring\n    if is_ssh_key:\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase',\n            self.kfp.text())\n    else:\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', self.\n            pw.text())\nexcept Exception:\n    pass\n",
        "CUT_3": "\"\"\"\n        Evaluate text and return (obj, valid)\n        where *obj* is the object represented by *text*\n        and *valid* is True if object evaluation did not raise any exception\n        \"\"\"\nassert is_text_string(text)\ntry:\n    return eval(text, self.locals), True\nexcept:\n    return None, False\n",
        "CUT_4": "\"\"\"\n        Evaluate text and return (obj, valid)\n        where *obj* is the object represented by *text*\n        and *valid* is True if object evaluation did not raise any exception\n        \"\"\"\nassert is_text_string(text)\ntry:\n    return eval(text, self.locals), True\nexcept:\n    return None, False\n",
        "CUT_5": "if not dialog:\n    dialog = KernelConnectionDialog(parent)\nresult = dialog.exec_()\nis_remote = bool(dialog.rm_group.isChecked())\naccepted = result == QDialog.Accepted\nif is_remote:\n\n    def falsy_to_none(arg):\n        return arg if arg else None\n    if dialog.hn.text() and dialog.un.text():\n        port = dialog.pn.text() if dialog.pn.text() else '22'\n        hostname = '{0}@{1}:{2}'.format(dialog.un.text(), dialog.hn.text(),\n            port)\n    else:\n        hostname = None\n    if dialog.pw_radio.isChecked():\n        password = falsy_to_none(dialog.pw.text())\n        keyfile = None\n    elif dialog.kf_radio.isChecked():\n        keyfile = falsy_to_none(dialog.kf.text())\n        password = falsy_to_none(dialog.kfp.text())\n    else:\n        keyfile = None\n        password = None\n    return dialog.cf.text(), hostname, keyfile, password, accepted\nelse:\n    path = dialog.cf.text()\n    _dir, filename = osp.dirname(path), osp.basename(path)\n    if _dir == '' and not filename.endswith('.json'):\n        path = osp.join(jupyter_runtime_dir(), 'kernel-' + path + '.json')\n    return path, None, None, None, accepted\nstaticmethod"
    },
    {
        "functionName": "test_connection_dialog_remembers_input_with_password",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/widgets/tests/test_kernelconnect.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the dialog remembers the user's kernel connection\n    settings and ssh password when the user checks the save checkbox.\n    \"\"\"\ndlg = connection_dialog_factory.submit_filled_dialog(use_keyfile=False,\n    save_settings=True)\nqtbot.mouseClick(dlg.accept_btns.button(QDialogButtonBox.Ok), Qt.LeftButton)\nnew_dlg = connection_dialog_factory.get_default_dialog()\nassert new_dlg.cf.text() == pytest.cf_path\nassert new_dlg.rm_group.isChecked()\nassert new_dlg.hn.text() == pytest.hn\nassert new_dlg.un.text() == pytest.un\nassert new_dlg.pn.text() == str(pytest.pn)\nif sys.platform == 'darwin' or not os.environ.get('CI') is not None:\n    assert new_dlg.pw.text() == pytest.pw\n",
        "CUT_1": "\"\"\"Save user's kernel connection settings.\"\"\"\nif not self.save_layout.isChecked():\n    return\nis_ssh_key = bool(self.kf_radio.isChecked())\nconnection_settings = {'json_file_path': self.cf.text(), 'is_remote': self.\n    rm_group.isChecked(), 'username': self.un.text(), 'hostname': self.hn.\n    text(), 'port': self.pn.text(), 'is_ssh_keyfile': is_ssh_key,\n    'ssh_key_file_path': self.kf.text()}\nCONF.set('existing-kernel', 'settings', connection_settings)\ntry:\n    import keyring\n    if is_ssh_key:\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase',\n            self.kfp.text())\n    else:\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', self.\n            pw.text())\nexcept Exception:\n    pass\n",
        "CUT_2": "\"\"\"Save user's kernel connection settings.\"\"\"\nif not self.save_layout.isChecked():\n    return\nis_ssh_key = bool(self.kf_radio.isChecked())\nconnection_settings = {'json_file_path': self.cf.text(), 'is_remote': self.\n    rm_group.isChecked(), 'username': self.un.text(), 'hostname': self.hn.\n    text(), 'port': self.pn.text(), 'is_ssh_keyfile': is_ssh_key,\n    'ssh_key_file_path': self.kf.text()}\nCONF.set('existing-kernel', 'settings', connection_settings)\ntry:\n    import keyring\n    if is_ssh_key:\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase',\n            self.kfp.text())\n    else:\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', self.\n            pw.text())\nexcept Exception:\n    pass\n",
        "CUT_3": "if not dialog:\n    dialog = KernelConnectionDialog(parent)\nresult = dialog.exec_()\nis_remote = bool(dialog.rm_group.isChecked())\naccepted = result == QDialog.Accepted\nif is_remote:\n\n    def falsy_to_none(arg):\n        return arg if arg else None\n    if dialog.hn.text() and dialog.un.text():\n        port = dialog.pn.text() if dialog.pn.text() else '22'\n        hostname = '{0}@{1}:{2}'.format(dialog.un.text(), dialog.hn.text(),\n            port)\n    else:\n        hostname = None\n    if dialog.pw_radio.isChecked():\n        password = falsy_to_none(dialog.pw.text())\n        keyfile = None\n    elif dialog.kf_radio.isChecked():\n        keyfile = falsy_to_none(dialog.kf.text())\n        password = falsy_to_none(dialog.kfp.text())\n    else:\n        keyfile = None\n        password = None\n    return dialog.cf.text(), hostname, keyfile, password, accepted\nelse:\n    path = dialog.cf.text()\n    _dir, filename = osp.dirname(path), osp.basename(path)\n    if _dir == '' and not filename.endswith('.json'):\n        path = osp.join(jupyter_runtime_dir(), 'kernel-' + path + '.json')\n    return path, None, None, None, accepted\nstaticmethod",
        "CUT_4": "if not dialog:\n    dialog = KernelConnectionDialog(parent)\nresult = dialog.exec_()\nis_remote = bool(dialog.rm_group.isChecked())\naccepted = result == QDialog.Accepted\nif is_remote:\n\n    def falsy_to_none(arg):\n        return arg if arg else None\n    if dialog.hn.text() and dialog.un.text():\n        port = dialog.pn.text() if dialog.pn.text() else '22'\n        hostname = '{0}@{1}:{2}'.format(dialog.un.text(), dialog.hn.text(),\n            port)\n    else:\n        hostname = None\n    if dialog.pw_radio.isChecked():\n        password = falsy_to_none(dialog.pw.text())\n        keyfile = None\n    elif dialog.kf_radio.isChecked():\n        keyfile = falsy_to_none(dialog.kf.text())\n        password = falsy_to_none(dialog.kfp.text())\n    else:\n        keyfile = None\n        password = None\n    return dialog.cf.text(), hostname, keyfile, password, accepted\nelse:\n    path = dialog.cf.text()\n    _dir, filename = osp.dirname(path), osp.basename(path)\n    if _dir == '' and not filename.endswith('.json'):\n        path = osp.join(jupyter_runtime_dir(), 'kernel-' + path + '.json')\n    return path, None, None, None, accepted\nstaticmethod",
        "CUT_5": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture"
    },
    {
        "functionName": "test_connection_dialog_doesnt_remember_input_with_password",
        "className": null,
        "fileName": "/spyder/plugins/ipythonconsole/widgets/tests/test_kernelconnect.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the dialog doesn't remember the user's kernel\n    connection settings and ssh password when the user doesn't\n    check the save checkbox.\n    \"\"\"\ndlg = connection_dialog_factory.submit_filled_dialog(use_keyfile=False,\n    save_settings=False)\nqtbot.mouseClick(dlg.accept_btns.button(QDialogButtonBox.Ok), Qt.LeftButton)\nnew_dlg = connection_dialog_factory.get_default_dialog()\nassert new_dlg.cf.text() == ''\nassert not new_dlg.rm_group.isChecked()\nassert new_dlg.hn.text() == ''\nassert new_dlg.un.text() == ''\nassert new_dlg.pn.text() == '22'\nif sys.platform == 'darwin' or not os.environ.get('CI') is not None:\n    assert new_dlg.pw.text() == ''\n",
        "CUT_1": "if not dialog:\n    dialog = KernelConnectionDialog(parent)\nresult = dialog.exec_()\nis_remote = bool(dialog.rm_group.isChecked())\naccepted = result == QDialog.Accepted\nif is_remote:\n\n    def falsy_to_none(arg):\n        return arg if arg else None\n    if dialog.hn.text() and dialog.un.text():\n        port = dialog.pn.text() if dialog.pn.text() else '22'\n        hostname = '{0}@{1}:{2}'.format(dialog.un.text(), dialog.hn.text(),\n            port)\n    else:\n        hostname = None\n    if dialog.pw_radio.isChecked():\n        password = falsy_to_none(dialog.pw.text())\n        keyfile = None\n    elif dialog.kf_radio.isChecked():\n        keyfile = falsy_to_none(dialog.kf.text())\n        password = falsy_to_none(dialog.kfp.text())\n    else:\n        keyfile = None\n        password = None\n    return dialog.cf.text(), hostname, keyfile, password, accepted\nelse:\n    path = dialog.cf.text()\n    _dir, filename = osp.dirname(path), osp.basename(path)\n    if _dir == '' and not filename.endswith('.json'):\n        path = osp.join(jupyter_runtime_dir(), 'kernel-' + path + '.json')\n    return path, None, None, None, accepted\nstaticmethod",
        "CUT_2": "if not dialog:\n    dialog = KernelConnectionDialog(parent)\nresult = dialog.exec_()\nis_remote = bool(dialog.rm_group.isChecked())\naccepted = result == QDialog.Accepted\nif is_remote:\n\n    def falsy_to_none(arg):\n        return arg if arg else None\n    if dialog.hn.text() and dialog.un.text():\n        port = dialog.pn.text() if dialog.pn.text() else '22'\n        hostname = '{0}@{1}:{2}'.format(dialog.un.text(), dialog.hn.text(),\n            port)\n    else:\n        hostname = None\n    if dialog.pw_radio.isChecked():\n        password = falsy_to_none(dialog.pw.text())\n        keyfile = None\n    elif dialog.kf_radio.isChecked():\n        keyfile = falsy_to_none(dialog.kf.text())\n        password = falsy_to_none(dialog.kfp.text())\n    else:\n        keyfile = None\n        password = None\n    return dialog.cf.text(), hostname, keyfile, password, accepted\nelse:\n    path = dialog.cf.text()\n    _dir, filename = osp.dirname(path), osp.basename(path)\n    if _dir == '' and not filename.endswith('.json'):\n        path = osp.join(jupyter_runtime_dir(), 'kernel-' + path + '.json')\n    return path, None, None, None, accepted\nstaticmethod",
        "CUT_3": "\"\"\"Save user's kernel connection settings.\"\"\"\nif not self.save_layout.isChecked():\n    return\nis_ssh_key = bool(self.kf_radio.isChecked())\nconnection_settings = {'json_file_path': self.cf.text(), 'is_remote': self.\n    rm_group.isChecked(), 'username': self.un.text(), 'hostname': self.hn.\n    text(), 'port': self.pn.text(), 'is_ssh_keyfile': is_ssh_key,\n    'ssh_key_file_path': self.kf.text()}\nCONF.set('existing-kernel', 'settings', connection_settings)\ntry:\n    import keyring\n    if is_ssh_key:\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase',\n            self.kfp.text())\n    else:\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', self.\n            pw.text())\nexcept Exception:\n    pass\n",
        "CUT_4": "\"\"\"Save user's kernel connection settings.\"\"\"\nif not self.save_layout.isChecked():\n    return\nis_ssh_key = bool(self.kf_radio.isChecked())\nconnection_settings = {'json_file_path': self.cf.text(), 'is_remote': self.\n    rm_group.isChecked(), 'username': self.un.text(), 'hostname': self.hn.\n    text(), 'port': self.pn.text(), 'is_ssh_keyfile': is_ssh_key,\n    'ssh_key_file_path': self.kf.text()}\nCONF.set('existing-kernel', 'settings', connection_settings)\ntry:\n    import keyring\n    if is_ssh_key:\n        keyring.set_password('spyder_remote_kernel', 'ssh_key_passphrase',\n            self.kfp.text())\n    else:\n        keyring.set_password('spyder_remote_kernel', 'ssh_password', self.\n            pw.text())\nexcept Exception:\n    pass\n",
        "CUT_5": "\"\"\"\n        Evaluate text and return (obj, valid)\n        where *obj* is the object represented by *text*\n        and *valid* is True if object evaluation did not raise any exception\n        \"\"\"\nassert is_text_string(text)\ntry:\n    return eval(text, self.locals), True\nexcept:\n    return None, False\n"
    },
    {
        "functionName": "test_snippet_completions",
        "className": null,
        "fileName": "/spyder/plugins/completion/snippets/tests/test_snippets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "snippets, completions = snippets_completions\nend_trim = random.randrange(1, len(trigger))\ndescriptions = PY_SNIPPETS[trigger]\nexpected_snippets = []\nfor description in descriptions:\n    snippet_info = descriptions[description]\n    text = snippet_info['text']\n    remove_trigger = snippet_info['remove_trigger']\n    expected_snippets.append({'kind': CompletionItemKind.SNIPPET,\n        'insertText': text, 'label': f'{trigger} ({description})',\n        'sortText': trigger, 'filterText': trigger, 'documentation': '',\n        'provider': 'Snippets', 'remove_trigger': remove_trigger})\ntrigger_text = trigger[:end_trim]\nsnippets_request = {'file': '', 'current_word': trigger_text}\nwith qtbot_module.waitSignal(completions.sig_recv_snippets, timeout=3000\n    ) as blocker:\n    snippets.send_request('python', LSPRequestTypes.DOCUMENT_COMPLETION,\n        snippets_request)\nresp_snippets = blocker.args[0]\nresp_snippets = [x for x in resp_snippets if x['filterText'] == trigger]\nresp_snippets = sorted(resp_snippets, key=lambda x: x['label'])\nexpected_snippets = sorted(expected_snippets, key=lambda x: x['label'])\nassert resp_snippets == expected_snippets\npytest.mark.slowpytest.mark.parametrize('trigger', list(PY_SNIPPETS.keys()))",
        "CUT_1": "\"\"\"Handle one message\"\"\"\nmsg_type, _id, file, msg = [message[k] for k in ('type', 'id', 'file', 'msg')]\nlogger.debug('Perform request {0} with id {1}'.format(msg_type, _id))\nif msg_type == LSPRequestTypes.DOCUMENT_COMPLETION:\n    language = msg['language']\n    current_word = msg['current_word']\n    snippets = []\n    if language in self.language_snippets:\n        language_snippets = self.language_snippets[language]\n        if language_snippets[current_word]:\n            for node in language_snippets[current_word]:\n                trigger, info = node.value\n                for description in info:\n                    description_snippet = info[description]\n                    text = description_snippet['text']\n                    remove_trigger = description_snippet['remove_trigger']\n                    snippets.append({'kind': CompletionItemKind.SNIPPET,\n                        'insertText': text, 'label':\n                        f'{trigger} ({description})', 'sortText': trigger,\n                        'filterText': trigger, 'documentation': '',\n                        'provider': SNIPPETS_COMPLETION, 'remove_trigger':\n                        remove_trigger})\n    snippets = {'params': snippets}\n    self.sig_snippets_response.emit(_id, snippets)\nSlot(dict)",
        "CUT_2": "\"\"\"Handle one message\"\"\"\nmsg_type, _id, file, msg = [message[k] for k in ('type', 'id', 'file', 'msg')]\nlogger.debug('Perform request {0} with id {1}'.format(msg_type, _id))\nif msg_type == LSPRequestTypes.DOCUMENT_COMPLETION:\n    language = msg['language']\n    current_word = msg['current_word']\n    snippets = []\n    if language in self.language_snippets:\n        language_snippets = self.language_snippets[language]\n        if language_snippets[current_word]:\n            for node in language_snippets[current_word]:\n                trigger, info = node.value\n                for description in info:\n                    description_snippet = info[description]\n                    text = description_snippet['text']\n                    remove_trigger = description_snippet['remove_trigger']\n                    snippets.append({'kind': CompletionItemKind.SNIPPET,\n                        'insertText': text, 'label':\n                        f'{trigger} ({description})', 'sortText': trigger,\n                        'filterText': trigger, 'documentation': '',\n                        'provider': SNIPPETS_COMPLETION, 'remove_trigger':\n                        remove_trigger})\n    snippets = {'params': snippets}\n    self.sig_snippets_response.emit(_id, snippets)\nSlot(dict)",
        "CUT_3": "language_snippets = []\nload_snippets = snippets is None\nif load_snippets:\n    snippets = CONF.get('snippet-completions', language.lower(), {})\nfor trigger in snippets:\n    trigger_descriptions = snippets[trigger]\n    for description in trigger_descriptions:\n        if load_snippets:\n            this_snippet = Snippet(language=language, trigger_text=trigger,\n                description=description)\n            this_snippet.load()\n        else:\n            current_snippet = trigger_descriptions[description]\n            text = current_snippet['text']\n            remove_trigger = current_snippet['remove_trigger']\n            this_snippet = Snippet(language=language, trigger_text=trigger,\n                description=description, snippet_text=text, remove_trigger=\n                remove_trigger)\n        language_snippets.append(this_snippet)\nreturn language_snippets\n",
        "CUT_4": "language_snippets = []\nload_snippets = snippets is None\nif load_snippets:\n    snippets = CONF.get('snippet-completions', language.lower(), {})\nfor trigger in snippets:\n    trigger_descriptions = snippets[trigger]\n    for description in trigger_descriptions:\n        if load_snippets:\n            this_snippet = Snippet(language=language, trigger_text=trigger,\n                description=description)\n            this_snippet.load()\n        else:\n            current_snippet = trigger_descriptions[description]\n            text = current_snippet['text']\n            remove_trigger = current_snippet['remove_trigger']\n            this_snippet = Snippet(language=language, trigger_text=trigger,\n                description=description, snippet_text=text, remove_trigger=\n                remove_trigger)\n        language_snippets.append(this_snippet)\nreturn language_snippets\n",
        "CUT_5": "if self.language is not None and self.trigger_text != '':\n    state = CONF.get('snippet-completions', self.language.lower())\n    trigger_info = state[self.trigger_text]\n    snippet_info = trigger_info[self.description]\n    self.snippet_text = snippet_info['text']\n    self.remove_trigger = snippet_info['remove_trigger']\n"
    },
    {
        "functionName": "__init__",
        "className": "MainWindowMock",
        "fileName": "/spyder/plugins/completion/languageserver/tests/test_lsp_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "super(MainWindowMock, self).__init__(None)\nself.statusBar = Mock()\nself.console = Mock()\n",
        "CUT_1": "return Mock()\n",
        "CUT_2": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_3": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_4": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_5": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "test_config_dialog",
        "className": null,
        "fileName": "/spyder/plugins/completion/languageserver/tests/test_lsp_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpage = config_dialog.get_page()\nassert configpage\nconfigpage.save_to_conf()\npytest.mark.parametrize('config_dialog', [[MainWindowMock, [], [\n    LanguageServerPlugin]]], indirect=True)",
        "CUT_1": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_2": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_3": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_4": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "handle_response",
        "className": "CompletionManager",
        "fileName": "/spyder/plugins/completion/languageserver/tests/test_client.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "self.sig_response.emit(method, params)\nSlot(str, dict)",
        "CUT_1": "if method in self.handler_registry:\n    handler_name = self.handler_registry[method]\n    handler = getattr(self, handler_name)\n    handler(params)\n    self.lsp_response_signal.emit(method, params)\nSlot(str, dict)",
        "CUT_2": "if method in self.handler_registry:\n    handler_name = self.handler_registry[method]\n    handler = getattr(self, handler_name)\n    handler(params)\n    self.lsp_response_signal.emit(method, params)\nSlot(str, dict)",
        "CUT_3": "params = {'textDocument': {'uri': path_as_uri(params['file'])}, 'position':\n    {'line': params['line'], 'character': params['column']}}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_4": "params = {'textDocument': {'uri': path_as_uri(params['file'])}, 'position':\n    {'line': params['line'], 'character': params['column']}}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_5": "params = {'textDocument': {'uri': path_as_uri(params['file'])}, 'position':\n    {'line': params['line'], 'character': params['column']}}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_HOVER)"
    },
    {
        "functionName": "lsp_client_and_completion",
        "className": null,
        "fileName": "/spyder/plugins/completion/languageserver/tests/test_client.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create an LSP client/completion pair.\"\"\"\ncompletion = CompletionManager()\nclient = request.param.clients['python']['instance']\nreturn client, completion\npytest.fixture(scope='module', params=[pytest.lazy_fixture('lsp_manager'),\n    pytest.lazy_fixture('lsp_stdio_manager')])",
        "CUT_1": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_2": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_3": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_4": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_5": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n"
    },
    {
        "functionName": "test_didOpen",
        "className": null,
        "fileName": "/spyder/plugins/completion/languageserver/tests/test_client.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "client, completion = lsp_client_and_completion\nparams = {'file': 'test.py', 'language': 'python', 'version': 1, 'text': '',\n    'response_callback': completion.handle_response, 'codeeditor':\n    completion, 'requires_response': False}\nwith qtbot.waitSignal(completion.sig_response, timeout=30000) as blocker:\n    client.perform_request(LSPRequestTypes.DOCUMENT_DID_OPEN, params)\nresponse, _ = blocker.args\nassert response == 'textDocument/publishDiagnostics'\npytest.mark.slowpytest.mark.third",
        "CUT_1": "\"\"\"Handle completion response.\"\"\"\nargs = self.completion_args\nif args is None:\n    return\nself.completion_args = None\nposition, automatic = args\nstart_cursor = self.textCursor()\nstart_cursor.movePosition(QTextCursor.StartOfBlock)\nline_text = self.get_text(start_cursor.position(), 'eol')\nleading_whitespace = self.compute_whitespace(line_text)\nindentation_whitespace = ' ' * leading_whitespace\neol_char = self.get_line_separator()\ntry:\n    completions = params['params']\n    completions = [] if completions is None else [completion for completion in\n        completions if completion.get('insertText') or completion.get(\n        'textEdit', {}).get('newText')]\n    prefix = self.get_current_word(completion=True, valid_python_variable=False\n        )\n    if len(completions) == 1 and completions[0].get('insertText'\n        ) == prefix and not completions[0].get('textEdit', {}).get('newText'):\n        completions.pop()\n    replace_end = self.textCursor().position()\n    under_cursor = self.get_current_word_and_position(completion=True)\n    if under_cursor:\n        word, replace_start = under_cursor\n    else:\n        word = ''\n        replace_start = replace_end\n    first_letter = ''\n    if len(word) > 0:\n        first_letter = word[0]\n\n    def sort_key(completion):\n        if 'textEdit' in completion:\n            text_insertion = completion['textEdit']['newText']\n        else:\n            text_insertion = completion['insertText']\n        first_insert_letter = text_insertion[0]\n        case_mismatch = first_letter.isupper() and first_insert_letter.islower(\n            ) or first_letter.islower() and first_insert_letter.isupper()\n        return case_mismatch, completion['sortText']\n    completion_list = sorted(completions, key=sort_key)\n    for completion in completion_list:\n        if 'textEdit' in completion:\n            c_replace_start = completion['textEdit']['range']['start']\n            c_replace_end = completion['textEdit']['range']['end']\n            if (c_replace_start == replace_start and c_replace_end ==\n                replace_end):\n                insert_text = completion['textEdit']['newText']\n                completion['filterText'] = insert_text\n                completion['insertText'] = insert_text\n                del completion['textEdit']\n        if 'insertText' in completion:\n            insert_text = completion['insertText']\n            insert_text_lines = insert_text.splitlines()\n            reindented_text = [insert_text_lines[0]]\n            for insert_line in insert_text_lines[1:]:\n                insert_line = indentation_whitespace + insert_line\n                reindented_text.append(insert_line)\n            reindented_text = eol_char.join(reindented_text)\n            completion['insertText'] = reindented_text\n    self.completion_widget.show_list(completion_list, position, automatic)\n    self.kite_call_to_action.handle_processed_completions(completions)\nexcept RuntimeError:\n    self.kite_call_to_action.hide_coverage_cta()\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing completions')\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_2": "\"\"\"Handle completion response.\"\"\"\nargs = self.completion_args\nif args is None:\n    return\nself.completion_args = None\nposition, automatic = args\nstart_cursor = self.textCursor()\nstart_cursor.movePosition(QTextCursor.StartOfBlock)\nline_text = self.get_text(start_cursor.position(), 'eol')\nleading_whitespace = self.compute_whitespace(line_text)\nindentation_whitespace = ' ' * leading_whitespace\neol_char = self.get_line_separator()\ntry:\n    completions = params['params']\n    completions = [] if completions is None else [completion for completion in\n        completions if completion.get('insertText') or completion.get(\n        'textEdit', {}).get('newText')]\n    prefix = self.get_current_word(completion=True, valid_python_variable=False\n        )\n    if len(completions) == 1 and completions[0].get('insertText'\n        ) == prefix and not completions[0].get('textEdit', {}).get('newText'):\n        completions.pop()\n    replace_end = self.textCursor().position()\n    under_cursor = self.get_current_word_and_position(completion=True)\n    if under_cursor:\n        word, replace_start = under_cursor\n    else:\n        word = ''\n        replace_start = replace_end\n    first_letter = ''\n    if len(word) > 0:\n        first_letter = word[0]\n\n    def sort_key(completion):\n        if 'textEdit' in completion:\n            text_insertion = completion['textEdit']['newText']\n        else:\n            text_insertion = completion['insertText']\n        first_insert_letter = text_insertion[0]\n        case_mismatch = first_letter.isupper() and first_insert_letter.islower(\n            ) or first_letter.islower() and first_insert_letter.isupper()\n        return case_mismatch, completion['sortText']\n    completion_list = sorted(completions, key=sort_key)\n    for completion in completion_list:\n        if 'textEdit' in completion:\n            c_replace_start = completion['textEdit']['range']['start']\n            c_replace_end = completion['textEdit']['range']['end']\n            if (c_replace_start == replace_start and c_replace_end ==\n                replace_end):\n                insert_text = completion['textEdit']['newText']\n                completion['filterText'] = insert_text\n                completion['insertText'] = insert_text\n                del completion['textEdit']\n        if 'insertText' in completion:\n            insert_text = completion['insertText']\n            insert_text_lines = insert_text.splitlines()\n            reindented_text = [insert_text_lines[0]]\n            for insert_line in insert_text_lines[1:]:\n                insert_line = indentation_whitespace + insert_line\n                reindented_text.append(insert_line)\n            reindented_text = eol_char.join(reindented_text)\n            completion['insertText'] = reindented_text\n    self.completion_widget.show_list(completion_list, position, automatic)\n    self.kite_call_to_action.handle_processed_completions(completions)\nexcept RuntimeError:\n    self.kite_call_to_action.hide_coverage_cta()\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing completions')\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_3": "\"\"\"Stop completion plugin.\"\"\"\npass\n",
        "CUT_4": "\"\"\"Stop completion plugin.\"\"\"\npass\n",
        "CUT_5": "params = {'textDocument': {'uri': path_as_uri(params['file']), 'version':\n    params['version']}, 'contentChanges': [{'text': params['text']}]}\nreturn params\nsend_notification(method=LSPRequestTypes.DOCUMENT_DID_CHANGE)"
    },
    {
        "functionName": "test_get_signature",
        "className": null,
        "fileName": "/spyder/plugins/completion/languageserver/tests/test_client.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "client, completion = lsp_client_and_completion\nparams = {'file': 'test.py', 'language': 'python', 'version': 1, 'text':\n    \"\"\"import os\nos.walk(\n\"\"\", 'codeeditor': completion,\n    'requires_response': False}\nwith qtbot.waitSignal(completion.sig_response, timeout=30000):\n    client.perform_request(LSPRequestTypes.DOCUMENT_DID_CHANGE, params)\nsignature_params = {'file': 'test.py', 'line': 1, 'column': 10,\n    'requires_response': True, 'response_callback': completion.handle_response}\nwith qtbot.waitSignal(completion.sig_response, timeout=30000) as blocker:\n    client.perform_request(LSPRequestTypes.DOCUMENT_SIGNATURE, signature_params\n        )\n_, response = blocker.args\nassert response['params']['signatures']['label'].startswith('walk')\npytest.mark.slowpytest.mark.third",
        "CUT_1": "params = {'textDocument': {'uri': path_as_uri(params['file'])}, 'position':\n    {'line': params['line'], 'character': params['column']}}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_SIGNATURE)",
        "CUT_2": "params = {'textDocument': {'uri': path_as_uri(params['file'])}, 'position':\n    {'line': params['line'], 'character': params['column']}}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_SIGNATURE)",
        "CUT_3": "\"\"\"Handle completion response.\"\"\"\nargs = self.completion_args\nif args is None:\n    return\nself.completion_args = None\nposition, automatic = args\nstart_cursor = self.textCursor()\nstart_cursor.movePosition(QTextCursor.StartOfBlock)\nline_text = self.get_text(start_cursor.position(), 'eol')\nleading_whitespace = self.compute_whitespace(line_text)\nindentation_whitespace = ' ' * leading_whitespace\neol_char = self.get_line_separator()\ntry:\n    completions = params['params']\n    completions = [] if completions is None else [completion for completion in\n        completions if completion.get('insertText') or completion.get(\n        'textEdit', {}).get('newText')]\n    prefix = self.get_current_word(completion=True, valid_python_variable=False\n        )\n    if len(completions) == 1 and completions[0].get('insertText'\n        ) == prefix and not completions[0].get('textEdit', {}).get('newText'):\n        completions.pop()\n    replace_end = self.textCursor().position()\n    under_cursor = self.get_current_word_and_position(completion=True)\n    if under_cursor:\n        word, replace_start = under_cursor\n    else:\n        word = ''\n        replace_start = replace_end\n    first_letter = ''\n    if len(word) > 0:\n        first_letter = word[0]\n\n    def sort_key(completion):\n        if 'textEdit' in completion:\n            text_insertion = completion['textEdit']['newText']\n        else:\n            text_insertion = completion['insertText']\n        first_insert_letter = text_insertion[0]\n        case_mismatch = first_letter.isupper() and first_insert_letter.islower(\n            ) or first_letter.islower() and first_insert_letter.isupper()\n        return case_mismatch, completion['sortText']\n    completion_list = sorted(completions, key=sort_key)\n    for completion in completion_list:\n        if 'textEdit' in completion:\n            c_replace_start = completion['textEdit']['range']['start']\n            c_replace_end = completion['textEdit']['range']['end']\n            if (c_replace_start == replace_start and c_replace_end ==\n                replace_end):\n                insert_text = completion['textEdit']['newText']\n                completion['filterText'] = insert_text\n                completion['insertText'] = insert_text\n                del completion['textEdit']\n        if 'insertText' in completion:\n            insert_text = completion['insertText']\n            insert_text_lines = insert_text.splitlines()\n            reindented_text = [insert_text_lines[0]]\n            for insert_line in insert_text_lines[1:]:\n                insert_line = indentation_whitespace + insert_line\n                reindented_text.append(insert_line)\n            reindented_text = eol_char.join(reindented_text)\n            completion['insertText'] = reindented_text\n    self.completion_widget.show_list(completion_list, position, automatic)\n    self.kite_call_to_action.handle_processed_completions(completions)\nexcept RuntimeError:\n    self.kite_call_to_action.hide_coverage_cta()\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing completions')\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_4": "\"\"\"Handle completion response.\"\"\"\nargs = self.completion_args\nif args is None:\n    return\nself.completion_args = None\nposition, automatic = args\nstart_cursor = self.textCursor()\nstart_cursor.movePosition(QTextCursor.StartOfBlock)\nline_text = self.get_text(start_cursor.position(), 'eol')\nleading_whitespace = self.compute_whitespace(line_text)\nindentation_whitespace = ' ' * leading_whitespace\neol_char = self.get_line_separator()\ntry:\n    completions = params['params']\n    completions = [] if completions is None else [completion for completion in\n        completions if completion.get('insertText') or completion.get(\n        'textEdit', {}).get('newText')]\n    prefix = self.get_current_word(completion=True, valid_python_variable=False\n        )\n    if len(completions) == 1 and completions[0].get('insertText'\n        ) == prefix and not completions[0].get('textEdit', {}).get('newText'):\n        completions.pop()\n    replace_end = self.textCursor().position()\n    under_cursor = self.get_current_word_and_position(completion=True)\n    if under_cursor:\n        word, replace_start = under_cursor\n    else:\n        word = ''\n        replace_start = replace_end\n    first_letter = ''\n    if len(word) > 0:\n        first_letter = word[0]\n\n    def sort_key(completion):\n        if 'textEdit' in completion:\n            text_insertion = completion['textEdit']['newText']\n        else:\n            text_insertion = completion['insertText']\n        first_insert_letter = text_insertion[0]\n        case_mismatch = first_letter.isupper() and first_insert_letter.islower(\n            ) or first_letter.islower() and first_insert_letter.isupper()\n        return case_mismatch, completion['sortText']\n    completion_list = sorted(completions, key=sort_key)\n    for completion in completion_list:\n        if 'textEdit' in completion:\n            c_replace_start = completion['textEdit']['range']['start']\n            c_replace_end = completion['textEdit']['range']['end']\n            if (c_replace_start == replace_start and c_replace_end ==\n                replace_end):\n                insert_text = completion['textEdit']['newText']\n                completion['filterText'] = insert_text\n                completion['insertText'] = insert_text\n                del completion['textEdit']\n        if 'insertText' in completion:\n            insert_text = completion['insertText']\n            insert_text_lines = insert_text.splitlines()\n            reindented_text = [insert_text_lines[0]]\n            for insert_line in insert_text_lines[1:]:\n                insert_line = indentation_whitespace + insert_line\n                reindented_text.append(insert_line)\n            reindented_text = eol_char.join(reindented_text)\n            completion['insertText'] = reindented_text\n    self.completion_widget.show_list(completion_list, position, automatic)\n    self.kite_call_to_action.handle_processed_completions(completions)\nexcept RuntimeError:\n    self.kite_call_to_action.hide_coverage_cta()\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing completions')\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_5": "params = {'textDocument': {'uri': path_as_uri(params['file']), 'version':\n    params['version']}, 'contentChanges': [{'text': params['text']}]}\nreturn params\nsend_notification(method=LSPRequestTypes.DOCUMENT_DID_CHANGE)"
    },
    {
        "functionName": "test_get_completions",
        "className": null,
        "fileName": "/spyder/plugins/completion/languageserver/tests/test_client.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "client, completion = lsp_client_and_completion\nparams = {'file': 'test.py', 'language': 'python', 'version': 1, 'text':\n    'import o', 'codeeditor': completion, 'requires_response': False}\nwith qtbot.waitSignal(completion.sig_response, timeout=30000):\n    client.perform_request(LSPRequestTypes.DOCUMENT_DID_CHANGE, params)\ncompletion_params = {'file': 'test.py', 'line': 0, 'column': 8,\n    'requires_response': True, 'response_callback': completion.handle_response}\nwith qtbot.waitSignal(completion.sig_response, timeout=30000) as blocker:\n    client.perform_request(LSPRequestTypes.DOCUMENT_COMPLETION,\n        completion_params)\n_, response = blocker.args\ncompletions = response['params']\nassert 'os' in [x['label'] for x in completions]\npytest.mark.slowpytest.mark.third",
        "CUT_1": "\"\"\"Handle completion response.\"\"\"\nargs = self.completion_args\nif args is None:\n    return\nself.completion_args = None\nposition, automatic = args\nstart_cursor = self.textCursor()\nstart_cursor.movePosition(QTextCursor.StartOfBlock)\nline_text = self.get_text(start_cursor.position(), 'eol')\nleading_whitespace = self.compute_whitespace(line_text)\nindentation_whitespace = ' ' * leading_whitespace\neol_char = self.get_line_separator()\ntry:\n    completions = params['params']\n    completions = [] if completions is None else [completion for completion in\n        completions if completion.get('insertText') or completion.get(\n        'textEdit', {}).get('newText')]\n    prefix = self.get_current_word(completion=True, valid_python_variable=False\n        )\n    if len(completions) == 1 and completions[0].get('insertText'\n        ) == prefix and not completions[0].get('textEdit', {}).get('newText'):\n        completions.pop()\n    replace_end = self.textCursor().position()\n    under_cursor = self.get_current_word_and_position(completion=True)\n    if under_cursor:\n        word, replace_start = under_cursor\n    else:\n        word = ''\n        replace_start = replace_end\n    first_letter = ''\n    if len(word) > 0:\n        first_letter = word[0]\n\n    def sort_key(completion):\n        if 'textEdit' in completion:\n            text_insertion = completion['textEdit']['newText']\n        else:\n            text_insertion = completion['insertText']\n        first_insert_letter = text_insertion[0]\n        case_mismatch = first_letter.isupper() and first_insert_letter.islower(\n            ) or first_letter.islower() and first_insert_letter.isupper()\n        return case_mismatch, completion['sortText']\n    completion_list = sorted(completions, key=sort_key)\n    for completion in completion_list:\n        if 'textEdit' in completion:\n            c_replace_start = completion['textEdit']['range']['start']\n            c_replace_end = completion['textEdit']['range']['end']\n            if (c_replace_start == replace_start and c_replace_end ==\n                replace_end):\n                insert_text = completion['textEdit']['newText']\n                completion['filterText'] = insert_text\n                completion['insertText'] = insert_text\n                del completion['textEdit']\n        if 'insertText' in completion:\n            insert_text = completion['insertText']\n            insert_text_lines = insert_text.splitlines()\n            reindented_text = [insert_text_lines[0]]\n            for insert_line in insert_text_lines[1:]:\n                insert_line = indentation_whitespace + insert_line\n                reindented_text.append(insert_line)\n            reindented_text = eol_char.join(reindented_text)\n            completion['insertText'] = reindented_text\n    self.completion_widget.show_list(completion_list, position, automatic)\n    self.kite_call_to_action.handle_processed_completions(completions)\nexcept RuntimeError:\n    self.kite_call_to_action.hide_coverage_cta()\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing completions')\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_2": "\"\"\"Handle completion response.\"\"\"\nargs = self.completion_args\nif args is None:\n    return\nself.completion_args = None\nposition, automatic = args\nstart_cursor = self.textCursor()\nstart_cursor.movePosition(QTextCursor.StartOfBlock)\nline_text = self.get_text(start_cursor.position(), 'eol')\nleading_whitespace = self.compute_whitespace(line_text)\nindentation_whitespace = ' ' * leading_whitespace\neol_char = self.get_line_separator()\ntry:\n    completions = params['params']\n    completions = [] if completions is None else [completion for completion in\n        completions if completion.get('insertText') or completion.get(\n        'textEdit', {}).get('newText')]\n    prefix = self.get_current_word(completion=True, valid_python_variable=False\n        )\n    if len(completions) == 1 and completions[0].get('insertText'\n        ) == prefix and not completions[0].get('textEdit', {}).get('newText'):\n        completions.pop()\n    replace_end = self.textCursor().position()\n    under_cursor = self.get_current_word_and_position(completion=True)\n    if under_cursor:\n        word, replace_start = under_cursor\n    else:\n        word = ''\n        replace_start = replace_end\n    first_letter = ''\n    if len(word) > 0:\n        first_letter = word[0]\n\n    def sort_key(completion):\n        if 'textEdit' in completion:\n            text_insertion = completion['textEdit']['newText']\n        else:\n            text_insertion = completion['insertText']\n        first_insert_letter = text_insertion[0]\n        case_mismatch = first_letter.isupper() and first_insert_letter.islower(\n            ) or first_letter.islower() and first_insert_letter.isupper()\n        return case_mismatch, completion['sortText']\n    completion_list = sorted(completions, key=sort_key)\n    for completion in completion_list:\n        if 'textEdit' in completion:\n            c_replace_start = completion['textEdit']['range']['start']\n            c_replace_end = completion['textEdit']['range']['end']\n            if (c_replace_start == replace_start and c_replace_end ==\n                replace_end):\n                insert_text = completion['textEdit']['newText']\n                completion['filterText'] = insert_text\n                completion['insertText'] = insert_text\n                del completion['textEdit']\n        if 'insertText' in completion:\n            insert_text = completion['insertText']\n            insert_text_lines = insert_text.splitlines()\n            reindented_text = [insert_text_lines[0]]\n            for insert_line in insert_text_lines[1:]:\n                insert_line = indentation_whitespace + insert_line\n                reindented_text.append(insert_line)\n            reindented_text = eol_char.join(reindented_text)\n            completion['insertText'] = reindented_text\n    self.completion_widget.show_list(completion_list, position, automatic)\n    self.kite_call_to_action.handle_processed_completions(completions)\nexcept RuntimeError:\n    self.kite_call_to_action.hide_coverage_cta()\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing completions')\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_3": "logger.debug(response)\nif response is None:\n    return {'params': []}\nspyder_completions = []\ncompletions = response['completions']\nif completions is not None:\n    for i, completion in enumerate(completions):\n        entry = {'kind': KITE_DOCUMENT_TYPES.get(completion['hint'],\n            CompletionItemKind.TEXT), 'label': completion['display'],\n            'textEdit': {'newText': convert_text_snippet(completion[\n            'snippet']), 'range': {'start': completion['replace']['begin'],\n            'end': completion['replace']['end']}}, 'filterText': '',\n            'sortText': (i, 0), 'documentation': completion['documentation'\n            ]['text'], 'provider': KITE_COMPLETION}\n        spyder_completions.append(entry)\n        if 'children' in completion:\n            for j, child in enumerate(completion['children']):\n                child_entry = {'kind': KITE_DOCUMENT_TYPES.get(child['hint'\n                    ], CompletionItemKind.TEXT), 'label': ' ' * 2 + child[\n                    'display'], 'textEdit': {'newText':\n                    convert_text_snippet(child['snippet']), 'range': {\n                    'start': child['replace']['begin'], 'end': child[\n                    'replace']['end']}}, 'insertText': convert_text_snippet\n                    (child['snippet']), 'filterText': '', 'sortText': (i, j +\n                    1), 'documentation': child['documentation']['text'],\n                    'provider': KITE_COMPLETION}\n                spyder_completions.append(child_entry)\nreturn {'params': spyder_completions}\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_4": "logger.debug(response)\nif response is None:\n    return {'params': []}\nspyder_completions = []\ncompletions = response['completions']\nif completions is not None:\n    for i, completion in enumerate(completions):\n        entry = {'kind': KITE_DOCUMENT_TYPES.get(completion['hint'],\n            CompletionItemKind.TEXT), 'label': completion['display'],\n            'textEdit': {'newText': convert_text_snippet(completion[\n            'snippet']), 'range': {'start': completion['replace']['begin'],\n            'end': completion['replace']['end']}}, 'filterText': '',\n            'sortText': (i, 0), 'documentation': completion['documentation'\n            ]['text'], 'provider': KITE_COMPLETION}\n        spyder_completions.append(entry)\n        if 'children' in completion:\n            for j, child in enumerate(completion['children']):\n                child_entry = {'kind': KITE_DOCUMENT_TYPES.get(child['hint'\n                    ], CompletionItemKind.TEXT), 'label': ' ' * 2 + child[\n                    'display'], 'textEdit': {'newText':\n                    convert_text_snippet(child['snippet']), 'range': {\n                    'start': child['replace']['begin'], 'end': child[\n                    'replace']['end']}}, 'insertText': convert_text_snippet\n                    (child['snippet']), 'filterText': '', 'sortText': (i, j +\n                    1), 'documentation': child['documentation']['text'],\n                    'provider': KITE_COMPLETION}\n                spyder_completions.append(child_entry)\nreturn {'params': spyder_completions}\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_5": "\"\"\"Send request/notification/response to all LSP servers.\"\"\"\nparams['requires_response'] = requires_response\nparams['response_instance'] = self\nself.main.completions.broadcast_notification(method, params)\n"
    },
    {
        "functionName": "test_go_to_definition",
        "className": null,
        "fileName": "/spyder/plugins/completion/languageserver/tests/test_client.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "client, completion = lsp_client_and_completion\nparams = {'file': 'test.py', 'language': 'python', 'version': 1, 'text':\n    \"\"\"import os\nos.walk\n\"\"\", 'codeeditor': completion, 'requires_response':\n    False}\nwith qtbot.waitSignal(completion.sig_response, timeout=30000):\n    client.perform_request(LSPRequestTypes.DOCUMENT_DID_CHANGE, params)\ngo_to_definition_params = {'file': 'test.py', 'line': 0, 'column': 19,\n    'requires_response': True, 'response_callback': completion.handle_response}\nwith qtbot.waitSignal(completion.sig_response, timeout=30000) as blocker:\n    client.perform_request(LSPRequestTypes.DOCUMENT_DEFINITION,\n        go_to_definition_params)\n_, response = blocker.args\ndefinition = response['params']\nassert 'os.py' in definition['file']\npytest.mark.slowpytest.mark.third",
        "CUT_1": "params = {'textDocument': {'uri': path_as_uri(params['file'])}, 'position':\n    {'line': params['line'], 'character': params['column']}}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_2": "params = {'textDocument': {'uri': path_as_uri(params['file'])}, 'position':\n    {'line': params['line'], 'character': params['column']}}\nreturn params\nsend_request(method=LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_3": "\"\"\"Handle completion response.\"\"\"\nargs = self.completion_args\nif args is None:\n    return\nself.completion_args = None\nposition, automatic = args\nstart_cursor = self.textCursor()\nstart_cursor.movePosition(QTextCursor.StartOfBlock)\nline_text = self.get_text(start_cursor.position(), 'eol')\nleading_whitespace = self.compute_whitespace(line_text)\nindentation_whitespace = ' ' * leading_whitespace\neol_char = self.get_line_separator()\ntry:\n    completions = params['params']\n    completions = [] if completions is None else [completion for completion in\n        completions if completion.get('insertText') or completion.get(\n        'textEdit', {}).get('newText')]\n    prefix = self.get_current_word(completion=True, valid_python_variable=False\n        )\n    if len(completions) == 1 and completions[0].get('insertText'\n        ) == prefix and not completions[0].get('textEdit', {}).get('newText'):\n        completions.pop()\n    replace_end = self.textCursor().position()\n    under_cursor = self.get_current_word_and_position(completion=True)\n    if under_cursor:\n        word, replace_start = under_cursor\n    else:\n        word = ''\n        replace_start = replace_end\n    first_letter = ''\n    if len(word) > 0:\n        first_letter = word[0]\n\n    def sort_key(completion):\n        if 'textEdit' in completion:\n            text_insertion = completion['textEdit']['newText']\n        else:\n            text_insertion = completion['insertText']\n        first_insert_letter = text_insertion[0]\n        case_mismatch = first_letter.isupper() and first_insert_letter.islower(\n            ) or first_letter.islower() and first_insert_letter.isupper()\n        return case_mismatch, completion['sortText']\n    completion_list = sorted(completions, key=sort_key)\n    for completion in completion_list:\n        if 'textEdit' in completion:\n            c_replace_start = completion['textEdit']['range']['start']\n            c_replace_end = completion['textEdit']['range']['end']\n            if (c_replace_start == replace_start and c_replace_end ==\n                replace_end):\n                insert_text = completion['textEdit']['newText']\n                completion['filterText'] = insert_text\n                completion['insertText'] = insert_text\n                del completion['textEdit']\n        if 'insertText' in completion:\n            insert_text = completion['insertText']\n            insert_text_lines = insert_text.splitlines()\n            reindented_text = [insert_text_lines[0]]\n            for insert_line in insert_text_lines[1:]:\n                insert_line = indentation_whitespace + insert_line\n                reindented_text.append(insert_line)\n            reindented_text = eol_char.join(reindented_text)\n            completion['insertText'] = reindented_text\n    self.completion_widget.show_list(completion_list, position, automatic)\n    self.kite_call_to_action.handle_processed_completions(completions)\nexcept RuntimeError:\n    self.kite_call_to_action.hide_coverage_cta()\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing completions')\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_4": "\"\"\"Handle completion response.\"\"\"\nargs = self.completion_args\nif args is None:\n    return\nself.completion_args = None\nposition, automatic = args\nstart_cursor = self.textCursor()\nstart_cursor.movePosition(QTextCursor.StartOfBlock)\nline_text = self.get_text(start_cursor.position(), 'eol')\nleading_whitespace = self.compute_whitespace(line_text)\nindentation_whitespace = ' ' * leading_whitespace\neol_char = self.get_line_separator()\ntry:\n    completions = params['params']\n    completions = [] if completions is None else [completion for completion in\n        completions if completion.get('insertText') or completion.get(\n        'textEdit', {}).get('newText')]\n    prefix = self.get_current_word(completion=True, valid_python_variable=False\n        )\n    if len(completions) == 1 and completions[0].get('insertText'\n        ) == prefix and not completions[0].get('textEdit', {}).get('newText'):\n        completions.pop()\n    replace_end = self.textCursor().position()\n    under_cursor = self.get_current_word_and_position(completion=True)\n    if under_cursor:\n        word, replace_start = under_cursor\n    else:\n        word = ''\n        replace_start = replace_end\n    first_letter = ''\n    if len(word) > 0:\n        first_letter = word[0]\n\n    def sort_key(completion):\n        if 'textEdit' in completion:\n            text_insertion = completion['textEdit']['newText']\n        else:\n            text_insertion = completion['insertText']\n        first_insert_letter = text_insertion[0]\n        case_mismatch = first_letter.isupper() and first_insert_letter.islower(\n            ) or first_letter.islower() and first_insert_letter.isupper()\n        return case_mismatch, completion['sortText']\n    completion_list = sorted(completions, key=sort_key)\n    for completion in completion_list:\n        if 'textEdit' in completion:\n            c_replace_start = completion['textEdit']['range']['start']\n            c_replace_end = completion['textEdit']['range']['end']\n            if (c_replace_start == replace_start and c_replace_end ==\n                replace_end):\n                insert_text = completion['textEdit']['newText']\n                completion['filterText'] = insert_text\n                completion['insertText'] = insert_text\n                del completion['textEdit']\n        if 'insertText' in completion:\n            insert_text = completion['insertText']\n            insert_text_lines = insert_text.splitlines()\n            reindented_text = [insert_text_lines[0]]\n            for insert_line in insert_text_lines[1:]:\n                insert_line = indentation_whitespace + insert_line\n                reindented_text.append(insert_line)\n            reindented_text = eol_char.join(reindented_text)\n            completion['insertText'] = reindented_text\n    self.completion_widget.show_list(completion_list, position, automatic)\n    self.kite_call_to_action.handle_processed_completions(completions)\nexcept RuntimeError:\n    self.kite_call_to_action.hide_coverage_cta()\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing completions')\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_5": "params = {'textDocument': {'uri': path_as_uri(params['file']), 'version':\n    params['version']}, 'contentChanges': [{'text': params['text']}]}\nreturn params\nsend_notification(method=LSPRequestTypes.DOCUMENT_DID_CHANGE)"
    },
    {
        "functionName": "test_local_signature",
        "className": null,
        "fileName": "/spyder/plugins/completion/languageserver/tests/test_client.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "client, completion = lsp_client_and_completion\ntext = dedent(\n    \"\"\"\n    def test(a, b):\n        \"\"\\\"Test docstring\"\"\\\"\n        pass\n    test\"\"\"\n    )\nparams = {'file': 'test.py', 'language': 'python', 'version': 1, 'text':\n    text, 'codeeditor': completion, 'requires_response': False}\nwith qtbot.waitSignal(completion.sig_response, timeout=30000) as blocker:\n    client.perform_request(LSPRequestTypes.DOCUMENT_DID_CHANGE, params)\nsignature_params = {'file': 'test.py', 'line': 4, 'column': 0,\n    'requires_response': True, 'response_callback': completion.handle_response}\nwith qtbot.waitSignal(completion.sig_response, timeout=30000) as blocker:\n    client.perform_request(LSPRequestTypes.DOCUMENT_HOVER, signature_params)\n_, response = blocker.args\ndefinition = response['params']\nassert 'Test docstring' in definition\npytest.mark.slowpytest.mark.third",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "params = {'textDocument': {'uri': path_as_uri(params['file']), 'version':\n    params['version']}, 'contentChanges': [{'text': params['text']}]}\nreturn params\nsend_notification(method=LSPRequestTypes.DOCUMENT_DID_CHANGE)"
    },
    {
        "functionName": "test_send_workspace_folders_change",
        "className": null,
        "fileName": "/spyder/plugins/completion/languageserver/tests/test_client.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "client, completion = lsp_client_and_completion\nfolder = '/tmp/'\nparams = {'folder': folder, 'kind': WorkspaceUpdateKind.ADDITION,\n    'instance': ''}\nclient.send_workspace_folders_change(params)\nassert folder in client.watched_folders\nparams = {'folder': folder, 'kind': WorkspaceUpdateKind.DELETION,\n    'instance': ''}\nclient.send_workspace_folders_change(params)\nassert folder not in client.watched_folders\npytest.mark.slowpytest.mark.third",
        "CUT_1": "folder = params['folder']\nworkspace_watcher = params['instance']\nfolder_uri = path_as_uri(folder)\nadded_folders = []\nremoved_folders = []\nif params['kind'] == WorkspaceUpdateKind.ADDITION:\n    if folder not in self.watched_folders:\n        self.watched_folders[folder] = {'uri': folder_uri, 'instance':\n            workspace_watcher}\n        added_folders.append({'uri': folder_uri, 'name': folder})\nelif params['kind'] == WorkspaceUpdateKind.DELETION:\n    if folder in self.watched_folders:\n        self.watched_folders.pop(folder)\n        removed_folders.append({'uri': folder_uri, 'name': folder})\nworkspace_settings = self.server_capabilites['workspace']\nrequest_params = {'event': {'added': added_folders, 'removed': removed_folders}\n    }\nif workspace_settings['workspaceFolders']['supported']:\n    logger.debug('Workspace folders change: {0} -> {1}'.format(folder,\n        params['kind']))\nelse:\n    request_params[ClientConstants.CANCEL] = True\nreturn request_params\nsend_notification(method=LSPRequestTypes.WORKSPACE_FOLDERS_CHANGE)",
        "CUT_2": "folder = params['folder']\nworkspace_watcher = params['instance']\nfolder_uri = path_as_uri(folder)\nadded_folders = []\nremoved_folders = []\nif params['kind'] == WorkspaceUpdateKind.ADDITION:\n    if folder not in self.watched_folders:\n        self.watched_folders[folder] = {'uri': folder_uri, 'instance':\n            workspace_watcher}\n        added_folders.append({'uri': folder_uri, 'name': folder})\nelif params['kind'] == WorkspaceUpdateKind.DELETION:\n    if folder in self.watched_folders:\n        self.watched_folders.pop(folder)\n        removed_folders.append({'uri': folder_uri, 'name': folder})\nworkspace_settings = self.server_capabilites['workspace']\nrequest_params = {'event': {'added': added_folders, 'removed': removed_folders}\n    }\nif workspace_settings['workspaceFolders']['supported']:\n    logger.debug('Workspace folders change: {0} -> {1}'.format(folder,\n        params['kind']))\nelse:\n    request_params[ClientConstants.CANCEL] = True\nreturn request_params\nsend_notification(method=LSPRequestTypes.WORKSPACE_FOLDERS_CHANGE)",
        "CUT_3": "\"\"\"New folder\"\"\"\ntitle = _('New folder')\nsubtitle = _('Folder name:')\nself.create_new_folder(basedir, title, subtitle, is_package=False)\n",
        "CUT_4": "\"\"\"New folder\"\"\"\ntitle = _('New folder')\nsubtitle = _('Folder name:')\nself.create_new_folder(basedir, title, subtitle, is_package=False)\n",
        "CUT_5": "\"\"\"Notify LSP server to unregister project path.\"\"\"\nparams = {'folder': path, 'instance': self, 'kind': 'deletion'}\nreturn params\nrequest(method=LSPRequestTypes.WORKSPACE_FOLDERS_CHANGE, requires_response=\n    False)"
    },
    {
        "functionName": "tokens_fixture",
        "className": null,
        "fileName": "/spyder/plugins/completion/fallback/tests/test_fallback.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "with open(TOKENS_FILE, 'r') as f:\n    tokens = json.load(f)\nreturn tokens\npytest.fixture",
        "CUT_1": "tokens = list(response['params'])\nself.sig_recv_tokens.emit(list(tokens))\n",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "\"\"\"Split source code into python identifier-like tokens\"\"\"\ntokens = set(re.split('[^0-9a-zA-Z_.]', source_code))\nvalid = re.compile('[a-zA-Z_]')\nreturn [token for token in tokens if re.match(valid, token)]\n",
        "CUT_4": "\"\"\"Split source code into python identifier-like tokens\"\"\"\ntokens = set(re.split('[^0-9a-zA-Z_.]', source_code))\nvalid = re.compile('[a-zA-Z_]')\nreturn [token for token in tokens if re.match(valid, token)]\n",
        "CUT_5": "\"\"\"Load a json file as a dictionary\"\"\"\ntry:\n    if PY2:\n        args = 'rb'\n    else:\n        args = 'r'\n    with open(filename, args) as fid:\n        data = json.load(fid)\n    return data, None\nexcept Exception as err:\n    return None, str(err)\n"
    },
    {
        "functionName": "file_fixture",
        "className": null,
        "fileName": "/spyder/plugins/completion/fallback/tests/test_fallback.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "ext = request.param\nfilename = 'example.{0}'.format(ext)\nexample_file = osp.join(DATA_PATH, filename)\nwith open(example_file) as f:\n    contents = f.read()\nreturn filename, set(tokens_fixture[filename]), contents\npytest.fixture",
        "CUT_1": "ext = osp.splitext(filename)[1].lower()\nif ext in self.load_funcs:\n    return self.load_funcs[ext](filename)\nelse:\n    return None, \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_2": "ext = osp.splitext(filename)[1].lower()\nif ext in self.save_funcs:\n    return self.save_funcs[ext](data, filename)\nelse:\n    return \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_3": "\"\"\"Get file language from filename\"\"\"\next = osp.splitext(filename)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nlanguage = ext\nif not ext:\n    if text is None:\n        text, _enc = encoding.read(filename)\n    for line in text.splitlines():\n        if not line.strip():\n            continue\n        if line.startswith('#!'):\n            shebang = line[2:]\n            if 'python' in shebang:\n                language = 'python'\n        else:\n            break\nreturn language\n",
        "CUT_4": "\"\"\"Get file language from filename\"\"\"\next = osp.splitext(filename)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nlanguage = ext\nif not ext:\n    if text is None:\n        text, _enc = encoding.read(filename)\n    for line in text.splitlines():\n        if not line.strip():\n            continue\n        if line.startswith('#!'):\n            shebang = line[2:]\n            if 'python' in shebang:\n                language = 'python'\n        else:\n            break\nreturn language\n",
        "CUT_5": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n"
    },
    {
        "functionName": "fallback_fixture",
        "className": null,
        "fileName": "/spyder/plugins/completion/fallback/tests/test_fallback.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "fallback, completions = fallback_completions\ndiff_match = diff_match_patch()\nreturn fallback, completions, diff_match\npytest.fixture(scope='module')",
        "CUT_1": "fallback = FallbackPlugin(None)\ncompletions = CompletionManagerMock(None)\nqtbot_module.addWidget(fallback)\nqtbot_module.addWidget(completions)\nwith qtbot_module.waitSignal(fallback.sig_plugin_ready, timeout=30000):\n    fallback.start()\ndef teardown():\n    fallback.shutdown()\nrequest.addfinalizer(teardown)\nfallback.sig_response_ready.connect(completions.handle_response)\nreturn fallback, completions\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"CodeEditor instance with Fallback enabled.\"\"\"\ncompletions = CompletionManager(None, ['fallback'])\ncompletions.start()\ncompletions.start_client('python')\ncompletions.language_status['python']['fallback'] = True\nqtbot_module.addWidget(completions)\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.show()\neditor.sig_perform_completion_request.connect(completions.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\neditor.completions_available = True\nqtbot_module.wait(2000)\ndef teardown():\n    completions.shutdown()\n    editor.hide()\n    editor.completion_widget.hide()\nrequest.addfinalizer(teardown)\nfallback = completions.get_client('fallback')\nreturn editor, fallback\npytest.fixture",
        "CUT_3": "fallback.shutdown()\n",
        "CUT_4": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n",
        "CUT_5": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n"
    },
    {
        "functionName": "test_file_open_close",
        "className": null,
        "fileName": "/spyder/plugins/completion/fallback/tests/test_fallback.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "fallback, completions, diff_match = fallback_fixture\nopen_request = {'file': 'test.py', 'text': TEST_FILE, 'offset': -1}\nfallback.send_request('python', LSPRequestTypes.DOCUMENT_DID_OPEN, open_request\n    )\nqtbot_module.wait(1000)\nassert 'test.py' in fallback.fallback_actor.file_tokens\nclose_request = {'file': 'test.py'}\nfallback.send_request('python', LSPRequestTypes.DOCUMENT_DID_CLOSE,\n    close_request)\nqtbot_module.wait(1000)\nassert 'test.py' not in fallback.fallback_actor.file_tokens\npytest.mark.slow",
        "CUT_1": "fallback = FallbackPlugin(None)\ncompletions = CompletionManagerMock(None)\nqtbot_module.addWidget(fallback)\nqtbot_module.addWidget(completions)\nwith qtbot_module.waitSignal(fallback.sig_plugin_ready, timeout=30000):\n    fallback.start()\ndef teardown():\n    fallback.shutdown()\nrequest.addfinalizer(teardown)\nfallback.sig_response_ready.connect(completions.handle_response)\nreturn fallback, completions\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"CodeEditor instance with Fallback enabled.\"\"\"\ncompletions = CompletionManager(None, ['fallback'])\ncompletions.start()\ncompletions.start_client('python')\ncompletions.language_status['python']['fallback'] = True\nqtbot_module.addWidget(completions)\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.show()\neditor.sig_perform_completion_request.connect(completions.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\neditor.completions_available = True\nqtbot_module.wait(2000)\ndef teardown():\n    completions.shutdown()\n    editor.hide()\n    editor.completion_widget.hide()\nrequest.addfinalizer(teardown)\nfallback = completions.get_client('fallback')\nreturn editor, fallback\npytest.fixture",
        "CUT_3": "fallback.shutdown()\n",
        "CUT_4": "\"\"\"Handle one message\"\"\"\nmsg_type, _id, file, msg = [message[k] for k in ('type', 'id', 'file', 'msg')]\nlogger.debug('Perform request {0} with id {1}'.format(msg_type, _id))\nif msg_type == LSPRequestTypes.DOCUMENT_DID_OPEN:\n    self.file_tokens[file] = {'text': msg['text'], 'offset': msg['offset'],\n        'language': msg['language']}\nelif msg_type == LSPRequestTypes.DOCUMENT_DID_CHANGE:\n    if file not in self.file_tokens:\n        self.file_tokens[file] = {'text': '', 'offset': msg['offset'],\n            'language': msg['language']}\n    diff = msg['diff']\n    text = self.file_tokens[file]\n    text['offset'] = msg['offset']\n    text, _ = self.diff_patch.patch_apply(diff, text['text'])\n    self.file_tokens[file]['text'] = text\nelif msg_type == LSPRequestTypes.DOCUMENT_DID_CLOSE:\n    self.file_tokens.pop(file, {})\nelif msg_type == LSPRequestTypes.DOCUMENT_COMPLETION:\n    tokens = []\n    if file in self.file_tokens:\n        text_info = self.file_tokens[file]\n        tokens = self.tokenize(text_info['text'], text_info['offset'],\n            text_info['language'], msg['current_word'])\n    tokens = {'params': tokens}\n    self.sig_set_tokens.emit(_id, tokens)\nSlot(dict)",
        "CUT_5": "\"\"\"Handle one message\"\"\"\nmsg_type, _id, file, msg = [message[k] for k in ('type', 'id', 'file', 'msg')]\nlogger.debug('Perform request {0} with id {1}'.format(msg_type, _id))\nif msg_type == LSPRequestTypes.DOCUMENT_DID_OPEN:\n    self.file_tokens[file] = {'text': msg['text'], 'offset': msg['offset'],\n        'language': msg['language']}\nelif msg_type == LSPRequestTypes.DOCUMENT_DID_CHANGE:\n    if file not in self.file_tokens:\n        self.file_tokens[file] = {'text': '', 'offset': msg['offset'],\n            'language': msg['language']}\n    diff = msg['diff']\n    text = self.file_tokens[file]\n    text['offset'] = msg['offset']\n    text, _ = self.diff_patch.patch_apply(diff, text['text'])\n    self.file_tokens[file]['text'] = text\nelif msg_type == LSPRequestTypes.DOCUMENT_DID_CLOSE:\n    self.file_tokens.pop(file, {})\nelif msg_type == LSPRequestTypes.DOCUMENT_COMPLETION:\n    tokens = []\n    if file in self.file_tokens:\n        text_info = self.file_tokens[file]\n        tokens = self.tokenize(text_info['text'], text_info['offset'],\n            text_info['language'], msg['current_word'])\n    tokens = {'params': tokens}\n    self.sig_set_tokens.emit(_id, tokens)\nSlot(dict)"
    },
    {
        "functionName": "test_get_words",
        "className": null,
        "fileName": "/spyder/plugins/completion/fallback/tests/test_fallback.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "source = 'foo bar123 baz car456'\ntokens = get_words(source, 5, 'python')\nassert set(tokens) == {'foo', 'baz', 'car456'}\n",
        "CUT_1": "tokens = list(response['params'])\nself.sig_recv_tokens.emit(list(tokens))\n",
        "CUT_2": "\"\"\"Split source code into python identifier-like tokens\"\"\"\ntokens = set(re.split('[^0-9a-zA-Z_.]', source_code))\nvalid = re.compile('[a-zA-Z_]')\nreturn [token for token in tokens if re.match(valid, token)]\n",
        "CUT_3": "\"\"\"Split source code into python identifier-like tokens\"\"\"\ntokens = set(re.split('[^0-9a-zA-Z_.]', source_code))\nvalid = re.compile('[a-zA-Z_]')\nreturn [token for token in tokens if re.match(valid, token)]\n",
        "CUT_4": "\"\"\"\n    :param text: Python source to analyze\n    :param cursor: The starting cursor in the source\n    :param line_start: line_start used in the source\n    :return: a string representing the defintion value or None\n\n    Finds the (syntactic) path of the function that\n    returned the value of the name before the cursor.\n\n    For example, the following input yields \"bar.baz\":\n      foo = bar.baz(\"abc\")\n      foo.ca\u2038r\n    \"\"\"\nfor i, c in enumerate(reversed(text[:cursor])):\n    if c == '.' or c == '_' or c.isalnum():\n        continue\n    break\nelse:\n    return None\nexpr = text[cursor - i:cursor]\nname = expr.split('.', 1)[0]\nif not re.match(ident_full_re, name):\n    return None\nif PY2:\n    line_start = line_start.encode('utf-8')\nassign_re = '{line_start}\\\\s*{name}\\\\s*=\\\\s*({dotted_path})\\\\('.format(\n    line_start=re.escape(line_start), name=re.escape(name), dotted_path=\n    dotted_path_re)\nmatch = None\nfor match in re.finditer(assign_re, text[:cursor]):\n    pass\nif match is None:\n    return None\nreturn match.group(1)\n",
        "CUT_5": "\"\"\"\n    :param text: Python source to analyze\n    :param cursor: The starting cursor in the source\n    :param line_start: line_start used in the source\n    :return: a string representing the defintion value or None\n\n    Finds the (syntactic) path of the function that\n    returned the value of the name before the cursor.\n\n    For example, the following input yields \"bar.baz\":\n      foo = bar.baz(\"abc\")\n      foo.ca\u2038r\n    \"\"\"\nfor i, c in enumerate(reversed(text[:cursor])):\n    if c == '.' or c == '_' or c.isalnum():\n        continue\n    break\nelse:\n    return None\nexpr = text[cursor - i:cursor]\nname = expr.split('.', 1)[0]\nif not re.match(ident_full_re, name):\n    return None\nif PY2:\n    line_start = line_start.encode('utf-8')\nassign_re = '{line_start}\\\\s*{name}\\\\s*=\\\\s*({dotted_path})\\\\('.format(\n    line_start=re.escape(line_start), name=re.escape(name), dotted_path=\n    dotted_path_re)\nmatch = None\nfor match in re.finditer(assign_re, text[:cursor]):\n    pass\nif match is None:\n    return None\nreturn match.group(1)\n"
    },
    {
        "functionName": "test_tokenize",
        "className": null,
        "fileName": "/spyder/plugins/completion/fallback/tests/test_fallback.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "filename, expected_tokens, contents = file_fixture\n_, ext = osp.splitext(filename)\nlanguage = extension_map[ext[1:]]\nfallback, completions, diff_match = fallback_fixture\nopen_request = {'file': filename, 'text': contents, 'offset': len(contents)}\nfallback.send_request(language, LSPRequestTypes.DOCUMENT_DID_OPEN, open_request\n    )\nqtbot_module.wait(1000)\ntokens_request = {'file': filename, 'current_word': ''}\nwith qtbot_module.waitSignal(completions.sig_recv_tokens, timeout=3000\n    ) as blocker:\n    fallback.send_request(language, LSPRequestTypes.DOCUMENT_COMPLETION,\n        tokens_request)\ntokens = blocker.args\ntokens = {token['insertText'] for token in tokens[0]}\nassert len(expected_tokens - tokens) == 0\npytest.mark.slowpytest.mark.parametrize('file_fixture', language_list, indirect=True)",
        "CUT_1": "fallback = FallbackPlugin(None)\ncompletions = CompletionManagerMock(None)\nqtbot_module.addWidget(fallback)\nqtbot_module.addWidget(completions)\nwith qtbot_module.waitSignal(fallback.sig_plugin_ready, timeout=30000):\n    fallback.start()\ndef teardown():\n    fallback.shutdown()\nrequest.addfinalizer(teardown)\nfallback.sig_response_ready.connect(completions.handle_response)\nreturn fallback, completions\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"CodeEditor instance with Fallback enabled.\"\"\"\ncompletions = CompletionManager(None, ['fallback'])\ncompletions.start()\ncompletions.start_client('python')\ncompletions.language_status['python']['fallback'] = True\nqtbot_module.addWidget(completions)\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.show()\neditor.sig_perform_completion_request.connect(completions.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\neditor.completions_available = True\nqtbot_module.wait(2000)\ndef teardown():\n    completions.shutdown()\n    editor.hide()\n    editor.completion_widget.hide()\nrequest.addfinalizer(teardown)\nfallback = completions.get_client('fallback')\nreturn editor, fallback\npytest.fixture",
        "CUT_3": "tokens = list(response['params'])\nself.sig_recv_tokens.emit(list(tokens))\n",
        "CUT_4": "self.to_delete = True\nfor token in self.tokens:\n    token.delete()\n",
        "CUT_5": "self.to_delete = True\nfor token in self.tokens:\n    token.delete()\n"
    },
    {
        "functionName": "test_token_update",
        "className": null,
        "fileName": "/spyder/plugins/completion/fallback/tests/test_fallback.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "fallback, completions, diff_match = fallback_fixture\nopen_request = {'file': 'test.py', 'text': TEST_FILE, 'offset': len(TEST_FILE)}\nfallback.send_request('python', LSPRequestTypes.DOCUMENT_DID_OPEN, open_request\n    )\nqtbot_module.wait(1000)\ntokens_request = {'file': 'test.py', 'current_word': ''}\nwith qtbot_module.waitSignal(completions.sig_recv_tokens, timeout=3000\n    ) as blocker:\n    fallback.send_request('python', LSPRequestTypes.DOCUMENT_COMPLETION,\n        tokens_request)\ninitial_tokens = blocker.args[0]\ninitial_tokens = {token['insertText'] for token in initial_tokens}\nassert 'args' not in initial_tokens\ndiff = diff_match.patch_make(TEST_FILE, TEST_FILE_UPDATE)\nupdate_request = {'file': 'test.py', 'diff': diff, 'offset': len(diff)}\nfallback.send_request('python', LSPRequestTypes.DOCUMENT_DID_CHANGE,\n    update_request)\nqtbot_module.wait(1000)\nwith qtbot_module.waitSignal(completions.sig_recv_tokens, timeout=3000\n    ) as blocker:\n    fallback.send_request('python', LSPRequestTypes.DOCUMENT_COMPLETION,\n        tokens_request)\nupdated_tokens = blocker.args[0]\nupdated_tokens = {token['insertText'] for token in updated_tokens}\nassert 'args' in updated_tokens\npytest.mark.slow",
        "CUT_1": "fallback = FallbackPlugin(None)\ncompletions = CompletionManagerMock(None)\nqtbot_module.addWidget(fallback)\nqtbot_module.addWidget(completions)\nwith qtbot_module.waitSignal(fallback.sig_plugin_ready, timeout=30000):\n    fallback.start()\ndef teardown():\n    fallback.shutdown()\nrequest.addfinalizer(teardown)\nfallback.sig_response_ready.connect(completions.handle_response)\nreturn fallback, completions\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"CodeEditor instance with Fallback enabled.\"\"\"\ncompletions = CompletionManager(None, ['fallback'])\ncompletions.start()\ncompletions.start_client('python')\ncompletions.language_status['python']['fallback'] = True\nqtbot_module.addWidget(completions)\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.show()\neditor.sig_perform_completion_request.connect(completions.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\neditor.completions_available = True\nqtbot_module.wait(2000)\ndef teardown():\n    completions.shutdown()\n    editor.hide()\n    editor.completion_widget.hide()\nrequest.addfinalizer(teardown)\nfallback = completions.get_client('fallback')\nreturn editor, fallback\npytest.fixture",
        "CUT_3": "fallback.shutdown()\n",
        "CUT_4": "\"\"\"CodeEditor instance with text snippets enabled.\"\"\"\ncompletions = CompletionManager(None, ['snippets'])\ncompletions.start()\ncompletions.start_client('python')\ncompletions.language_status['python']['snippets'] = True\nqtbot_module.addWidget(completions)\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.show()\neditor.sig_perform_completion_request.connect(completions.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\neditor.completions_available = True\nqtbot_module.wait(2000)\ndef teardown():\n    completions.shutdown()\n    editor.hide()\n    editor.completion_widget.hide()\nrequest.addfinalizer(teardown)\nsnippets = completions.get_client('snippets')\nsnippets.update_configuration()\nreturn editor, snippets\npytest.fixture",
        "CUT_5": "if not isinstance(y, Token):\n    return True\nreturn self.token != y.token\n"
    },
    {
        "functionName": "test_kite_install",
        "className": null,
        "fileName": "/spyder/plugins/completion/kite/utils/tests/test_install.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the correct execution of the installation process of kite.\"\"\"\ninstall_manager = KiteInstallationThread(None)\ninstallation_statuses = []\ndef installation_status(status):\n    installation_statuses.append(status)\ndef error_msg(error):\n    assert False\ndef download_progress(progress, total):\n    assert total != 0\ndef finished():\n    if sys.platform.startswith('linux'):\n        expected_installation_status = [DOWNLOADING_SCRIPT,\n            DOWNLOADING_INSTALLER, INSTALLING, FINISHED]\n    else:\n        expected_installation_status = [DOWNLOADING_INSTALLER, INSTALLING,\n            FINISHED]\n    if not installation_statuses == ['Installation finished']:\n        assert installation_statuses == expected_installation_status\ninstall_manager.sig_installation_status.connect(installation_status)\ninstall_manager.sig_error_msg.connect(error_msg)\ninstall_manager.sig_download_progress.connect(download_progress)\ninstall_manager.finished.connect(finished)\nwith qtbot.waitSignal(install_manager.finished, timeout=INSTALL_TIMEOUT):\n    install_manager.install()\nqtbot.waitUntil(lambda : check_if_kite_installed() and\n    check_if_kite_running(), timeout=5000)\npytest.mark.slowpytest.mark.firstpytest.mark.skip(reason=\"Fail on CIs and it's too heavy to run locally\")",
        "CUT_1": "\"\"\"Handle finished installation.\"\"\"\nif status == FINISHED:\n    self.setup()\n    self.accept()\n",
        "CUT_2": "\"\"\"Handle finished installation.\"\"\"\nif status == FINISHED:\n    self.setup()\n    self.accept()\n",
        "CUT_3": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n",
        "CUT_4": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n",
        "CUT_5": "\"\"\"Update installation status (downloading, installing, finished).\"\"\"\nself._progress_label.setText(status)\nif status == INSTALLING:\n    self._progress_bar.setRange(0, 0)\n"
    },
    {
        "functionName": "installation_status",
        "className": null,
        "fileName": "/spyder/plugins/completion/kite/utils/tests/test_install.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "installation_statuses.append(status)\n",
        "CUT_1": "\"\"\"Set the installation status.\"\"\"\nself.status = status\nself.sig_installation_status.emit(self.status)\n",
        "CUT_2": "\"\"\"Set the installation status.\"\"\"\nself.status = status\nself.sig_installation_status.emit(self.status)\n",
        "CUT_3": "self.host_input.setEnabled(status)\nself.port_spinner.setEnabled(status)\nself.external_cb.setEnabled(status)\nself.stdio_cb.setEnabled(status)\nself.cmd_input.setEnabled(status)\nself.args_input.setEnabled(status)\nself.conf_input.setEnabled(status)\nself.json_label.setVisible(status)\n",
        "CUT_4": "self.host_input.setEnabled(status)\nself.port_spinner.setEnabled(status)\nself.external_cb.setEnabled(status)\nself.stdio_cb.setEnabled(status)\nself.cmd_input.setEnabled(status)\nself.args_input.setEnabled(status)\nself.conf_input.setEnabled(status)\nself.json_label.setVisible(status)\n",
        "CUT_5": "\"\"\"Set LSP status.\"\"\"\nif status in [ClientStatus.STARTING, ClientStatus.RESTARTING]:\n    self.spinner.show()\n    self.spinner.start()\nelse:\n    self.spinner.hide()\n    self.spinner.stop()\nif status is None:\n    status = ClientStatus.STRINGS_FOR_TRANSLATION[ClientStatus.STARTING]\nelse:\n    status = ClientStatus.STRINGS_FOR_TRANSLATION[status]\nif lsp_language is not None:\n    status = self.STATUS.format(lsp_language, status)\nself.set_value(status)\n"
    },
    {
        "functionName": "error_msg",
        "className": null,
        "fileName": "/spyder/plugins/completion/kite/utils/tests/test_install.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert False\n",
        "CUT_1": "\"\"\"Init Pdb.\"\"\"\nself.curframe_locals = None\nself.continue_if_has_breakpoints = False\nself.pdb_ignore_lib = False\nself.pdb_execute_events = False\nself.pdb_use_exclamation_mark = False\nself._exclamation_warning_printed = False\nself.pdb_stop_first_line = True\nself._disable_next_stack_entry = False\nsuper(SpyderPdb, self).__init__()\nself._pdb_breaking = False\nself._frontend_notified = False\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_4": "return False\nproperty",
        "CUT_5": "return False\nproperty"
    },
    {
        "functionName": "download_progress",
        "className": null,
        "fileName": "/spyder/plugins/completion/kite/utils/tests/test_install.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert total != 0\n",
        "CUT_1": "\"\"\"Return document total line number\"\"\"\nreturn self.blockCount()\n",
        "CUT_2": "\"\"\"Return document total line number\"\"\"\nreturn self.blockCount()\n",
        "CUT_3": "\"\"\"Returns the total number of elements stored in this SBF\"\"\"\nreturn sum(f.count for f in self.filters)\n",
        "CUT_4": "\"\"\"Returns the total number of elements stored in this SBF\"\"\"\nreturn sum(f.count for f in self.filters)\n",
        "CUT_5": "\"\"\"Returns the total capacity for all filters in this SBF\"\"\"\nreturn sum(f.capacity for f in self.filters)\nproperty"
    },
    {
        "functionName": "finished",
        "className": null,
        "fileName": "/spyder/plugins/completion/kite/utils/tests/test_install.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if sys.platform.startswith('linux'):\n    expected_installation_status = [DOWNLOADING_SCRIPT,\n        DOWNLOADING_INSTALLER, INSTALLING, FINISHED]\nelse:\n    expected_installation_status = [DOWNLOADING_INSTALLER, INSTALLING, FINISHED\n        ]\nif not installation_statuses == ['Installation finished']:\n    assert installation_statuses == expected_installation_status\n",
        "CUT_1": "\"\"\"Handle finished installation.\"\"\"\nif status == FINISHED:\n    self.setup()\n    self.accept()\n",
        "CUT_2": "\"\"\"Handle finished installation.\"\"\"\nif status == FINISHED:\n    self.setup()\n    self.accept()\n",
        "CUT_3": "\"\"\"Update installation status (downloading, installing, finished).\"\"\"\nself._progress_label.setText(status)\nif status == INSTALLING:\n    self._progress_bar.setRange(0, 0)\n",
        "CUT_4": "\"\"\"Update installation status (downloading, installing, finished).\"\"\"\nself._progress_label.setText(status)\nif status == INSTALLING:\n    self._progress_bar.setRange(0, 0)\n",
        "CUT_5": "\"\"\"Download the installer or installation script.\"\"\"\ntemp_dir = gettempdir()\npath = osp.join(temp_dir, self._installer_name)\nif sys.platform.startswith('linux'):\n    self._change_installation_status(status=DOWNLOADING_SCRIPT)\nelse:\n    self._change_installation_status(status=DOWNLOADING_INSTALLER)\nreturn urlretrieve(self._download_url, path, reporthook=self._progress_reporter\n    )\n"
    },
    {
        "functionName": "test_find_returning_function_path",
        "className": null,
        "fileName": "/spyder/plugins/completion/kite/parsing/tests/test_parsing.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "table = [['pd.read_csv',\n    \"\"\"import pandas as pd\ndf = pd.read_csv(\"a\")\ndf.$\"\"\"], ['pd.read_csv',\n    \"\"\"import pandas as pd\ndf = pd.read_csv(\"a\")\ndf.a$\"\"\"], ['pd.read_csv',\n    \"\"\"import pandas as pd\ndf = pd.read_csv(\"a\")\nfoo = df.$\"\"\"], [\n    'pd.read_csv',\n    \"\"\"import pandas as pd\ndf = pd.read_csv(\"a\")\nfoo = df.a$\"\"\"], [\n    'plt.figure',\n    \"\"\"import matplotlib.pyplot as plt\nfig=plt.figure(figsize=(15, 10))\nfig.$\"\"\"\n    ], ['sns.pairplot',\n    \"\"\"import seaborn as sns\ng = sns.pairplot(temp[[u'Pclass', u'Sex', u'Age', u'Parch', u'Fare',\n    u'Embarked', u'FamilySize', u'Title', u'Survived']],\n    hue='Survived', palette = 'seismic',size=1.2,diag_kind = 'kde',\n    diag_kws=dict(shade=True),plot_kws=dict(s=10) )\ng.s$\"\"\"\n    ]]\nfor k in table:\n    expected, content = k\n    offset = content.find('$')\n    content = content[0:offset]\n    print('Checking {}: {}\\n'.format(expected, content.replace('\\n', '\\\\n')))\n    assert expected == find_returning_function_path(content, offset)\n",
        "CUT_1": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_2": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_3": "\"\"\"Load a pickle file as a dictionary\"\"\"\ntry:\n    if pd:\n        return pd.read_pickle(filename), None\n    else:\n        with open(filename, 'rb') as fid:\n            data = pickle.load(fid)\n        return data, None\nexcept Exception as err:\n    return None, str(err)\n",
        "CUT_4": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_5": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n"
    },
    {
        "functionName": "pydocbrowser",
        "className": null,
        "fileName": "/spyder/plugins/onlinehelp/tests/test_pydocgui.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up pydocbrowser.\"\"\"\nwidget = PydocBrowser(parent=None, name='pydoc')\noptions = PydocBrowser.DEFAULT_OPTIONS.copy()\nwidget._setup(options)\nwidget.setup(options)\nwith qtbot.waitSignal(widget.sig_load_finished, timeout=6000):\n    widget.initialize()\nqtbot.addWidget(widget)\nreturn qtbot, widget\npytest.fixture",
        "CUT_1": "\"\"\"Run web browser.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = PydocBrowser.DEFAULT_OPTIONS.copy()\nwidget = PydocBrowser(None)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "\"\"\"Run web browser.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = PydocBrowser.DEFAULT_OPTIONS.copy()\nwidget = PydocBrowser(None)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "\"\"\"Run history widget.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = HistoryWidget.DEFAULT_OPTIONS.copy()\nwidget = HistoryWidget('historylog', None, None, options=options)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_4": "\"\"\"Run history widget.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = HistoryWidget.DEFAULT_OPTIONS.copy()\nwidget = HistoryWidget('historylog', None, None, options=options)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "test_pydocbrowser",
        "className": null,
        "fileName": "/spyder/plugins/onlinehelp/tests/test_pydocgui.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run Pydoc Browser.\"\"\"\nqtbot, browser = pydocbrowser\nassert browser\npytest.mark.skipif(sys.platform == 'darwin', reason='Does not work on Mac')",
        "CUT_1": "\"\"\"Run web browser.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = PydocBrowser.DEFAULT_OPTIONS.copy()\nwidget = PydocBrowser(None)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_2": "\"\"\"Run web browser.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = PydocBrowser.DEFAULT_OPTIONS.copy()\nwidget = PydocBrowser(None)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_3": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_4": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_get_pydoc",
        "className": null,
        "fileName": "/spyder/plugins/onlinehelp/tests/test_pydocgui.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Go to the documentation by url.\n    Regression test for spyder-ide/spyder#10740\n    \"\"\"\nqtbot, browser = pydocbrowser\nelement, doc, matches = lib\nwebview = browser.webview\nelement_url = browser.text_to_url(element)\nwith qtbot.waitSignal(webview.loadFinished):\n    browser.set_url(element_url)\nqtbot.waitUntil(lambda : webview.get_number_matches(doc) in [matches, \n    matches + 1])\npytest.mark.parametrize('lib', [('str', 'class str', 1), ('numpy.compat',\n    'numpy.compat', 2)])pytest.mark.skipif(sys.platform == 'darwin', reason='Does not work on Mac')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "super().__init__(name, plugin, parent=parent, options=options)\nself._is_running = False\nself.home_url = None\nself.server = None\nself.label = QLabel(_('Package:'))\nself.url_combo = UrlComboBox(self)\nself.webview = WebView(self, handle_links=self.get_option('handle_links'))\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview)\nself.find_widget.hide()\nself.url_combo.setMaxCount(self.get_option('max_history_entries'))\ntip = _('Write a package name here, e.g. pandas')\nself.url_combo.lineEdit().setPlaceholderText(tip)\nself.url_combo.lineEdit().setToolTip(tip)\nself.webview.setup()\nself.webview.set_zoom_factor(self.get_option('zoom_factor'))\nspacing = 10\nlayout = QVBoxLayout()\nlayout.addWidget(self.webview)\nlayout.addSpacing(spacing)\nlayout.addWidget(self.find_widget)\nlayout.addSpacing(int(spacing / 2))\nself.setLayout(layout)\nself.url_combo.valid.connect(lambda x: self._handle_url_combo_activation())\nself.webview.loadStarted.connect(self._start)\nself.webview.loadFinished.connect(self._finish)\nself.webview.titleChanged.connect(self.setWindowTitle)\nself.webview.urlChanged.connect(self._change_url)\nif not WEBENGINE:\n    self.webview.iconChanged.connect(self._handle_icon_change)\n",
        "CUT_3": "super().__init__(name, plugin, parent=parent, options=options)\nself._is_running = False\nself.home_url = None\nself.server = None\nself.label = QLabel(_('Package:'))\nself.url_combo = UrlComboBox(self)\nself.webview = WebView(self, handle_links=self.get_option('handle_links'))\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.webview)\nself.find_widget.hide()\nself.url_combo.setMaxCount(self.get_option('max_history_entries'))\ntip = _('Write a package name here, e.g. pandas')\nself.url_combo.lineEdit().setPlaceholderText(tip)\nself.url_combo.lineEdit().setToolTip(tip)\nself.webview.setup()\nself.webview.set_zoom_factor(self.get_option('zoom_factor'))\nspacing = 10\nlayout = QVBoxLayout()\nlayout.addWidget(self.webview)\nlayout.addSpacing(spacing)\nlayout.addWidget(self.find_widget)\nlayout.addSpacing(int(spacing / 2))\nself.setLayout(layout)\nself.url_combo.valid.connect(lambda x: self._handle_url_combo_activation())\nself.webview.loadStarted.connect(self._start)\nself.webview.loadFinished.connect(self._finish)\nself.webview.titleChanged.connect(self.setWindowTitle)\nself.webview.urlChanged.connect(self._change_url)\nif not WEBENGINE:\n    self.webview.iconChanged.connect(self._handle_icon_change)\n",
        "CUT_4": "self.set_html('', self.webview.url())\n",
        "CUT_5": "self.set_html('', self.webview.url())\n"
    },
    {
        "functionName": "test_config_dialog",
        "className": null,
        "fileName": "/spyder/plugins/explorer/tests/test_explorer_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpage = config_dialog.get_page()\nassert configpage\nconfigpage.save_to_conf()\npytest.mark.parametrize('config_dialog', [[None, [], [Explorer]]], indirect\n    =True)",
        "CUT_1": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_2": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_3": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_4": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "test_input_text_dialog",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_fileassociations.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = InputTextDialog()\nqtbot.addWidget(widget)\nwidget.show()\nwidget.validate()\nassert not widget.button_ok.isEnabled()\nwidget.set_text('hello')\nwidget.validate()\nassert widget.button_ok.isEnabled()\nwidget.set_text('')\nwidget.set_regex_validation('hello')\nqtbot.keyClicks(widget.lineedit, 'hello world!')\nassert widget.text() == 'hello'\nassert widget.button_ok.isEnabled()\nwidget.validate()\nwidget.set_text('')\nwidget.set_regex_validation('hello')\nqtbot.keyClicks(widget.lineedit, 'hell')\nassert not widget.button_ok.isEnabled()\nwidget.validate()\npytest.mark.firstpytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on win and py2!')",
        "CUT_1": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_apps_dialog",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_fileassociations.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = ApplicationsDialog()\nqtbot.addWidget(widget)\nwidget.show()\nif os.name == 'nt':\n    ext = '.exe'\nelif sys.platform == 'darwin':\n    ext = '.app'\nelse:\n    ext = '.desktop'\nmock_apps = {'some app 1': '/some/fake/some app 1' + ext, 'some app 2': \n    '/some/fake/path/some app 2' + ext, 'some app 3': \n    '/some/fake/path/some app 3' + ext}\nwidget.setup(mock_apps)\nqtbot.keyClicks(widget.edit_filter, '1')\ncount_hidden = 0\nfor row in range(widget.list.count()):\n    item = widget.list.item(row)\n    count_hidden += int(item.isHidden())\nassert count_hidden == 2\nwidget.list.setCurrentItem(widget.list.item(0))\nassert widget.application_name == 'some app 1'\nassert widget.application_path == '/some/fake/some app 1' + ext\nwidget.set_extension('.hello')\nassert '.hello' in widget.label.text()\nwidget.edit_filter.setText('')\ncount_hidden = 0\nfor row in range(widget.list.count()):\n    item = widget.list.item(row)\n    count_hidden += int(item.isHidden())\nassert count_hidden == 0\nfpath = '/some/other/path'\nwidget.browse(fpath)\nassert widget.list.count() == 3\nif os.name == 'nt':\n    path_obj = tmp_path / ('some-new-app' + ext)\n    path_obj.write_bytes(b'\\x00\\x00')\n    fpath = str(path_obj)\nelif sys.platform == 'darwin':\n    path_obj = tmp_path / ('some-new-app' + ext)\n    path_obj.mkdir()\n    fpath = str(path_obj)\nelse:\n    path_obj = tmp_path / ('some-new-app' + ext)\n    path_obj.write_text(\n        \"\"\"\n[Desktop Entry]\nName=Suer app\nType=Application\nExec=/something/bleerp\nIcon=/blah/blah.xpm\n\"\"\"\n        )\n    fpath = str(path_obj)\nwidget.browse(fpath)\nassert widget.list.count() == 4\nwidget.browse(fpath)\nassert widget.list.count() == 4\npytest.mark.firstpytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on win and py2!')",
        "CUT_1": "widget = FileAssociationsWidget()\nqtbot.addWidget(widget)\nif os.name == 'nt':\n    ext = '.exe'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.write_bytes(b'Binary file contents')\n    fpath = str(path_obj)\nelif sys.platform == 'darwin':\n    ext = '.app'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.mkdir()\n    fpath = str(path_obj)\nelse:\n    ext = '.desktop'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.write_text('Text file contents')\n    fpath = str(path_obj)\ndata = {'*.csv': [('App name 1', '/path/to/app 1' + ext), ('App name 2',\n    fpath)], '*.txt': [('App name 2', fpath), ('App name 3', \n    '/path/to/app 3' + ext)]}\nwidget.load_values(data)\nwidget.show()\nwidget.test_data = data\nreturn qtbot, widget\npytest.fixture",
        "CUT_2": "\"\"\"Prompt user to select an application not found on the list.\"\"\"\napp = None\nitem = None\nif sys.platform == 'darwin':\n    if fpath is None:\n        basedir = '/Applications/'\n        filters = _('Applications (*.app)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.app') and os.path.isdir(fpath):\n        app = os.path.basename(fpath).split('.app')[0]\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nelif os.name == 'nt':\n    if fpath is None:\n        basedir = 'C:\\\\'\n        filters = _('Applications (*.exe *.bat *.com)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath:\n        check_1 = fpath.endswith('.bat') and is_text_file(fpath)\n        check_2 = fpath.endswith(('.exe', '.com')) and not is_text_file(fpath)\n        if check_1 or check_2:\n            app = os.path.basename(fpath).capitalize().rsplit('.')[0]\n            for row in range(self.list.count()):\n                item = self.list.item(row)\n                if app == item.text() and fpath == item.fpath:\n                    break\n            else:\n                item = None\nelse:\n    if fpath is None:\n        basedir = '/'\n        filters = _('Applications (*.desktop)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.desktop') and is_text_file(fpath):\n        entry_data = parse_linux_desktop_entry(fpath)\n        app = entry_data['name']\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nif fpath:\n    if item:\n        self.list.setCurrentItem(item)\n    elif app:\n        icon = get_application_icon(fpath)\n        item = QListWidgetItem(icon, app)\n        item.fpath = fpath\n        self.list.addItem(item)\n        self.list.setCurrentItem(item)\nself.list.setFocus()\nself._refresh()\n",
        "CUT_3": "\"\"\"Prompt user to select an application not found on the list.\"\"\"\napp = None\nitem = None\nif sys.platform == 'darwin':\n    if fpath is None:\n        basedir = '/Applications/'\n        filters = _('Applications (*.app)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.app') and os.path.isdir(fpath):\n        app = os.path.basename(fpath).split('.app')[0]\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nelif os.name == 'nt':\n    if fpath is None:\n        basedir = 'C:\\\\'\n        filters = _('Applications (*.exe *.bat *.com)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath:\n        check_1 = fpath.endswith('.bat') and is_text_file(fpath)\n        check_2 = fpath.endswith(('.exe', '.com')) and not is_text_file(fpath)\n        if check_1 or check_2:\n            app = os.path.basename(fpath).capitalize().rsplit('.')[0]\n            for row in range(self.list.count()):\n                item = self.list.item(row)\n                if app == item.text() and fpath == item.fpath:\n                    break\n            else:\n                item = None\nelse:\n    if fpath is None:\n        basedir = '/'\n        filters = _('Applications (*.desktop)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.desktop') and is_text_file(fpath):\n        entry_data = parse_linux_desktop_entry(fpath)\n        app = entry_data['name']\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nif fpath:\n    if item:\n        self.list.setCurrentItem(item)\n    elif app:\n        icon = get_application_icon(fpath)\n        item = QListWidgetItem(icon, app)\n        item.fpath = fpath\n        self.list.addItem(item)\n        self.list.setCurrentItem(item)\nself.list.setFocus()\nself._refresh()\n",
        "CUT_4": "path_obj = pathlib.Path(osp.abspath(path))\nif os.name == 'nt' and PY2:\n    return make_as_uri(path_obj)\nelse:\n    return path_obj.as_uri()\n",
        "CUT_5": "path_obj = pathlib.Path(osp.abspath(path))\nif os.name == 'nt' and PY2:\n    return make_as_uri(path_obj)\nelse:\n    return path_obj.as_uri()\n"
    },
    {
        "functionName": "create_timer",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_fileassociations.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Helper function to help interact with modal dialogs.\"\"\"\ntimer = QTimer()\ntimer.setInterval(interval)\ntimer.setSingleShot(True)\ntimer.timeout.connect(func)\ntimer.start()\nreturn timer\n",
        "CUT_1": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n",
        "CUT_2": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n",
        "CUT_3": "\"\"\"Set timer interval (ms).\"\"\"\nself._interval = interval\nif self.timer is not None:\n    self.timer.setInterval(interval)\n",
        "CUT_4": "\"\"\"Set timer interval (ms).\"\"\"\nself._interval = interval\nif self.timer is not None:\n    self.timer.setInterval(interval)\n",
        "CUT_5": "\"\"\"Stop the autosave timer.\"\"\"\nself.timer.stop()\n"
    },
    {
        "functionName": "test_file_assoc_widget",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_fileassociations.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, widget = file_assoc_widget\nassert widget.data == widget.test_data\nextension = 'blooper.foo,'\ndef interact_with_dialog_1():\n    qtbot.keyClicks(widget._dlg_input.lineedit, extension)\n    assert widget._dlg_input.lineedit.text() == extension\n    assert not widget._dlg_input.button_ok.isEnabled()\n    qtbot.keyClick(widget._dlg_input.button_cancel, Qt.Key_Return)\n_ = create_timer(interact_with_dialog_1)\nqtbot.mouseClick(widget.button_add, Qt.LeftButton)\nextension = '*.zpam,MANIFEST.in'\ndef interact_with_dialog_2():\n    qtbot.keyClicks(widget._dlg_input.lineedit, extension)\n    qtbot.keyClick(widget._dlg_input.button_ok, Qt.Key_Return)\n_ = create_timer(interact_with_dialog_2)\nqtbot.mouseClick(widget.button_add, Qt.LeftButton)\nassert widget.list_extensions.count() == 3\nassert widget.list_extensions.item(2).text() == extension\nwidget.add_association(value='mehh')\nassert widget.list_extensions.count() == 3\nwidget.add_association(value='*.boom')\nassert widget.list_extensions.count() == 4\nwidget.add_association(value='*.csv')\nassert widget.list_extensions.count() == 4\nwidget._add_association(value='*.csv')\nassert widget.list_extensions.count() == 4\nextension = '*.zpam'\ndef interact_with_dialog_3():\n    widget._dlg_input.lineedit.clear()\n    qtbot.keyClicks(widget._dlg_input.lineedit, extension)\n    qtbot.keyClick(widget._dlg_input.button_ok, Qt.Key_Return)\n_ = create_timer(interact_with_dialog_3)\nqtbot.mouseClick(widget.button_edit, Qt.LeftButton)\nassert widget.list_extensions.count() == 4\nassert widget.list_extensions.item(2).text() == extension\nqtbot.mouseClick(widget.button_remove, Qt.LeftButton)\nassert widget.list_extensions.count() == 3\nwidget.list_applications.setCurrentRow(1)\nqtbot.mouseClick(widget.button_default, Qt.LeftButton)\nassert 'App name 2' in widget.list_applications.item(0).text()\ndef interact_with_dialog_4():\n    assert not widget._dlg_applications.button_ok.isEnabled()\n    count = widget._dlg_applications.list.count()\n    if count > 0:\n        widget._dlg_applications.list.setCurrentRow(count - 1)\n        qtbot.keyClick(widget._dlg_applications.button_ok, Qt.Key_Return)\n    else:\n        qtbot.keyClick(widget._dlg_applications.button_cancel, Qt.Key_Return)\n_ = create_timer(interact_with_dialog_4)\nqtbot.mouseClick(widget.button_add_application, Qt.LeftButton)\ncount = widget.list_applications.count()\nassert count in [2, 3]\napp_name, app_path = widget.test_data['*.csv'][0]\nwidget._add_application(app_name, app_path)\ncount = widget.list_applications.count()\nassert count in [2, 3]\nwidget.list_applications.setCurrentRow(0)\nqtbot.mouseClick(widget.button_remove_application, Qt.LeftButton)\ncount = widget.list_applications.count()\nassert count in [1, 2]\nassert 'App name 1' in widget.list_applications.item(0).text()\npytest.mark.firstpytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on win and py2!')",
        "CUT_1": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n",
        "CUT_2": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "interact_with_dialog_1",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_fileassociations.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot.keyClicks(widget._dlg_input.lineedit, extension)\nassert widget._dlg_input.lineedit.text() == extension\nassert not widget._dlg_input.button_ok.isEnabled()\nqtbot.keyClick(widget._dlg_input.button_cancel, Qt.Key_Return)\n",
        "CUT_1": "\"\"\"Add extension file association.\"\"\"\nif value is None:\n    text, ok_pressed = '', False\n    self._dlg_input.set_text('')\n    if self._dlg_input.exec_():\n        text = self._dlg_input.text()\n        ok_pressed = True\nelse:\n    match = self._regex.match(value)\n    text, ok_pressed = value, bool(match)\nif ok_pressed:\n    if text not in self._data:\n        self._data[text] = []\n        self._add_association(text)\n        self.check_data_changed()\n",
        "CUT_2": "\"\"\"Add extension file association.\"\"\"\nif value is None:\n    text, ok_pressed = '', False\n    self._dlg_input.set_text('')\n    if self._dlg_input.exec_():\n        text = self._dlg_input.text()\n        ok_pressed = True\nelse:\n    match = self._regex.match(value)\n    text, ok_pressed = value, bool(match)\nif ok_pressed:\n    if text not in self._data:\n        self._data[text] = []\n        self._add_association(text)\n        self.check_data_changed()\n",
        "CUT_3": "return self.lineedit.text()\n",
        "CUT_4": "return self.lineedit.text()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "interact_with_dialog_2",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_fileassociations.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot.keyClicks(widget._dlg_input.lineedit, extension)\nqtbot.keyClick(widget._dlg_input.button_ok, Qt.Key_Return)\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"Add extension file association.\"\"\"\nif value is None:\n    text, ok_pressed = '', False\n    self._dlg_input.set_text('')\n    if self._dlg_input.exec_():\n        text = self._dlg_input.text()\n        ok_pressed = True\nelse:\n    match = self._regex.match(value)\n    text, ok_pressed = value, bool(match)\nif ok_pressed:\n    if text not in self._data:\n        self._data[text] = []\n        self._add_association(text)\n        self.check_data_changed()\n",
        "CUT_5": "\"\"\"Add extension file association.\"\"\"\nif value is None:\n    text, ok_pressed = '', False\n    self._dlg_input.set_text('')\n    if self._dlg_input.exec_():\n        text = self._dlg_input.text()\n        ok_pressed = True\nelse:\n    match = self._regex.match(value)\n    text, ok_pressed = value, bool(match)\nif ok_pressed:\n    if text not in self._data:\n        self._data[text] = []\n        self._add_association(text)\n        self.check_data_changed()\n"
    },
    {
        "functionName": "interact_with_dialog_3",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_fileassociations.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget._dlg_input.lineedit.clear()\nqtbot.keyClicks(widget._dlg_input.lineedit, extension)\nqtbot.keyClick(widget._dlg_input.button_ok, Qt.Key_Return)\n",
        "CUT_1": "return self.lineedit.text()\n",
        "CUT_2": "return self.lineedit.text()\n",
        "CUT_3": "\"\"\"Add extension file association.\"\"\"\nif value is None:\n    text, ok_pressed = '', False\n    self._dlg_input.set_text('')\n    if self._dlg_input.exec_():\n        text = self._dlg_input.text()\n        ok_pressed = True\nelse:\n    match = self._regex.match(value)\n    text, ok_pressed = value, bool(match)\nif ok_pressed:\n    if text not in self._data:\n        self._data[text] = []\n        self._add_association(text)\n        self.check_data_changed()\n",
        "CUT_4": "\"\"\"Add extension file association.\"\"\"\nif value is None:\n    text, ok_pressed = '', False\n    self._dlg_input.set_text('')\n    if self._dlg_input.exec_():\n        text = self._dlg_input.text()\n        ok_pressed = True\nelse:\n    match = self._regex.match(value)\n    text, ok_pressed = value, bool(match)\nif ok_pressed:\n    if text not in self._data:\n        self._data[text] = []\n        self._add_association(text)\n        self.check_data_changed()\n",
        "CUT_5": "\"\"\"Return the text of the lineedit.\"\"\"\nreturn self.lineedit.text()\n"
    },
    {
        "functionName": "interact_with_dialog_4",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_fileassociations.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert not widget._dlg_applications.button_ok.isEnabled()\ncount = widget._dlg_applications.list.count()\nif count > 0:\n    widget._dlg_applications.list.setCurrentRow(count - 1)\n    qtbot.keyClick(widget._dlg_applications.button_ok, Qt.Key_Return)\nelse:\n    qtbot.keyClick(widget._dlg_applications.button_cancel, Qt.Key_Return)\n",
        "CUT_1": "\"\"\"Remove application to selected extension.\"\"\"\nif self.current_extension:\n    if self._dlg_applications is None:\n        self._dlg_applications = ApplicationsDialog(self)\n    self._dlg_applications.set_extension(self.current_extension)\n    if self._dlg_applications.exec_():\n        app_name = self._dlg_applications.application_name\n        fpath = self._dlg_applications.application_path\n        self._data[self.current_extension].append((app_name, fpath))\n        self._add_application(app_name, fpath)\n        self.check_data_changed()\n",
        "CUT_2": "\"\"\"Remove application to selected extension.\"\"\"\nif self.current_extension:\n    if self._dlg_applications is None:\n        self._dlg_applications = ApplicationsDialog(self)\n    self._dlg_applications.set_extension(self.current_extension)\n    if self._dlg_applications.exec_():\n        app_name = self._dlg_applications.application_name\n        fpath = self._dlg_applications.application_path\n        self._data[self.current_extension].append((app_name, fpath))\n        self._add_application(app_name, fpath)\n        self.check_data_changed()\n",
        "CUT_3": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n",
        "CUT_4": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "file_explorer",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up FileExplorerTest.\"\"\"\nwidget = FileExplorerTest()\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "file_explorer_associations",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up FileExplorerTest.\"\"\"\nif os.name == 'nt':\n    ext = '.exe'\nelif sys.platform == 'darwin':\n    ext = '.app'\nelse:\n    ext = '.desktop'\nassociations = {'*.txt': [('App 1', '/some/fake/some_app_1' + ext)],\n    '*.json,*.csv': [('App 2', '/some/fake/some_app_2' + ext), ('App 1', \n    '/some/fake/some_app_1' + ext)]}\nwidget = FileExplorerTest(file_associations=associations)\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_2": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_3": "widget = FileAssociationsWidget()\nqtbot.addWidget(widget)\nif os.name == 'nt':\n    ext = '.exe'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.write_bytes(b'Binary file contents')\n    fpath = str(path_obj)\nelif sys.platform == 'darwin':\n    ext = '.app'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.mkdir()\n    fpath = str(path_obj)\nelse:\n    ext = '.desktop'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.write_text('Text file contents')\n    fpath = str(path_obj)\ndata = {'*.csv': [('App name 1', '/path/to/app 1' + ext), ('App name 2',\n    fpath)], '*.txt': [('App name 2', fpath), ('App name 3', \n    '/path/to/app 3' + ext)]}\nwidget.load_values(data)\nwidget.show()\nwidget.test_data = data\nreturn qtbot, widget\npytest.fixture",
        "CUT_4": "ext = osp.splitext(filename)[1].lower()\nif ext in self.load_funcs:\n    return self.load_funcs[ext](filename)\nelse:\n    return None, \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_5": "ext = osp.splitext(filename)[1].lower()\nif ext in self.save_funcs:\n    return self.save_funcs[ext](data, filename)\nelse:\n    return \"<b>Unsupported file type '%s'</b>\" % ext\n"
    },
    {
        "functionName": "project_explorer",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up FileExplorerTest.\"\"\"\nwidget = ProjectExplorerTest()\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "create_timer",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Helper function to help interact with modal dialogs.\"\"\"\ntimer = QTimer()\ntimer.setInterval(interval)\ntimer.setSingleShot(True)\ntimer.timeout.connect(func)\ntimer.start()\nreturn timer\n",
        "CUT_1": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n",
        "CUT_2": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n",
        "CUT_3": "\"\"\"Set timer interval (ms).\"\"\"\nself._interval = interval\nif self.timer is not None:\n    self.timer.setInterval(interval)\n",
        "CUT_4": "\"\"\"Set timer interval (ms).\"\"\"\nself._interval = interval\nif self.timer is not None:\n    self.timer.setInterval(interval)\n",
        "CUT_5": "\"\"\"Stop the autosave timer.\"\"\"\nself.timer.stop()\n"
    },
    {
        "functionName": "explorer_with_files",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Setup Project/File Explorer widget.\"\"\"\ncb = QApplication.clipboard()\npaths, project_dir, destination_dir, top_folder = create_folders_files\nexplorer_orig = request.param(directory=project_dir)\nexplorer_dest = request.param(directory=destination_dir)\nqtbot.addWidget(explorer_orig)\nqtbot.addWidget(explorer_dest)\nreturn explorer_orig, explorer_dest, paths, top_folder, cb\npytest.fixture(params=[FileExplorerTest, ProjectExplorerTest2])",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"A project directory with dirs and files for testing.\"\"\"\nproject_dir = to_text_string(tmpdir.mkdir('project'))\ndestination_dir = to_text_string(tmpdir.mkdir('destination'))\ntop_folder = osp.join(project_dir, 'top_folder_in_proj')\nif not osp.exists(top_folder):\n    os.mkdir(top_folder)\nlist_paths = []\nfor item in request.param:\n    if osp.splitext(item)[1]:\n        if osp.split(item)[0]:\n            dirs, fname = osp.split(item)\n            dirpath = osp.join(top_folder, dirs)\n            if not osp.exists(dirpath):\n                os.makedirs(dirpath)\n                item_path = osp.join(dirpath, fname)\n        else:\n            item_path = osp.join(top_folder, item)\n    else:\n        dirpath = osp.join(top_folder, item)\n        if not osp.exists(dirpath):\n            os.makedirs(dirpath)\n            item_path = dirpath\n    if not osp.isdir(item_path):\n        with open(item_path, 'w') as fh:\n            fh.write('File Path:\\n' + str(item_path).replace(os.sep, '/'))\n    list_paths.append(item_path)\nreturn list_paths, project_dir, destination_dir, top_folder\npytest.fixture(params=[['script.py', 'dir1/dir2/dir3/dir4'], ['script.py',\n    'script1.py', 'testdir/dir1/script2.py'], [\n    'subdir/innerdir/dir3/text.txt', 'dir1/dir2/dir3',\n    'dir1/dir2/dir3/file.txt', 'dir1/dir2/dir3/dir4/python.py']])",
        "CUT_3": "\"\"\"Restore last text using callback.\"\"\"\nif self.source_is_console():\n    cb = self._last_console_cb\nelse:\n    cb = self._last_editor_cb\nif cb is None:\n    if self.get_option('plain_mode'):\n        self.switch_to_plain_text()\n    else:\n        self.switch_to_rich_text()\nelse:\n    func = cb[0]\n    args = cb[1:]\n    func(*args)\n    if get_meth_class_inst(func) is self.rich_text:\n        self.switch_to_rich_text()\n    else:\n        self.switch_to_plain_text()\n",
        "CUT_4": "\"\"\"Restore last text using callback.\"\"\"\nif self.source_is_console():\n    cb = self._last_console_cb\nelse:\n    cb = self._last_editor_cb\nif cb is None:\n    if self.get_option('plain_mode'):\n        self.switch_to_plain_text()\n    else:\n        self.switch_to_rich_text()\nelse:\n    func = cb[0]\n    args = cb[1:]\n    func(*args)\n    if get_meth_class_inst(func) is self.rich_text:\n        self.switch_to_rich_text()\n    else:\n        self.switch_to_plain_text()\n",
        "CUT_5": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture"
    },
    {
        "functionName": "test_file_explorer",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run FileExplorerTest.\"\"\"\nfile_explorer.resize(640, 480)\nfile_explorer.show()\nassert file_explorer\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "\"\"\"Run pylint widget test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=20)\nwidget = PylintWidget(None)\nwidget.resize(640, 480)\nwidget.show()\nwidget.analyze(__file__)\nsys.exit(app.exec_())\n",
        "CUT_4": "\"\"\"Run pylint widget test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=20)\nwidget = PylintWidget(None)\nwidget.resize(640, 480)\nwidget.show()\nwidget.analyze(__file__)\nsys.exit(app.exec_())\n",
        "CUT_5": "return _('Run')\n"
    },
    {
        "functionName": "test_project_explorer",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run ProjectExplorerTest.\"\"\"\nproject_explorer.resize(640, 480)\nproject_explorer.show()\nassert project_explorer\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "\"\"\"Run pylint widget test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=20)\nwidget = PylintWidget(None)\nwidget.resize(640, 480)\nwidget.show()\nwidget.analyze(__file__)\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_copy_path",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test copy absolute and relative paths.\"\"\"\nproject, __, file_paths, __, cb = explorer_with_files\nexplorer_directory = project.explorer.treewidget.fsmodel.rootPath()\ncopied_from = project.explorer.treewidget.parent_widget.__class__.__name__\nproject.explorer.treewidget.copy_path(fnames=file_paths, method=path_method)\ncb_output = cb.text(mode=cb.Clipboard)\npath_list = [path.strip(',\"') for path in cb_output.splitlines()]\nassert len(path_list) == len(file_paths)\nfor path, expected_path in zip(path_list, file_paths):\n    if path_method == 'relative':\n        expected_path = osp.relpath(expected_path, explorer_directory)\n        if copied_from == 'ProjectExplorerWidget':\n            expected_path = os.sep.join(expected_path.strip(os.sep).split(\n                os.sep)[1:])\n    assert osp.normpath(path) == osp.normpath(expected_path)\npytest.mark.parametrize('path_method', ['absolute', 'relative'])",
        "CUT_1": "\"\"\"Copy absolute or relative path to given file(s)/folders(s).\"\"\"\ncb = QApplication.clipboard()\nexplorer_dir = self.fsmodel.rootPath()\nif fnames is None:\n    fnames = self.get_selected_filenames()\nif not isinstance(fnames, (tuple, list)):\n    fnames = [fnames]\nfnames = [_fn.replace(os.sep, '/') for _fn in fnames]\nif len(fnames) > 1:\n    if method == 'absolute':\n        clipboard_files = ',\\n'.join('\"' + _fn + '\"' for _fn in fnames)\n    elif method == 'relative':\n        clipboard_files = ',\\n'.join('\"' + osp.relpath(_fn, explorer_dir).\n            replace(os.sep, '/') + '\"' for _fn in fnames)\nelif method == 'absolute':\n    clipboard_files = fnames[0]\nelif method == 'relative':\n    clipboard_files = osp.relpath(fnames[0], explorer_dir).replace(os.sep, '/')\ncopied_from = self.parent_widget.__class__.__name__\nif copied_from == 'ProjectExplorerWidget' and method == 'relative':\n    clipboard_files = [path.strip(',\"') for path in clipboard_files.\n        splitlines()]\n    clipboard_files = ['/'.join(path.strip('/').split('/')[1:]) for path in\n        clipboard_files]\n    if len(clipboard_files) > 1:\n        clipboard_files = ',\\n'.join('\"' + _fn + '\"' for _fn in clipboard_files\n            )\n    else:\n        clipboard_files = clipboard_files[0]\ncb.setText(clipboard_files, mode=cb.Clipboard)\n",
        "CUT_2": "\"\"\"Copy absolute or relative path to given file(s)/folders(s).\"\"\"\ncb = QApplication.clipboard()\nexplorer_dir = self.fsmodel.rootPath()\nif fnames is None:\n    fnames = self.get_selected_filenames()\nif not isinstance(fnames, (tuple, list)):\n    fnames = [fnames]\nfnames = [_fn.replace(os.sep, '/') for _fn in fnames]\nif len(fnames) > 1:\n    if method == 'absolute':\n        clipboard_files = ',\\n'.join('\"' + _fn + '\"' for _fn in fnames)\n    elif method == 'relative':\n        clipboard_files = ',\\n'.join('\"' + osp.relpath(_fn, explorer_dir).\n            replace(os.sep, '/') + '\"' for _fn in fnames)\nelif method == 'absolute':\n    clipboard_files = fnames[0]\nelif method == 'relative':\n    clipboard_files = osp.relpath(fnames[0], explorer_dir).replace(os.sep, '/')\ncopied_from = self.parent_widget.__class__.__name__\nif copied_from == 'ProjectExplorerWidget' and method == 'relative':\n    clipboard_files = [path.strip(',\"') for path in clipboard_files.\n        splitlines()]\n    clipboard_files = ['/'.join(path.strip('/').split('/')[1:]) for path in\n        clipboard_files]\n    if len(clipboard_files) > 1:\n        clipboard_files = ',\\n'.join('\"' + _fn + '\"' for _fn in clipboard_files\n            )\n    else:\n        clipboard_files = clipboard_files[0]\ncb.setText(clipboard_files, mode=cb.Clipboard)\n",
        "CUT_3": "\"\"\"Copy relative paths of named files/directories to the clipboard.\"\"\"\nself.copy_path(method='relative')\nSlot()",
        "CUT_4": "\"\"\"Copy relative paths of named files/directories to the clipboard.\"\"\"\nself.copy_path(method='relative')\nSlot()",
        "CUT_5": "\"\"\"Setup proxy model filter parameters\"\"\"\nself.root_path = osp.normpath(to_text_string(root_path))\nself.path_list = [osp.normpath(to_text_string(p)) for p in path_list]\nself.invalidateFilter()\n"
    },
    {
        "functionName": "test_copy_file",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test copy file(s)/folders(s) to clipboard.\"\"\"\nproject, __, file_paths, __, cb = explorer_with_files\nproject.explorer.treewidget.copy_file_clipboard(fnames=file_paths)\ncb_data = cb.mimeData().urls()\nassert len(cb_data) == len(file_paths)\nfor url, expected_path in zip(cb_data, file_paths):\n    file_name = url.toLocalFile()\n    assert osp.normpath(file_name) == osp.normpath(expected_path)\n    try:\n        assert osp.isdir(file_name)\n    except AssertionError:\n        assert osp.isfile(file_name)\n        with open(file_name, 'r') as fh:\n            text = fh.read()\n        assert text == 'File Path:\\n' + str(file_name)\n",
        "CUT_1": "\"\"\"Paste file from clipboard into file/project explorer directory.\"\"\"\nif fnames is None:\n    fnames = self.get_selected_filenames()\nif not isinstance(fnames, (tuple, list)):\n    fnames = [fnames]\nif len(fnames) >= 1:\n    try:\n        selected_item = osp.commonpath(fnames)\n    except AttributeError:\n        if len(fnames) > 1:\n            selected_item = osp.normpath(osp.dirname(osp.commonprefix(fnames)))\n        else:\n            selected_item = fnames[0]\n    if osp.isfile(selected_item):\n        parent_path = osp.dirname(selected_item)\n    else:\n        parent_path = osp.normpath(selected_item)\n    cb_data = QApplication.clipboard().mimeData()\n    if cb_data.hasUrls():\n        urls = cb_data.urls()\n        for url in urls:\n            source_name = url.toLocalFile()\n            base_name = osp.basename(source_name)\n            if osp.isfile(source_name):\n                try:\n                    while base_name in os.listdir(parent_path):\n                        file_no_ext, file_ext = osp.splitext(base_name)\n                        end_number = re.search('\\\\d+$', file_no_ext)\n                        if end_number:\n                            new_number = int(end_number.group()) + 1\n                        else:\n                            new_number = 1\n                        left_string = re.sub('\\\\d+$', '', file_no_ext)\n                        left_string += str(new_number)\n                        base_name = left_string + file_ext\n                        destination = osp.join(parent_path, base_name)\n                    else:\n                        destination = osp.join(parent_path, base_name)\n                    shutil.copy(source_name, destination)\n                except Exception as e:\n                    QMessageBox.critical(self, _('Error pasting file'), _(\n                        \"\"\"Unsupported copy operation. The error was:\n\n\"\"\") +\n                        to_text_string(e))\n            else:\n                try:\n                    while base_name in os.listdir(parent_path):\n                        end_number = re.search('\\\\d+$', base_name)\n                        if end_number:\n                            new_number = int(end_number.group()) + 1\n                        else:\n                            new_number = 1\n                        left_string = re.sub('\\\\d+$', '', base_name)\n                        base_name = left_string + str(new_number)\n                        destination = osp.join(parent_path, base_name)\n                    else:\n                        destination = osp.join(parent_path, base_name)\n                    if osp.realpath(destination).startswith(osp.realpath(\n                        source_name) + os.sep):\n                        QMessageBox.critical(self, _('Recursive copy'), _(\n                            'Source is an ancestor of destination folder.'))\n                        continue\n                    shutil.copytree(source_name, destination)\n                except Exception as e:\n                    QMessageBox.critical(self, _('Error pasting folder'), _\n                        (\"\"\"Unsupported copy operation. The error was:\n\n\"\"\"\n                        ) + to_text_string(e))\n    else:\n        QMessageBox.critical(self, _('No file in clipboard'), _(\n            'No file in the clipboard. Please copy a file to the clipboard first.'\n            ))\nelif QApplication.clipboard().mimeData().hasUrls():\n    QMessageBox.critical(self, _('Blank area'), _(\n        'Cannot paste in the blank area.'))\nelse:\n    pass\nSlot()",
        "CUT_2": "\"\"\"Paste file from clipboard into file/project explorer directory.\"\"\"\nif fnames is None:\n    fnames = self.get_selected_filenames()\nif not isinstance(fnames, (tuple, list)):\n    fnames = [fnames]\nif len(fnames) >= 1:\n    try:\n        selected_item = osp.commonpath(fnames)\n    except AttributeError:\n        if len(fnames) > 1:\n            selected_item = osp.normpath(osp.dirname(osp.commonprefix(fnames)))\n        else:\n            selected_item = fnames[0]\n    if osp.isfile(selected_item):\n        parent_path = osp.dirname(selected_item)\n    else:\n        parent_path = osp.normpath(selected_item)\n    cb_data = QApplication.clipboard().mimeData()\n    if cb_data.hasUrls():\n        urls = cb_data.urls()\n        for url in urls:\n            source_name = url.toLocalFile()\n            base_name = osp.basename(source_name)\n            if osp.isfile(source_name):\n                try:\n                    while base_name in os.listdir(parent_path):\n                        file_no_ext, file_ext = osp.splitext(base_name)\n                        end_number = re.search('\\\\d+$', file_no_ext)\n                        if end_number:\n                            new_number = int(end_number.group()) + 1\n                        else:\n                            new_number = 1\n                        left_string = re.sub('\\\\d+$', '', file_no_ext)\n                        left_string += str(new_number)\n                        base_name = left_string + file_ext\n                        destination = osp.join(parent_path, base_name)\n                    else:\n                        destination = osp.join(parent_path, base_name)\n                    shutil.copy(source_name, destination)\n                except Exception as e:\n                    QMessageBox.critical(self, _('Error pasting file'), _(\n                        \"\"\"Unsupported copy operation. The error was:\n\n\"\"\") +\n                        to_text_string(e))\n            else:\n                try:\n                    while base_name in os.listdir(parent_path):\n                        end_number = re.search('\\\\d+$', base_name)\n                        if end_number:\n                            new_number = int(end_number.group()) + 1\n                        else:\n                            new_number = 1\n                        left_string = re.sub('\\\\d+$', '', base_name)\n                        base_name = left_string + str(new_number)\n                        destination = osp.join(parent_path, base_name)\n                    else:\n                        destination = osp.join(parent_path, base_name)\n                    if osp.realpath(destination).startswith(osp.realpath(\n                        source_name) + os.sep):\n                        QMessageBox.critical(self, _('Recursive copy'), _(\n                            'Source is an ancestor of destination folder.'))\n                        continue\n                    shutil.copytree(source_name, destination)\n                except Exception as e:\n                    QMessageBox.critical(self, _('Error pasting folder'), _\n                        (\"\"\"Unsupported copy operation. The error was:\n\n\"\"\"\n                        ) + to_text_string(e))\n    else:\n        QMessageBox.critical(self, _('No file in clipboard'), _(\n            'No file in the clipboard. Please copy a file to the clipboard first.'\n            ))\nelif QApplication.clipboard().mimeData().hasUrls():\n    QMessageBox.critical(self, _('Blank area'), _(\n        'Cannot paste in the blank area.'))\nelse:\n    pass\nSlot()",
        "CUT_3": "\"\"\"Copy file(s)/folders(s) to clipboard.\"\"\"\nif fnames is None:\n    fnames = self.get_selected_filenames()\nif not isinstance(fnames, (tuple, list)):\n    fnames = [fnames]\ntry:\n    file_content = QMimeData()\n    file_content.setUrls([QUrl.fromLocalFile(_fn) for _fn in fnames])\n    cb = QApplication.clipboard()\n    cb.setMimeData(file_content, mode=cb.Clipboard)\nexcept Exception as e:\n    QMessageBox.critical(self, _('File/Folder copy error'), _(\n        \"\"\"Cannot copy this type of file(s) or folder(s). The error was:\n\n\"\"\"\n        ) + to_text_string(e))\nSlot()",
        "CUT_4": "\"\"\"Copy file(s)/folders(s) to clipboard.\"\"\"\nif fnames is None:\n    fnames = self.get_selected_filenames()\nif not isinstance(fnames, (tuple, list)):\n    fnames = [fnames]\ntry:\n    file_content = QMimeData()\n    file_content.setUrls([QUrl.fromLocalFile(_fn) for _fn in fnames])\n    cb = QApplication.clipboard()\n    cb.setMimeData(file_content, mode=cb.Clipboard)\nexcept Exception as e:\n    QMessageBox.critical(self, _('File/Folder copy error'), _(\n        \"\"\"Cannot copy this type of file(s) or folder(s). The error was:\n\n\"\"\"\n        ) + to_text_string(e))\nSlot()",
        "CUT_5": "\"\"\"\n        Insert text or file/folder path copied from clipboard.\n\n        Reimplement QPlainTextEdit's method to fix the following issue:\n        on Windows, pasted text has only 'LF' EOL chars even if the original\n        text has 'CRLF' EOL chars.\n        The function also changes the clipboard data if they are copied as\n        files/folders but does not change normal text data except if they are\n        multiple lines. Since we are changing clipboard data we cannot use\n        paste, which directly pastes from clipboard instead we use\n        insertPlainText and pass the formatted/changed text without modifying\n        clipboard content.\n        \"\"\"\nclipboard = QApplication.clipboard()\ntext = to_text_string(clipboard.text())\nif clipboard.mimeData().hasUrls():\n    urls = clipboard.mimeData().urls()\n    if all([url.isLocalFile() for url in urls]):\n        if len(urls) > 1:\n            sep_chars = ',' + self.get_line_separator()\n            text = sep_chars.join('\"' + url.toLocalFile().replace(osp.os.\n                sep, '/') + '\"' for url in urls)\n        else:\n            text = urls[0].toLocalFile().replace(osp.os.sep, '/')\nif len(text.splitlines()) > 1:\n    eol_chars = self.get_line_separator()\n    text = eol_chars.join((text + eol_chars).splitlines())\nself.skip_rstrip = True\nself.sig_will_paste_text.emit(text)\nTextEditBaseWidget.insertPlainText(self, text)\nself.sig_text_was_inserted.emit()\nself.document_did_change(text)\nself.skip_rstrip = False\nSlot()"
    },
    {
        "functionName": "test_save_file",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test save file(s)/folders(s) from clipboard.\"\"\"\nproject, dest, file_paths, __, __ = explorer_with_files\nproject.explorer.treewidget.copy_file_clipboard(fnames=file_paths)\ndest.explorer.treewidget.save_file_clipboard(fnames=[dest.directory])\nfor item in file_paths:\n    destination_item = osp.join(dest.directory, osp.basename(item))\n    assert osp.exists(destination_item)\n    if osp.isfile(destination_item):\n        with open(destination_item, 'r') as fh:\n            text = fh.read()\n        assert text == 'File Path:\\n' + str(item).replace(os.sep, '/')\n",
        "CUT_1": "\"\"\"Directory was renamed in file explorer or in project explorer.\"\"\"\ndirname = osp.abspath(to_text_string(source))\ntofile = to_text_string(dest)\nfor fname in self.get_filenames():\n    if osp.abspath(fname).startswith(dirname):\n        new_filename = fname.replace(dirname, tofile)\n        self.renamed(source=fname, dest=new_filename)\n",
        "CUT_2": "\"\"\"Directory was renamed in file explorer or in project explorer.\"\"\"\ndirname = osp.abspath(to_text_string(source))\ntofile = to_text_string(dest)\nfor fname in self.get_filenames():\n    if osp.abspath(fname).startswith(dirname):\n        new_filename = fname.replace(dirname, tofile)\n        self.renamed(source=fname, dest=new_filename)\n",
        "CUT_3": "\"\"\"Set the project directory\"\"\"\nif directory is not None:\n    self.treewidget.set_root_path(osp.dirname(directory))\n    self.treewidget.set_folder_names([osp.basename(directory)])\nself.treewidget.setup_project_view()\ntry:\n    self.treewidget.setExpanded(self.treewidget.get_index(directory), True)\nexcept TypeError:\n    pass\n",
        "CUT_4": "\"\"\"Set the project directory\"\"\"\nif directory is not None:\n    self.treewidget.set_root_path(osp.dirname(directory))\n    self.treewidget.set_folder_names([osp.basename(directory)])\nself.treewidget.setup_project_view()\ntry:\n    self.treewidget.setExpanded(self.treewidget.get_index(directory), True)\nexcept TypeError:\n    pass\n",
        "CUT_5": "\"\"\"\n        Propagate file rename to editor stacks and autosave component.\n\n        This function is called when a file is renamed in the file explorer\n        widget or the project explorer. The file may not be opened in the\n        editor.\n        \"\"\"\nfilename = osp.abspath(to_text_string(source))\nindex = self.editorstacks[0].has_filename(filename)\nif index is not None:\n    for editorstack in self.editorstacks:\n        editorstack.rename_in_data(filename, new_filename=to_text_string(dest))\n    self.editorstacks[0].autosave.file_renamed(filename, to_text_string(dest))\n"
    },
    {
        "functionName": "test_delete_file",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test delete file(s)/folders(s).\"\"\"\nproject, __, __, top_folder, __ = explorer_with_files\nmocker.patch.object(QMessageBox, 'warning', return_value=QMessageBox.Yes)\nproject.explorer.treewidget.delete(fnames=[top_folder])\nassert not osp.exists(top_folder)\n",
        "CUT_1": "\"\"\"A project directory with dirs and files for testing.\"\"\"\nproject_dir = to_text_string(tmpdir.mkdir('project'))\ndestination_dir = to_text_string(tmpdir.mkdir('destination'))\ntop_folder = osp.join(project_dir, 'top_folder_in_proj')\nif not osp.exists(top_folder):\n    os.mkdir(top_folder)\nlist_paths = []\nfor item in request.param:\n    if osp.splitext(item)[1]:\n        if osp.split(item)[0]:\n            dirs, fname = osp.split(item)\n            dirpath = osp.join(top_folder, dirs)\n            if not osp.exists(dirpath):\n                os.makedirs(dirpath)\n                item_path = osp.join(dirpath, fname)\n        else:\n            item_path = osp.join(top_folder, item)\n    else:\n        dirpath = osp.join(top_folder, item)\n        if not osp.exists(dirpath):\n            os.makedirs(dirpath)\n            item_path = dirpath\n    if not osp.isdir(item_path):\n        with open(item_path, 'w') as fh:\n            fh.write('File Path:\\n' + str(item_path).replace(os.sep, '/'))\n    list_paths.append(item_path)\nreturn list_paths, project_dir, destination_dir, top_folder\npytest.fixture(params=[['script.py', 'dir1/dir2/dir3/dir4'], ['script.py',\n    'script1.py', 'testdir/dir1/script2.py'], [\n    'subdir/innerdir/dir3/text.txt', 'dir1/dir2/dir3',\n    'dir1/dir2/dir3/file.txt', 'dir1/dir2/dir3/dir4/python.py']])",
        "CUT_2": "\"\"\"\n        Delete the current project without deleting the files in the directory.\n        \"\"\"\nif self.current_active_project:\n    self.unmaximize()\n    path = self.current_active_project.root_path\n    buttons = QMessageBox.Yes | QMessageBox.No\n    answer = QMessageBox.warning(self, _('Delete'), _(\n        'Do you really want to delete <b>{filename}</b>?<br><br><b>Note:</b> This action will only delete the project. Its files are going to be preserved on disk.'\n        ).format(filename=osp.basename(path)), buttons)\n    if answer == QMessageBox.Yes:\n        try:\n            self.close_project()\n            shutil.rmtree(osp.join(path, '.spyproject'))\n        except EnvironmentError as error:\n            QMessageBox.critical(self, _('Project Explorer'), _(\n                '<b>Unable to delete <i>{varpath}</i></b><br><br>The error message was:<br>{error}'\n                ).format(varpath=path, error=to_text_string(error)))\n",
        "CUT_3": "\"\"\"\n        Delete the current project without deleting the files in the directory.\n        \"\"\"\nif self.current_active_project:\n    self.unmaximize()\n    path = self.current_active_project.root_path\n    buttons = QMessageBox.Yes | QMessageBox.No\n    answer = QMessageBox.warning(self, _('Delete'), _(\n        'Do you really want to delete <b>{filename}</b>?<br><br><b>Note:</b> This action will only delete the project. Its files are going to be preserved on disk.'\n        ).format(filename=osp.basename(path)), buttons)\n    if answer == QMessageBox.Yes:\n        try:\n            self.close_project()\n            shutil.rmtree(osp.join(path, '.spyproject'))\n        except EnvironmentError as error:\n            QMessageBox.critical(self, _('Project Explorer'), _(\n                '<b>Unable to delete <i>{varpath}</i></b><br><br>The error message was:<br>{error}'\n                ).format(varpath=path, error=to_text_string(error)))\n",
        "CUT_4": "\"\"\"Delete file\"\"\"\nif multiple:\n    buttons = (QMessageBox.Yes | QMessageBox.YesToAll | QMessageBox.No |\n        QMessageBox.Cancel)\nelse:\n    buttons = QMessageBox.Yes | QMessageBox.No\nif yes_to_all is None:\n    answer = QMessageBox.warning(self, _('Delete'), _(\n        'Do you really want to delete <b>%s</b>?') % osp.basename(fname),\n        buttons)\n    if answer == QMessageBox.No:\n        return yes_to_all\n    elif answer == QMessageBox.Cancel:\n        return False\n    elif answer == QMessageBox.YesToAll:\n        yes_to_all = True\ntry:\n    if osp.isfile(fname):\n        misc.remove_file(fname)\n        self.sig_removed.emit(fname)\n    else:\n        self.remove_tree(fname)\n        self.sig_removed_tree.emit(fname)\n    return yes_to_all\nexcept EnvironmentError as error:\n    action_str = _('delete')\n    QMessageBox.critical(self, _('Project Explorer'), _(\n        '<b>Unable to %s <i>%s</i></b><br><br>Error message:<br>%s') % (\n        action_str, fname, to_text_string(error)))\nreturn False\n",
        "CUT_5": "\"\"\"Delete file\"\"\"\nif multiple:\n    buttons = (QMessageBox.Yes | QMessageBox.YesToAll | QMessageBox.No |\n        QMessageBox.Cancel)\nelse:\n    buttons = QMessageBox.Yes | QMessageBox.No\nif yes_to_all is None:\n    answer = QMessageBox.warning(self, _('Delete'), _(\n        'Do you really want to delete <b>%s</b>?') % osp.basename(fname),\n        buttons)\n    if answer == QMessageBox.No:\n        return yes_to_all\n    elif answer == QMessageBox.Cancel:\n        return False\n    elif answer == QMessageBox.YesToAll:\n        yes_to_all = True\ntry:\n    if osp.isfile(fname):\n        misc.remove_file(fname)\n        self.sig_removed.emit(fname)\n    else:\n        self.remove_tree(fname)\n        self.sig_removed_tree.emit(fname)\n    return yes_to_all\nexcept EnvironmentError as error:\n    action_str = _('delete')\n    QMessageBox.critical(self, _('Project Explorer'), _(\n        '<b>Unable to %s <i>%s</i></b><br><br>Error message:<br>%s') % (\n        action_str, fname, to_text_string(error)))\nreturn False\n"
    },
    {
        "functionName": "test_rename_file_with_files",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that rename_file renames the file and sends out right signal.\"\"\"\nproject, __, file_paths, __, __ = explorer_with_files\nfor old_path in file_paths:\n    if osp.isfile(old_path):\n        old_basename = osp.basename(old_path)\n        new_basename = 'new' + old_basename\n        new_path = osp.join(osp.dirname(old_path), new_basename)\n        mocker.patch.object(QInputDialog, 'getText', return_value=(\n            new_basename, True))\n        treewidget = project.explorer.treewidget\n        with qtbot.waitSignal(treewidget.sig_renamed) as blocker:\n            treewidget.rename_file(old_path)\n        assert blocker.args == [old_path, new_path]\n        assert not osp.exists(old_path)\n        with open(new_path, 'r') as fh:\n            text = fh.read()\n        assert text == 'File Path:\\n' + str(old_path).replace(os.sep, '/')\n",
        "CUT_1": "\"\"\"Return a URI with the given part(s) replaced.\n\n    Parts are decoded / encoded.\n    \"\"\"\nold_scheme, old_netloc, old_path, old_params, old_query, old_fragment = (\n    urlparse(uri))\npath, _netloc = _normalize_win_path(path)\nreturn urlunparse((scheme or old_scheme, netloc or old_netloc, path or\n    old_path, params or old_params, query or old_query, fragment or\n    old_fragment))\n",
        "CUT_2": "\"\"\"Set the project directory\"\"\"\nif directory is not None:\n    self.treewidget.set_root_path(osp.dirname(directory))\n    self.treewidget.set_folder_names([osp.basename(directory)])\nself.treewidget.setup_project_view()\ntry:\n    self.treewidget.setExpanded(self.treewidget.get_index(directory), True)\nexcept TypeError:\n    pass\n",
        "CUT_3": "\"\"\"Set the project directory\"\"\"\nif directory is not None:\n    self.treewidget.set_root_path(osp.dirname(directory))\n    self.treewidget.set_folder_names([osp.basename(directory)])\nself.treewidget.setup_project_view()\ntry:\n    self.treewidget.setExpanded(self.treewidget.get_index(directory), True)\nexcept TypeError:\n    pass\n",
        "CUT_4": "QWidget.__init__(self, parent)\nvlayout = QVBoxLayout()\nself.setLayout(vlayout)\nself.treewidget = FilteredDirView(self)\nself.treewidget.setup_view()\nself.treewidget.set_root_path(osp.dirname(osp.abspath(__file__)))\nself.treewidget.set_folder_names(['variableexplorer'])\nself.treewidget.setup_project_view()\nvlayout.addWidget(self.treewidget)\n",
        "CUT_5": "QWidget.__init__(self, parent)\nvlayout = QVBoxLayout()\nself.setLayout(vlayout)\nself.treewidget = FilteredDirView(self)\nself.treewidget.setup_view()\nself.treewidget.set_root_path(osp.dirname(osp.abspath(__file__)))\nself.treewidget.set_folder_names(['variableexplorer'])\nself.treewidget.setup_project_view()\nvlayout.addWidget(self.treewidget)\n"
    },
    {
        "functionName": "test_single_click_to_open",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test single and double click open option for the file explorer.\"\"\"\nfile_explorer.show()\ntreewidget = file_explorer.explorer.treewidget\nmodel = treewidget.model()\ncwd = os.getcwd()\nqtbot.keyClick(treewidget, Qt.Key_Up)\ninitial_index = treewidget.currentIndex()\ndef run_test_helper(single_click, initial_index):\n    treewidget.setCurrentIndex(initial_index)\n    file_explorer.label3.setText('')\n    file_explorer.label1.setText('')\n    for __ in range(4):\n        qtbot.keyClick(treewidget, Qt.Key_Down)\n        index = treewidget.currentIndex()\n        path = model.data(index)\n        if path:\n            full_path = os.path.join(cwd, path)\n            if os.path.isfile(full_path):\n                rect = treewidget.visualRect(index)\n                pos = rect.center()\n                qtbot.mouseClick(treewidget.viewport(), Qt.LeftButton, pos=pos)\n                if single_click:\n                    assert full_path == file_explorer.label1.text()\n                else:\n                    assert full_path != file_explorer.label1.text()\ntreewidget.set_single_click_to_open(True)\nassert 'True' in file_explorer.label3.text()\nrun_test_helper(single_click=True, initial_index=initial_index)\ntreewidget.set_single_click_to_open(False)\nassert 'False' in file_explorer.label3.text()\nrun_test_helper(single_click=False, initial_index=initial_index)\n",
        "CUT_1": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_2": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_3": "QWidget.__init__(self, parent)\nvlayout = QVBoxLayout()\nself.setLayout(vlayout)\nself.treewidget = FilteredDirView(self)\nself.treewidget.setup_view()\nself.treewidget.set_root_path(osp.dirname(osp.abspath(__file__)))\nself.treewidget.set_folder_names(['variableexplorer'])\nself.treewidget.setup_project_view()\nvlayout.addWidget(self.treewidget)\n",
        "CUT_4": "QWidget.__init__(self, parent)\nvlayout = QVBoxLayout()\nself.setLayout(vlayout)\nself.treewidget = FilteredDirView(self)\nself.treewidget.setup_view()\nself.treewidget.set_root_path(osp.dirname(osp.abspath(__file__)))\nself.treewidget.set_folder_names(['variableexplorer'])\nself.treewidget.setup_project_view()\nvlayout.addWidget(self.treewidget)\n",
        "CUT_5": "\"\"\"Register plugin in Spyder's main window\"\"\"\nipyconsole = self.main.ipyconsole\ntreewidget = self.fileexplorer.treewidget\nself.add_dockwidget()\nself.fileexplorer.sig_open_file.connect(self.main.open_file)\nself.register_widget_shortcuts(treewidget)\ntreewidget.sig_edit.connect(self.main.editor.load)\ntreewidget.sig_removed.connect(self.main.editor.removed)\ntreewidget.sig_removed_tree.connect(self.main.editor.removed_tree)\ntreewidget.sig_renamed.connect(self.main.editor.renamed)\ntreewidget.sig_renamed_tree.connect(self.main.editor.renamed_tree)\ntreewidget.sig_create_module.connect(self.main.editor.new)\ntreewidget.sig_new_file.connect(lambda t: self.main.editor.new(text=t))\ntreewidget.sig_open_interpreter.connect(ipyconsole.create_client_from_path)\ntreewidget.redirect_stdio.connect(self.main.redirect_internalshell_stdio)\ntreewidget.sig_run.connect(lambda fname: ipyconsole.run_script(fname, osp.\n    dirname(fname), '', False, False, False, True, False))\ntreewidget.sig_dir_opened.connect(self.sig_dir_opened)\n"
    },
    {
        "functionName": "run_test_helper",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "treewidget.setCurrentIndex(initial_index)\nfile_explorer.label3.setText('')\nfile_explorer.label1.setText('')\nfor __ in range(4):\n    qtbot.keyClick(treewidget, Qt.Key_Down)\n    index = treewidget.currentIndex()\n    path = model.data(index)\n    if path:\n        full_path = os.path.join(cwd, path)\n        if os.path.isfile(full_path):\n            rect = treewidget.visualRect(index)\n            pos = rect.center()\n            qtbot.mouseClick(treewidget.viewport(), Qt.LeftButton, pos=pos)\n            if single_click:\n                assert full_path == file_explorer.label1.text()\n            else:\n                assert full_path != file_explorer.label1.text()\n",
        "CUT_1": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_2": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_3": "QWidget.__init__(self, parent)\nvlayout = QVBoxLayout()\nself.setLayout(vlayout)\nself.treewidget = FilteredDirView(self)\nself.treewidget.setup_view()\nself.treewidget.set_root_path(osp.dirname(osp.abspath(__file__)))\nself.treewidget.set_folder_names(['variableexplorer'])\nself.treewidget.setup_project_view()\nvlayout.addWidget(self.treewidget)\n",
        "CUT_4": "QWidget.__init__(self, parent)\nvlayout = QVBoxLayout()\nself.setLayout(vlayout)\nself.treewidget = FilteredDirView(self)\nself.treewidget.setup_view()\nself.treewidget.set_root_path(osp.dirname(osp.abspath(__file__)))\nself.treewidget.set_folder_names(['variableexplorer'])\nself.treewidget.setup_project_view()\nvlayout.addWidget(self.treewidget)\n",
        "CUT_5": "\"\"\"Return image absolute path\"\"\"\nfor img_path in IMG_PATH:\n    full_path = osp.join(img_path, name)\n    if osp.isfile(full_path):\n        return osp.abspath(full_path)\nif default is not None:\n    img_path = osp.join(get_module_path('spyder'), 'images')\n    return osp.abspath(osp.join(img_path, default))\n"
    },
    {
        "functionName": "test_get_common_file_associations",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = file_explorer_associations.explorer.treewidget\nassociations = widget.get_common_file_associations(['/some/path/file.txt',\n    '/some/path/file1.json', '/some/path/file2.csv'])\nif os.name == 'nt':\n    ext = '.exe'\nelif sys.platform == 'darwin':\n    ext = '.app'\nelse:\n    ext = '.desktop'\nassert associations[0][-1] == '/some/fake/some_app_1' + ext\npytest.mark.first",
        "CUT_1": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_2": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_3": "ext = osp.splitext(filename)[1].lower()\nif ext in self.load_funcs:\n    return self.load_funcs[ext](filename)\nelse:\n    return None, \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_4": "ext = osp.splitext(filename)[1].lower()\nif ext in self.save_funcs:\n    return self.save_funcs[ext](data, filename)\nelse:\n    return \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_5": "widget = FileAssociationsWidget()\nqtbot.addWidget(widget)\nif os.name == 'nt':\n    ext = '.exe'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.write_bytes(b'Binary file contents')\n    fpath = str(path_obj)\nelif sys.platform == 'darwin':\n    ext = '.app'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.mkdir()\n    fpath = str(path_obj)\nelse:\n    ext = '.desktop'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.write_text('Text file contents')\n    fpath = str(path_obj)\ndata = {'*.csv': [('App name 1', '/path/to/app 1' + ext), ('App name 2',\n    fpath)], '*.txt': [('App name 2', fpath), ('App name 3', \n    '/path/to/app 3' + ext)]}\nwidget.load_values(data)\nwidget.show()\nwidget.test_data = data\nreturn qtbot, widget\npytest.fixture"
    },
    {
        "functionName": "test_get_file_associations",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = file_explorer_associations.explorer.treewidget\nassociations = widget.get_file_associations('/some/path/file.txt')\nif os.name == 'nt':\n    ext = '.exe'\nelif sys.platform == 'darwin':\n    ext = '.app'\nelse:\n    ext = '.desktop'\nassert associations[0][-1] == '/some/fake/some_app_1' + ext\npytest.mark.first",
        "CUT_1": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_2": "\"\"\"Return file type icon\"\"\"\next = osp.splitext(fname)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nreturn get_icon('%s.png' % ext, ima.icon('FileIcon'))\n",
        "CUT_3": "ext = osp.splitext(filename)[1].lower()\nif ext in self.load_funcs:\n    return self.load_funcs[ext](filename)\nelse:\n    return None, \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_4": "ext = osp.splitext(filename)[1].lower()\nif ext in self.save_funcs:\n    return self.save_funcs[ext](data, filename)\nelse:\n    return \"<b>Unsupported file type '%s'</b>\" % ext\n",
        "CUT_5": "\"\"\"Get file language from filename\"\"\"\next = osp.splitext(filename)[1]\nif ext.startswith('.'):\n    ext = ext[1:]\nlanguage = ext\nif not ext:\n    if text is None:\n        text, _enc = encoding.read(filename)\n    for line in text.splitlines():\n        if not line.strip():\n            continue\n        if line.startswith('#!'):\n            shebang = line[2:]\n            if 'python' in shebang:\n                language = 'python'\n        else:\n            break\nreturn language\n"
    },
    {
        "functionName": "test_create_file_manage_actions",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = widget = file_explorer_associations.explorer.treewidget\nfpath = tmp_path / 'text.txt'\nfpath.write_text('hello!')\nfpath_2 = tmp_path / 'text.json'\nfpath_2.write_text('hello!')\nfpath_3 = tmp_path / 'text.md'\nfpath_3.write_text('hello!')\nactions = widget.create_file_manage_actions([str(fpath)])\naction_texts = [action.title().lower() for action in actions if isinstance(\n    action, QMenu)]\nassert 'open with' in action_texts\nactions = widget.create_file_manage_actions([str(fpath), str(fpath_2)])\naction_texts = [action.title().lower() for action in actions if isinstance(\n    action, QMenu)]\nassert 'open with' in action_texts\nactions = widget.create_file_manage_actions([str(fpath_3)])\naction_texts = [action.title().lower() for action in actions if isinstance(\n    action, QMenu)]\nassert not action_texts\npytest.mark.firstpytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on win and py2!')",
        "CUT_1": "\"\"\"Enable/disable actions\"\"\"\nif actions is not None:\n    for action in actions:\n        if action is not None:\n            action.setEnabled(enable)\n",
        "CUT_2": "\"\"\"Enable/disable actions\"\"\"\nif actions is not None:\n    for action in actions:\n        if action is not None:\n            action.setEnabled(enable)\n",
        "CUT_3": "for __, action in self.get_actions().items():\n    for widget in [self.plain_text, self.rich_text, self.source_combo, self\n        .object_combo, self.object_edit]:\n        if action not in widget.actions():\n            widget.addAction(action)\n",
        "CUT_4": "for __, action in self.get_actions().items():\n    for widget in [self.plain_text, self.rich_text, self.source_combo, self\n        .object_combo, self.object_edit]:\n        if action not in widget.actions():\n            widget.addAction(action)\n",
        "CUT_5": "\"\"\"Hide action shortcuts in menu.\"\"\"\nmenu_actions = menu.actions()\nfor action in menu_actions:\n    if getattr(action, '_shown_shortcut', False):\n        if action._shown_shortcut is not None:\n            action.setShortcut(QKeySequence())\n    elif action.menu() is not None:\n        self.hide_shortcuts(action.menu())\n    else:\n        continue\n"
    },
    {
        "functionName": "test_clicked",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = file_explorer_associations.explorer.treewidget\nsome_dir = tmp_path / 'some_dir'\nsome_dir.mkdir()\nfpath = some_dir / 'text.txt'\nfpath.write_text('hello!')\nwidget.chdir(str(some_dir))\nqtbot.wait(500)\nqtbot.keyClick(widget, Qt.Key_Up)\ndef interact():\n    msgbox = widget.findChild(QMessageBox)\n    assert msgbox\n    qtbot.keyClick(msgbox, Qt.Key_Return)\n_ = create_timer(interact)\nqtbot.keyClick(widget, Qt.Key_Return)\ndef interact_2():\n    msgbox = widget.findChild(QMessageBox)\n    assert not msgbox\nwidget.set_file_associations({})\n_ = create_timer(interact_2)\nqtbot.keyClick(widget, Qt.Key_Return)\npytest.mark.firstpytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on win and py2!')",
        "CUT_1": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "interact",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "msgbox = widget.findChild(QMessageBox)\nassert msgbox\nqtbot.keyClick(msgbox, Qt.Key_Return)\n",
        "CUT_1": "heading = _('Error message:')\nmsgbox = QMessageBox(QMessageBox.Critical, _('Restore'), _(\n    '<b>{}</b><br><br>{}<br>{}').format(text, heading, error), parent=self)\nmsgbox.exec_()\n",
        "CUT_2": "heading = _('Error message:')\nmsgbox = QMessageBox(QMessageBox.Critical, _('Restore'), _(\n    '<b>{}</b><br><br>{}<br>{}').format(text, heading, error), parent=self)\nmsgbox.exec_()\n",
        "CUT_3": "\"\"\"Show message to restart Spyder since the DPI scale changed.\"\"\"\nself.screen.logicalDotsPerInchChanged.disconnect(self.show_dpi_change_message)\nif self.current_dpi == dpi:\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n    return\nif not self.show_dpi_message:\n    return\nwindow = self.window().windowHandle()\nif window.windowState() == Qt.WindowFullScreen and sys.platform == 'darwin':\n    return\ndismiss_box = QCheckBox(_('Hide this message during the current session'))\nmsgbox = QMessageBox(self)\nmsgbox.setIcon(QMessageBox.Warning)\nmsgbox.setText(_(\n    \"A monitor scale change was detected. <br><br>We recommend restarting Spyder to ensure that it's properly displayed. If you don't want to do that, please be sure to activate the option<br><br><tt>Enable auto high DPI scaling</tt><br><br>in <tt>Preferences > General > Interface</tt>, in case Spyder is not displayed correctly.<br><br>Do you want to restart Spyder?\"\n    ))\nrestart_button = msgbox.addButton(_('Restart now'), QMessageBox.NoRole)\ndismiss_button = msgbox.addButton(_('Dismiss'), QMessageBox.NoRole)\nmsgbox.setCheckBox(dismiss_box)\nmsgbox.setDefaultButton(dismiss_button)\nmsgbox.exec_()\nif dismiss_box.isChecked():\n    self.show_dpi_message = False\nif msgbox.clickedButton() == restart_button:\n    CONF.set('main', 'normal_screen_resolution', False)\n    CONF.set('main', 'high_dpi_scaling', True)\n    CONF.set('main', 'high_dpi_custom_scale_factor', False)\n    self.restart()\nelse:\n    self.current_dpi = dpi\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n",
        "CUT_4": "\"\"\"Show message to restart Spyder since the DPI scale changed.\"\"\"\nself.screen.logicalDotsPerInchChanged.disconnect(self.show_dpi_change_message)\nif self.current_dpi == dpi:\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n    return\nif not self.show_dpi_message:\n    return\nwindow = self.window().windowHandle()\nif window.windowState() == Qt.WindowFullScreen and sys.platform == 'darwin':\n    return\ndismiss_box = QCheckBox(_('Hide this message during the current session'))\nmsgbox = QMessageBox(self)\nmsgbox.setIcon(QMessageBox.Warning)\nmsgbox.setText(_(\n    \"A monitor scale change was detected. <br><br>We recommend restarting Spyder to ensure that it's properly displayed. If you don't want to do that, please be sure to activate the option<br><br><tt>Enable auto high DPI scaling</tt><br><br>in <tt>Preferences > General > Interface</tt>, in case Spyder is not displayed correctly.<br><br>Do you want to restart Spyder?\"\n    ))\nrestart_button = msgbox.addButton(_('Restart now'), QMessageBox.NoRole)\ndismiss_button = msgbox.addButton(_('Dismiss'), QMessageBox.NoRole)\nmsgbox.setCheckBox(dismiss_box)\nmsgbox.setDefaultButton(dismiss_button)\nmsgbox.exec_()\nif dismiss_box.isChecked():\n    self.show_dpi_message = False\nif msgbox.clickedButton() == restart_button:\n    CONF.set('main', 'normal_screen_resolution', False)\n    CONF.set('main', 'high_dpi_scaling', True)\n    CONF.set('main', 'high_dpi_custom_scale_factor', False)\n    self.restart()\nelse:\n    self.current_dpi = dpi\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n",
        "CUT_5": "\"\"\"Revert file from disk.\"\"\"\nindex = self.get_stack_index()\nfinfo = self.data[index]\nlogger.debug('Reverting {}'.format(finfo.filename))\nfilename = finfo.filename\nif finfo.editor.document().isModified():\n    self.msgbox = QMessageBox(QMessageBox.Warning, self.title, _(\n        'All changes to <b>%s</b> will be lost.<br>Do you want to revert file from disk?'\n        ) % osp.basename(filename), QMessageBox.Yes | QMessageBox.No, self)\n    answer = self.msgbox.exec_()\n    if answer != QMessageBox.Yes:\n        return\nself.reload(index)\n"
    },
    {
        "functionName": "interact_2",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "msgbox = widget.findChild(QMessageBox)\nassert not msgbox\n",
        "CUT_1": "heading = _('Error message:')\nmsgbox = QMessageBox(QMessageBox.Critical, _('Restore'), _(\n    '<b>{}</b><br><br>{}<br>{}').format(text, heading, error), parent=self)\nmsgbox.exec_()\n",
        "CUT_2": "heading = _('Error message:')\nmsgbox = QMessageBox(QMessageBox.Critical, _('Restore'), _(\n    '<b>{}</b><br><br>{}<br>{}').format(text, heading, error), parent=self)\nmsgbox.exec_()\n",
        "CUT_3": "\"\"\"Show message to restart Spyder since the DPI scale changed.\"\"\"\nself.screen.logicalDotsPerInchChanged.disconnect(self.show_dpi_change_message)\nif self.current_dpi == dpi:\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n    return\nif not self.show_dpi_message:\n    return\nwindow = self.window().windowHandle()\nif window.windowState() == Qt.WindowFullScreen and sys.platform == 'darwin':\n    return\ndismiss_box = QCheckBox(_('Hide this message during the current session'))\nmsgbox = QMessageBox(self)\nmsgbox.setIcon(QMessageBox.Warning)\nmsgbox.setText(_(\n    \"A monitor scale change was detected. <br><br>We recommend restarting Spyder to ensure that it's properly displayed. If you don't want to do that, please be sure to activate the option<br><br><tt>Enable auto high DPI scaling</tt><br><br>in <tt>Preferences > General > Interface</tt>, in case Spyder is not displayed correctly.<br><br>Do you want to restart Spyder?\"\n    ))\nrestart_button = msgbox.addButton(_('Restart now'), QMessageBox.NoRole)\ndismiss_button = msgbox.addButton(_('Dismiss'), QMessageBox.NoRole)\nmsgbox.setCheckBox(dismiss_box)\nmsgbox.setDefaultButton(dismiss_button)\nmsgbox.exec_()\nif dismiss_box.isChecked():\n    self.show_dpi_message = False\nif msgbox.clickedButton() == restart_button:\n    CONF.set('main', 'normal_screen_resolution', False)\n    CONF.set('main', 'high_dpi_scaling', True)\n    CONF.set('main', 'high_dpi_custom_scale_factor', False)\n    self.restart()\nelse:\n    self.current_dpi = dpi\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n",
        "CUT_4": "\"\"\"Show message to restart Spyder since the DPI scale changed.\"\"\"\nself.screen.logicalDotsPerInchChanged.disconnect(self.show_dpi_change_message)\nif self.current_dpi == dpi:\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n    return\nif not self.show_dpi_message:\n    return\nwindow = self.window().windowHandle()\nif window.windowState() == Qt.WindowFullScreen and sys.platform == 'darwin':\n    return\ndismiss_box = QCheckBox(_('Hide this message during the current session'))\nmsgbox = QMessageBox(self)\nmsgbox.setIcon(QMessageBox.Warning)\nmsgbox.setText(_(\n    \"A monitor scale change was detected. <br><br>We recommend restarting Spyder to ensure that it's properly displayed. If you don't want to do that, please be sure to activate the option<br><br><tt>Enable auto high DPI scaling</tt><br><br>in <tt>Preferences > General > Interface</tt>, in case Spyder is not displayed correctly.<br><br>Do you want to restart Spyder?\"\n    ))\nrestart_button = msgbox.addButton(_('Restart now'), QMessageBox.NoRole)\ndismiss_button = msgbox.addButton(_('Dismiss'), QMessageBox.NoRole)\nmsgbox.setCheckBox(dismiss_box)\nmsgbox.setDefaultButton(dismiss_button)\nmsgbox.exec_()\nif dismiss_box.isChecked():\n    self.show_dpi_message = False\nif msgbox.clickedButton() == restart_button:\n    CONF.set('main', 'normal_screen_resolution', False)\n    CONF.set('main', 'high_dpi_scaling', True)\n    CONF.set('main', 'high_dpi_custom_scale_factor', False)\n    self.restart()\nelse:\n    self.current_dpi = dpi\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n",
        "CUT_5": "\"\"\"Revert file from disk.\"\"\"\nindex = self.get_stack_index()\nfinfo = self.data[index]\nlogger.debug('Reverting {}'.format(finfo.filename))\nfilename = finfo.filename\nif finfo.editor.document().isModified():\n    self.msgbox = QMessageBox(QMessageBox.Warning, self.title, _(\n        'All changes to <b>%s</b> will be lost.<br>Do you want to revert file from disk?'\n        ) % osp.basename(filename), QMessageBox.Yes | QMessageBox.No, self)\n    answer = self.msgbox.exec_()\n    if answer != QMessageBox.Yes:\n        return\nself.reload(index)\n"
    },
    {
        "functionName": "test_check_launch_error_codes",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = file_explorer_associations.explorer.treewidget\nreturn_codes = {'some-command': 0, 'some-other-command': 0}\nassert widget.check_launch_error_codes(return_codes)\ndef interact():\n    msgbox = widget.findChild(QMessageBox)\n    assert msgbox\n    qtbot.keyClick(msgbox, Qt.Key_Return)\nreturn_codes = {'some-command': 1}\n_ = create_timer(interact)\nres = widget.check_launch_error_codes(return_codes)\nassert not res\ndef interact_2():\n    msgbox = widget.findChild(QMessageBox)\n    assert msgbox\n    qtbot.keyClick(msgbox, Qt.Key_Return)\nreturn_codes = {'some-command': 1, 'some-other-command': 1}\n_ = create_timer(interact_2)\nres = widget.check_launch_error_codes(return_codes)\nassert not res\npytest.mark.firstpytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on win and py2!')",
        "CUT_1": "\"\"\"Open files with given application executable path.\"\"\"\nif not (os.path.isdir(app_path) or os.path.isfile(app_path)):\n    return_codes = {app_path: 1}\n    app_path = None\nelse:\n    return_codes = {}\nif app_path:\n    fnames = self.get_selected_filenames()\n    return_codes = programs.open_files_with_application(app_path, fnames)\nself.check_launch_error_codes(return_codes)\nSlot()",
        "CUT_2": "\"\"\"Open files with given application executable path.\"\"\"\nif not (os.path.isdir(app_path) or os.path.isfile(app_path)):\n    return_codes = {app_path: 1}\n    app_path = None\nelse:\n    return_codes = {}\nif app_path:\n    fnames = self.get_selected_filenames()\n    return_codes = programs.open_files_with_application(app_path, fnames)\nself.check_launch_error_codes(return_codes)\nSlot()",
        "CUT_3": "heading = _('Error message:')\nmsgbox = QMessageBox(QMessageBox.Critical, _('Restore'), _(\n    '<b>{}</b><br><br>{}<br>{}').format(text, heading, error), parent=self)\nmsgbox.exec_()\n",
        "CUT_4": "heading = _('Error message:')\nmsgbox = QMessageBox(QMessageBox.Critical, _('Restore'), _(\n    '<b>{}</b><br><br>{}<br>{}').format(text, heading, error), parent=self)\nmsgbox.exec_()\n",
        "CUT_5": "\"\"\"Show message to restart Spyder since the DPI scale changed.\"\"\"\nself.screen.logicalDotsPerInchChanged.disconnect(self.show_dpi_change_message)\nif self.current_dpi == dpi:\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n    return\nif not self.show_dpi_message:\n    return\nwindow = self.window().windowHandle()\nif window.windowState() == Qt.WindowFullScreen and sys.platform == 'darwin':\n    return\ndismiss_box = QCheckBox(_('Hide this message during the current session'))\nmsgbox = QMessageBox(self)\nmsgbox.setIcon(QMessageBox.Warning)\nmsgbox.setText(_(\n    \"A monitor scale change was detected. <br><br>We recommend restarting Spyder to ensure that it's properly displayed. If you don't want to do that, please be sure to activate the option<br><br><tt>Enable auto high DPI scaling</tt><br><br>in <tt>Preferences > General > Interface</tt>, in case Spyder is not displayed correctly.<br><br>Do you want to restart Spyder?\"\n    ))\nrestart_button = msgbox.addButton(_('Restart now'), QMessageBox.NoRole)\ndismiss_button = msgbox.addButton(_('Dismiss'), QMessageBox.NoRole)\nmsgbox.setCheckBox(dismiss_box)\nmsgbox.setDefaultButton(dismiss_button)\nmsgbox.exec_()\nif dismiss_box.isChecked():\n    self.show_dpi_message = False\nif msgbox.clickedButton() == restart_button:\n    CONF.set('main', 'normal_screen_resolution', False)\n    CONF.set('main', 'high_dpi_scaling', True)\n    CONF.set('main', 'high_dpi_custom_scale_factor', False)\n    self.restart()\nelse:\n    self.current_dpi = dpi\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n"
    },
    {
        "functionName": "test_open_association",
        "className": null,
        "fileName": "/spyder/plugins/explorer/widgets/tests/test_explorer.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = file_explorer_associations.explorer.treewidget\nsome_dir = tmp_path / 'some_dir'\nsome_dir.mkdir()\nfpath = some_dir / 'text.txt'\nfpath.write_text('hello!')\nqtbot.keyClick(widget, Qt.Key_Down)\ndef interact():\n    msgbox = widget.findChild(QMessageBox)\n    assert msgbox\n    qtbot.keyClick(msgbox, Qt.Key_Return)\n_ = create_timer(interact)\nwidget.open_association('some-app')\npytest.mark.firstpytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on win and py2!')",
        "CUT_1": "widget = FileAssociationsWidget()\nqtbot.addWidget(widget)\nif os.name == 'nt':\n    ext = '.exe'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.write_bytes(b'Binary file contents')\n    fpath = str(path_obj)\nelif sys.platform == 'darwin':\n    ext = '.app'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.mkdir()\n    fpath = str(path_obj)\nelse:\n    ext = '.desktop'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.write_text('Text file contents')\n    fpath = str(path_obj)\ndata = {'*.csv': [('App name 1', '/path/to/app 1' + ext), ('App name 2',\n    fpath)], '*.txt': [('App name 2', fpath), ('App name 3', \n    '/path/to/app 3' + ext)]}\nwidget.load_values(data)\nwidget.show()\nwidget.test_data = data\nreturn qtbot, widget\npytest.fixture",
        "CUT_2": "\"\"\"Prompt user to select an application not found on the list.\"\"\"\napp = None\nitem = None\nif sys.platform == 'darwin':\n    if fpath is None:\n        basedir = '/Applications/'\n        filters = _('Applications (*.app)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.app') and os.path.isdir(fpath):\n        app = os.path.basename(fpath).split('.app')[0]\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nelif os.name == 'nt':\n    if fpath is None:\n        basedir = 'C:\\\\'\n        filters = _('Applications (*.exe *.bat *.com)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath:\n        check_1 = fpath.endswith('.bat') and is_text_file(fpath)\n        check_2 = fpath.endswith(('.exe', '.com')) and not is_text_file(fpath)\n        if check_1 or check_2:\n            app = os.path.basename(fpath).capitalize().rsplit('.')[0]\n            for row in range(self.list.count()):\n                item = self.list.item(row)\n                if app == item.text() and fpath == item.fpath:\n                    break\n            else:\n                item = None\nelse:\n    if fpath is None:\n        basedir = '/'\n        filters = _('Applications (*.desktop)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.desktop') and is_text_file(fpath):\n        entry_data = parse_linux_desktop_entry(fpath)\n        app = entry_data['name']\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nif fpath:\n    if item:\n        self.list.setCurrentItem(item)\n    elif app:\n        icon = get_application_icon(fpath)\n        item = QListWidgetItem(icon, app)\n        item.fpath = fpath\n        self.list.addItem(item)\n        self.list.setCurrentItem(item)\nself.list.setFocus()\nself._refresh()\n",
        "CUT_3": "\"\"\"Prompt user to select an application not found on the list.\"\"\"\napp = None\nitem = None\nif sys.platform == 'darwin':\n    if fpath is None:\n        basedir = '/Applications/'\n        filters = _('Applications (*.app)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.app') and os.path.isdir(fpath):\n        app = os.path.basename(fpath).split('.app')[0]\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nelif os.name == 'nt':\n    if fpath is None:\n        basedir = 'C:\\\\'\n        filters = _('Applications (*.exe *.bat *.com)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath:\n        check_1 = fpath.endswith('.bat') and is_text_file(fpath)\n        check_2 = fpath.endswith(('.exe', '.com')) and not is_text_file(fpath)\n        if check_1 or check_2:\n            app = os.path.basename(fpath).capitalize().rsplit('.')[0]\n            for row in range(self.list.count()):\n                item = self.list.item(row)\n                if app == item.text() and fpath == item.fpath:\n                    break\n            else:\n                item = None\nelse:\n    if fpath is None:\n        basedir = '/'\n        filters = _('Applications (*.desktop)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.desktop') and is_text_file(fpath):\n        entry_data = parse_linux_desktop_entry(fpath)\n        app = entry_data['name']\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nif fpath:\n    if item:\n        self.list.setCurrentItem(item)\n    elif app:\n        icon = get_application_icon(fpath)\n        item = QListWidgetItem(icon, app)\n        item.fpath = fpath\n        self.list.addItem(item)\n        self.list.setCurrentItem(item)\nself.list.setFocus()\nself._refresh()\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "create_file",
        "className": null,
        "fileName": "/spyder/plugins/history/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "path = os.path.join(tempfile.gettempdir(), name)\nwith open(path, 'w') as fh:\n    fh.write(content)\nreturn path\n",
        "CUT_1": "return path\n",
        "CUT_2": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_3": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_4": "netloc = ''\nif IS_WIN:\n    path = path.replace('\\\\', '/')\nif path[:2] == '//':\n    idx = path.index('/', 2)\n    if idx == -1:\n        netloc = path[2:]\n    else:\n        netloc = path[2:idx]\n        path = path[idx:]\nelse:\n    path = path\nif not path.startswith('/'):\n    path = '/' + path\nif RE_DRIVE_LETTER_PATH.match(path):\n    path = path[0] + path[1].lower() + path[2:]\nreturn path, netloc\n",
        "CUT_5": "\"\"\"Normalize windows path and remove extra quotes.\"\"\"\npath = path.replace('\\\\', '/').lower()\nif path[0] == '\"' and path[-1] == '\"':\n    path = literal_eval(path)\nreturn path\n"
    },
    {
        "functionName": "historylog",
        "className": null,
        "fileName": "/spyder/plugins/history/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Return a fixture for base history log, which is a plugin widget.\n    \"\"\"\nhistorylog = history.HistoryLog(None, configuration=CONF)\nhistorylog.close = lambda : True\nqtbot.addWidget(historylog)\nhistorylog.get_widget().show()\nyield historylog\nhistorylog.on_close()\nhistorylog.close()\npytest.fixture",
        "CUT_1": "\"\"\"\n        Bind historylog instance to this console.\n\n        Not used anymore since v2.0.\n        \"\"\"\nhistorylog.add_history(self.shell.history_filename)\nself.shell.append_to_history.connect(historylog.append_to_history)\n",
        "CUT_2": "\"\"\"\n        Bind historylog instance to this console.\n\n        Not used anymore since v2.0.\n        \"\"\"\nhistorylog.add_history(self.shell.history_filename)\nself.shell.append_to_history.connect(historylog.append_to_history)\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Run history widget.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = HistoryWidget.DEFAULT_OPTIONS.copy()\nwidget = HistoryWidget('historylog', None, None, options=options)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n",
        "CUT_5": "\"\"\"Run history widget.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\noptions = HistoryWidget.DEFAULT_OPTIONS.copy()\nwidget = HistoryWidget('historylog', None, None, options=options)\nwidget._setup(options)\nwidget.setup(options)\nwidget.show()\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_max_entries",
        "className": null,
        "fileName": "/spyder/plugins/history/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that history is truncated at max_entries.\n    \"\"\"\nhw = historylog.get_widget()\nmax_entries = hw.get_option('max_entries')\nhistory = ''\nfor i in range(max_entries + 1):\n    history = history + '{}\\n'.format(i)\npath = create_file('history.py', history)\nhw.add_history(to_text_string(path))\nwith open(path) as fh:\n    lines = fh.readlines()\nassert len(lines) == max_entries\nassert '0' not in lines[0]\n",
        "CUT_1": "\"\"\"\n        Load history from a text file in the user configuration directory.\n        \"\"\"\nif os.path.isfile(self.LOG_PATH):\n    with open(self.LOG_PATH, 'r') as fh:\n        lines = fh.read().split('\\n')\n    history = [line.replace('\\n', '') for line in lines]\nelse:\n    history = []\nreturn history\n",
        "CUT_2": "\"\"\"\n        Load history from a text file in the user configuration directory.\n        \"\"\"\nif os.path.isfile(self.LOG_PATH):\n    with open(self.LOG_PATH, 'r') as fh:\n        lines = fh.read().split('\\n')\n    history = [line.replace('\\n', '') for line in lines]\nelse:\n    history = []\nreturn history\n",
        "CUT_3": "\"\"\"\n        Load history from a text file in the Spyder configuration directory.\n        \"\"\"\nif osp.isfile(self.LOG_PATH):\n    with open(self.LOG_PATH, 'r') as fh:\n        lines = fh.read().split('\\n')\n    history = [line.replace('\\n', '') for line in lines]\nelse:\n    history = []\nreturn history\n",
        "CUT_4": "\"\"\"\n        Load history from a text file in the Spyder configuration directory.\n        \"\"\"\nif osp.isfile(self.LOG_PATH):\n    with open(self.LOG_PATH, 'r') as fh:\n        lines = fh.read().split('\\n')\n    history = [line.replace('\\n', '') for line in lines]\nelse:\n    history = []\nreturn history\n",
        "CUT_5": "return _('History')\n"
    },
    {
        "functionName": "test_init",
        "className": null,
        "fileName": "/spyder/plugins/history/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test HistoryLog\n\n    Test that the initialization created the expected instance variables\n    and widgets for a new HistoryLog instance.\n    \"\"\"\nhl = historylog\nassert hl.get_widget().editors == []\nassert hl.get_widget().filenames == []\nassert len(hl.get_actions()) == 3\n",
        "CUT_1": "\"\"\"Apply color scheme from syntax highlighter to the editor\"\"\"\nhl = self.highlighter\nif hl is not None:\n    self.set_palette(background=hl.get_background_color(), foreground=hl.\n        get_foreground_color())\n    self.currentline_color = hl.get_currentline_color()\n    self.currentcell_color = hl.get_currentcell_color()\n    self.occurrence_color = hl.get_occurrence_color()\n    self.ctrl_click_color = hl.get_ctrlclick_color()\n    self.sideareas_color = hl.get_sideareas_color()\n    self.comment_color = hl.get_comment_color()\n    self.normal_color = hl.get_foreground_color()\n    self.matched_p_color = hl.get_matched_p_color()\n    self.unmatched_p_color = hl.get_unmatched_p_color()\n    self.edge_line.update_color()\n    self.indent_guides.update_color()\n    self.sig_theme_colors_changed.emit({'occurrence': self.occurrence_color})\n",
        "CUT_2": "\"\"\"Apply color scheme from syntax highlighter to the editor\"\"\"\nhl = self.highlighter\nif hl is not None:\n    self.set_palette(background=hl.get_background_color(), foreground=hl.\n        get_foreground_color())\n    self.currentline_color = hl.get_currentline_color()\n    self.currentcell_color = hl.get_currentcell_color()\n    self.occurrence_color = hl.get_occurrence_color()\n    self.ctrl_click_color = hl.get_ctrlclick_color()\n    self.sideareas_color = hl.get_sideareas_color()\n    self.comment_color = hl.get_comment_color()\n    self.normal_color = hl.get_foreground_color()\n    self.matched_p_color = hl.get_matched_p_color()\n    self.unmatched_p_color = hl.get_unmatched_p_color()\n    self.edge_line.update_color()\n    self.indent_guides.update_color()\n    self.sig_theme_colors_changed.emit({'occurrence': self.occurrence_color})\n",
        "CUT_3": "hl = self._highlighter\nif hl is not None:\n    hl.setup_formats(self.font())\n    if self._color_scheme is not None:\n        hl.set_color_scheme(self._color_scheme)\n    self._set_palette(background=hl.get_background_color(), foreground=hl.\n        get_foreground_color())\n",
        "CUT_4": "hl = self._highlighter\nif hl is not None:\n    hl.setup_formats(self.font())\n    if self._color_scheme is not None:\n        hl.set_color_scheme(self._color_scheme)\n    self._set_palette(background=hl.get_background_color(), foreground=hl.\n        get_foreground_color())\n",
        "CUT_5": "\"\"\"\n        Bind historylog instance to this console.\n\n        Not used anymore since v2.0.\n        \"\"\"\nhistorylog.add_history(self.shell.history_filename)\nself.shell.append_to_history.connect(historylog.append_to_history)\n"
    },
    {
        "functionName": "test_add_history",
        "className": null,
        "fileName": "/spyder/plugins/history/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the add_history method.\n\n    Test adding a history file to the history log widget and the\n    code editor properties that are enabled/disabled.\n    \"\"\"\nhl = historylog\nhw = historylog.get_widget()\nassert len(hw.editors) == 0\nname1 = 'test_history.py'\ntext1 = \"\"\"a = 5\nb= 10\na + b\n\"\"\"\npath1 = create_file(name1, text1)\ntab1 = os.path.basename(path1)\nhw.set_option('line_numbers', False)\nhw.set_option('wrap', False)\nhl.add_history(path1)\nassert len(hw.editors) == 1\nassert hw.filenames == [path1]\nassert hw.tabwidget.currentIndex() == 0\nassert not hw.editors[0].linenumberarea.isVisible()\nassert hw.editors[0].wordWrapMode() == QTextOption.NoWrap\nassert hw.tabwidget.tabText(0) == tab1\nassert hw.tabwidget.tabToolTip(0) == path1\nhw.add_history(path1)\nassert hw.tabwidget.currentIndex() == 0\nname2 = 'history2.js'\ntext2 = \"\"\"random text\nspam line\n\n\n\n\"\"\"\npath2 = create_file(name2, text2)\ntab2 = os.path.basename(path2)\nhw.set_option('line_numbers', True)\nhw.set_option('wrap', True)\nhw.add_history(path2)\nassert len(hw.editors) == 2\nassert hw.filenames == [path1, path2]\nassert hw.tabwidget.currentIndex() == 1\nassert hw.editors[1].wordWrapMode() == QTextOption.WrapAtWordBoundaryOrAnywhere\nassert hw.editors[1].linenumberarea.isVisible()\nassert hw.tabwidget.tabText(1) == tab2\nassert hw.tabwidget.tabToolTip(1) == path2\nassert hw.filenames == [path1, path2]\nassert hw.editors[0].supported_language\nassert hw.editors[0].isReadOnly()\nassert not hw.editors[0].isVisible()\nassert hw.editors[0].toPlainText() == text1\nassert not hw.editors[1].supported_language\nassert hw.editors[1].isReadOnly()\nassert hw.editors[1].isVisible()\nassert hw.editors[1].toPlainText() == text2\n",
        "CUT_1": "if self.tabwidget is not None:\n    if option == 'wrap':\n        for editor in self.editors:\n            editor.toggle_wrap_mode(value)\n    elif option == 'line_numbers':\n        for editor in self.editors:\n            editor.toggle_line_numbers(value)\n    elif option == 'color_scheme_name':\n        for editor in self.editors:\n            editor.set_font(self.font)\n",
        "CUT_2": "if self.tabwidget is not None:\n    if option == 'wrap':\n        for editor in self.editors:\n            editor.toggle_wrap_mode(value)\n    elif option == 'line_numbers':\n        for editor in self.editors:\n            editor.toggle_line_numbers(value)\n    elif option == 'color_scheme_name':\n        for editor in self.editors:\n            editor.set_font(self.font)\n",
        "CUT_3": "codeeditor = params['codeeditor']\nfilename = path_as_uri(params['file'])\nparams = {'textDocument': {'uri': filename}}\nif filename not in self.watched_files:\n    params[ClientConstants.CANCEL] = True\nelse:\n    editors = self.watched_files[filename]\n    if len(editors) > 1:\n        params[ClientConstants.CANCEL] = True\n    idx = -1\n    for i, editor in enumerate(editors):\n        if id(codeeditor) == id(editor):\n            idx = i\n            break\n    if idx > 0:\n        editors.pop(idx)\n    if len(editors) == 0:\n        self.watched_files.pop(filename)\nreturn params\nsend_notification(method=LSPRequestTypes.DOCUMENT_DID_CLOSE)",
        "CUT_4": "codeeditor = params['codeeditor']\nfilename = path_as_uri(params['file'])\nparams = {'textDocument': {'uri': filename}}\nif filename not in self.watched_files:\n    params[ClientConstants.CANCEL] = True\nelse:\n    editors = self.watched_files[filename]\n    if len(editors) > 1:\n        params[ClientConstants.CANCEL] = True\n    idx = -1\n    for i, editor in enumerate(editors):\n        if id(codeeditor) == id(editor):\n            idx = i\n            break\n    if idx > 0:\n        editors.pop(idx)\n    if len(editors) == 0:\n        self.watched_files.pop(filename)\nreturn params\nsend_notification(method=LSPRequestTypes.DOCUMENT_DID_CLOSE)",
        "CUT_5": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n"
    },
    {
        "functionName": "test_append_to_history",
        "className": null,
        "fileName": "/spyder/plugins/history/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the append_to_history method.\n\n    Test adding text to a history file.  Also test the go_to_eof config\n    option for positioning the cursor.\n    \"\"\"\nhl = historylog\nhw = historylog.get_widget()\nhw.set_option('go_to_eof', True)\ntext1 = 'import re\\n'\npath1 = create_file('test_history.py', text1)\nhw.add_history(path1)\nhw.editors[0].set_cursor_position('sof')\nhw.append_to_history(path1, 'foo = \"bar\"\\n')\nassert hw.editors[0].toPlainText() == text1 + 'foo = \"bar\"\\n'\nassert hw.tabwidget.currentIndex() == 0\nassert hw.editors[0].is_cursor_at_end()\nassert not hw.editors[0].linenumberarea.isVisible()\nhw.set_option('go_to_eof', False)\nhw.editors[0].set_cursor_position('sof')\nhw.append_to_history(path1, 'a = r\"[a-z]\"\\n')\nassert hw.editors[0].toPlainText() == \"\"\"import re\nfoo = \"bar\"\na = r\"[a-z]\\\"\n\"\"\"\nassert not hw.editors[0].is_cursor_at_end()\n",
        "CUT_1": "if self.tabwidget is not None:\n    if option == 'wrap':\n        for editor in self.editors:\n            editor.toggle_wrap_mode(value)\n    elif option == 'line_numbers':\n        for editor in self.editors:\n            editor.toggle_line_numbers(value)\n    elif option == 'color_scheme_name':\n        for editor in self.editors:\n            editor.set_font(self.font)\n",
        "CUT_2": "if self.tabwidget is not None:\n    if option == 'wrap':\n        for editor in self.editors:\n            editor.toggle_wrap_mode(value)\n    elif option == 'line_numbers':\n        for editor in self.editors:\n            editor.toggle_line_numbers(value)\n    elif option == 'color_scheme_name':\n        for editor in self.editors:\n            editor.set_font(self.font)\n",
        "CUT_3": "codeeditor = params['codeeditor']\nfilename = path_as_uri(params['file'])\nparams = {'textDocument': {'uri': filename}}\nif filename not in self.watched_files:\n    params[ClientConstants.CANCEL] = True\nelse:\n    editors = self.watched_files[filename]\n    if len(editors) > 1:\n        params[ClientConstants.CANCEL] = True\n    idx = -1\n    for i, editor in enumerate(editors):\n        if id(codeeditor) == id(editor):\n            idx = i\n            break\n    if idx > 0:\n        editors.pop(idx)\n    if len(editors) == 0:\n        self.watched_files.pop(filename)\nreturn params\nsend_notification(method=LSPRequestTypes.DOCUMENT_DID_CLOSE)",
        "CUT_4": "codeeditor = params['codeeditor']\nfilename = path_as_uri(params['file'])\nparams = {'textDocument': {'uri': filename}}\nif filename not in self.watched_files:\n    params[ClientConstants.CANCEL] = True\nelse:\n    editors = self.watched_files[filename]\n    if len(editors) > 1:\n        params[ClientConstants.CANCEL] = True\n    idx = -1\n    for i, editor in enumerate(editors):\n        if id(codeeditor) == id(editor):\n            idx = i\n            break\n    if idx > 0:\n        editors.pop(idx)\n    if len(editors) == 0:\n        self.watched_files.pop(filename)\nreturn params\nsend_notification(method=LSPRequestTypes.DOCUMENT_DID_CLOSE)",
        "CUT_5": "\"\"\"\n        Bind historylog instance to this console.\n\n        Not used anymore since v2.0.\n        \"\"\"\nhistorylog.add_history(self.shell.history_filename)\nself.shell.append_to_history.connect(historylog.append_to_history)\n"
    },
    {
        "functionName": "test_change_history_depth",
        "className": null,
        "fileName": "/spyder/plugins/history/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the change_history_depth method.\n\n    Modify the 'Maximum history entries' values to test the config action.\n    \"\"\"\nhw = historylog.get_widget()\nassert hw.get_option('max_entries') == 100\nhw.change_history_depth(100)\nassert hw.get_option('max_entries') == 100\nhw.change_history_depth(475)\nassert hw.get_option('max_entries') == 475\n",
        "CUT_1": "super().__init__(parent)\nmax_entries = self.get_option('max_entries', DEFAULT_HISTORY_ENTRIES)\nself.pylint = PylintWidget(self, max_entries=max_entries, options_button=\n    self.options_button, text_color=MAIN_TEXT_COLOR, prevrate_color=\n    MAIN_PREVRATE_COLOR, top_max_entries=MAX_HISTORY_ENTRIES)\nlayout = QVBoxLayout()\nlayout.addWidget(self.pylint)\nself.setLayout(layout)\nhistory_action = create_action(self, _('History...'), None, ima.icon(\n    'history'), _('Set history maximum entries'), triggered=self.\n    change_history_depth)\nself.pylint.treewidget.common_actions += None, history_action\nself.main.editor.sig_editor_focus_changed.connect(self.set_filename)\nself.pylint.start_analysis.connect(self.run_pylint_from_analyze_button)\n",
        "CUT_2": "super().__init__(parent)\nmax_entries = self.get_option('max_entries', DEFAULT_HISTORY_ENTRIES)\nself.pylint = PylintWidget(self, max_entries=max_entries, options_button=\n    self.options_button, text_color=MAIN_TEXT_COLOR, prevrate_color=\n    MAIN_PREVRATE_COLOR, top_max_entries=MAX_HISTORY_ENTRIES)\nlayout = QVBoxLayout()\nlayout.addWidget(self.pylint)\nself.setLayout(layout)\nhistory_action = create_action(self, _('History...'), None, ima.icon(\n    'history'), _('Set history maximum entries'), triggered=self.\n    change_history_depth)\nself.pylint.treewidget.common_actions += None, history_action\nself.main.editor.sig_editor_focus_changed.connect(self.set_filename)\nself.pylint.start_analysis.connect(self.run_pylint_from_analyze_button)\n",
        "CUT_3": "\"\"\"Apply configuration file's plugin settings\"\"\"\nself.pylint.change_history_limit(self.get_option('max_entries'))\n",
        "CUT_4": "\"\"\"Apply configuration file's plugin settings\"\"\"\nself.pylint.change_history_limit(self.get_option('max_entries'))\n",
        "CUT_5": "\"\"\"\n        Change history max entries.\n\n        Parameters\n        ----------\n        depth: int, optional\n            Number of entries to use for the history. If None, an input dialog\n            will be used. Default is None.\n        \"\"\"\nvalid = True\nif depth is None:\n    depth, valid = QInputDialog.getInt(self, _('History'), _(\n        'Maximum entries'), self.get_option('max_entries'), 10, 10000)\nif valid:\n    self.set_option('max_entries', depth)\nSlot()Slot(int)"
    },
    {
        "functionName": "test_toggle_wrap_mode",
        "className": null,
        "fileName": "/spyder/plugins/history/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the toggle_wrap_mode method.\n\n    Toggle the 'Wrap lines' config action.\n    \"\"\"\nhw = historylog.get_widget()\npath = create_file('test.py', 'a = 1')\nhw.add_history(path)\nhw.set_option('wrap', False)\nassert hw.editors[0].wordWrapMode() == QTextOption.NoWrap\nassert not hw.get_option('wrap')\nhw.set_option('wrap', True)\nassert hw.editors[0].wordWrapMode() == QTextOption.WrapAtWordBoundaryOrAnywhere\nassert hw.get_option('wrap')\nhw.set_option('wrap', False)\nassert hw.editors[0].wordWrapMode() == QTextOption.NoWrap\nassert not hw.get_option('wrap')\n",
        "CUT_1": "\"\"\"\n        Set line wrap..\n\n        Paramaters\n        ----------\n        state: bool\n            Wrap state.\n        \"\"\"\nself.set_wrap_mode('word' if state else None)\n",
        "CUT_2": "\"\"\"\n        Set line wrap..\n\n        Paramaters\n        ----------\n        state: bool\n            Wrap state.\n        \"\"\"\nself.set_wrap_mode('word' if state else None)\n",
        "CUT_3": "\"\"\"\n        Set wrap mode\n        Valid *mode* values: None, 'word', 'character'\n        \"\"\"\nif mode == 'word':\n    wrap_mode = QTextOption.WrapAtWordBoundaryOrAnywhere\nelif mode == 'character':\n    wrap_mode = QTextOption.WrapAnywhere\nelse:\n    wrap_mode = QTextOption.NoWrap\nself.setWordWrapMode(wrap_mode)\n",
        "CUT_4": "\"\"\"\n        Set wrap mode\n        Valid *mode* values: None, 'word', 'character'\n        \"\"\"\nif mode == 'word':\n    wrap_mode = QTextOption.WrapAtWordBoundaryOrAnywhere\nelif mode == 'character':\n    wrap_mode = QTextOption.WrapAnywhere\nelse:\n    wrap_mode = QTextOption.NoWrap\nself.setWordWrapMode(wrap_mode)\n",
        "CUT_5": "if self.tabwidget is not None:\n    if option == 'wrap':\n        for editor in self.editors:\n            editor.toggle_wrap_mode(value)\n    elif option == 'line_numbers':\n        for editor in self.editors:\n            editor.toggle_line_numbers(value)\n    elif option == 'color_scheme_name':\n        for editor in self.editors:\n            editor.set_font(self.font)\n"
    },
    {
        "functionName": "test_toggle_line_numbers",
        "className": null,
        "fileName": "/spyder/plugins/history/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test toggle_line_numbers method.\n\n    Toggle the 'Show line numbers' config action.\n    \"\"\"\nhw = historylog.get_widget()\npath = create_file('test.py', 'a = 1')\nhw.add_history(path)\nhw.set_option('line_numbers', False)\nassert not hw.editors[0].linenumberarea.isVisible()\nassert not hw.get_option('line_numbers')\nhw.set_option('line_numbers', True)\nassert hw.editors[0].linenumberarea.isVisible()\nassert hw.get_option('line_numbers')\nhw.set_option('line_numbers', False)\nassert not hw.editors[0].linenumberarea.isVisible()\nassert not hw.get_option('line_numbers')\n",
        "CUT_1": "if self.tabwidget is not None:\n    if option == 'wrap':\n        for editor in self.editors:\n            editor.toggle_wrap_mode(value)\n    elif option == 'line_numbers':\n        for editor in self.editors:\n            editor.toggle_line_numbers(value)\n    elif option == 'color_scheme_name':\n        for editor in self.editors:\n            editor.set_font(self.font)\n",
        "CUT_2": "if self.tabwidget is not None:\n    if option == 'wrap':\n        for editor in self.editors:\n            editor.toggle_wrap_mode(value)\n    elif option == 'line_numbers':\n        for editor in self.editors:\n            editor.toggle_line_numbers(value)\n    elif option == 'color_scheme_name':\n        for editor in self.editors:\n            editor.set_font(self.font)\n",
        "CUT_3": "self.history_action = self.create_action(HistoryWidgetActions.\n    MaximumHistoryEntries, text=_('History...'), tip=_(\n    'Set history maximum entries'), icon=self.create_icon('history'),\n    triggered=self.change_history_depth)\nself.wrap_action = self.create_action(HistoryWidgetActions.ToggleWrap, text\n    =_('Wrap lines'), toggled=lambda value: self.set_option('wrap', value),\n    initial=self.get_option('wrap'))\nself.linenumbers_action = self.create_action(HistoryWidgetActions.\n    ToggleLineNumbers, text=_('Show line numbers'), toggled=lambda value:\n    self.set_option('line_numbers', value), initial=self.get_option(\n    'line_numbers'))\nmenu = self.get_options_menu()\nfor item in [self.history_action, self.wrap_action, self.linenumbers_action]:\n    self.add_item_to_menu(item, menu=menu, section=\n        HistoryWidgetOptionsMenuSections.Main)\n",
        "CUT_4": "self.history_action = self.create_action(HistoryWidgetActions.\n    MaximumHistoryEntries, text=_('History...'), tip=_(\n    'Set history maximum entries'), icon=self.create_icon('history'),\n    triggered=self.change_history_depth)\nself.wrap_action = self.create_action(HistoryWidgetActions.ToggleWrap, text\n    =_('Wrap lines'), toggled=lambda value: self.set_option('wrap', value),\n    initial=self.get_option('wrap'))\nself.linenumbers_action = self.create_action(HistoryWidgetActions.\n    ToggleLineNumbers, text=_('Show line numbers'), toggled=lambda value:\n    self.set_option('line_numbers', value), initial=self.get_option(\n    'line_numbers'))\nmenu = self.get_options_menu()\nfor item in [self.history_action, self.wrap_action, self.linenumbers_action]:\n    self.add_item_to_menu(item, menu=menu, section=\n        HistoryWidgetOptionsMenuSections.Main)\n",
        "CUT_5": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n"
    },
    {
        "functionName": "test_config_dialog",
        "className": null,
        "fileName": "/spyder/plugins/history/tests/test_history_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpage = config_dialog.get_page()\nassert configpage\nconfigpage.save_to_conf()\npytest.mark.parametrize('config_dialog', [[None, [], [HistoryLog]]],\n    indirect=True)",
        "CUT_1": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_2": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_3": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_4": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "test_config_dialog",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpage = config_dialog.get_page()\nconfigpage.save_to_conf()\nassert configpage\npytest.mark.parametrize('config_dialog', [[None, [], [Shortcuts]]],\n    indirect=True)",
        "CUT_1": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_2": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_3": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_4": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "shortcut_table",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up shortcuts.\"\"\"\nshortcut_table = ShortcutsTable()\nshortcut_table = load_shortcuts(shortcut_table)\nqtbot.addWidget(shortcut_table)\nreturn shortcut_table\npytest.fixture",
        "CUT_1": "\"\"\"\n    Load shortcuts into `shortcut_table`.\n    \"\"\"\nshortcut_data = load_shortcuts_data()\nshortcut_table.set_shortcut_data(shortcut_data)\nshortcut_table.load_shortcuts()\nreturn shortcut_table\n",
        "CUT_2": "\"\"\"\n    Load shortcuts into `shortcut_table`.\n    \"\"\"\nshortcut_data = load_shortcuts_data()\nshortcut_table.set_shortcut_data(shortcut_data)\nshortcut_table.load_shortcuts()\nreturn shortcut_table\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_5": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture"
    },
    {
        "functionName": "create_shortcut_editor",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "shortcuts = shortcut_table.source_model.shortcuts\ndef _create_bot(context, name):\n    sequence = CONF.get('shortcuts', '{}/{}'.format(context, name))\n    shortcut_editor = ShortcutEditor(shortcut_table, context, name,\n        sequence, shortcuts)\n    qtbot.addWidget(shortcut_editor)\n    shortcut_editor.show()\n    return shortcut_editor\nreturn _create_bot\npytest.fixture",
        "CUT_1": "\"\"\"Load shortcuts and assign to table model.\"\"\"\nshortcut_data = set([(item[1].lower(), item[2].lower()) for item in self.\n    shortcut_data])\nshortcut_data = list(sorted(set(shortcut_data)))\nshortcuts = []\nfor context, name, keystr in CONF.iter_shortcuts():\n    if (context, name) in shortcut_data:\n        context = context.lower()\n        name = name.lower()\n        shortcut = Shortcut(context, name, keystr)\n        shortcuts.append(shortcut)\nshortcuts = sorted(shortcuts, key=lambda item: item.context + item.name)\nfor i, shortcut in enumerate(shortcuts):\n    shortcut.index = i\nself.source_model.shortcuts = shortcuts\nself.source_model.scores = [0] * len(shortcuts)\nself.source_model.rich_text = [s.name for s in shortcuts]\nself.source_model.reset()\nself.adjust_cells()\nself.sortByColumn(CONTEXT, Qt.AscendingOrder)\n",
        "CUT_2": "\"\"\"Load shortcuts and assign to table model.\"\"\"\nshortcut_data = set([(item[1].lower(), item[2].lower()) for item in self.\n    shortcut_data])\nshortcut_data = list(sorted(set(shortcut_data)))\nshortcuts = []\nfor context, name, keystr in CONF.iter_shortcuts():\n    if (context, name) in shortcut_data:\n        context = context.lower()\n        name = name.lower()\n        shortcut = Shortcut(context, name, keystr)\n        shortcuts.append(shortcut)\nshortcuts = sorted(shortcuts, key=lambda item: item.context + item.name)\nfor i, shortcut in enumerate(shortcuts):\n    shortcut.index = i\nself.source_model.shortcuts = shortcuts\nself.source_model.scores = [0] * len(shortcuts)\nself.source_model.rich_text = [s.name for s in shortcuts]\nself.source_model.reset()\nself.adjust_cells()\nself.sortByColumn(CONTEXT, Qt.AscendingOrder)\n",
        "CUT_3": "\"\"\"Qt Override.\"\"\"\nself.shortcuts = sorted(self.shortcuts, key=lambda x: x.context + '/' + x.name)\nself.reset()\n",
        "CUT_4": "\"\"\"Qt Override.\"\"\"\nself.shortcuts = sorted(self.shortcuts, key=lambda x: x.context + '/' + x.name)\nself.reset()\n",
        "CUT_5": "\"\"\"Create, setup and display the shortcut editor dialog.\"\"\"\nindex = self.proxy_model.mapToSource(self.currentIndex())\nrow, column = index.row(), index.column()\nshortcuts = self.source_model.shortcuts\ncontext = shortcuts[row].context\nname = shortcuts[row].name\nsequence_index = self.source_model.index(row, SEQUENCE)\nsequence = sequence_index.data()\ndialog = ShortcutEditor(self, context, name, sequence, shortcuts)\nif dialog.exec_():\n    new_sequence = dialog.new_sequence\n    self.source_model.setData(sequence_index, new_sequence)\n"
    },
    {
        "functionName": "_create_bot",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "sequence = CONF.get('shortcuts', '{}/{}'.format(context, name))\nshortcut_editor = ShortcutEditor(shortcut_table, context, name, sequence,\n    shortcuts)\nqtbot.addWidget(shortcut_editor)\nshortcut_editor.show()\nreturn shortcut_editor\n",
        "CUT_1": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_2": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_3": "\"\"\"Set the new sequence to the default value defined in the config.\"\"\"\nsequence = CONF.get_default('shortcuts', '{}/{}'.format(self.context, self.\n    name))\nif sequence:\n    self._qsequences = sequence.split(', ')\n    self.update_warning()\nelse:\n    self.unbind_shortcut()\n",
        "CUT_4": "\"\"\"Set the new sequence to the default value defined in the config.\"\"\"\nsequence = CONF.get_default('shortcuts', '{}/{}'.format(self.context, self.\n    name))\nif sequence:\n    self._qsequences = sequence.split(', ')\n    self.update_warning()\nelse:\n    self.unbind_shortcut()\n",
        "CUT_5": "super(ShortcutEditor, self).__init__(parent)\nself._parent = parent\nself.setWindowFlags(self.windowFlags() & ~Qt.WindowContextHelpButtonHint)\nself.context = context\nself.name = name\nself.shortcuts = shortcuts\nself.current_sequence = sequence or _('<None>')\nself._qsequences = list()\nself.setup()\nself.update_warning()\n"
    },
    {
        "functionName": "__init__",
        "className": "FilterTextMock",
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "self.txt = text\n",
        "CUT_1": "\"\"\"Replaces the selected text by its lower version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.lower())\n",
        "CUT_2": "\"\"\"Replaces the selected text by its lower version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.lower())\n",
        "CUT_3": "\"\"\"Replaces the selected text by its upper version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.upper())\n",
        "CUT_4": "\"\"\"Replaces the selected text by its upper version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.upper())\n",
        "CUT_5": "return self.text\n"
    },
    {
        "functionName": "text",
        "className": "FilterTextMock",
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return self.txt\n",
        "CUT_1": "\"\"\"Replaces the selected text by its lower version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.lower())\n",
        "CUT_2": "\"\"\"Replaces the selected text by its lower version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.lower())\n",
        "CUT_3": "\"\"\"Replaces the selected text by its upper version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.upper())\n",
        "CUT_4": "\"\"\"Replaces the selected text by its upper version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.upper())\n",
        "CUT_5": "\"\"\"Return the last valid object name in string\"\"\"\ntxt_end = ''\nfor startchar, endchar in ['[]', '()']:\n    if txt.endswith(endchar):\n        pos = txt.rfind(startchar)\n        if pos:\n            txt_end = txt[pos:]\n            txt = txt[:pos]\ntokens = re.split(SYMBOLS, txt)\ntoken = None\ntry:\n    while token is None or re.match(SYMBOLS, token):\n        token = tokens.pop()\n    if token.endswith('.'):\n        token = token[:-1]\n    if token.startswith('.'):\n        return None\n    if last:\n        token += txt[txt.rfind(token) + len(token)]\n    token += txt_end\n    if token:\n        return token\nexcept IndexError:\n    return None\n"
    },
    {
        "functionName": "test_shortcuts",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run shortcuts table.\"\"\"\nshortcut_table.show()\nshortcut_table.check_shortcuts()\nassert shortcut_table\npytest.mark.skipif(sys.platform.startswith('linux') and os.environ.get('CI'\n    ) is not None, reason=\n    'It fails on Linux due to the lack of a proper X server.')",
        "CUT_1": "\"\"\"\n    Load shortcuts into `shortcut_table`.\n    \"\"\"\nshortcut_data = load_shortcuts_data()\nshortcut_table.set_shortcut_data(shortcut_data)\nshortcut_table.load_shortcuts()\nreturn shortcut_table\n",
        "CUT_2": "\"\"\"\n    Load shortcuts into `shortcut_table`.\n    \"\"\"\nshortcut_data = load_shortcuts_data()\nshortcut_table.set_shortcut_data(shortcut_data)\nshortcut_table.load_shortcuts()\nreturn shortcut_table\n",
        "CUT_3": "self.table.check_shortcuts()\n",
        "CUT_4": "self.table.check_shortcuts()\n",
        "CUT_5": "\"\"\"Save shortcuts from table model.\"\"\"\nself.check_shortcuts()\nfor shortcut in self.source_model.shortcuts:\n    shortcut.save()\n"
    },
    {
        "functionName": "test_shortcut_in_conf_is_filtered_with_shortcut_data",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "shortcut_table = ShortcutsTable()\nshortcut_table = load_shortcuts(shortcut_table)\nqtbot.addWidget(shortcut_table)\nrow_count = shortcut_table.model().rowCount()\nassert row_count != 0\nshortcut_table_empty = ShortcutsTable()\nshortcut_table_empty.set_shortcut_data([(None, '_', 'switch to plots', None,\n    None), (None, '_', 'switch to editor', None, None)])\nshortcut_table_empty.load_shortcuts()\nqtbot.addWidget(shortcut_table_empty)\nrow_count = shortcut_table_empty.model().rowCount()\nassert row_count == 2\n",
        "CUT_1": "\"\"\"\n    Load shortcuts into `shortcut_table`.\n    \"\"\"\nshortcut_data = load_shortcuts_data()\nshortcut_table.set_shortcut_data(shortcut_data)\nshortcut_table.load_shortcuts()\nreturn shortcut_table\n",
        "CUT_2": "\"\"\"\n    Load shortcuts into `shortcut_table`.\n    \"\"\"\nshortcut_data = load_shortcuts_data()\nshortcut_table.set_shortcut_data(shortcut_data)\nshortcut_table.load_shortcuts()\nreturn shortcut_table\n",
        "CUT_3": "self.args = None\nself.args_enabled = None\nself.wdir = None\nself.wdir_enabled = None\nself.current = None\nself.systerm = None\nself.interact = None\nself.post_mortem = None\nself.python_args = None\nself.python_args_enabled = None\nself.clear_namespace = None\nself.console_namespace = None\nself.file_dir = None\nself.cw_dir = None\nself.fixed_dir = None\nself.dir = None\nself.set(CONF.get('run', 'defaultconfiguration', default={}))\n",
        "CUT_4": "self.args = None\nself.args_enabled = None\nself.wdir = None\nself.wdir_enabled = None\nself.current = None\nself.systerm = None\nself.interact = None\nself.post_mortem = None\nself.python_args = None\nself.python_args_enabled = None\nself.clear_namespace = None\nself.console_namespace = None\nself.file_dir = None\nself.cw_dir = None\nself.fixed_dir = None\nself.dir = None\nself.set(CONF.get('run', 'defaultconfiguration', default={}))\n",
        "CUT_5": "QWidget.__init__(self, parent)\nself.shellwidget = None\nself.is_visible = True\nself.setup_in_progress = None\nself.check_all = None\nself.exclude_private = None\nself.exclude_uppercase = None\nself.exclude_capitalized = None\nself.exclude_unsupported = None\nself.exclude_callables_and_modules = None\nself.excluded_names = None\nself.minmax = None\nself.dataframe_format = None\nself.show_callable_attributes = None\nself.show_special_attributes = None\nself.editor = None\nself.exclude_private_action = None\nself.exclude_uppercase_action = None\nself.exclude_capitalized_action = None\nself.exclude_unsupported_action = None\nself.exclude_callables_and_modules_action = None\nself.finder = None\nself.options_button = options_button\nself.actions = None\nself.plugin_actions = plugin_actions\nself.filename = None\n"
    },
    {
        "functionName": "test_shortcuts_filtering",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run shortcuts table.\"\"\"\nrow_count = shortcut_table.model().rowCount()\nshortcut_table.finder = FilterTextMock('debug')\nshortcut_table.set_regex()\nassert not shortcut_table.isSortingEnabled()\nassert shortcut_table.model().rowCount() == 7\nshortcut_table.finder = FilterTextMock('')\nshortcut_table.set_regex()\nassert shortcut_table.isSortingEnabled()\nassert shortcut_table.model().rowCount() == row_count\nshortcut_table.finder = FilterTextMock('debug')\nshortcut_table.set_regex()\nshortcut_table.set_regex(reset=True)\nassert shortcut_table.isSortingEnabled()\nassert shortcut_table.model().rowCount() == row_count\n",
        "CUT_1": "\"\"\"\n    Load shortcuts into `shortcut_table`.\n    \"\"\"\nshortcut_data = load_shortcuts_data()\nshortcut_table.set_shortcut_data(shortcut_data)\nshortcut_table.load_shortcuts()\nreturn shortcut_table\n",
        "CUT_2": "\"\"\"\n    Load shortcuts into `shortcut_table`.\n    \"\"\"\nshortcut_data = load_shortcuts_data()\nshortcut_table.set_shortcut_data(shortcut_data)\nshortcut_table.load_shortcuts()\nreturn shortcut_table\n",
        "CUT_3": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_4": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_5": "self.table = ShortcutsTable(self, text_color=ima.MAIN_FG_COLOR)\nself.finder = ShortcutFinder(self.table, self.table.set_regex)\nself.label_finder = QLabel(_('Search: '))\nself.reset_btn = QPushButton(_('Reset to default values'))\nself.top_label = QLabel(_(\n    'Here you can browse the list of all available shortcuts in Spyder. You can also customize them by double-clicking on any entry in this table.'\n    ))\nself.table.finder = self.finder\nself.table.set_shortcut_data(self.plugin.get_shortcut_data())\nself.table.load_shortcuts()\nself.table.finder.setPlaceholderText(_(\n    'Search for a shortcut in the table above'))\nself.top_label.setWordWrap(True)\nhlayout = QHBoxLayout()\nvlayout = QVBoxLayout()\nvlayout.addWidget(self.top_label)\nhlayout.addWidget(self.label_finder)\nhlayout.addWidget(self.finder)\nvlayout.addWidget(self.table)\nvlayout.addLayout(hlayout)\nvlayout.addWidget(self.reset_btn)\nself.setLayout(vlayout)\nself.setTabOrder(self.table, self.finder)\nself.setTabOrder(self.finder, self.reset_btn)\nself.table.proxy_model.dataChanged.connect(lambda i1, i2, roles, opt='':\n    self.has_been_modified(opt))\nself.reset_btn.clicked.connect(self.reset_to_default)\n"
    },
    {
        "functionName": "test_shortcut_filtering_context",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test multifiltering by context and name in the table.\"\"\"\nassert len(shortcut_table.model().filters) == 2\nshortcut_table.finder = FilterTextMock('console')\nshortcut_table.set_regex()\nassert shortcut_table.model().rowCount() == 7\nshortcut_table.finder = FilterTextMock('pylint')\nshortcut_table.set_regex()\nassert shortcut_table.model().rowCount() == 2\n",
        "CUT_1": "\"\"\"\n    Load shortcuts into `shortcut_table`.\n    \"\"\"\nshortcut_data = load_shortcuts_data()\nshortcut_table.set_shortcut_data(shortcut_data)\nshortcut_table.load_shortcuts()\nreturn shortcut_table\n",
        "CUT_2": "\"\"\"\n    Load shortcuts into `shortcut_table`.\n    \"\"\"\nshortcut_data = load_shortcuts_data()\nshortcut_table.set_shortcut_data(shortcut_data)\nshortcut_table.load_shortcuts()\nreturn shortcut_table\n",
        "CUT_3": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_4": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_5": "self.table = ShortcutsTable(self, text_color=ima.MAIN_FG_COLOR)\nself.finder = ShortcutFinder(self.table, self.table.set_regex)\nself.label_finder = QLabel(_('Search: '))\nself.reset_btn = QPushButton(_('Reset to default values'))\nself.top_label = QLabel(_(\n    'Here you can browse the list of all available shortcuts in Spyder. You can also customize them by double-clicking on any entry in this table.'\n    ))\nself.table.finder = self.finder\nself.table.set_shortcut_data(self.plugin.get_shortcut_data())\nself.table.load_shortcuts()\nself.table.finder.setPlaceholderText(_(\n    'Search for a shortcut in the table above'))\nself.top_label.setWordWrap(True)\nhlayout = QHBoxLayout()\nvlayout = QVBoxLayout()\nvlayout.addWidget(self.top_label)\nhlayout.addWidget(self.label_finder)\nhlayout.addWidget(self.finder)\nvlayout.addWidget(self.table)\nvlayout.addLayout(hlayout)\nvlayout.addWidget(self.reset_btn)\nself.setLayout(vlayout)\nself.setTabOrder(self.table, self.finder)\nself.setTabOrder(self.finder, self.reset_btn)\nself.table.proxy_model.dataChanged.connect(lambda i1, i2, roles, opt='':\n    self.has_been_modified(opt))\nself.reset_btn.clicked.connect(self.reset_to_default)\n"
    },
    {
        "functionName": "test_clear_shortcut",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that pressing on the 'Clear' button to unbind the command from a\n    shortcut is working as expected.\n    \"\"\"\nshortcut_editor = create_shortcut_editor('editor', 'delete line')\nqtbot.mouseClick(shortcut_editor.button_clear, Qt.LeftButton)\nassert shortcut_editor.new_sequence == ''\n",
        "CUT_1": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_2": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_3": "\"\"\"Unbind the shortcut.\"\"\"\nself._qsequences = []\nself.accept()\n",
        "CUT_4": "\"\"\"Unbind the shortcut.\"\"\"\nself._qsequences = []\nself.accept()\n",
        "CUT_5": "self.editor.clear()\n"
    },
    {
        "functionName": "test_press_new_sequence",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that pressing a key sequence with modifier keys is registered as\n    expected by the Shortcut Editor.\n    \"\"\"\nshortcut_editor = create_shortcut_editor('editor', 'delete line')\nmodifiers = Qt.ControlModifier | Qt.ShiftModifier | Qt.AltModifier\nqtbot.keyClick(shortcut_editor, Qt.Key_D, modifier=modifiers)\nassert shortcut_editor.new_sequence == 'Ctrl+Alt+Shift+D'\nassert shortcut_editor.warning == NO_WARNING\nassert shortcut_editor.button_ok.isEnabled()\n",
        "CUT_1": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_2": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_3": "\"\"\"Override Qt method to process keypress.\"\"\"\ntext, key = event.text(), event.key()\nalt = event.modifiers() & Qt.AltModifier\nshift = event.modifiers() & Qt.ShiftModifier\nctrl = event.modifiers() & Qt.ControlModifier\naltgr = event.modifiers() and key == Qt.Key_AltGr\nneo2_level4 = key == 0\nmodifier = shift or ctrl or alt or altgr or neo2_level4\nif key in (Qt.Key_Return, Qt.Key_Enter, Qt.Key_Tab):\n    item = self.currentItem()\n    if item is None:\n        item = self.item(0)\n    if self.is_up_to_date(item=item):\n        self.item_selected(item=item)\n    else:\n        self.hide()\n        self.textedit.keyPressEvent(event)\nelif key == Qt.Key_Escape:\n    self.hide()\nelif key in (Qt.Key_Left, Qt.Key_Right) or text in ('.', ':'):\n    self.hide()\n    self.textedit.keyPressEvent(event)\nelif key in (Qt.Key_Up, Qt.Key_Down, Qt.Key_PageUp, Qt.Key_PageDown, Qt.\n    Key_Home, Qt.Key_End) and not modifier:\n    self.textedit._completions_hint_idle = True\n    if key == Qt.Key_Up and self.currentRow() == 0:\n        self.setCurrentRow(self.count() - 1)\n    elif key == Qt.Key_Down and self.currentRow() == self.count() - 1:\n        self.setCurrentRow(0)\n    else:\n        QListWidget.keyPressEvent(self, event)\nelif len(text) or key == Qt.Key_Backspace:\n    self.textedit.keyPressEvent(event)\n    self.update_current(new=False)\nelif modifier:\n    self.textedit.keyPressEvent(event)\nelse:\n    self.hide()\n    QListWidget.keyPressEvent(self, event)\n",
        "CUT_4": "\"\"\"Override Qt method to process keypress.\"\"\"\ntext, key = event.text(), event.key()\nalt = event.modifiers() & Qt.AltModifier\nshift = event.modifiers() & Qt.ShiftModifier\nctrl = event.modifiers() & Qt.ControlModifier\naltgr = event.modifiers() and key == Qt.Key_AltGr\nneo2_level4 = key == 0\nmodifier = shift or ctrl or alt or altgr or neo2_level4\nif key in (Qt.Key_Return, Qt.Key_Enter, Qt.Key_Tab):\n    item = self.currentItem()\n    if item is None:\n        item = self.item(0)\n    if self.is_up_to_date(item=item):\n        self.item_selected(item=item)\n    else:\n        self.hide()\n        self.textedit.keyPressEvent(event)\nelif key == Qt.Key_Escape:\n    self.hide()\nelif key in (Qt.Key_Left, Qt.Key_Right) or text in ('.', ':'):\n    self.hide()\n    self.textedit.keyPressEvent(event)\nelif key in (Qt.Key_Up, Qt.Key_Down, Qt.Key_PageUp, Qt.Key_PageDown, Qt.\n    Key_Home, Qt.Key_End) and not modifier:\n    self.textedit._completions_hint_idle = True\n    if key == Qt.Key_Up and self.currentRow() == 0:\n        self.setCurrentRow(self.count() - 1)\n    elif key == Qt.Key_Down and self.currentRow() == self.count() - 1:\n        self.setCurrentRow(0)\n    else:\n        QListWidget.keyPressEvent(self, event)\nelif len(text) or key == Qt.Key_Backspace:\n    self.textedit.keyPressEvent(event)\n    self.update_current(new=False)\nelif modifier:\n    self.textedit.keyPressEvent(event)\nelse:\n    self.hide()\n    QListWidget.keyPressEvent(self, event)\n",
        "CUT_5": "if isinstance(event, tuple):\n    _, key, modifiers, text, _, _ = event\n    event = tuple2keyevent(event)\nelse:\n    text = event.text()\n    modifiers = event.modifiers()\n    key = event.key()\nctrl = modifiers & Qt.ControlModifier\nshift = modifiers & Qt.ShiftModifier\nreturn event, text, key, ctrl, shift\n"
    },
    {
        "functionName": "test_press_new_compound_sequence",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that pressing a compund of key sequences is registered as\n    expected by the Shortcut Editor.\n    \"\"\"\nshortcut_editor = create_shortcut_editor('editor', 'delete line')\nqtbot.keyClick(shortcut_editor, Qt.Key_D, modifier=Qt.ControlModifier)\nqtbot.keyClick(shortcut_editor, Qt.Key_A)\nqtbot.keyClick(shortcut_editor, Qt.Key_B, modifier=Qt.ControlModifier)\nqtbot.keyClick(shortcut_editor, Qt.Key_C)\nqtbot.keyClick(shortcut_editor, Qt.Key_D)\nassert shortcut_editor.new_sequence == 'Ctrl+D, A, Ctrl+B, C'\nassert shortcut_editor.warning == NO_WARNING\nassert shortcut_editor.button_ok.isEnabled()\n",
        "CUT_1": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_2": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_clear_back_new_sequence",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that removing the last key sequence entered and clearing all entered\n    key sequence from the Shortcut Editor is working as expected.\n    \"\"\"\nshortcut_editor = create_shortcut_editor('editor', 'delete line')\nqtbot.keyClick(shortcut_editor, Qt.Key_X, modifier=Qt.ControlModifier)\nqtbot.keyClick(shortcut_editor, Qt.Key_A)\nqtbot.keyClick(shortcut_editor, Qt.Key_B, modifier=Qt.ControlModifier)\nqtbot.keyClick(shortcut_editor, Qt.Key_C)\nqtbot.keyClick(shortcut_editor, Qt.Key_D)\nqtbot.mouseClick(shortcut_editor.button_back_sequence, Qt.LeftButton)\nassert shortcut_editor.new_sequence == 'Ctrl+X, A, Ctrl+B'\nassert shortcut_editor.warning == SEQUENCE_CONFLICT\nassert shortcut_editor.button_ok.isEnabled()\nqtbot.mouseClick(shortcut_editor.button_back_sequence, Qt.LeftButton)\nassert shortcut_editor.new_sequence == 'Ctrl+X, A'\nassert shortcut_editor.warning == SEQUENCE_CONFLICT\nassert shortcut_editor.button_ok.isEnabled()\nqtbot.mouseClick(shortcut_editor.btn_clear_sequence, Qt.LeftButton)\nassert shortcut_editor.new_sequence == ''\nassert shortcut_editor.warning == SEQUENCE_EMPTY\nassert not shortcut_editor.button_ok.isEnabled()\n",
        "CUT_1": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_2": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_5": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n"
    },
    {
        "functionName": "test_sequence_conflict",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the Shortcut Editor is able to detect key sequence conflict\n    with other shortcuts.\n    \"\"\"\nshortcut_editor = create_shortcut_editor('editor', 'delete line')\nqtbot.keyClick(shortcut_editor, Qt.Key_X, modifier=Qt.ControlModifier)\nassert shortcut_editor.new_sequence == 'Ctrl+X'\nassert shortcut_editor.warning == SEQUENCE_CONFLICT\nassert shortcut_editor.button_ok.isEnabled()\nqtbot.keyClick(shortcut_editor, Qt.Key_X)\nassert shortcut_editor.new_sequence == 'Ctrl+X, X'\nassert shortcut_editor.warning == SEQUENCE_CONFLICT\nassert shortcut_editor.button_ok.isEnabled()\n",
        "CUT_1": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_2": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_3": "\"\"\"Update the warning label, buttons state and sequence text.\"\"\"\nnew_qsequence = self.new_qsequence\nnew_sequence = self.new_sequence\nself.text_new_sequence.setText(new_qsequence.toString(QKeySequence.NativeText))\nconflicts = self.check_conflicts()\nif len(self._qsequences) == 0:\n    warning = SEQUENCE_EMPTY\n    tip = ''\n    icon = QIcon()\nelif conflicts:\n    warning = SEQUENCE_CONFLICT\n    template = '<p style=\"margin-bottom: 0.3em\">{0}</p>{1}{2}'\n    tip_title = _('This key sequence conflicts with:')\n    tip_body = ''\n    for s in conflicts:\n        tip_body += '&nbsp;' * 2\n        tip_body += ' - {0}: <b>{1}</b><br>'.format(s.context, s.name)\n    tip_body += '<br>'\n    if len(conflicts) == 1:\n        tip_override = _(\"Press 'Ok' to unbind it and assign it to\")\n    else:\n        tip_override = _(\"Press 'Ok' to unbind them and assign it to\")\n    tip_override += ' <b>{}</b>.'.format(self.name)\n    tip = template.format(tip_title, tip_body, tip_override)\n    icon = get_std_icon('MessageBoxWarning')\nelif new_sequence in BLACKLIST:\n    warning = IN_BLACKLIST\n    tip = _('This key sequence is forbidden.')\n    icon = get_std_icon('MessageBoxWarning')\nelif self.check_singlekey() is False or self.check_ascii() is False:\n    warning = INVALID_KEY\n    tip = _('This key sequence is invalid.')\n    icon = get_std_icon('MessageBoxWarning')\nelse:\n    warning = NO_WARNING\n    tip = _('This key sequence is valid.')\n    icon = get_std_icon('DialogApplyButton')\nself.warning = warning\nself.conflicts = conflicts\nself.helper_button.setIcon(icon)\nself.button_ok.setEnabled(self.warning in [NO_WARNING, SEQUENCE_CONFLICT])\nself.label_warning.setText(tip)\n",
        "CUT_4": "\"\"\"Update the warning label, buttons state and sequence text.\"\"\"\nnew_qsequence = self.new_qsequence\nnew_sequence = self.new_sequence\nself.text_new_sequence.setText(new_qsequence.toString(QKeySequence.NativeText))\nconflicts = self.check_conflicts()\nif len(self._qsequences) == 0:\n    warning = SEQUENCE_EMPTY\n    tip = ''\n    icon = QIcon()\nelif conflicts:\n    warning = SEQUENCE_CONFLICT\n    template = '<p style=\"margin-bottom: 0.3em\">{0}</p>{1}{2}'\n    tip_title = _('This key sequence conflicts with:')\n    tip_body = ''\n    for s in conflicts:\n        tip_body += '&nbsp;' * 2\n        tip_body += ' - {0}: <b>{1}</b><br>'.format(s.context, s.name)\n    tip_body += '<br>'\n    if len(conflicts) == 1:\n        tip_override = _(\"Press 'Ok' to unbind it and assign it to\")\n    else:\n        tip_override = _(\"Press 'Ok' to unbind them and assign it to\")\n    tip_override += ' <b>{}</b>.'.format(self.name)\n    tip = template.format(tip_title, tip_body, tip_override)\n    icon = get_std_icon('MessageBoxWarning')\nelif new_sequence in BLACKLIST:\n    warning = IN_BLACKLIST\n    tip = _('This key sequence is forbidden.')\n    icon = get_std_icon('MessageBoxWarning')\nelif self.check_singlekey() is False or self.check_ascii() is False:\n    warning = INVALID_KEY\n    tip = _('This key sequence is invalid.')\n    icon = get_std_icon('MessageBoxWarning')\nelse:\n    warning = NO_WARNING\n    tip = _('This key sequence is valid.')\n    icon = get_std_icon('DialogApplyButton')\nself.warning = warning\nself.conflicts = conflicts\nself.helper_button.setIcon(icon)\nself.button_ok.setEnabled(self.warning in [NO_WARNING, SEQUENCE_CONFLICT])\nself.label_warning.setText(tip)\n",
        "CUT_5": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n"
    },
    {
        "functionName": "test_sequence_single_key",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the Shortcut Editor raise a warning when the first key\n    sequence entered is composed of a single key with no modifier and this\n    single key is not in the list of supported single key sequence.\n    \"\"\"\nshortcut_editor = create_shortcut_editor('editor', 'delete line')\nqtbot.keyClick(shortcut_editor, Qt.Key_D)\nassert shortcut_editor.new_sequence == 'D'\nassert shortcut_editor.warning == INVALID_KEY\nassert not shortcut_editor.button_ok.isEnabled()\nqtbot.keyClick(shortcut_editor, Qt.Key_D, modifier=Qt.ControlModifier)\nassert shortcut_editor.new_sequence == 'D, Ctrl+D'\nassert shortcut_editor.warning == INVALID_KEY\nassert not shortcut_editor.button_ok.isEnabled()\nqtbot.mouseClick(shortcut_editor.btn_clear_sequence, Qt.LeftButton)\nqtbot.keyClick(shortcut_editor, Qt.Key_Home)\nassert shortcut_editor.new_sequence == 'Home'\nassert shortcut_editor.warning == NO_WARNING\nassert shortcut_editor.button_ok.isEnabled()\n",
        "CUT_1": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_2": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_3": "\"\"\"Update the warning label, buttons state and sequence text.\"\"\"\nnew_qsequence = self.new_qsequence\nnew_sequence = self.new_sequence\nself.text_new_sequence.setText(new_qsequence.toString(QKeySequence.NativeText))\nconflicts = self.check_conflicts()\nif len(self._qsequences) == 0:\n    warning = SEQUENCE_EMPTY\n    tip = ''\n    icon = QIcon()\nelif conflicts:\n    warning = SEQUENCE_CONFLICT\n    template = '<p style=\"margin-bottom: 0.3em\">{0}</p>{1}{2}'\n    tip_title = _('This key sequence conflicts with:')\n    tip_body = ''\n    for s in conflicts:\n        tip_body += '&nbsp;' * 2\n        tip_body += ' - {0}: <b>{1}</b><br>'.format(s.context, s.name)\n    tip_body += '<br>'\n    if len(conflicts) == 1:\n        tip_override = _(\"Press 'Ok' to unbind it and assign it to\")\n    else:\n        tip_override = _(\"Press 'Ok' to unbind them and assign it to\")\n    tip_override += ' <b>{}</b>.'.format(self.name)\n    tip = template.format(tip_title, tip_body, tip_override)\n    icon = get_std_icon('MessageBoxWarning')\nelif new_sequence in BLACKLIST:\n    warning = IN_BLACKLIST\n    tip = _('This key sequence is forbidden.')\n    icon = get_std_icon('MessageBoxWarning')\nelif self.check_singlekey() is False or self.check_ascii() is False:\n    warning = INVALID_KEY\n    tip = _('This key sequence is invalid.')\n    icon = get_std_icon('MessageBoxWarning')\nelse:\n    warning = NO_WARNING\n    tip = _('This key sequence is valid.')\n    icon = get_std_icon('DialogApplyButton')\nself.warning = warning\nself.conflicts = conflicts\nself.helper_button.setIcon(icon)\nself.button_ok.setEnabled(self.warning in [NO_WARNING, SEQUENCE_CONFLICT])\nself.label_warning.setText(tip)\n",
        "CUT_4": "\"\"\"Update the warning label, buttons state and sequence text.\"\"\"\nnew_qsequence = self.new_qsequence\nnew_sequence = self.new_sequence\nself.text_new_sequence.setText(new_qsequence.toString(QKeySequence.NativeText))\nconflicts = self.check_conflicts()\nif len(self._qsequences) == 0:\n    warning = SEQUENCE_EMPTY\n    tip = ''\n    icon = QIcon()\nelif conflicts:\n    warning = SEQUENCE_CONFLICT\n    template = '<p style=\"margin-bottom: 0.3em\">{0}</p>{1}{2}'\n    tip_title = _('This key sequence conflicts with:')\n    tip_body = ''\n    for s in conflicts:\n        tip_body += '&nbsp;' * 2\n        tip_body += ' - {0}: <b>{1}</b><br>'.format(s.context, s.name)\n    tip_body += '<br>'\n    if len(conflicts) == 1:\n        tip_override = _(\"Press 'Ok' to unbind it and assign it to\")\n    else:\n        tip_override = _(\"Press 'Ok' to unbind them and assign it to\")\n    tip_override += ' <b>{}</b>.'.format(self.name)\n    tip = template.format(tip_title, tip_body, tip_override)\n    icon = get_std_icon('MessageBoxWarning')\nelif new_sequence in BLACKLIST:\n    warning = IN_BLACKLIST\n    tip = _('This key sequence is forbidden.')\n    icon = get_std_icon('MessageBoxWarning')\nelif self.check_singlekey() is False or self.check_ascii() is False:\n    warning = INVALID_KEY\n    tip = _('This key sequence is invalid.')\n    icon = get_std_icon('MessageBoxWarning')\nelse:\n    warning = NO_WARNING\n    tip = _('This key sequence is valid.')\n    icon = get_std_icon('DialogApplyButton')\nself.warning = warning\nself.conflicts = conflicts\nself.helper_button.setIcon(icon)\nself.button_ok.setEnabled(self.warning in [NO_WARNING, SEQUENCE_CONFLICT])\nself.label_warning.setText(tip)\n",
        "CUT_5": "\"\"\" \"\"\"\nkey = event.key()\nself.key_pressed = key\nkeys = [Qt.Key_Right, Qt.Key_Left, Qt.Key_Down, Qt.Key_Up, Qt.Key_Escape,\n    Qt.Key_PageUp, Qt.Key_PageDown, Qt.Key_Home, Qt.Key_End, Qt.Key_Menu]\nif key in keys:\n    if not self.is_fade_running():\n        self.sig_key_pressed.emit()\n"
    },
    {
        "functionName": "test_set_sequence_to_default",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that clicking on the button 'Default' set the sequence in the\n    Shortcut Editor to the default value as espected.\n    \"\"\"\nshortcut_editor = create_shortcut_editor('editor', 'delete line')\ndefault_sequence = CONF.get('shortcuts', '{}/{}'.format('editor',\n    'delete line'))\nqtbot.mouseClick(shortcut_editor.button_default, Qt.LeftButton)\nassert shortcut_editor.new_sequence == default_sequence\nassert shortcut_editor.warning == NO_WARNING\nassert shortcut_editor.button_ok.isEnabled()\n",
        "CUT_1": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_2": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Set the new sequence to the default value defined in the config.\"\"\"\nsequence = CONF.get_default('shortcuts', '{}/{}'.format(self.context, self.\n    name))\nif sequence:\n    self._qsequences = sequence.split(', ')\n    self.update_warning()\nelse:\n    self.unbind_shortcut()\n"
    },
    {
        "functionName": "test_invalid_char_in_sequence",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the key sequence is rejected and a warning is shown if an\n    invalid character is present in the new key sequence.\n    \"\"\"\nshortcut_editor = create_shortcut_editor('editor', 'delete line')\nqtbot.keyClick(shortcut_editor, Qt.Key_Odiaeresis, modifier=Qt.\n    ControlModifier | Qt.AltModifier)\nassert shortcut_editor.warning == INVALID_KEY\nassert not shortcut_editor.button_ok.isEnabled()\n",
        "CUT_1": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_2": "\"\"\"Show message on Help with the right shortcuts.\"\"\"\nintro_message_eq = _(\n    'Here you can get help of any object by pressing %s in front of it, either on the Editor or the Console.%s'\n    )\nintro_message_dif = _(\n    'Here you can get help of any object by pressing %s in front of it on the Editor, or %s in front of it on the Console.%s'\n    )\nintro_message_common = _(\n    'Help can also be shown automatically after writing a left parenthesis next to an object. You can activate this behavior in %s.'\n    )\nprefs = _('Preferences > Help')\nshortcut_editor = self.get_option('editor_shortcut')\nshortcut_console = self.get_option('console_shortcut')\nif sys.platform == 'darwin':\n    shortcut_editor = shortcut_editor.replace('Ctrl', 'Cmd')\n    shortcut_console = shortcut_console.replace('Ctrl', 'Cmd')\nif self.get_option('rich_mode'):\n    title = _('Usage')\n    tutorial_message = _('New to Spyder? Read our')\n    tutorial = _('tutorial')\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<br><br>', '<i>' + prefs + '</i>')\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % ('<b>' +\n            shortcut_editor + '</b>', '<b>' + shortcut_console + '</b>',\n            '<br><br>', '<i>' + prefs + '</i>')\n    self.set_rich_text_html(usage(title, intro_message, tutorial_message,\n        tutorial, css_path=self.css_path), QUrl.fromLocalFile(self.css_path))\nelse:\n    install_sphinx = '\\n\\n%s' % _(\n        'Please consider installing Sphinx to get documentation rendered in rich text.'\n        )\n    if shortcut_editor == shortcut_console:\n        intro_message = (intro_message_eq + intro_message_common) % (\n            shortcut_editor, '\\n\\n', prefs)\n    else:\n        intro_message = (intro_message_dif + intro_message_common) % (\n            shortcut_editor, shortcut_console, '\\n\\n', prefs)\n    intro_message += install_sphinx\n    self.set_plain_text(intro_message, is_code=False)\n",
        "CUT_3": "\"\"\"Override Qt method to process keypress.\"\"\"\ntext, key = event.text(), event.key()\nalt = event.modifiers() & Qt.AltModifier\nshift = event.modifiers() & Qt.ShiftModifier\nctrl = event.modifiers() & Qt.ControlModifier\naltgr = event.modifiers() and key == Qt.Key_AltGr\nneo2_level4 = key == 0\nmodifier = shift or ctrl or alt or altgr or neo2_level4\nif key in (Qt.Key_Return, Qt.Key_Enter, Qt.Key_Tab):\n    item = self.currentItem()\n    if item is None:\n        item = self.item(0)\n    if self.is_up_to_date(item=item):\n        self.item_selected(item=item)\n    else:\n        self.hide()\n        self.textedit.keyPressEvent(event)\nelif key == Qt.Key_Escape:\n    self.hide()\nelif key in (Qt.Key_Left, Qt.Key_Right) or text in ('.', ':'):\n    self.hide()\n    self.textedit.keyPressEvent(event)\nelif key in (Qt.Key_Up, Qt.Key_Down, Qt.Key_PageUp, Qt.Key_PageDown, Qt.\n    Key_Home, Qt.Key_End) and not modifier:\n    self.textedit._completions_hint_idle = True\n    if key == Qt.Key_Up and self.currentRow() == 0:\n        self.setCurrentRow(self.count() - 1)\n    elif key == Qt.Key_Down and self.currentRow() == self.count() - 1:\n        self.setCurrentRow(0)\n    else:\n        QListWidget.keyPressEvent(self, event)\nelif len(text) or key == Qt.Key_Backspace:\n    self.textedit.keyPressEvent(event)\n    self.update_current(new=False)\nelif modifier:\n    self.textedit.keyPressEvent(event)\nelse:\n    self.hide()\n    QListWidget.keyPressEvent(self, event)\n",
        "CUT_4": "\"\"\"Override Qt method to process keypress.\"\"\"\ntext, key = event.text(), event.key()\nalt = event.modifiers() & Qt.AltModifier\nshift = event.modifiers() & Qt.ShiftModifier\nctrl = event.modifiers() & Qt.ControlModifier\naltgr = event.modifiers() and key == Qt.Key_AltGr\nneo2_level4 = key == 0\nmodifier = shift or ctrl or alt or altgr or neo2_level4\nif key in (Qt.Key_Return, Qt.Key_Enter, Qt.Key_Tab):\n    item = self.currentItem()\n    if item is None:\n        item = self.item(0)\n    if self.is_up_to_date(item=item):\n        self.item_selected(item=item)\n    else:\n        self.hide()\n        self.textedit.keyPressEvent(event)\nelif key == Qt.Key_Escape:\n    self.hide()\nelif key in (Qt.Key_Left, Qt.Key_Right) or text in ('.', ':'):\n    self.hide()\n    self.textedit.keyPressEvent(event)\nelif key in (Qt.Key_Up, Qt.Key_Down, Qt.Key_PageUp, Qt.Key_PageDown, Qt.\n    Key_Home, Qt.Key_End) and not modifier:\n    self.textedit._completions_hint_idle = True\n    if key == Qt.Key_Up and self.currentRow() == 0:\n        self.setCurrentRow(self.count() - 1)\n    elif key == Qt.Key_Down and self.currentRow() == self.count() - 1:\n        self.setCurrentRow(0)\n    else:\n        QListWidget.keyPressEvent(self, event)\nelif len(text) or key == Qt.Key_Backspace:\n    self.textedit.keyPressEvent(event)\n    self.update_current(new=False)\nelif modifier:\n    self.textedit.keyPressEvent(event)\nelse:\n    self.hide()\n    QListWidget.keyPressEvent(self, event)\n",
        "CUT_5": "\"\"\" \"\"\"\nkey = event.key()\nself.key_pressed = key\nkeys = [Qt.Key_Right, Qt.Key_Left, Qt.Key_Down, Qt.Key_Up, Qt.Key_Escape,\n    Qt.Key_PageUp, Qt.Key_PageDown, Qt.Key_Home, Qt.Key_End, Qt.Key_Menu]\nif key in keys:\n    if not self.is_fade_running():\n        self.sig_key_pressed.emit()\n"
    },
    {
        "functionName": "dlg_shortcuts",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/widgets/tests/test_summary.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up shortcut summary widget.\"\"\"\ndlg_shortcuts = ShortcutsSummaryDialog(None)\nqtbot.addWidget(dlg_shortcuts)\ndlg_shortcuts.show()\nyield dlg_shortcuts\ndlg_shortcuts.close()\npytest.fixture",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg_shortcuts = ShortcutsSummaryDialog(None)\ndlg_shortcuts.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg_shortcuts = ShortcutsSummaryDialog(None)\ndlg_shortcuts.show()\napp.exec_()\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_5": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture"
    },
    {
        "functionName": "test_shortcutssummary",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/widgets/tests/test_summary.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that shortcut summary is visible and is not empty\"\"\"\nassert dlg_shortcuts.isVisible()\nassert not dlg_shortcuts._layout.isEmpty()\nqtbot.keyClick(dlg_shortcuts, Qt.Key_Escape)\nassert not dlg_shortcuts.isVisible()\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg_shortcuts = ShortcutsSummaryDialog(None)\ndlg_shortcuts.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg_shortcuts = ShortcutsSummaryDialog(None)\ndlg_shortcuts.show()\napp.exec_()\n",
        "CUT_3": "\"\"\"Return True is completion list widget is visible\"\"\"\nreturn self.completion_widget.isVisible()\n",
        "CUT_4": "\"\"\"Return True is completion list widget is visible\"\"\"\nreturn self.completion_widget.isVisible()\n",
        "CUT_5": "self._checkbox.isVisible()\n"
    },
    {
        "functionName": "test_shortcutssummary_texts",
        "className": null,
        "fileName": "/spyder/plugins/shortcuts/widgets/tests/test_summary.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that each shortcut has platform-specific key names.\"\"\"\nchildren = dlg_shortcuts.scroll_widget.layout().children()\nfor column_layout in sample(children, 3):\n    for group_idx in range(column_layout.count()):\n        try:\n            group_layout = column_layout.itemAt(group_idx).widget().layout()\n        except AttributeError:\n            continue\n        for shortcut_idx in range(group_layout.rowCount()):\n            try:\n                shortcut_keystr = group_layout.itemAtPosition(shortcut_idx, 1\n                    ).widget().text()\n            except AttributeError:\n                continue\n            if not shortcut_keystr:\n                continue\n            if sys.platform.startswith('darwin'):\n                keywords = ['\u21e7', '\u2303', '\u2318', '\u2325', '\u2326', '\u238b', 'F']\n            else:\n                keywords = ['Alt', 'Ctrl', 'Del', 'Esc', 'F', 'Meta', 'Shift']\n            assert any([(key in shortcut_keystr) for key in keywords])\n",
        "CUT_1": "self.children = {}\nself.key = key\nself.value = value\n",
        "CUT_2": "self.children = {}\nself.key = key\nself.value = value\n",
        "CUT_3": "\"\"\"Index of keywords.\"\"\"\nheading = html.heading('Index of Keywords')\nnames = sorted(Helper.keywords.keys())\ndef bltinlink(name):\n    return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\ncontents = html.multicolumn(names, bltinlink)\ncontents = heading + '<br>' + html.bigsection('Keywords', contents,\n    css_class='keywords')\nreturn 'Keywords', contents\n",
        "CUT_4": "\"\"\"Index of keywords.\"\"\"\nheading = html.heading('Index of Keywords')\nnames = sorted(Helper.keywords.keys())\ndef bltinlink(name):\n    return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\ncontents = html.multicolumn(names, bltinlink)\ncontents = heading + '<br>' + html.bigsection('Keywords', contents,\n    css_class='keywords')\nreturn 'Keywords', contents\n",
        "CUT_5": "\"\"\"Get the keywords for a given lexer.\n    \"\"\"\nsearch_attrs = 'builtin', 'keyword', 'word'\nkeywords = []\nfor attr in dir(lexer):\n    for search_attr in search_attrs:\n        if attr.lower().startswith(search_attr):\n            keywords += getattr(lexer, attr)\nif not hasattr(lexer, 'tokens'):\n    return keywords\nif 'keywords' in lexer.tokens:\n    try:\n        return keywords + lexer.tokens['keywords'][0][0].words\n    except Exception:\n        pass\nfor vals in lexer.tokens.values():\n    for val in vals:\n        try:\n            if isinstance(val[0], words):\n                keywords.extend(val[0].words)\n            else:\n                ini_val = val[0]\n                if ')\\\\b' in val[0] or ')(\\\\s+)' in val[0]:\n                    val = re.sub('\\\\\\\\.', '', val[0])\n                    val = re.sub('[^0-9a-zA-Z|]+', '', val)\n                    if '|' in ini_val:\n                        keywords.extend(val.split('|'))\n                    else:\n                        keywords.append(val)\n        except Exception:\n            continue\nreturn keywords\n"
    },
    {
        "functionName": "profiler_datatree_bot",
        "className": null,
        "fileName": "/spyder/plugins/profiler/tests/test_profiler.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up Profiler widget.\"\"\"\nProfilerDataTree.create_icon = lambda x, y: QIcon()\ntree = ProfilerDataTree(None)\nqtbot.addWidget(tree)\ntree.show()\nyield tree\ntree.destroy()\npytest.fixture",
        "CUT_1": "\"\"\" Returns the number of columns in the tree \"\"\"\nreturn len(self._attr_cols)\n",
        "CUT_2": "\"\"\" Returns the number of columns in the tree \"\"\"\nreturn len(self._attr_cols)\n",
        "CUT_3": "\"\"\"Update explorer tree\"\"\"\nself.explorer.setup_project(self.get_active_project_path())\n",
        "CUT_4": "\"\"\"Update explorer tree\"\"\"\nself.explorer.setup_project(self.get_active_project_path())\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_format_measure",
        "className": null,
        "fileName": "/spyder/plugins/profiler/tests/test_profiler.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\" Test ProfilerDataTree.format_measure().\"\"\"\ntree = profiler_datatree_bot\nfm = tree.format_measure\nassert fm(125) == '125'\nassert fm(1.25e-08) == '12.50 ns'\nassert fm(1.25e-05) == '12.50 \u03bcs'\nassert fm(0.0125) == '12.50 ms'\nassert fm(12.5) == '12.50 s'\nassert fm(125.5) == '2.5 min'\nassert fm(12555.5) == '3h:29min'\nassert fm(-125) == '125'\nassert fm(-1.25e-08) == '12.50 ns'\nassert fm(-1.25e-05) == '12.50 \u03bcs'\nassert fm(-0.0125) == '12.50 ms'\nassert fm(-12.5) == '12.50 s'\nassert fm(-125.5) == '2.5 min'\nassert fm(-12555.5) == '3h:29min'\n",
        "CUT_1": "\"\"\"Override Qt method.\n\n        Returns the widget size hint (based on the editor font size).\n        \"\"\"\nfm = QFontMetrics(self.editor.font())\nsize_hint = QSize(fm.height(), fm.height())\nif size_hint.width() > 16:\n    size_hint.setWidth(16)\nreturn size_hint\n",
        "CUT_2": "\"\"\"Override Qt method.\n\n        Returns the widget size hint (based on the editor font size).\n        \"\"\"\nfm = QFontMetrics(self.editor.font())\nsize_hint = QSize(fm.height(), fm.height())\nif size_hint.width() > 16:\n    size_hint.setWidth(16)\nreturn size_hint\n",
        "CUT_3": "\"\"\"Adjust column size based on contents.\"\"\"\nself.resizeColumnsToContents()\nfm = self.horizontalHeader().fontMetrics()\nnames = [fm.width(s.name + ' ' * 9) for s in self.source_model.shortcuts]\nself.setColumnWidth(NAME, max(names))\nself.horizontalHeader().setStretchLastSection(True)\n",
        "CUT_4": "\"\"\"Adjust column size based on contents.\"\"\"\nself.resizeColumnsToContents()\nfm = self.horizontalHeader().fontMetrics()\nnames = [fm.width(s.name + ' ' * 9) for s in self.source_model.shortcuts]\nself.setColumnWidth(NAME, max(names))\nself.horizontalHeader().setStretchLastSection(True)\n",
        "CUT_5": "\"\"\"Returns the widget size hint (based on the editor font size) \"\"\"\nfm = QFontMetricsF(self.editor.font())\nsize_hint = QSize(ceil(fm.height()), ceil(fm.height()))\nif size_hint.width() > 16:\n    size_hint.setWidth(16)\nreturn size_hint\n"
    },
    {
        "functionName": "test_color_string",
        "className": null,
        "fileName": "/spyder/plugins/profiler/tests/test_profiler.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\" Test ProfilerDataTree.color_string().\"\"\"\ntree = profiler_datatree_bot\ncs = tree.color_string\ntree.compare_file = 'test'\nassert cs([5.0]) == ['5.00 s', ['', 'black']]\nassert cs([1.251e-05, 1.251e-05]) == ['12.51 \u03bcs', ['', 'black']]\nassert cs([5.0, 4.0]) == ['5.00 s', ['+1000.00 ms', 'red']]\nassert cs([4.0, 5.0]) == ['4.00 s', ['-1000.00 ms', 'green']]\ntree.compare_file = None\nassert cs([4.0, 5.0]) == ['4.00 s', ['', 'black']]\n",
        "CUT_1": "cs = self.comment_string\nreturn to_text_string(cursor.block().text()).startswith(cs)\n",
        "CUT_2": "cs = self.comment_string\nreturn to_text_string(cursor.block().text()).startswith(cs)\n",
        "CUT_3": "self.hide_diff_cols(False)\nself.compare_file = filename\n",
        "CUT_4": "self.hide_diff_cols(False)\nself.compare_file = filename\n",
        "CUT_5": "\"\"\" Returns the number of columns in the tree \"\"\"\nreturn len(self._attr_cols)\n"
    },
    {
        "functionName": "test_format_output",
        "className": null,
        "fileName": "/spyder/plugins/profiler/tests/test_profiler.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\" Test ProfilerDataTree.format_output().\"\"\"\ntree = profiler_datatree_bot\nfo = tree.format_output\nclass Stats:\n    stats = {}\ntree.stats1 = [Stats(), Stats()]\ntree.stats1[0].stats = {'key1': (1, 1000, 3.5, 1.5, {}), 'key2': (1, 1200, \n    2.0, 2.0, {})}\ntree.stats1[1].stats = {'key1': (1, 1000, 3.7, 1.3, {}), 'key2': (1, 1199, \n    2.4, 2.4, {})}\ntree.compare_file = 'test'\nassert list(fo('key1')) == [['1000', ['', 'black']], ['3.50 s', [\n    '-200.00 ms', 'green']], ['1.50 s', ['+200.00 ms', 'red']]]\nassert list(fo('key2')) == [['1200', ['+1', 'red']], ['2.00 s', [\n    '-400.00 ms', 'green']], ['2.00 s', ['-400.00 ms', 'green']]]\n",
        "CUT_1": "\"\"\" Formats the data.\n\n        self.stats1 contains a list of one or two pstat.Stats() instances, with\n        the first being the current run and the second, the saved run, if it\n        exists.  Each Stats instance is a dictionary mapping a function to\n        5 data points - cumulative calls, number of calls, total time,\n        cumulative time, and callers.\n\n        format_output() converts the number of calls, total time, and\n        cumulative time to a string format for the child_key parameter.\n        \"\"\"\ndata = [x.stats.get(child_key, [0, 0, 0, 0, {}]) for x in self.stats1]\nreturn map(self.color_string, islice(zip(*data), 1, 4))\n",
        "CUT_2": "\"\"\" Formats the data.\n\n        self.stats1 contains a list of one or two pstat.Stats() instances, with\n        the first being the current run and the second, the saved run, if it\n        exists.  Each Stats instance is a dictionary mapping a function to\n        5 data points - cumulative calls, number of calls, total time,\n        cumulative time, and callers.\n\n        format_output() converts the number of calls, total time, and\n        cumulative time to a string format for the child_key parameter.\n        \"\"\"\ndata = [x.stats.get(child_key, [0, 0, 0, 0, {}]) for x in self.stats1]\nreturn map(self.color_string, islice(zip(*data), 1, 4))\n",
        "CUT_3": "\"\"\"Load profiler data saved by profile/cProfile module\"\"\"\nimport pstats\ntry:\n    stats_indi = [pstats.Stats(profdatafile)]\nexcept (OSError, IOError):\n    self.profdata = None\n    return\nself.profdata = stats_indi[0]\nif self.compare_file is not None:\n    try:\n        stats_indi.append(pstats.Stats(self.compare_file))\n    except (OSError, IOError) as e:\n        QMessageBox.critical(self, _('Error'), _(\n            'Error when trying to load profiler results. The error was<br><br><tt>{0}</tt>'\n            ).format(e))\n        self.compare_file = None\nmap(lambda x: x.calc_callees(), stats_indi)\nself.profdata.calc_callees()\nself.stats1 = stats_indi\nself.stats = stats_indi[0].stats\n",
        "CUT_4": "\"\"\"Load profiler data saved by profile/cProfile module\"\"\"\nimport pstats\ntry:\n    stats_indi = [pstats.Stats(profdatafile)]\nexcept (OSError, IOError):\n    self.profdata = None\n    return\nself.profdata = stats_indi[0]\nif self.compare_file is not None:\n    try:\n        stats_indi.append(pstats.Stats(self.compare_file))\n    except (OSError, IOError) as e:\n        QMessageBox.critical(self, _('Error'), _(\n            'Error when trying to load profiler results. The error was<br><br><tt>{0}</tt>'\n            ).format(e))\n        self.compare_file = None\nmap(lambda x: x.calc_callees(), stats_indi)\nself.profdata.calc_callees()\nself.stats1 = stats_indi\nself.stats = stats_indi[0].stats\n",
        "CUT_5": "self.completions_hint_after_ms = ms\nif self.data:\n    for finfo in self.data:\n        finfo.editor.set_completions_hint_after_ms(ms)\n"
    },
    {
        "functionName": "test_config_dialog",
        "className": null,
        "fileName": "/spyder/plugins/profiler/tests/test_profiler_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpage = config_dialog.get_page()\nconfigpage.save_to_conf()\nassert configpage\npytest.mark.parametrize('config_dialog', [[None, [], [Profiler]]], indirect\n    =True)",
        "CUT_1": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_2": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_3": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_4": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "setup_workingdirectory",
        "className": null,
        "fileName": "/spyder/plugins/workingdirectory/tests/test_workingdirectory.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Setup working directory plugin.\"\"\"\nCONF.reset_to_defaults()\nuse_startup_wdir = request.node.get_closest_marker('use_startup_wdir')\nif use_startup_wdir:\n    new_wdir = osp.join(os.getcwd(), NEW_DIR)\n    if not osp.exists(new_wdir):\n        os.mkdir(new_wdir)\n    CONF.set('workingdir', 'startup/use_fixed_directory', True)\n    CONF.set('workingdir', 'startup/fixed_directory', new_wdir)\nelse:\n    CONF.set('workingdir', 'startup/use_fixed_directory', False)\n    CONF.set('workingdir', 'console/use_fixed_directory', False)\n    CONF.set('workingdir', 'startup/fixed_directory', get_home_dir())\nworkingdirectory = WorkingDirectory(None, configuration=CONF)\nworkingdirectory.close = lambda : True\nqtbot.addWidget(workingdirectory)\nreturn workingdirectory, qtbot\npytest.fixture",
        "CUT_1": "\"\"\"Register new client\"\"\"\nclient.configure_shellwidget(give_focus=give_focus)\nshellwidget = client.shellwidget\ncontrol = shellwidget._control\nshellwidget.new_client.connect(self.create_new_client)\ncontrol.go_to_error.connect(self.go_to_error)\ncontrol.sig_help_requested.connect(self.sig_help_requested)\nshellwidget.sig_pdb_step.connect(lambda fname, lineno, shellwidget=\n    shellwidget: self.pdb_has_stopped(fname, lineno, shellwidget))\nshellwidget.sig_pdb_state.connect(self.sig_pdb_state)\nshellwidget.custom_edit_requested.connect(self.edit_file)\ncwd_path = ''\nif CONF.get('workingdir', 'console/use_project_or_home_directory'):\n    cwd_path = get_home_dir()\n    if (self.main.projects is not None and self.main.projects.\n        get_active_project() is not None):\n        cwd_path = self.main.projects.get_active_project_path()\nelif CONF.get('workingdir', 'startup/use_fixed_directory'):\n    cwd_path = CONF.get('workingdir', 'startup/fixed_directory', default=\n        get_home_dir())\nelif CONF.get('workingdir', 'console/use_fixed_directory'):\n    cwd_path = CONF.get('workingdir', 'console/fixed_directory')\nif osp.isdir(cwd_path) and self.main is not None:\n    shellwidget.set_cwd(cwd_path)\n    if give_focus:\n        shellwidget.update_cwd()\nif self.main.historylog is not None:\n    self.main.historylog.add_history(client.history_filename)\n    client.append_to_history.connect(self.main.historylog.append_to_history)\nclient.set_font(self.get_font())\ncontrol.focus_changed.connect(lambda : self.focus_changed.emit())\nshellwidget.sig_change_cwd.connect(self.set_working_directory)\nself.find_widget.set_editor(control)\n",
        "CUT_2": "\"\"\"Register new client\"\"\"\nclient.configure_shellwidget(give_focus=give_focus)\nshellwidget = client.shellwidget\ncontrol = shellwidget._control\nshellwidget.new_client.connect(self.create_new_client)\ncontrol.go_to_error.connect(self.go_to_error)\ncontrol.sig_help_requested.connect(self.sig_help_requested)\nshellwidget.sig_pdb_step.connect(lambda fname, lineno, shellwidget=\n    shellwidget: self.pdb_has_stopped(fname, lineno, shellwidget))\nshellwidget.sig_pdb_state.connect(self.sig_pdb_state)\nshellwidget.custom_edit_requested.connect(self.edit_file)\ncwd_path = ''\nif CONF.get('workingdir', 'console/use_project_or_home_directory'):\n    cwd_path = get_home_dir()\n    if (self.main.projects is not None and self.main.projects.\n        get_active_project() is not None):\n        cwd_path = self.main.projects.get_active_project_path()\nelif CONF.get('workingdir', 'startup/use_fixed_directory'):\n    cwd_path = CONF.get('workingdir', 'startup/fixed_directory', default=\n        get_home_dir())\nelif CONF.get('workingdir', 'console/use_fixed_directory'):\n    cwd_path = CONF.get('workingdir', 'console/fixed_directory')\nif osp.isdir(cwd_path) and self.main is not None:\n    shellwidget.set_cwd(cwd_path)\n    if give_focus:\n        shellwidget.update_cwd()\nif self.main.historylog is not None:\n    self.main.historylog.add_history(client.history_filename)\n    client.append_to_history.connect(self.main.historylog.append_to_history)\nclient.set_font(self.get_font())\ncontrol.focus_changed.connect(lambda : self.focus_changed.emit())\nshellwidget.sig_change_cwd.connect(self.set_working_directory)\nself.find_widget.set_editor(control)\n",
        "CUT_3": "CONF.set('run', 'breakpoints', {})\n",
        "CUT_4": "CONF.set('run', 'breakpoints', {})\n",
        "CUT_5": "\"\"\"Set current working directory.\n        In the workingdirectory and explorer plugins.\n        \"\"\"\nif osp.isdir(dirname):\n    self.sig_current_directory_changed.emit(dirname)\n"
    },
    {
        "functionName": "test_basic_initialization",
        "className": null,
        "fileName": "/spyder/plugins/workingdirectory/tests/test_workingdirectory.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test Working Directory plugin initialization.\"\"\"\nworkingdirectory, qtbot = setup_workingdirectory\nassert workingdirectory is not None\n",
        "CUT_1": "\"\"\"Set current working directory.\n        In the workingdirectory and explorer plugins.\n        \"\"\"\nif osp.isdir(dirname):\n    self.sig_current_directory_changed.emit(dirname)\n",
        "CUT_2": "\"\"\"Set current working directory.\n        In the workingdirectory and explorer plugins.\n        \"\"\"\nif osp.isdir(dirname):\n    self.sig_current_directory_changed.emit(dirname)\n",
        "CUT_3": "return _('Current working directory')\n",
        "CUT_4": "return _('Current working directory')\n",
        "CUT_5": "\"\"\"\n        Set working directory.\n\n        Parameters\n        ----------\n        directory: str\n            The new working directory path.\n        emit: bool, optional\n            Emit a signal to indicate the working directory has changed.\n            Default is True.\n        \"\"\"\nself.fileexplorer.treewidget.chdir(directory, emit=emit)\n"
    },
    {
        "functionName": "test_get_workingdir",
        "className": null,
        "fileName": "/spyder/plugins/workingdirectory/tests/test_workingdirectory.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the method that defines the working directory at home.\"\"\"\nworkingdirectory, qtbot = setup_workingdirectory\nact_wdir = workingdirectory.get_workdir()\nassert act_wdir == get_home_dir()\n",
        "CUT_1": "\"\"\"Set current working directory.\n        In the workingdirectory and explorer plugins.\n        \"\"\"\nif osp.isdir(dirname):\n    self.sig_current_directory_changed.emit(dirname)\n",
        "CUT_2": "\"\"\"Set current working directory.\n        In the workingdirectory and explorer plugins.\n        \"\"\"\nif osp.isdir(dirname):\n    self.sig_current_directory_changed.emit(dirname)\n",
        "CUT_3": "\"\"\"\n        Get current working directory.\n\n        Returns\n        -------\n        str\n            Current working directory.\n        \"\"\"\nreturn self.get_container().get_workdir()\n",
        "CUT_4": "\"\"\"\n        Get current working directory.\n\n        Returns\n        -------\n        str\n            Current working directory.\n        \"\"\"\nreturn self.get_container().get_workdir()\n",
        "CUT_5": "return _('Current working directory')\n"
    },
    {
        "functionName": "test_get_workingdir_startup",
        "className": null,
        "fileName": "/spyder/plugins/workingdirectory/tests/test_workingdirectory.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the method that defines the working directory at home.\"\"\"\nworkingdirectory, qtbot = setup_workingdirectory\nact_wdir = workingdirectory.get_workdir()\nfolders = osp.split(act_wdir)\nassert folders[-1] == NEW_DIR\nCONF.reset_to_defaults()\npytest.mark.use_startup_wdir",
        "CUT_1": "\"\"\"Set current working directory.\n        In the workingdirectory and explorer plugins.\n        \"\"\"\nif osp.isdir(dirname):\n    self.sig_current_directory_changed.emit(dirname)\n",
        "CUT_2": "\"\"\"Set current working directory.\n        In the workingdirectory and explorer plugins.\n        \"\"\"\nif osp.isdir(dirname):\n    self.sig_current_directory_changed.emit(dirname)\n",
        "CUT_3": "\"\"\"\n        Get current working directory.\n\n        Returns\n        -------\n        str\n            Current working directory.\n        \"\"\"\nreturn self.get_container().get_workdir()\n",
        "CUT_4": "\"\"\"\n        Get current working directory.\n\n        Returns\n        -------\n        str\n            Current working directory.\n        \"\"\"\nreturn self.get_container().get_workdir()\n",
        "CUT_5": "return _('Current working directory')\n"
    },
    {
        "functionName": "test_config_dialog",
        "className": null,
        "fileName": "/spyder/plugins/workingdirectory/tests/test_workingdirectory_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpage = config_dialog.get_page()\nconfigpage.save_to_conf()\nassert configpage\npytest.mark.parametrize('config_dialog', [[None, [], [WorkingDirectory]]],\n    indirect=True)",
        "CUT_1": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_2": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_3": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_4": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "editor_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/panels/tests/test_scrollflag.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = CodeEditor(None)\nwidget.setup_editor(linenumbers=True, markers=True, show_blanks=True,\n    scrollflagarea=True, font=QFont('Courier New', 10), color_scheme=\n    'Zenburn', language='Python')\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "QSplitter.__init__(self, parent)\nself.editor = CodeEditor(self)\nself.editor.setup_editor(linenumbers=True, markers=True, tab_mode=False,\n    font=QFont('Courier New', 10), show_blanks=True, color_scheme='Zenburn')\nself.addWidget(self.editor)\nself.setWindowIcon(ima.icon('spyder'))\n",
        "CUT_2": "QSplitter.__init__(self, parent)\nself.editor = CodeEditor(self)\nself.editor.setup_editor(linenumbers=True, markers=True, tab_mode=False,\n    font=QFont('Courier New', 10), show_blanks=True, color_scheme='Zenburn')\nself.addWidget(self.editor)\nself.setWindowIcon(ima.icon('spyder'))\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "\"\"\" \"\"\"\nfor widget in self.widgets:\n    widget.setDisabled(True)\n"
    },
    {
        "functionName": "test_enabled",
        "className": null,
        "fileName": "/spyder/plugins/editor/panels/tests/test_scrollflag.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\"Test that enabling and disabling the srollflagarea panel make\n    it visible or invisible depending on the case.\"\"\"\neditor = editor_bot\nsfa = editor.scrollflagarea\neditor.show()\neditor.set_text(short_code)\nassert sfa.isVisible()\nsfa.set_enabled(False)\nassert not sfa.isVisible()\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n",
        "CUT_4": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_flag_painting",
        "className": null,
        "fileName": "/spyder/plugins/editor/panels/tests/test_scrollflag.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\"Test that there is no error when painting all flag types on the\n    scrollbar area when the editor vertical scrollbar is visible and not\n    visible. There is seven different flags: breakpoints, todos, warnings,\n    errors, found_results, and occurences\"\"\"\neditor = editor_bot\nsfa = editor.scrollflagarea\neditor.resize(450, 300)\neditor.show()\neditor.set_text(short_code)\nqtbot.waitUntil(lambda : not sfa.slider)\neditor.debugger.toogle_breakpoint(line_number=2)\neditor.process_todo([[True, 3]])\nanalysis = [{'source': 'pycodestyle', 'range': {'start': {'line': 4,\n    'character': 0}, 'end': {'line': 4, 'character': 1}}, 'line': 4, 'code':\n    'E227', 'message': 'E227 warning', 'severity': 2}, {'source':\n    'pyflakes', 'range': {'start': {'line': 5, 'character': 0}, 'end': {\n    'line': 5, 'character': 1}}, 'message': 'syntax error', 'severity': 1}]\neditor.process_code_analysis(analysis)\neditor.highlight_found_results('line6')\nwith qtbot.waitSignal(editor.sig_flags_changed, raising=True, timeout=5000):\n    cursor = editor.textCursor()\n    cursor.setPosition(2)\n    editor.setTextCursor(cursor)\neditor.set_text(long_code)\neditor.debugger.toogle_breakpoint(line_number=2)\neditor.process_todo([[True, 3]])\nanalysis = [{'source': 'pycodestyle', 'range': {'start': {'line': 4,\n    'character': 0}, 'end': {'line': 4, 'character': 1}}, 'line': 4, 'code':\n    'E227', 'message': 'E227 warning', 'severity': 2}, {'source':\n    'pyflakes', 'range': {'start': {'line': 5, 'character': 0}, 'end': {\n    'line': 5, 'character': 1}}, 'message': 'syntax error', 'severity': 1}]\neditor.process_code_analysis(analysis)\neditor.highlight_found_results('line6')\nwith qtbot.waitSignal(editor.sig_flags_changed, raising=True, timeout=5000):\n    cursor = editor.textCursor()\n    cursor.setPosition(2)\n    editor.setTextCursor(cursor)\npytest.mark.skipif(sys.platform.startswith('linux'), reason='Fails in Linux')",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n"
    },
    {
        "functionName": "test_range_indicator_visible_on_hover_only",
        "className": null,
        "fileName": "/spyder/plugins/editor/panels/tests/test_scrollflag.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the slider range indicator is visible only when hovering\n    over the scrollflag area when the editor vertical scrollbar is visible.\n    The scrollflag area should remain hidden at all times when the editor\n    vertical scrollbar is not visible.\"\"\"\neditor = editor_bot\nsfa = editor.scrollflagarea\neditor.show()\neditor.set_text(short_code)\neditor.resize(450, 150)\nqtbot.waitUntil(lambda : not sfa.slider)\nx = int(sfa.width() / 2)\ny = int(sfa.height() / 2)\nqtbot.mouseMove(sfa, pos=QPoint(x, y), delay=-1)\nassert sfa._range_indicator_is_visible is False\neditor.set_text(long_code)\neditor.resize(450, 150)\nqtbot.waitUntil(lambda : sfa.slider)\nx = int(sfa.width() / 2)\ny = int(sfa.height() / 2)\nqtbot.mouseMove(sfa, pos=QPoint(x, y), delay=-1)\nassert sfa._range_indicator_is_visible is True\nx = int(editor.width() / 2)\ny = int(editor.height() / 2)\nqtbot.mouseMove(editor, pos=QPoint(x, y), delay=-1)\nqtbot.waitUntil(lambda : not sfa._range_indicator_is_visible)\npytest.mark.skipif(os.environ.get('CI', None) is not None, reason=\n    'It fails on CIs')",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Positions the tab switcher in the top-center of the editor.\"\"\"\nleft = self.editor.geometry().width() / 2 - self.width() / 2\ntop = self.editor.tabs.tabBar().geometry().height(\n    ) + self.editor.fname_label.geometry().height()\nself.move(self.editor.mapToGlobal(QPoint(left, top)))\n",
        "CUT_5": "\"\"\"Positions the tab switcher in the top-center of the editor.\"\"\"\nleft = self.editor.geometry().width() / 2 - self.width() / 2\ntop = self.editor.tabs.tabBar().geometry().height(\n    ) + self.editor.fname_label.geometry().height()\nself.move(self.editor.mapToGlobal(QPoint(left, top)))\n"
    },
    {
        "functionName": "test_range_indicator_alt_modifier_response",
        "className": null,
        "fileName": "/spyder/plugins/editor/panels/tests/test_scrollflag.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the slider range indicator is visible while the alt key is\n    held down while the cursor is over the editor, but outside of the\n    scrollflag area. In addition, while the alt key is held down, mouse\n    click events in the editor should be forwarded to the scrollfag area and\n    should set the value of the editor vertical scrollbar.\"\"\"\neditor = editor_bot\nsfa = editor.scrollflagarea\nsfa._unit_testing = True\nvsb = editor.verticalScrollBar()\neditor.show()\neditor.resize(600, 150)\neditor.set_text(long_code)\neditor.resize(600, 150)\nqtbot.waitUntil(lambda : sfa.slider)\nw = editor.width()\nh = editor.height()\nqtbot.mousePress(editor, Qt.LeftButton, pos=QPoint(w // 2, h // 2))\nqtbot.keyPress(editor, Qt.Key_Alt)\neditor.resize(600, 150)\nx = int(sfa.width() / 2)\ny = int(sfa.height() / 2)\nqtbot.mouseMove(sfa, pos=QPoint(x, y), delay=-1)\nqtbot.waitUntil(lambda : sfa._range_indicator_is_visible)\nwith qtbot.waitSignal(editor.sig_alt_left_mouse_pressed, raising=True):\n    qtbot.mousePress(editor.viewport(), Qt.LeftButton, pos=QPoint(w // 2, h //\n        2), modifier=Qt.AltModifier)\nassert vsb.value() == (vsb.minimum() + vsb.maximum()) // 2\nwith qtbot.waitSignal(editor.sig_alt_left_mouse_pressed, raising=True):\n    qtbot.mousePress(editor.viewport(), Qt.LeftButton, pos=QPoint(w // 2, 1\n        ), modifier=Qt.AltModifier)\nassert vsb.value() == vsb.minimum()\nwith qtbot.waitSignal(editor.sig_alt_left_mouse_pressed, raising=True):\n    qtbot.mousePress(editor.viewport(), Qt.LeftButton, pos=QPoint(w // 2, h -\n        1), modifier=Qt.AltModifier)\nassert vsb.value() == vsb.maximum()\neditor.resize(600, 150)\nx = int(sfa.width() / 2)\ny = int(sfa.height() / 2)\nqtbot.mouseMove(sfa, pos=QPoint(x * 100, y), delay=-1)\nqtbot.keyRelease(editor, Qt.Key_Alt)\nqtbot.waitUntil(lambda : not sfa._range_indicator_is_visible, timeout=3000)\npytest.mark.skipif(os.environ.get('CI', None) is not None, reason=\n    'It fails on CIs')",
        "CUT_1": "\"\"\"Override Qt method\"\"\"\nif self.slider and event.button() == Qt.LeftButton:\n    vsb = self.editor.verticalScrollBar()\n    value = self.position_to_value(event.pos().y())\n    vsb.setValue(int(value - vsb.pageStep() / 2))\n",
        "CUT_2": "\"\"\"Override Qt method\"\"\"\nif self.slider and event.button() == Qt.LeftButton:\n    vsb = self.editor.verticalScrollBar()\n    value = self.position_to_value(event.pos().y())\n    vsb.setValue(int(value - vsb.pageStep() / 2))\n",
        "CUT_3": "\"\"\"Return the value span height of the scrollbar\"\"\"\nvsb = self.editor.verticalScrollBar()\nreturn vsb.maximum() - vsb.minimum() + vsb.pageStep()\n",
        "CUT_4": "\"\"\"Return the value span height of the scrollbar\"\"\"\nvsb = self.editor.verticalScrollBar()\nreturn vsb.maximum() - vsb.minimum() + vsb.pageStep()\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_basic_initialization",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test Editor plugin initialization.\"\"\"\neditor = editor_plugin\nassert editor is not None\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Get the current editorstack.\"\"\"\nplugin = self.ipyclient.plugin\nif plugin.main.editor is not None:\n    editor = plugin.main.editor\n    return editor.get_current_editorstack()\nraise RuntimeError('No editorstack found.')\n",
        "CUT_4": "\"\"\"Get the current editorstack.\"\"\"\nplugin = self.ipyclient.plugin\nif plugin.main.editor is not None:\n    editor = plugin.main.editor\n    return editor.get_current_editorstack()\nraise RuntimeError('No editorstack found.')\n",
        "CUT_5": "\"\"\"Comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.toggle_comment()\nSlot()"
    },
    {
        "functionName": "test_setup_open_files",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test Editor plugin open files setup.\n\n    Test that the file order is preserved during the Editor plugin setup and\n    that the current file correspond to the last focused file.\n    \"\"\"\neditor_factory = editor_plugin_open_files\neditor, expected_filenames, expected_current_filename = editor_factory(\n    last_focused_filename, expected_current_filename)\ncurrent_filename = editor.get_current_editorstack().get_current_filename()\ncurrent_filename = osp.normcase(current_filename)\nassert current_filename == expected_current_filename\nfilenames = editor.get_current_editorstack().get_filenames()\nfilenames = [osp.normcase(f) for f in filenames]\nassert filenames == expected_filenames\npytest.mark.parametrize('last_focused_filename, expected_current_filename',\n    [('other_file.py', 'file1.py'), ('file1.py', 'file1.py'), ('file2.py',\n    'file2.py'), ('file4.py', 'file4.py')])",
        "CUT_1": "\"\"\"\n    Setup an Editor with a set of open files, given a past file in focus.\n\n    If no/None ``last_focused_filename`` is passed, the ``\"layout_settings\"``\n    key is not included in the options dict.\n    If no/None ``expected_current_filename``, is assumed to be the first file.\n    \"\"\"\ndef _get_editor_open_files(last_focused_filename, expected_current_filename):\n    editor = editor_plugin\n    expected_filenames, tmpdir = python_files\n    if expected_current_filename is None:\n        expected_current_filename = expected_filenames[0]\n    expected_current_filename = osp.join(tmpdir, expected_current_filename)\n    options_dict = {'filenames': expected_filenames, 'max_recent_files': 20,\n        'indent_chars': '*    *', 'show_tab_bar': True, 'code_folding':\n        True, 'edge_line': True, 'indent_guides': False, 'scroll_past_end':\n        False, 'line_numbers': True, 'occurrence_highlighting/timeout': \n        1500, 'tab_stop_width_spaces': 4, 'show_class_func_dropdown': False}\n    if last_focused_filename is not None:\n        splitsettings = [(False, osp.join(tmpdir, last_focused_filename), [\n            1] * len(expected_filenames))]\n        layout_dict = {'layout_settings': {'splitsettings': splitsettings}}\n        options_dict.update(layout_dict)\n\n    def get_option(option, default=None):\n        return options_dict.get(option)\n    editor.get_option = get_option\n    editor.setup_open_files()\n    return editor, expected_filenames, expected_current_filename\nreturn _get_editor_open_files\npytest.fixture",
        "CUT_2": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_3": "editor = editor_plugin\nexpected_filenames, tmpdir = python_files\nif expected_current_filename is None:\n    expected_current_filename = expected_filenames[0]\nexpected_current_filename = osp.join(tmpdir, expected_current_filename)\noptions_dict = {'filenames': expected_filenames, 'max_recent_files': 20,\n    'indent_chars': '*    *', 'show_tab_bar': True, 'code_folding': True,\n    'edge_line': True, 'indent_guides': False, 'scroll_past_end': False,\n    'line_numbers': True, 'occurrence_highlighting/timeout': 1500,\n    'tab_stop_width_spaces': 4, 'show_class_func_dropdown': False}\nif last_focused_filename is not None:\n    splitsettings = [(False, osp.join(tmpdir, last_focused_filename), [1] *\n        len(expected_filenames))]\n    layout_dict = {'layout_settings': {'splitsettings': splitsettings}}\n    options_dict.update(layout_dict)\ndef get_option(option, default=None):\n    return options_dict.get(option)\neditor.get_option = get_option\neditor.setup_open_files()\nreturn editor, expected_filenames, expected_current_filename\n",
        "CUT_4": "\"\"\"Get the list of open files in the current stack\"\"\"\neditorstack = self.editorstacks[0]\nfilenames = []\nfilenames += [finfo.filename for finfo in editorstack.data]\nreturn filenames\n",
        "CUT_5": "\"\"\"Get the list of open files in the current stack\"\"\"\neditorstack = self.editorstacks[0]\nfilenames = []\nfilenames += [finfo.filename for finfo in editorstack.data]\nreturn filenames\n"
    },
    {
        "functionName": "test_setup_open_files_cleanprefs",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that Editor successfully opens files if layout is not defined.\n\n    Regression test for spyder-ide/spyder#8458.\n    \"\"\"\neditor_factory = editor_plugin_open_files\neditor, expected_filenames, expected_current_filename = editor_factory(None,\n    None)\nfilenames = editor.get_current_editorstack().get_filenames()\nfilenames = [osp.normcase(f) for f in filenames]\nassert filenames == expected_filenames\ncurrent_filename = editor.get_current_editorstack().get_current_filename()\ncurrent_filename = osp.normcase(current_filename)\nassert current_filename == expected_current_filename\n",
        "CUT_1": "editor = editor_plugin\nexpected_filenames, tmpdir = python_files\nif expected_current_filename is None:\n    expected_current_filename = expected_filenames[0]\nexpected_current_filename = osp.join(tmpdir, expected_current_filename)\noptions_dict = {'filenames': expected_filenames, 'max_recent_files': 20,\n    'indent_chars': '*    *', 'show_tab_bar': True, 'code_folding': True,\n    'edge_line': True, 'indent_guides': False, 'scroll_past_end': False,\n    'line_numbers': True, 'occurrence_highlighting/timeout': 1500,\n    'tab_stop_width_spaces': 4, 'show_class_func_dropdown': False}\nif last_focused_filename is not None:\n    splitsettings = [(False, osp.join(tmpdir, last_focused_filename), [1] *\n        len(expected_filenames))]\n    layout_dict = {'layout_settings': {'splitsettings': splitsettings}}\n    options_dict.update(layout_dict)\ndef get_option(option, default=None):\n    return options_dict.get(option)\neditor.get_option = get_option\neditor.setup_open_files()\nreturn editor, expected_filenames, expected_current_filename\n",
        "CUT_2": "\"\"\"\n    Setup an Editor with a set of open files, given a past file in focus.\n\n    If no/None ``last_focused_filename`` is passed, the ``\"layout_settings\"``\n    key is not included in the options dict.\n    If no/None ``expected_current_filename``, is assumed to be the first file.\n    \"\"\"\ndef _get_editor_open_files(last_focused_filename, expected_current_filename):\n    editor = editor_plugin\n    expected_filenames, tmpdir = python_files\n    if expected_current_filename is None:\n        expected_current_filename = expected_filenames[0]\n    expected_current_filename = osp.join(tmpdir, expected_current_filename)\n    options_dict = {'filenames': expected_filenames, 'max_recent_files': 20,\n        'indent_chars': '*    *', 'show_tab_bar': True, 'code_folding':\n        True, 'edge_line': True, 'indent_guides': False, 'scroll_past_end':\n        False, 'line_numbers': True, 'occurrence_highlighting/timeout': \n        1500, 'tab_stop_width_spaces': 4, 'show_class_func_dropdown': False}\n    if last_focused_filename is not None:\n        splitsettings = [(False, osp.join(tmpdir, last_focused_filename), [\n            1] * len(expected_filenames))]\n        layout_dict = {'layout_settings': {'splitsettings': splitsettings}}\n        options_dict.update(layout_dict)\n\n    def get_option(option, default=None):\n        return options_dict.get(option)\n    editor.get_option = get_option\n    editor.setup_open_files()\n    return editor, expected_filenames, expected_current_filename\nreturn _get_editor_open_files\npytest.fixture",
        "CUT_3": "\"\"\"\n        Set the recent opened files on editor based on active project.\n\n        If no project is active, then editor filenames are saved, otherwise\n        the opened filenames are stored in the project config info.\n        \"\"\"\nif self.projects is not None:\n    if not self.projects.get_active_project():\n        filenames = self.get_open_filenames()\n        self.set_option('filenames', filenames)\n",
        "CUT_4": "\"\"\"\n        Set the recent opened files on editor based on active project.\n\n        If no project is active, then editor filenames are saved, otherwise\n        the opened filenames are stored in the project config info.\n        \"\"\"\nif self.projects is not None:\n    if not self.projects.get_active_project():\n        filenames = self.get_open_filenames()\n        self.set_option('filenames', filenames)\n",
        "CUT_5": "\"\"\"Get the list of open files in the current stack\"\"\"\neditorstack = self.editorstacks[0]\nfilenames = []\nfilenames += [finfo.filename for finfo in editorstack.data]\nreturn filenames\n"
    },
    {
        "functionName": "test_open_untitled_files",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test for checking the counter of the untitled files is starting\n    correctly when there is one or more `untitledx.py` files saved.\n\n    Regression test for spyder-ide/spyder#7831\n    \"\"\"\neditor_factory = editor_plugin_open_files\neditor, expected_filenames, expected_current_filename = editor_factory(None,\n    None)\neditor.new()\nfilenames = editor.get_current_editorstack().get_filenames()\nnew_filename = filenames[-1]\nassert 'untitled5.py' in new_filename\n",
        "CUT_1": "\"\"\"\n    Setup an Editor with a set of open files, given a past file in focus.\n\n    If no/None ``last_focused_filename`` is passed, the ``\"layout_settings\"``\n    key is not included in the options dict.\n    If no/None ``expected_current_filename``, is assumed to be the first file.\n    \"\"\"\ndef _get_editor_open_files(last_focused_filename, expected_current_filename):\n    editor = editor_plugin\n    expected_filenames, tmpdir = python_files\n    if expected_current_filename is None:\n        expected_current_filename = expected_filenames[0]\n    expected_current_filename = osp.join(tmpdir, expected_current_filename)\n    options_dict = {'filenames': expected_filenames, 'max_recent_files': 20,\n        'indent_chars': '*    *', 'show_tab_bar': True, 'code_folding':\n        True, 'edge_line': True, 'indent_guides': False, 'scroll_past_end':\n        False, 'line_numbers': True, 'occurrence_highlighting/timeout': \n        1500, 'tab_stop_width_spaces': 4, 'show_class_func_dropdown': False}\n    if last_focused_filename is not None:\n        splitsettings = [(False, osp.join(tmpdir, last_focused_filename), [\n            1] * len(expected_filenames))]\n        layout_dict = {'layout_settings': {'splitsettings': splitsettings}}\n        options_dict.update(layout_dict)\n\n    def get_option(option, default=None):\n        return options_dict.get(option)\n    editor.get_option = get_option\n    editor.setup_open_files()\n    return editor, expected_filenames, expected_current_filename\nreturn _get_editor_open_files\npytest.fixture",
        "CUT_2": "\"\"\"\n        Set the recent opened files on editor based on active project.\n\n        If no project is active, then editor filenames are saved, otherwise\n        the opened filenames are stored in the project config info.\n        \"\"\"\nif self.projects is not None:\n    if not self.projects.get_active_project():\n        filenames = self.get_open_filenames()\n        self.set_option('filenames', filenames)\n",
        "CUT_3": "\"\"\"\n        Set the recent opened files on editor based on active project.\n\n        If no project is active, then editor filenames are saved, otherwise\n        the opened filenames are stored in the project config info.\n        \"\"\"\nif self.projects is not None:\n    if not self.projects.get_active_project():\n        filenames = self.get_open_filenames()\n        self.set_option('filenames', filenames)\n",
        "CUT_4": "\"\"\"Get the list of open files in the current stack\"\"\"\neditorstack = self.editorstacks[0]\nfilenames = []\nfilenames += [finfo.filename for finfo in editorstack.data]\nreturn filenames\n",
        "CUT_5": "\"\"\"Get the list of open files in the current stack\"\"\"\neditorstack = self.editorstacks[0]\nfilenames = []\nfilenames += [finfo.filename for finfo in editorstack.data]\nreturn filenames\n"
    },
    {
        "functionName": "test_renamed_tree",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test editor.renamed_tree().\n\n    This tests that the file renaming functions are called correctly,\n    but does not test that all the renaming happens in File Explorer,\n    Project Explorer, and Editor widget as those aren't part of the plugin.\n    \"\"\"\neditor = editor_plugin\nmocker.patch.object(editor, 'get_filenames')\nmocker.patch.object(editor, 'renamed')\neditor.get_filenames.return_value = ['/test/directory/file1.py',\n    '/test/directory/file2.txt', '/home/spyder/testing/file3.py',\n    '/test/directory/file4.rst']\neditor.renamed_tree('/test/directory', '/test/dir')\nassert editor.renamed.call_count == 3\nassert editor.renamed.called_with(source='/test/directory/file1.py', dest=\n    'test/dir/file1.py')\nassert editor.renamed.called_with(source='/test/directory/file2.txt', dest=\n    'test/dir/file2.txt')\nassert editor.renamed.called_with(source='/test/directory/file4.rst', dest=\n    'test/dir/file4.rst')\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\nfrom spyder.config.base import get_module_path\nspyder_dir = get_module_path('spyder')\napp = qapplication(test_time=8)\ntest = EditorPluginExample()\ntest.resize(900, 700)\ntest.show()\nimport time\nt0 = time.time()\ntest.load(osp.join(spyder_dir, 'widgets', 'collectionseditor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'editor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'explorer', 'widgets', 'explorer.py')\n    )\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'codeeditor.py')\n    )\nprint('Elapsed time: %.3f s' % (time.time() - t0))\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_no_template",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that new files can be opened when no template is found.\n    \"\"\"\neditor = editor_plugin\ntemplate = editor.TEMPLATE_PATH\nshutil.move(template, osp.join(osp.dirname(template), 'template.py.old'))\neditor.new()\ncode_editor = editor.get_focus_widget()\ncontents = code_editor.get_text('sof', 'eof')\nassert not contents\nshutil.move(osp.join(osp.dirname(template), 'template.py.old'), template)\n",
        "CUT_1": "\"\"\"Edit new file template\"\"\"\nself.load(self.TEMPLATE_PATH)\n",
        "CUT_2": "\"\"\"Edit new file template\"\"\"\nself.load(self.TEMPLATE_PATH)\n",
        "CUT_3": "\"\"\"Render the html template for this item.\"\"\"\nraise NotImplementedError\n",
        "CUT_4": "\"\"\"Render the html template for this item.\"\"\"\nraise NotImplementedError\n",
        "CUT_5": "\"\"\"\n        Render text that contains Jinja2 expressions and set their values.\n        \"\"\"\ncookiecutter_settings = self.get_values()\nfor setting, value in self._rendered_settings.items():\n    if not setting.startswith(('__', '_')):\n        template = Template(value)\n        val = template.render(cookiecutter=Namespace(**cookiecutter_settings))\n        __, widget = self._widgets[setting]\n        widget.set_value(val)\n"
    },
    {
        "functionName": "test_editor_has_autosave_component",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that Editor includes an AutosaveForPlugin.\"\"\"\neditor = editor_plugin\nassert isinstance(editor.autosave, AutosaveForPlugin)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"CodeEditor instance with LSP services activated.\"\"\"\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.sig_perform_completion_request.connect(lsp_plugin.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\nlsp_plugin.register_file('python', 'test.py', editor)\ncapabilities = lsp_plugin.main.editor.completion_capabilities['python']\neditor.start_completion_services()\neditor.register_completion_capabilities(capabilities)\nwith qtbot_module.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_open()\ndef teardown():\n    editor.completion_widget.hide()\n    editor.tooltip_widget.hide()\n    editor.hide()\n    sys_stream = capsys.readouterr()\n    sys_err = sys_stream.err\n    if PY2:\n        sys_err = to_text_string(sys_err).encode('utf-8')\n    assert sys_err == ''\nrequest.addfinalizer(teardown)\nlsp_plugin = lsp_plugin.get_client('lsp')\neditor.show()\nreturn editor, lsp_plugin\npytest.fixture"
    },
    {
        "functionName": "test_autosave_component_do_autosave",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that AutosaveForPlugin's do_autosave() calls the current editor\n    stack's autosave_all().\"\"\"\neditor = editor_plugin\neditorStack = editor.get_current_editorstack()\nmocker.patch.object(editorStack.autosave, 'autosave_all')\neditor.autosave.do_autosave()\nassert editorStack.autosave.autosave_all.called\n",
        "CUT_1": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n",
        "CUT_2": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "test_editor_transmits_sig_option_changed",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = editor_plugin\neditorStack = editor.get_current_editorstack()\nwith qtbot.waitSignal(editor.sig_option_changed) as blocker:\n    editorStack.sig_option_changed.emit('autosave_mapping', {(1): 2})\nassert blocker.args == ['autosave_mapping', {(1): 2}]\n",
        "CUT_1": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_finfo()\n"
    },
    {
        "functionName": "test_editorstacks_share_autosave_data",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Check that two EditorStacks share the same autosave data.\"\"\"\neditor = editor_plugin\neditor.editorsplitter.split()\nassert len(editor.editorstacks) == 2\nautosave1 = editor.editorstacks[0].autosave\nautosave2 = editor.editorstacks[1].autosave\nassert autosave1.name_mapping is autosave2.name_mapping\nassert autosave1.file_hashes is autosave2.file_hashes\n",
        "CUT_1": "\"\"\"\n        Propagate file rename to editor stacks and autosave component.\n\n        This function is called when a file is renamed in the file explorer\n        widget or the project explorer. The file may not be opened in the\n        editor.\n        \"\"\"\nfilename = osp.abspath(to_text_string(source))\nindex = self.editorstacks[0].has_filename(filename)\nif index is not None:\n    for editorstack in self.editorstacks:\n        editorstack.rename_in_data(filename, new_filename=to_text_string(dest))\n    self.editorstacks[0].autosave.file_renamed(filename, to_text_string(dest))\n",
        "CUT_2": "\"\"\"\n        Propagate file rename to editor stacks and autosave component.\n\n        This function is called when a file is renamed in the file explorer\n        widget or the project explorer. The file may not be opened in the\n        editor.\n        \"\"\"\nfilename = osp.abspath(to_text_string(source))\nindex = self.editorstacks[0].has_filename(filename)\nif index is not None:\n    for editorstack in self.editorstacks:\n        editorstack.rename_in_data(filename, new_filename=to_text_string(dest))\n    self.editorstacks[0].autosave.file_renamed(filename, to_text_string(dest))\n",
        "CUT_3": "\"\"\"\n        Register an AutosaveForStack object.\n\n        This replaces the `name_mapping` and `file_hashes` attributes\n        in `autosave_for_stack` with references to the corresponding\n        attributes of `self`, so that all AutosaveForStack objects\n        share the same data.\n        \"\"\"\nautosave_for_stack.name_mapping = self.name_mapping\nautosave_for_stack.file_hashes = self.file_hashes\n",
        "CUT_4": "\"\"\"\n        Register an AutosaveForStack object.\n\n        This replaces the `name_mapping` and `file_hashes` attributes\n        in `autosave_for_stack` with references to the corresponding\n        attributes of `self`, so that all AutosaveForStack objects\n        share the same data.\n        \"\"\"\nautosave_for_stack.name_mapping = self.name_mapping\nautosave_for_stack.file_hashes = self.file_hashes\n",
        "CUT_5": "\"\"\"\n        Constructor.\n\n        Autosave is disabled after construction and needs to be enabled\n        explicitly if required.\n\n        Args:\n            editor (Editor): editor plugin.\n        \"\"\"\nself.editor = editor\nself.name_mapping = {}\nself.file_hashes = {}\nself.timer = QTimer(self.editor)\nself.timer.setSingleShot(True)\nself.timer.timeout.connect(self.do_autosave)\nself._enabled = False\nself._interval = self.DEFAULT_AUTOSAVE_INTERVAL\n"
    },
    {
        "functionName": "test_editor_calls_recoverydialog_exec_if_nonempty",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Check that editor tries to exec a recovery dialog on construction.\"\"\"\nassert mock_RecoveryDialog.return_value.exec_if_nonempty.called\n",
        "CUT_1": "\"\"\"This method is called to check settings after configuration\n        dialog has been shown\"\"\"\npass\n",
        "CUT_2": "\"\"\"This method is called to check settings after configuration\n        dialog has been shown\"\"\"\npass\n",
        "CUT_3": "\"\"\"This method is called to check all configuration page settings\n        after configuration dialog has been shown\"\"\"\nself.check_settings.emit()\n",
        "CUT_4": "\"\"\"This method is called to check all configuration page settings\n        after configuration dialog has been shown\"\"\"\nself.check_settings.emit()\n",
        "CUT_5": "\"\"\"\n        Offer to recover files from autosave.\n\n        Read pid files to get a list of files that can possibly be recovered,\n        then ask the user what to do with these files, and finally remove\n        the pid files.\n        \"\"\"\nfiles_to_recover, pidfiles = self.get_files_to_recover()\nparent = self.editor if running_under_pytest() else self.editor.main\ndialog = RecoveryDialog(files_to_recover, parent=parent)\ndialog.exec_if_nonempty()\nself.recover_files_to_open = dialog.files_to_open[:]\nfor pidfile in pidfiles:\n    try:\n        os.remove(pidfile)\n    except (IOError, OSError):\n        pass\n"
    },
    {
        "functionName": "test_closing_editor_plugin_stops_autosave_timer",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = editor_plugin\nassert editor.autosave.timer.isActive()\neditor.closing_plugin()\nassert not editor.autosave.timer.isActive()\n",
        "CUT_1": "\"\"\"Stop the autosave timer.\"\"\"\nself.timer.stop()\n",
        "CUT_2": "\"\"\"Stop the autosave timer.\"\"\"\nself.timer.stop()\n",
        "CUT_3": "\"\"\"\n        Constructor.\n\n        Autosave is disabled after construction and needs to be enabled\n        explicitly if required.\n\n        Args:\n            editor (Editor): editor plugin.\n        \"\"\"\nself.editor = editor\nself.name_mapping = {}\nself.file_hashes = {}\nself.timer = QTimer(self.editor)\nself.timer.setSingleShot(True)\nself.timer.timeout.connect(self.do_autosave)\nself._enabled = False\nself._interval = self.DEFAULT_AUTOSAVE_INTERVAL\n",
        "CUT_4": "\"\"\"\n        Constructor.\n\n        Autosave is disabled after construction and needs to be enabled\n        explicitly if required.\n\n        Args:\n            editor (Editor): editor plugin.\n        \"\"\"\nself.editor = editor\nself.name_mapping = {}\nself.file_hashes = {}\nself.timer = QTimer(self.editor)\nself.timer.setSingleShot(True)\nself.timer.timeout.connect(self.do_autosave)\nself._enabled = False\nself._interval = self.DEFAULT_AUTOSAVE_INTERVAL\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_renamed_propagates_to_autosave",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that editor.renamed() propagates info to autosave component if,\n    and only if, renamed file is open in editor.\n\n    Regression test for spyder-ide/spyder#11348\"\"\"\neditor_factory = editor_plugin_open_files\neditor, expected_filenames, expected_current_filename = editor_factory(None,\n    None)\neditorstack = editor.get_current_editorstack()\nmocker.patch.object(editorstack, 'rename_in_data')\nmocker.patch.object(editorstack.autosave, 'file_renamed')\neditor.renamed('nonexisting', 'newname')\nassert not editorstack.autosave.file_renamed.called\nfilename = editorstack.get_filenames()[0]\neditor.renamed(filename, 'newname')\nassert editorstack.autosave.file_renamed.called\n",
        "CUT_1": "\"\"\"\n        Propagate file rename to editor stacks and autosave component.\n\n        This function is called when a file is renamed in the file explorer\n        widget or the project explorer. The file may not be opened in the\n        editor.\n        \"\"\"\nfilename = osp.abspath(to_text_string(source))\nindex = self.editorstacks[0].has_filename(filename)\nif index is not None:\n    for editorstack in self.editorstacks:\n        editorstack.rename_in_data(filename, new_filename=to_text_string(dest))\n    self.editorstacks[0].autosave.file_renamed(filename, to_text_string(dest))\n",
        "CUT_2": "\"\"\"\n        Propagate file rename to editor stacks and autosave component.\n\n        This function is called when a file is renamed in the file explorer\n        widget or the project explorer. The file may not be opened in the\n        editor.\n        \"\"\"\nfilename = osp.abspath(to_text_string(source))\nindex = self.editorstacks[0].has_filename(filename)\nif index is not None:\n    for editorstack in self.editorstacks:\n        editorstack.rename_in_data(filename, new_filename=to_text_string(dest))\n    self.editorstacks[0].autosave.file_renamed(filename, to_text_string(dest))\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_5": "\"\"\"Get editor for filename and set it as the current editor.\"\"\"\neditorstack = self.get_editorstack()\nif editorstack is None:\n    return None\nif not filename:\n    return None\nindex = editorstack.has_filename(filename)\nif index is None:\n    return None\nreturn editorstack.data[index].editor\n"
    },
    {
        "functionName": "test_go_to_prev_next_cursor_position",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the previous and next cursor position feature of the Editor.\n\n    Regression test for spyder-ide/spyder#8000.\n    \"\"\"\nfilenames, tmpdir = python_files\neditorstack = editor_plugin.get_current_editorstack()\nexpected_cursor_pos_history = []\nassert editor_plugin.cursor_pos_history == expected_cursor_pos_history\neditor_plugin.load(filenames)\neditor_plugin.new()\ncur_editor = editorstack.get_current_editor()\ncur_line, cur_col = cur_editor.get_cursor_line_column()\neditorstack.set_stack_index(2)\neditorstack.get_current_editor().set_cursor_position(5)\nfilenames = editor_plugin.get_filenames()\nexpected_cursor_pos_history = [(filenames[0], 0, 0, 0), (filenames[-1], len\n    (editorstack.data[-1].get_source_code()), cur_line, cur_col), (\n    filenames[2], 5, 0, 5)]\nassert editor_plugin.cursor_pos_history == expected_cursor_pos_history\nexpected_cursor_pos_history[-1] = filenames[2], 5, 0, 5\ncursor_index_moves = [-1, 1, 1, -1, -1, -1, 1, -1]\nexpected_cursor_pos_indexes = [1, 2, 2, 1, 0, 0, 1, 0]\nfor move, index in zip(cursor_index_moves, expected_cursor_pos_indexes):\n    if move == -1:\n        editor_plugin.go_to_previous_cursor_position()\n    elif move == 1:\n        editor_plugin.go_to_next_cursor_position()\n    assert editor_plugin.cursor_pos_index == index\n    cur_line, cur_col = editorstack.get_current_editor(\n        ).get_cursor_line_column()\n    assert (editor_plugin.get_current_filename(), editor_plugin.\n        get_current_editor().get_position('cursor'), cur_line, cur_col\n        ) == expected_cursor_pos_history[index]\nassert editor_plugin.cursor_pos_history == expected_cursor_pos_history\neditorstack.set_stack_index(3)\nexpected_cursor_pos_history = expected_cursor_pos_history[:1]\nexpected_cursor_pos_history.append((filenames[3], 0, 0, 0))\nassert editor_plugin.cursor_pos_history == expected_cursor_pos_history\n",
        "CUT_1": "\"\"\"Get the list of open files in the current stack\"\"\"\neditorstack = self.editorstacks[0]\nfilenames = []\nfilenames += [finfo.filename for finfo in editorstack.data]\nreturn filenames\n",
        "CUT_2": "\"\"\"Get the list of open files in the current stack\"\"\"\neditorstack = self.editorstacks[0]\nfilenames = []\nfilenames += [finfo.filename for finfo in editorstack.data]\nreturn filenames\n",
        "CUT_3": "\"\"\"\n        Move the cursor position forward or backward in the cursor\n        position history by the specified index increment.\n        \"\"\"\nif self.cursor_pos_index is None:\n    return\nfilename, _position, _line, _column = self.cursor_pos_history[self.\n    cursor_pos_index]\ncur_line, cur_col = self.get_current_editor().get_cursor_line_column()\nself.cursor_pos_history[self.cursor_pos_index\n    ] = filename, self.get_current_editor().get_position('cursor'\n    ), cur_line, cur_col\nself.__ignore_cursor_position = True\nold_index = self.cursor_pos_index\nself.cursor_pos_index = min(len(self.cursor_pos_history) - 1, max(0, self.\n    cursor_pos_index + index_move))\nfilename, position, line, col = self.cursor_pos_history[self.cursor_pos_index]\nfilenames = self.get_current_editorstack().get_filenames()\nif not osp.isfile(filename) and filename not in filenames:\n    self.cursor_pos_history.pop(self.cursor_pos_index)\n    if self.cursor_pos_index <= old_index:\n        old_index -= 1\n    self.cursor_pos_index = old_index\nelse:\n    self.load(filename)\n    editor = self.get_current_editor()\n    if position < editor.document().characterCount():\n        editor.set_cursor_position(position)\nself.__ignore_cursor_position = False\nself.update_cursorpos_actions()\n",
        "CUT_4": "\"\"\"\n        Move the cursor position forward or backward in the cursor\n        position history by the specified index increment.\n        \"\"\"\nif self.cursor_pos_index is None:\n    return\nfilename, _position, _line, _column = self.cursor_pos_history[self.\n    cursor_pos_index]\ncur_line, cur_col = self.get_current_editor().get_cursor_line_column()\nself.cursor_pos_history[self.cursor_pos_index\n    ] = filename, self.get_current_editor().get_position('cursor'\n    ), cur_line, cur_col\nself.__ignore_cursor_position = True\nold_index = self.cursor_pos_index\nself.cursor_pos_index = min(len(self.cursor_pos_history) - 1, max(0, self.\n    cursor_pos_index + index_move))\nfilename, position, line, col = self.cursor_pos_history[self.cursor_pos_index]\nfilenames = self.get_current_editorstack().get_filenames()\nif not osp.isfile(filename) and filename not in filenames:\n    self.cursor_pos_history.pop(self.cursor_pos_index)\n    if self.cursor_pos_index <= old_index:\n        old_index -= 1\n    self.cursor_pos_index = old_index\nelse:\n    self.load(filename)\n    editor = self.get_current_editor()\n    if position < editor.document().characterCount():\n        editor.set_cursor_position(position)\nself.__ignore_cursor_position = False\nself.update_cursorpos_actions()\n",
        "CUT_5": "\"\"\"\n        Return the position index of a file in the tab bar of the editorstack\n        from its name.\n        \"\"\"\nfilenames = [d.filename for d in self.data]\nreturn filenames.index(filename)\n"
    },
    {
        "functionName": "test_open_and_close_lsp_requests",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that we send the right LSP requests when opening and closing\n    files.\n    \"\"\"\nmocker.patch.object(CodeEditor, 'document_did_open')\nmocker.patch.object(CodeEditor, 'notify_close')\neditor_factory = editor_plugin_open_files\neditor, expected_filenames, expected_current_filename = editor_factory(None,\n    None)\nassert CodeEditor.document_did_open.call_count == 5\neditorstack = editor.get_current_editorstack()\neditorstack.sig_split_vertically.emit()\ncodeeditor = editor.get_current_editor()\nassert codeeditor.is_cloned\nassert CodeEditor.document_did_open.call_count == 5\nassert CodeEditor.notify_close.call_count == 0\neditorstack = editor.get_current_editorstack()\neditorstack.close_file()\nassert CodeEditor.notify_close.call_count == 2\nassert editorstack.get_current_editor().is_cloned\neditorstack.close_split()\nassert CodeEditor.notify_close.call_count == 2\n",
        "CUT_1": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "test_config_dialog",
        "className": null,
        "fileName": "/spyder/plugins/editor/tests/test_editor_config_dialog.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "configpage = config_dialog.get_page()\nassert configpage\nconfigpage.save_to_conf()\npytest.mark.parametrize('config_dialog', [[MainWindowMock, [], [Editor]]],\n    indirect=True)",
        "CUT_1": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_2": "if button is self.apply_btn:\n    configpage = self.get_page()\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\n",
        "CUT_3": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_4": "\"\"\"Reimplement Qt method\"\"\"\nfor index in range(self.pages_widget.count()):\n    configpage = self.get_page(index)\n    if not configpage.is_valid():\n        return\n    configpage.apply_changes()\nQDialog.accept(self)\nSlot()",
        "CUT_5": "ConfigPage.set_modified(self, state)\nif not state:\n    self.changed_options = set()\n"
    },
    {
        "functionName": "test_autosave_component_set_interval",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that setting the interval does indeed change it and calls\n    do_autosave if enabled.\"\"\"\nmocker.patch.object(AutosaveForPlugin, 'do_autosave')\naddon = AutosaveForPlugin(None)\naddon.do_autosave.assert_not_called()\naddon.interval = 10000\nassert addon.interval == 10000\naddon.do_autosave.assert_not_called()\naddon.enabled = True\naddon.interval = 20000\nassert addon.do_autosave.called\n",
        "CUT_1": "\"\"\"\n        Start a timer which calls do_autosave() after `self.interval`.\n\n        The autosave timer is only started if autosave is enabled.\n        \"\"\"\nif self.enabled:\n    self.timer.start(self.interval)\n",
        "CUT_2": "\"\"\"\n        Start a timer which calls do_autosave() after `self.interval`.\n\n        The autosave timer is only started if autosave is enabled.\n        \"\"\"\nif self.enabled:\n    self.timer.start(self.interval)\n",
        "CUT_3": "\"\"\"Set timer interval (ms).\"\"\"\nself._interval = interval\nif self.timer is not None:\n    self.timer.setInterval(interval)\n",
        "CUT_4": "\"\"\"Set timer interval (ms).\"\"\"\nself._interval = interval\nif self.timer is not None:\n    self.timer.setInterval(interval)\n",
        "CUT_5": "\"\"\"\n        Interval between two autosaves, in milliseconds.\n\n        The setter will perform an autosave if the interval is changed and\n        autosave is enabled.\n        \"\"\"\nreturn self._interval\nproperty"
    },
    {
        "functionName": "test_autosave_component_timer_if_enabled",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that AutosaveForPlugin calls do_autosave() on timer if enabled.\"\"\"\nmocker.patch.object(AutosaveForPlugin, 'do_autosave')\naddon = AutosaveForPlugin(None)\naddon.do_autosave.assert_not_called()\naddon.interval = 100\naddon.enabled = enabled\nqtbot.wait(500)\nif enabled:\n    assert addon.do_autosave.called\nelse:\n    addon.do_autosave.assert_not_called()\npytest.mark.parametrize('enabled', [False, True])",
        "CUT_1": "\"\"\"\n        Start a timer which calls do_autosave() after `self.interval`.\n\n        The autosave timer is only started if autosave is enabled.\n        \"\"\"\nif self.enabled:\n    self.timer.start(self.interval)\n",
        "CUT_2": "\"\"\"\n        Start a timer which calls do_autosave() after `self.interval`.\n\n        The autosave timer is only started if autosave is enabled.\n        \"\"\"\nif self.enabled:\n    self.timer.start(self.interval)\n",
        "CUT_3": "\"\"\"\n        Constructor.\n\n        Autosave is disabled after construction and needs to be enabled\n        explicitly if required.\n\n        Args:\n            editor (Editor): editor plugin.\n        \"\"\"\nself.editor = editor\nself.name_mapping = {}\nself.file_hashes = {}\nself.timer = QTimer(self.editor)\nself.timer.setSingleShot(True)\nself.timer.timeout.connect(self.do_autosave)\nself._enabled = False\nself._interval = self.DEFAULT_AUTOSAVE_INTERVAL\n",
        "CUT_4": "\"\"\"\n        Constructor.\n\n        Autosave is disabled after construction and needs to be enabled\n        explicitly if required.\n\n        Args:\n            editor (Editor): editor plugin.\n        \"\"\"\nself.editor = editor\nself.name_mapping = {}\nself.file_hashes = {}\nself.timer = QTimer(self.editor)\nself.timer.setSingleShot(True)\nself.timer.timeout.connect(self.do_autosave)\nself._enabled = False\nself._interval = self.DEFAULT_AUTOSAVE_INTERVAL\n",
        "CUT_5": "self.enabled = self.get_option('enable')\nself.start()\n"
    },
    {
        "functionName": "test_get_files_to_recover_with_empty_autosave_dir",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test get_files_to_recover() when autosave dir contains no files.\"\"\"\nmocker.patch('spyder.plugins.editor.utils.autosave.get_conf_path',\n    return_value=str(tmpdir))\naddon = AutosaveForPlugin(None)\nresult = addon.get_files_to_recover()\nassert result == ([], [])\n",
        "CUT_1": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_2": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_3": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n",
        "CUT_4": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n",
        "CUT_5": "\"\"\"\n            Produce HTML for a class tree as given by inspect.getclasstree().\n            \"\"\"\nresult = ''\nfor entry in tree:\n    if type(entry) is type(()):\n        c, bases = entry\n        result = result + '<dt>'\n        result = result + self.classlink(c, modname)\n        if bases and bases != (parent,):\n            parents = []\n            for base in bases:\n                parents.append(self.classlink(base, modname))\n            result = result + '(' + ', '.join(parents) + ')'\n        result = result + '\\n</dt>'\n    elif type(entry) is type([]):\n        result = result + '<dd>\\n%s</dd>\\n' % self.formattree(entry, modname, c\n            )\nreturn \"\"\"<dl><dt></dt>\n%s<dd></dd></dl>\n\"\"\" % result\n"
    },
    {
        "functionName": "test_get_files_to_recover_with_one_pid_file",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test get_files_to_recover() if autosave dir contains one pid file with\n    one autosave file. If running is True, then pretend that the pid file\n    belongs to a running Spyder instance. If empty is True, then the pid file\n    is empty (regression test for spyder-ide/spyder#11375).\"\"\"\nmocker.patch('spyder.plugins.editor.utils.autosave.get_conf_path',\n    return_value=str(tmpdir))\nmock_is_spyder_process = mocker.patch(\n    'spyder.plugins.editor.utils.autosave.is_spyder_process', return_value=\n    running)\npidfile = tmpdir.join('pid42.txt')\nautosavefile = tmpdir.join('foo.py')\nif empty:\n    pidfile.write('')\nelse:\n    pidfile.write('{\"original\": ' + repr(str(autosavefile)) + '}')\nautosavefile.write('bar = 1')\naddon = AutosaveForPlugin(None)\nresult = addon.get_files_to_recover()\nif empty:\n    expected_files = [(None, str(autosavefile))]\nelif running:\n    expected_files = []\nelse:\n    expected_files = [('original', str(autosavefile))]\nexpected = expected_files, [str(pidfile)]\nassert result == expected\nmock_is_spyder_process.assert_called_with(42)\npytest.mark.parametrize('running,empty', [(True, False), (False, False), (\n    False, True)])",
        "CUT_1": "\"\"\"\n        Writes current autosave mapping to a pidNNN.txt file.\n\n        This function should be called after updating `self.autosave_mapping`.\n        The NNN in the file name is the pid of the Spyder process. If the\n        current autosave mapping is empty, then delete the file if it exists.\n        \"\"\"\nautosave_dir = get_conf_path('autosave')\nmy_pid = os.getpid()\npidfile_name = osp.join(autosave_dir, 'pid{}.txt'.format(my_pid))\nif self.name_mapping:\n    with open(pidfile_name, 'w') as pidfile:\n        if PY2:\n            pidfile.write(repr(self.name_mapping))\n        else:\n            pidfile.write(ascii(self.name_mapping))\nelse:\n    try:\n        os.remove(pidfile_name)\n    except (IOError, OSError):\n        pass\n",
        "CUT_2": "\"\"\"\n        Writes current autosave mapping to a pidNNN.txt file.\n\n        This function should be called after updating `self.autosave_mapping`.\n        The NNN in the file name is the pid of the Spyder process. If the\n        current autosave mapping is empty, then delete the file if it exists.\n        \"\"\"\nautosave_dir = get_conf_path('autosave')\nmy_pid = os.getpid()\npidfile_name = osp.join(autosave_dir, 'pid{}.txt'.format(my_pid))\nif self.name_mapping:\n    with open(pidfile_name, 'w') as pidfile:\n        if PY2:\n            pidfile.write(repr(self.name_mapping))\n        else:\n            pidfile.write(ascii(self.name_mapping))\nelse:\n    try:\n        os.remove(pidfile_name)\n    except (IOError, OSError):\n        pass\n",
        "CUT_3": "\"\"\"Check if widget is empty.\"\"\"\nif self.count() == 0:\n    return True\nreturn False\n",
        "CUT_4": "\"\"\"Check if widget is empty.\"\"\"\nif self.count() == 0:\n    return True\nreturn False\n",
        "CUT_5": "\"\"\"Detect if kite is running.\"\"\"\nrunning = False\ntry:\n    for proc in psutil.process_iter(attrs=['pid', 'name', 'username', 'status']\n        ):\n        if is_proc_kite(proc):\n            logger.debug('Kite process already running with PID {0}'.format\n                (proc.pid))\n            running = True\n            break\nexcept OSError:\n    pass\nreturn running\n"
    },
    {
        "functionName": "test_get_files_to_recover_with_non_pid_file",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test get_files_to_recover() if autosave dir contains no pid file, but\n    one Python file.\"\"\"\nmocker.patch('spyder.plugins.editor.utils.autosave.get_conf_path',\n    return_value=str(tmpdir))\npythonfile = tmpdir.join('foo.py')\npythonfile.write('bar = 1')\naddon = AutosaveForPlugin(None)\nresult = addon.get_files_to_recover()\nexpected = [(None, str(pythonfile))], []\nassert result == expected\n",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_3": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_4": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_5": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n"
    },
    {
        "functionName": "test_get_files_to_recover_without_autosave_dir",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that get_files_to_recover() does not break if there is no autosave\n    directory.\"\"\"\nmocker.patch('spyder.plugins.editor.utils.autosave.get_conf_path',\n    return_value='non-existing-directory')\naddon = AutosaveForPlugin(None)\nresult = addon.get_files_to_recover()\nassert result == ([], [])\n",
        "CUT_1": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_2": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_3": "\"\"\"\n        Select working directory.\n\n        Parameters\n        ----------\n        directory: str, optional\n            The directory to change to.\n\n        Notes\n        -----\n        If directory is None, a get directorty dialog will be used.\n        \"\"\"\nif directory is None:\n    self.sig_redirect_stdio_requested.emit(False)\n    directory = getexistingdirectory(self, _('Select directory'),\n        getcwd_or_home())\n    self.sig_redirect_stdio_requested.emit(True)\nif directory:\n    self.chdir(directory)\nSlot()",
        "CUT_4": "\"\"\"\n        Select working directory.\n\n        Parameters\n        ----------\n        directory: str, optional\n            The directory to change to.\n\n        Notes\n        -----\n        If directory is None, a get directorty dialog will be used.\n        \"\"\"\nif directory is None:\n    self.sig_redirect_stdio_requested.emit(False)\n    directory = getexistingdirectory(self, _('Select directory'),\n        getcwd_or_home())\n    self.sig_redirect_stdio_requested.emit(True)\nif directory:\n    self.chdir(directory)\nSlot()",
        "CUT_5": "\"\"\"Select directory\"\"\"\nself.sig_redirect_stdio_requested.emit(False)\ndirectory = getexistingdirectory(self, _('Select directory'), self.path)\nif directory:\n    directory = to_unicode_from_fs(osp.abspath(directory))\nself.sig_redirect_stdio_requested.emit(True)\nreturn directory\nSlot()"
    },
    {
        "functionName": "test_try_recover",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that try_recover_from_autosave() displays a RecoveryDialog, that\n    it stores the files that the user wants to open as reported by the dialog,\n    and that it removes the pid file. If error_on_remove is set, then\n    removing the pid file will raise an OSError; this should be ignored.\"\"\"\nmock_RecoveryDialog = mocker.patch(\n    'spyder.plugins.editor.utils.autosave.RecoveryDialog')\nmocker.patch('spyder.plugins.editor.utils.autosave.get_conf_path',\n    return_value=str(tmpdir))\npidfile = tmpdir.join('pid42.txt')\nautosavefile = tmpdir.join('foo.py')\npidfile.write('{\"original\": ' + repr(str(autosavefile)) + '}')\nautosavefile.write('bar = 1')\naddon = AutosaveForPlugin(None)\nif error_on_remove:\n    mocker.patch('os.remove', side_effect=OSError)\naddon.try_recover_from_autosave()\nexpected_mapping = [('original', str(autosavefile))]\nmock_RecoveryDialog.assert_called_with(expected_mapping, parent=None)\nexpected_files_to_open = mock_RecoveryDialog().files_to_open[:]\nassert addon.recover_files_to_open == expected_files_to_open\nif not error_on_remove:\n    assert not pidfile.check()\npytest.mark.parametrize('error_on_remove', [False, True])",
        "CUT_1": "\"\"\"\n        Writes current autosave mapping to a pidNNN.txt file.\n\n        This function should be called after updating `self.autosave_mapping`.\n        The NNN in the file name is the pid of the Spyder process. If the\n        current autosave mapping is empty, then delete the file if it exists.\n        \"\"\"\nautosave_dir = get_conf_path('autosave')\nmy_pid = os.getpid()\npidfile_name = osp.join(autosave_dir, 'pid{}.txt'.format(my_pid))\nif self.name_mapping:\n    with open(pidfile_name, 'w') as pidfile:\n        if PY2:\n            pidfile.write(repr(self.name_mapping))\n        else:\n            pidfile.write(ascii(self.name_mapping))\nelse:\n    try:\n        os.remove(pidfile_name)\n    except (IOError, OSError):\n        pass\n",
        "CUT_2": "\"\"\"\n        Writes current autosave mapping to a pidNNN.txt file.\n\n        This function should be called after updating `self.autosave_mapping`.\n        The NNN in the file name is the pid of the Spyder process. If the\n        current autosave mapping is empty, then delete the file if it exists.\n        \"\"\"\nautosave_dir = get_conf_path('autosave')\nmy_pid = os.getpid()\npidfile_name = osp.join(autosave_dir, 'pid{}.txt'.format(my_pid))\nif self.name_mapping:\n    with open(pidfile_name, 'w') as pidfile:\n        if PY2:\n            pidfile.write(repr(self.name_mapping))\n        else:\n            pidfile.write(ascii(self.name_mapping))\nelse:\n    try:\n        os.remove(pidfile_name)\n    except (IOError, OSError):\n        pass\n",
        "CUT_3": "\"\"\"\n        Offer to recover files from autosave.\n\n        Read pid files to get a list of files that can possibly be recovered,\n        then ask the user what to do with these files, and finally remove\n        the pid files.\n        \"\"\"\nfiles_to_recover, pidfiles = self.get_files_to_recover()\nparent = self.editor if running_under_pytest() else self.editor.main\ndialog = RecoveryDialog(files_to_recover, parent=parent)\ndialog.exec_if_nonempty()\nself.recover_files_to_open = dialog.files_to_open[:]\nfor pidfile in pidfiles:\n    try:\n        os.remove(pidfile)\n    except (IOError, OSError):\n        pass\n",
        "CUT_4": "\"\"\"\n        Offer to recover files from autosave.\n\n        Read pid files to get a list of files that can possibly be recovered,\n        then ask the user what to do with these files, and finally remove\n        the pid files.\n        \"\"\"\nfiles_to_recover, pidfiles = self.get_files_to_recover()\nparent = self.editor if running_under_pytest() else self.editor.main\ndialog = RecoveryDialog(files_to_recover, parent=parent)\ndialog.exec_if_nonempty()\nself.recover_files_to_open = dialog.files_to_open[:]\nfor pidfile in pidfiles:\n    try:\n        os.remove(pidfile)\n    except (IOError, OSError):\n        pass\n",
        "CUT_5": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture"
    },
    {
        "functionName": "test_create_unique_autosave_filename",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that AutosaveForStack.create_unique_autosave_filename() returns\n    a file name in the autosave directory with the same base name as the\n    original file name, unless that already exists in the autosave mapping\n    or on disk.\"\"\"\ndef new_exists(path):\n    if path == osp.join('autosave', 'ham.py'):\n        return on_disk\n    else:\n        return False\nmocker.patch('os.path.exists', side_effect=new_exists)\naddon = AutosaveForStack(mocker.Mock())\nif in_mapping:\n    addon.name_mapping = {osp.join('somedir', 'ham.py'): osp.join(\n        'autosave', 'ham.py')}\nautosave_filename = addon.create_unique_autosave_filename(osp.join('orig',\n    'ham.py'), 'autosave')\nif in_mapping or on_disk:\n    assert autosave_filename == osp.join('autosave', 'ham-1.py')\nelse:\n    assert autosave_filename == osp.join('autosave', 'ham.py')\npytest.mark.parametrize('in_mapping,on_disk', [(False, False), (True, False\n    ), (False, True)])",
        "CUT_1": "\"\"\"\n        Create unique autosave file name for specified file name.\n\n        The created autosave file name does not yet exist either in\n        `self.name_mapping` or on disk.\n\n        Args:\n            filename (str): original file name\n            autosave_dir (str): directory in which autosave files are stored\n        \"\"\"\nbasename = osp.basename(filename)\nautosave_filename = osp.join(autosave_dir, basename)\nif autosave_filename in self.name_mapping.values() or osp.exists(\n    autosave_filename):\n    counter = 0\n    root, ext = osp.splitext(basename)\n    while autosave_filename in self.name_mapping.values() or osp.exists(\n        autosave_filename):\n        counter += 1\n        autosave_basename = '{}-{}{}'.format(root, counter, ext)\n        autosave_filename = osp.join(autosave_dir, autosave_basename)\nreturn autosave_filename\n",
        "CUT_2": "\"\"\"\n        Create unique autosave file name for specified file name.\n\n        The created autosave file name does not yet exist either in\n        `self.name_mapping` or on disk.\n\n        Args:\n            filename (str): original file name\n            autosave_dir (str): directory in which autosave files are stored\n        \"\"\"\nbasename = osp.basename(filename)\nautosave_filename = osp.join(autosave_dir, basename)\nif autosave_filename in self.name_mapping.values() or osp.exists(\n    autosave_filename):\n    counter = 0\n    root, ext = osp.splitext(basename)\n    while autosave_filename in self.name_mapping.values() or osp.exists(\n        autosave_filename):\n        counter += 1\n        autosave_basename = '{}-{}{}'.format(root, counter, ext)\n        autosave_filename = osp.join(autosave_dir, autosave_basename)\nreturn autosave_filename\n",
        "CUT_3": "\"\"\"\n        Get name of autosave file for specified file name.\n\n        This function uses the dict in `self.name_mapping`. If `filename` is\n        in the mapping, then return the corresponding autosave file name.\n        Otherwise, construct a unique file name and update the mapping.\n\n        Args:\n            filename (str): original file name\n        \"\"\"\ntry:\n    autosave_filename = self.name_mapping[filename]\nexcept KeyError:\n    autosave_dir = get_conf_path('autosave')\n    if not osp.isdir(autosave_dir):\n        try:\n            os.mkdir(autosave_dir)\n        except EnvironmentError as error:\n            action = _('Error while creating autosave directory')\n            msgbox = AutosaveErrorDialog(action, error)\n            msgbox.exec_if_enabled()\n    autosave_filename = self.create_unique_autosave_filename(filename,\n        autosave_dir)\n    self.name_mapping[filename] = autosave_filename\n    self.save_autosave_mapping()\n    logger.debug('New autosave file name')\nreturn autosave_filename\n",
        "CUT_4": "\"\"\"\n        Get name of autosave file for specified file name.\n\n        This function uses the dict in `self.name_mapping`. If `filename` is\n        in the mapping, then return the corresponding autosave file name.\n        Otherwise, construct a unique file name and update the mapping.\n\n        Args:\n            filename (str): original file name\n        \"\"\"\ntry:\n    autosave_filename = self.name_mapping[filename]\nexcept KeyError:\n    autosave_dir = get_conf_path('autosave')\n    if not osp.isdir(autosave_dir):\n        try:\n            os.mkdir(autosave_dir)\n        except EnvironmentError as error:\n            action = _('Error while creating autosave directory')\n            msgbox = AutosaveErrorDialog(action, error)\n            msgbox.exec_if_enabled()\n    autosave_filename = self.create_unique_autosave_filename(filename,\n        autosave_dir)\n    self.name_mapping[filename] = autosave_filename\n    self.save_autosave_mapping()\n    logger.debug('New autosave file name')\nreturn autosave_filename\n",
        "CUT_5": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n"
    },
    {
        "functionName": "new_exists",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if path == osp.join('autosave', 'ham.py'):\n    return on_disk\nelse:\n    return False\n",
        "CUT_1": "\"\"\"Return True if path is a Python module/package\"\"\"\nis_module = osp.isfile(path) and osp.splitext(path)[1] in ('.py', '.pyw')\nis_package = osp.isdir(path) and osp.isfile(osp.join(path, '__init__.py'))\nreturn is_module or is_package\n",
        "CUT_2": "\"\"\"Return True if path is a Python module/package\"\"\"\nis_module = osp.isfile(path) and osp.splitext(path)[1] in ('.py', '.pyw')\nis_package = osp.isdir(path) and osp.isfile(osp.join(path, '__init__.py'))\nreturn is_module or is_package\n",
        "CUT_3": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_4": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_5": "return path\n"
    },
    {
        "functionName": "test_autosave",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that AutosaveForStack.maybe_autosave writes the contents to the\n    autosave file and updates the file_hashes.\"\"\"\nmock_editor = mocker.Mock()\nmock_fileinfo = mocker.Mock(editor=mock_editor, filename='orig',\n    newly_created=False)\nmock_document = mocker.Mock()\nmock_fileinfo.editor.document.return_value = mock_document\nmock_stack = mocker.Mock(data=[mock_fileinfo])\naddon = AutosaveForStack(mock_stack)\naddon.name_mapping = {'orig': 'autosave'}\naddon.file_hashes = {'autosave': 2}\nif have_hash:\n    addon.file_hashes['orig'] = 1\nmock_stack.compute_hash.return_value = 3\naddon.maybe_autosave(0)\nmock_stack._write_to_file.assert_called_with(mock_fileinfo, 'autosave')\nmock_stack.compute_hash.assert_called_with(mock_fileinfo)\nif have_hash:\n    assert addon.file_hashes == {'orig': 1, 'autosave': 3}\nelse:\n    assert addon.file_hashes == {'autosave': 3}\npytest.mark.parametrize('have_hash', [True, False])",
        "CUT_1": "orig, autosave = self.data[idx]\nif orig:\n    self.files_to_open.append(orig['name'])\nself.files_to_open.append(autosave['name'])\nself.deactivate(idx)\n",
        "CUT_2": "orig, autosave = self.data[idx]\nif orig:\n    self.files_to_open.append(orig['name'])\nself.files_to_open.append(autosave['name'])\nself.deactivate(idx)\n",
        "CUT_3": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_4": "return Mock()\n",
        "CUT_5": "orig, autosave = self.data[idx]\nif orig:\n    orig_name = orig['name']\nelse:\n    orig_name, ignored = getsavefilename(self, _(\n        'Restore autosave file to ...'), osp.basename(autosave['name']))\n    if not orig_name:\n        return\ntry:\n    try:\n        os.replace(autosave['name'], orig_name)\n    except (AttributeError, OSError):\n        shutil.copy2(autosave['name'], orig_name)\n        os.remove(autosave['name'])\n    self.deactivate(idx)\nexcept EnvironmentError as error:\n    text = _('Unable to restore {} using {}').format(orig_name, autosave[\n        'name'])\n    self.report_error(text, error)\n"
    },
    {
        "functionName": "test_save_autosave_mapping_with_nonempty_mapping",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that save_autosave_mapping() writes the current autosave mapping\n    to the correct file if the mapping is not empty.\"\"\"\nmocker.patch('os.getpid', return_value=42)\nmocker.patch('spyder.plugins.editor.utils.autosave.get_conf_path',\n    return_value=str(tmpdir))\naddon = AutosaveForStack(None)\nif latin:\n    addon.name_mapping = {'orig': 'autosave'}\nelse:\n    addon.name_mapping = {'\u539f\u4ef6': 'autosave'}\naddon.save_autosave_mapping()\npidfile = tmpdir.join('pid42.txt')\nassert ast.literal_eval(pidfile.read()) == addon.name_mapping\npytest.mark.parametrize('latin', [True, False])",
        "CUT_1": "\"\"\"\n        Writes current autosave mapping to a pidNNN.txt file.\n\n        This function should be called after updating `self.autosave_mapping`.\n        The NNN in the file name is the pid of the Spyder process. If the\n        current autosave mapping is empty, then delete the file if it exists.\n        \"\"\"\nautosave_dir = get_conf_path('autosave')\nmy_pid = os.getpid()\npidfile_name = osp.join(autosave_dir, 'pid{}.txt'.format(my_pid))\nif self.name_mapping:\n    with open(pidfile_name, 'w') as pidfile:\n        if PY2:\n            pidfile.write(repr(self.name_mapping))\n        else:\n            pidfile.write(ascii(self.name_mapping))\nelse:\n    try:\n        os.remove(pidfile_name)\n    except (IOError, OSError):\n        pass\n",
        "CUT_2": "\"\"\"\n        Writes current autosave mapping to a pidNNN.txt file.\n\n        This function should be called after updating `self.autosave_mapping`.\n        The NNN in the file name is the pid of the Spyder process. If the\n        current autosave mapping is empty, then delete the file if it exists.\n        \"\"\"\nautosave_dir = get_conf_path('autosave')\nmy_pid = os.getpid()\npidfile_name = osp.join(autosave_dir, 'pid{}.txt'.format(my_pid))\nif self.name_mapping:\n    with open(pidfile_name, 'w') as pidfile:\n        if PY2:\n            pidfile.write(repr(self.name_mapping))\n        else:\n            pidfile.write(ascii(self.name_mapping))\nelse:\n    try:\n        os.remove(pidfile_name)\n    except (IOError, OSError):\n        pass\n",
        "CUT_3": "\"\"\"\n        Get name of autosave file for specified file name.\n\n        This function uses the dict in `self.name_mapping`. If `filename` is\n        in the mapping, then return the corresponding autosave file name.\n        Otherwise, construct a unique file name and update the mapping.\n\n        Args:\n            filename (str): original file name\n        \"\"\"\ntry:\n    autosave_filename = self.name_mapping[filename]\nexcept KeyError:\n    autosave_dir = get_conf_path('autosave')\n    if not osp.isdir(autosave_dir):\n        try:\n            os.mkdir(autosave_dir)\n        except EnvironmentError as error:\n            action = _('Error while creating autosave directory')\n            msgbox = AutosaveErrorDialog(action, error)\n            msgbox.exec_if_enabled()\n    autosave_filename = self.create_unique_autosave_filename(filename,\n        autosave_dir)\n    self.name_mapping[filename] = autosave_filename\n    self.save_autosave_mapping()\n    logger.debug('New autosave file name')\nreturn autosave_filename\n",
        "CUT_4": "\"\"\"\n        Get name of autosave file for specified file name.\n\n        This function uses the dict in `self.name_mapping`. If `filename` is\n        in the mapping, then return the corresponding autosave file name.\n        Otherwise, construct a unique file name and update the mapping.\n\n        Args:\n            filename (str): original file name\n        \"\"\"\ntry:\n    autosave_filename = self.name_mapping[filename]\nexcept KeyError:\n    autosave_dir = get_conf_path('autosave')\n    if not osp.isdir(autosave_dir):\n        try:\n            os.mkdir(autosave_dir)\n        except EnvironmentError as error:\n            action = _('Error while creating autosave directory')\n            msgbox = AutosaveErrorDialog(action, error)\n            msgbox.exec_if_enabled()\n    autosave_filename = self.create_unique_autosave_filename(filename,\n        autosave_dir)\n    self.name_mapping[filename] = autosave_filename\n    self.save_autosave_mapping()\n    logger.debug('New autosave file name')\nreturn autosave_filename\n",
        "CUT_5": "\"\"\"\n        Remove autosave file for specified file.\n\n        This function also updates `self.name_mapping` and `self.file_hashes`.\n        If there is no autosave file, then the function returns without doing\n        anything.\n        \"\"\"\nif filename not in self.name_mapping:\n    return\nautosave_filename = self.name_mapping[filename]\ntry:\n    os.remove(autosave_filename)\nexcept EnvironmentError as error:\n    action = _('Error while removing autosave file {}').format(\n        autosave_filename)\n    msgbox = AutosaveErrorDialog(action, error)\n    msgbox.exec_if_enabled()\ndel self.name_mapping[filename]\ndel self.file_hashes[autosave_filename]\nself.save_autosave_mapping()\nlogger.debug('Removing autosave file %s', autosave_filename)\n"
    },
    {
        "functionName": "test_save_autosave_mapping_with_empty_mapping",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that save_autosave_mapping() does not write the pidfile if the\n    mapping is empty, and that is removes the pidfile if it exists.\"\"\"\nmocker.patch('os.getpid', return_value=42)\nmocker.patch('spyder.plugins.editor.utils.autosave.get_conf_path',\n    return_value=str(tmpdir))\naddon = AutosaveForStack(None)\naddon.name_mapping = {}\npidfile = tmpdir.join('pid42.txt')\nif pidfile_exists:\n    pidfile.write('This is an ex-parrot!')\naddon.save_autosave_mapping()\nassert not pidfile.check()\npytest.mark.parametrize('pidfile_exists', [False, True])",
        "CUT_1": "\"\"\"\n        Writes current autosave mapping to a pidNNN.txt file.\n\n        This function should be called after updating `self.autosave_mapping`.\n        The NNN in the file name is the pid of the Spyder process. If the\n        current autosave mapping is empty, then delete the file if it exists.\n        \"\"\"\nautosave_dir = get_conf_path('autosave')\nmy_pid = os.getpid()\npidfile_name = osp.join(autosave_dir, 'pid{}.txt'.format(my_pid))\nif self.name_mapping:\n    with open(pidfile_name, 'w') as pidfile:\n        if PY2:\n            pidfile.write(repr(self.name_mapping))\n        else:\n            pidfile.write(ascii(self.name_mapping))\nelse:\n    try:\n        os.remove(pidfile_name)\n    except (IOError, OSError):\n        pass\n",
        "CUT_2": "\"\"\"\n        Writes current autosave mapping to a pidNNN.txt file.\n\n        This function should be called after updating `self.autosave_mapping`.\n        The NNN in the file name is the pid of the Spyder process. If the\n        current autosave mapping is empty, then delete the file if it exists.\n        \"\"\"\nautosave_dir = get_conf_path('autosave')\nmy_pid = os.getpid()\npidfile_name = osp.join(autosave_dir, 'pid{}.txt'.format(my_pid))\nif self.name_mapping:\n    with open(pidfile_name, 'w') as pidfile:\n        if PY2:\n            pidfile.write(repr(self.name_mapping))\n        else:\n            pidfile.write(ascii(self.name_mapping))\nelse:\n    try:\n        os.remove(pidfile_name)\n    except (IOError, OSError):\n        pass\n",
        "CUT_3": "\"\"\"\n        Offer to recover files from autosave.\n\n        Read pid files to get a list of files that can possibly be recovered,\n        then ask the user what to do with these files, and finally remove\n        the pid files.\n        \"\"\"\nfiles_to_recover, pidfiles = self.get_files_to_recover()\nparent = self.editor if running_under_pytest() else self.editor.main\ndialog = RecoveryDialog(files_to_recover, parent=parent)\ndialog.exec_if_nonempty()\nself.recover_files_to_open = dialog.files_to_open[:]\nfor pidfile in pidfiles:\n    try:\n        os.remove(pidfile)\n    except (IOError, OSError):\n        pass\n",
        "CUT_4": "\"\"\"\n        Offer to recover files from autosave.\n\n        Read pid files to get a list of files that can possibly be recovered,\n        then ask the user what to do with these files, and finally remove\n        the pid files.\n        \"\"\"\nfiles_to_recover, pidfiles = self.get_files_to_recover()\nparent = self.editor if running_under_pytest() else self.editor.main\ndialog = RecoveryDialog(files_to_recover, parent=parent)\ndialog.exec_if_nonempty()\nself.recover_files_to_open = dialog.files_to_open[:]\nfor pidfile in pidfiles:\n    try:\n        os.remove(pidfile)\n    except (IOError, OSError):\n        pass\n",
        "CUT_5": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture"
    },
    {
        "functionName": "test_autosave_remove_autosave_file",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that AutosaveForStack.remove_autosave_file removes the autosave\n    file, that an error dialog is displayed if an exception is raised,\n    and that the autosave file is removed from `name_mapping` and\n    `file_hashes`.\"\"\"\nmock_remove = mocker.patch('os.remove')\nif exception:\n    mock_remove.side_effect = OSError()\nmock_dialog = mocker.patch(\n    'spyder.plugins.editor.utils.autosave.AutosaveErrorDialog')\nmock_stack = mocker.Mock()\nfileinfo = mocker.Mock()\nfileinfo.filename = 'orig'\naddon = AutosaveForStack(mock_stack)\naddon.name_mapping = {'orig': 'autosave'}\naddon.file_hashes = {'autosave': 42}\naddon.remove_autosave_file(fileinfo.filename)\nassert addon.name_mapping == {}\nassert addon.file_hashes == {}\nmock_remove.assert_any_call('autosave')\nassert mock_dialog.called == exception\npytest.mark.parametrize('exception', [False, True])",
        "CUT_1": "\"\"\"\n        Remove autosave file for specified file.\n\n        This function also updates `self.name_mapping` and `self.file_hashes`.\n        If there is no autosave file, then the function returns without doing\n        anything.\n        \"\"\"\nif filename not in self.name_mapping:\n    return\nautosave_filename = self.name_mapping[filename]\ntry:\n    os.remove(autosave_filename)\nexcept EnvironmentError as error:\n    action = _('Error while removing autosave file {}').format(\n        autosave_filename)\n    msgbox = AutosaveErrorDialog(action, error)\n    msgbox.exec_if_enabled()\ndel self.name_mapping[filename]\ndel self.file_hashes[autosave_filename]\nself.save_autosave_mapping()\nlogger.debug('Removing autosave file %s', autosave_filename)\n",
        "CUT_2": "\"\"\"\n        Remove autosave file for specified file.\n\n        This function also updates `self.name_mapping` and `self.file_hashes`.\n        If there is no autosave file, then the function returns without doing\n        anything.\n        \"\"\"\nif filename not in self.name_mapping:\n    return\nautosave_filename = self.name_mapping[filename]\ntry:\n    os.remove(autosave_filename)\nexcept EnvironmentError as error:\n    action = _('Error while removing autosave file {}').format(\n        autosave_filename)\n    msgbox = AutosaveErrorDialog(action, error)\n    msgbox.exec_if_enabled()\ndel self.name_mapping[filename]\ndel self.file_hashes[autosave_filename]\nself.save_autosave_mapping()\nlogger.debug('Removing autosave file %s', autosave_filename)\n",
        "CUT_3": "\"\"\"\n        Register an AutosaveForStack object.\n\n        This replaces the `name_mapping` and `file_hashes` attributes\n        in `autosave_for_stack` with references to the corresponding\n        attributes of `self`, so that all AutosaveForStack objects\n        share the same data.\n        \"\"\"\nautosave_for_stack.name_mapping = self.name_mapping\nautosave_for_stack.file_hashes = self.file_hashes\n",
        "CUT_4": "\"\"\"\n        Register an AutosaveForStack object.\n\n        This replaces the `name_mapping` and `file_hashes` attributes\n        in `autosave_for_stack` with references to the corresponding\n        attributes of `self`, so that all AutosaveForStack objects\n        share the same data.\n        \"\"\"\nautosave_for_stack.name_mapping = self.name_mapping\nautosave_for_stack.file_hashes = self.file_hashes\n",
        "CUT_5": "\"\"\"\n        Get name of autosave file for specified file name.\n\n        This function uses the dict in `self.name_mapping`. If `filename` is\n        in the mapping, then return the corresponding autosave file name.\n        Otherwise, construct a unique file name and update the mapping.\n\n        Args:\n            filename (str): original file name\n        \"\"\"\ntry:\n    autosave_filename = self.name_mapping[filename]\nexcept KeyError:\n    autosave_dir = get_conf_path('autosave')\n    if not osp.isdir(autosave_dir):\n        try:\n            os.mkdir(autosave_dir)\n        except EnvironmentError as error:\n            action = _('Error while creating autosave directory')\n            msgbox = AutosaveErrorDialog(action, error)\n            msgbox.exec_if_enabled()\n    autosave_filename = self.create_unique_autosave_filename(filename,\n        autosave_dir)\n    self.name_mapping[filename] = autosave_filename\n    self.save_autosave_mapping()\n    logger.debug('New autosave file name')\nreturn autosave_filename\n"
    },
    {
        "functionName": "test_get_autosave_filename",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that AutosaveForStack.get_autosave_filename returns a consistent\n    and unique name for the autosave file is returned.\"\"\"\naddon = AutosaveForStack(mocker.Mock())\nmocker.patch('spyder.plugins.editor.utils.autosave.get_conf_path',\n    return_value=str(tmpdir))\nexpected = str(tmpdir.join('foo.py'))\nassert addon.get_autosave_filename('foo.py') == expected\nexpected2 = str(tmpdir.join('foo-1.py'))\nassert addon.get_autosave_filename('foo.py') == expected\nassert addon.get_autosave_filename('ham/foo.py') == expected2\n",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_3": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_4": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_5": "\"\"\"\n        This must be reimplemented by plugins that need to adjust their fonts.\n\n        The following plugins illustrate the usage of this method:\n          * spyder/plugins/help/plugin.py\n          * spyder/plugins/onlinehelp/plugin.py\n        \"\"\"\npass\n"
    },
    {
        "functionName": "test_autosave_file_renamed",
        "className": null,
        "fileName": "/spyder/plugins/editor/utils/tests/test_autosave.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that AutosaveForStack.file_renamed removes the old autosave file,\n    creates a new one, and updates `name_mapping` and `file_hashes`.\"\"\"\nmock_remove = mocker.patch('os.remove')\nmocker.patch('spyder.plugins.editor.utils.autosave.get_conf_path',\n    return_value=str(tmpdir))\nmock_editor = mocker.Mock()\nmock_fileinfo = mocker.Mock(editor=mock_editor, filename='new_foo.py',\n    newly_created=False)\nmock_document = mocker.Mock()\nmock_fileinfo.editor.document.return_value = mock_document\nmock_stack = mocker.Mock(data=[mock_fileinfo])\nmock_stack.has_filename.return_value = 0\nmock_stack.compute_hash.return_value = 3\naddon = AutosaveForStack(mock_stack)\nold_autosavefile = str(tmpdir.join('old_foo.py'))\nnew_autosavefile = str(tmpdir.join('new_foo.py'))\naddon.name_mapping = {'old_foo.py': old_autosavefile}\naddon.file_hashes = {'old_foo.py': 1, old_autosavefile: 42}\nif have_hash:\n    addon.file_hashes = {'old_foo.py': 1, old_autosavefile: 42}\nelse:\n    addon.file_hashes = {old_autosavefile: 42}\naddon.file_renamed('old_foo.py', 'new_foo.py')\nmock_remove.assert_any_call(old_autosavefile)\nmock_stack._write_to_file.assert_called_with(mock_fileinfo, new_autosavefile)\nassert addon.name_mapping == {'new_foo.py': new_autosavefile}\nif have_hash:\n    assert addon.file_hashes == {'new_foo.py': 1, new_autosavefile: 3}\nelse:\n    assert addon.file_hashes == {new_autosavefile: 3}\npytest.mark.parametrize('have_hash', [True, False])",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Register an AutosaveForStack object.\n\n        This replaces the `name_mapping` and `file_hashes` attributes\n        in `autosave_for_stack` with references to the corresponding\n        attributes of `self`, so that all AutosaveForStack objects\n        share the same data.\n        \"\"\"\nautosave_for_stack.name_mapping = self.name_mapping\nautosave_for_stack.file_hashes = self.file_hashes\n",
        "CUT_3": "\"\"\"\n        Register an AutosaveForStack object.\n\n        This replaces the `name_mapping` and `file_hashes` attributes\n        in `autosave_for_stack` with references to the corresponding\n        attributes of `self`, so that all AutosaveForStack objects\n        share the same data.\n        \"\"\"\nautosave_for_stack.name_mapping = self.name_mapping\nautosave_for_stack.file_hashes = self.file_hashes\n",
        "CUT_4": "return Mock()\n",
        "CUT_5": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture"
    },
    {
        "functionName": "editor_close_quotes",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closequotes.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up Editor with close quotes activated.\"\"\"\napp = qapplication()\neditor = CodeEditor(parent=None)\nkwargs = {}\nkwargs['language'] = 'Python'\nkwargs['close_quotes'] = True\neditor.setup_editor(**kwargs)\nreturn editor\npytest.fixture",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "test_runner = unittest.TextTestRunner(stream=sys.stderr)\nkwargs['testRunner'] = kwargs.pop('testRunner', test_runner)\nkwargs['exit'] = False\nTestProgram.__init__(self, *args, **kwargs)\n",
        "CUT_4": "kwargs['creationflags'] = creation_flag\nsuper(SubprocessPopen, self).__init__(*args, **kwargs)\n",
        "CUT_5": "if os.name == 'nt':\n    return zmqtunnel.paramiko_tunnel(*args, **kwargs)\nelse:\n    return openssh_tunnel(self, *args, **kwargs)\n"
    },
    {
        "functionName": "test_close_quotes",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closequotes.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test insertion of extra quotes.\"\"\"\neditor = editor_close_quotes\nqtbot.keyClicks(editor, text)\nassert editor.toPlainText() == expected_text\nassert cursor_column == TextHelper(editor).current_column_nbr()\npytest.mark.parametrize('text, expected_text, cursor_column', [('\"', '\"\"', \n    1), (\"'\", \"''\", 1), ('#\"', '#\"', 2), (\"#'\", \"#'\", 2), ('\"\"\"', '\"\"\"', 3),\n    (\"'''\", \"'''\", 3), ('\"\"\"\"', '\"\"\"\"\"\"', 3), (\"''''\", \"''''''\", 3), (\n    '\"some_string\"', '\"some_string\"', 13), (\"'some_string'\",\n    \"'some_string'\", 13)])",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_trailing_text",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closequotes.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test insertion of extra quotes inside brackets and before commas,\n    colons and semi-colons.\n    \"\"\"\neditor = editor_close_quotes\nqtbot.keyClicks(editor, text)\neditor.move_cursor(-1)\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == expected_text\nassert cursor_column == TextHelper(editor).current_column_nbr()\npytest.mark.parametrize('text, expected_text, cursor_column', [('()',\n    '(\"\")', 2), ('{}', '{\"\"}', 2), ('[]', '[\"\"]', 2), (',', '\"\",', 1), (':',\n    '\"\":', 1), (';', '\"\";', 1), ('a', '\"a', 1)])",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n"
    },
    {
        "functionName": "test_selected_text",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closequotes.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test insert surronding quotes to selected text.\"\"\"\neditor = editor_close_quotes\neditor.set_text('some text')\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor, 4)\neditor.setTextCursor(cursor)\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == '\"some\" text'\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == '\"\"some\"\" text'\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == '\"\"\"some\"\"\" text'\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n"
    },
    {
        "functionName": "test_selected_text_multiple_lines",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closequotes.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test insert surronding quotes to multiple lines selected text.\"\"\"\neditor = editor_close_quotes\ntext = \"\"\"some text\n\nsome text\"\"\"\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor, 4)\ncursor.movePosition(QTextCursor.Down, QTextCursor.KeepAnchor, 2)\neditor.setTextCursor(cursor)\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == \"\"\"\"some text\n\nsome\" text\"\"\"\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == \"\"\"\"\"some text\n\nsome\"\" text\"\"\"\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == \"\"\"\"\"\\\"some text\n\nsome\"\"\\\" text\"\"\"\n",
        "CUT_1": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_2": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_3": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_4": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_5": "\"\"\"Returns True if some text is selected.\"\"\"\nreturn bool(to_text_string(self.textCursor().selectedText()))\n"
    },
    {
        "functionName": "test_close_quotes_in_brackets",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closequotes.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test quote completion in nested brackets.\"\"\"\neditor = editor_close_quotes\neditor.textCursor().insertText('foo()')\neditor.move_cursor(-1)\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == 'foo(\"\")'\nassert editor.textCursor().columnNumber() == 5\nqtbot.keyPress(editor, Qt.Key_Delete)\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == 'foo(\"\")'\nassert editor.textCursor().columnNumber() == 6\nqtbot.keyClicks(editor, ', ,')\neditor.move_cursor(-1)\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == 'foo(\"\", \"\",)'\nassert editor.textCursor().columnNumber() == 9\neditor.move_cursor(2)\nqtbot.keyClicks(editor, ' { },')\neditor.move_cursor(-3)\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == 'foo(\"\", \"\", {\"\" },)'\nassert editor.textCursor().columnNumber() == 14\neditor.move_cursor(4)\nqtbot.keyClicks(editor, ' bar')\neditor.move_cursor(-3)\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == 'foo(\"\", \"\", {\"\" }, \"bar)'\nassert editor.textCursor().columnNumber() == 20\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n"
    },
    {
        "functionName": "test_activate_deactivate",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closequotes.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test activating/desctivating close quotes editor extension.\"\"\"\neditor = editor_close_quotes\nquote_extension = editor.editor_extensions.get(CloseQuotesExtension)\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == '\"\"'\neditor.set_text('')\nquote_extension.enabled = False\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == '\"'\neditor.set_text('')\nquote_extension.enabled = True\nqtbot.keyClicks(editor, '\"')\nassert editor.toPlainText() == '\"\"'\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Enable/disable automatic quote insertion feature\"\"\"\nself.close_quotes_enabled = enable\nquote_extension = self.editor_extensions.get(CloseQuotesExtension)\nif quote_extension is not None:\n    quote_extension.enabled = enable\n"
    },
    {
        "functionName": "editor_close_brackets",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closebrackets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up Editor with close brackets activated.\"\"\"\napp = qapplication()\neditor = CodeEditor(parent=None)\nkwargs = {}\nkwargs['language'] = 'Python'\nkwargs['close_parentheses'] = True\neditor.setup_editor(**kwargs)\nreturn editor\npytest.fixture",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "test_runner = unittest.TextTestRunner(stream=sys.stderr)\nkwargs['testRunner'] = kwargs.pop('testRunner', test_runner)\nkwargs['exit'] = False\nTestProgram.__init__(self, *args, **kwargs)\n",
        "CUT_4": "kwargs['creationflags'] = creation_flag\nsuper(SubprocessPopen, self).__init__(*args, **kwargs)\n",
        "CUT_5": "if os.name == 'nt':\n    return zmqtunnel.paramiko_tunnel(*args, **kwargs)\nelse:\n    return openssh_tunnel(self, *args, **kwargs)\n"
    },
    {
        "functionName": "test_bracket_closing_new_line",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closebrackets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test bracket completion with existing brackets in a new line.\n\n    For spyder-ide/spyder#11217\n    \"\"\"\neditor = editor_close_brackets\neditor.textCursor().insertText('foo(\\nbar)')\neditor.move_cursor(-1)\nqtbot.keyClicks(editor, '()')\nassert editor.toPlainText() == 'foo(\\nbar())'\nassert editor.textCursor().columnNumber() == 5\nqtbot.keyClicks(editor, ')')\nassert editor.toPlainText() == 'foo(\\nbar())'\nassert editor.textCursor().columnNumber() == 6\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n"
    },
    {
        "functionName": "test_close_brackets",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closebrackets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test insertion of brackets.\"\"\"\neditor = editor_close_brackets\nqtbot.keyClicks(editor, text)\nassert editor.toPlainText() == expected_text\nassert cursor_column == TextHelper(editor).current_column_nbr()\npytest.mark.parametrize('text, expected_text, cursor_column', [('(', '()', \n    1), ('{', '{}', 1), ('[', '[]', 1)])",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_nested_brackets",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closebrackets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test completion of brackets inside brackets and before commas,\n    colons and semi-colons.\n    \"\"\"\neditor = editor_close_brackets\nqtbot.keyClicks(editor, text)\neditor.move_cursor(-1)\nqtbot.keyClicks(editor, '(')\nassert editor.toPlainText() == expected_text\nassert cursor_column == TextHelper(editor).current_column_nbr()\npytest.mark.parametrize('text, expected_text, cursor_column', [('()',\n    '(())', 2), ('{}', '{()}', 2), ('[]', '[()]', 2), (',', '(),', 1), (':',\n    '():', 1), (';', '();', 1)])",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n"
    },
    {
        "functionName": "test_selected_text",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closebrackets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test insert surronding brackets to selected text.\"\"\"\neditor = editor_close_brackets\neditor.set_text('some text')\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor, 4)\neditor.setTextCursor(cursor)\nqtbot.keyClicks(editor, '(')\nassert editor.toPlainText() == '(some) text'\nqtbot.keyClicks(editor, '}')\nassert editor.toPlainText() == '({some}) text'\nqtbot.keyClicks(editor, '[')\nassert editor.toPlainText() == '({[some]}) text'\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n"
    },
    {
        "functionName": "test_selected_text_multiple_lines",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closebrackets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test insert surronding brackets to multiple lines selected text.\"\"\"\neditor = editor_close_brackets\ntext = \"\"\"some text\n\nsome text\"\"\"\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor, 4)\ncursor.movePosition(QTextCursor.Down, QTextCursor.KeepAnchor, 2)\neditor.setTextCursor(cursor)\nqtbot.keyClicks(editor, ')')\nassert editor.toPlainText() == \"\"\"(some text\n\nsome) text\"\"\"\nqtbot.keyClicks(editor, '{')\nassert editor.toPlainText() == \"\"\"({some text\n\nsome}) text\"\"\"\nqtbot.keyClicks(editor, ']')\nassert editor.toPlainText() == \"\"\"({[some text\n\nsome]}) text\"\"\"\n",
        "CUT_1": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_2": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_3": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "\"\"\"Returns True if some text is selected.\"\"\"\nreturn bool(to_text_string(self.textCursor().selectedText()))\n"
    },
    {
        "functionName": "test_complex_completion",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closebrackets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test bracket completion in nested brackets.\"\"\"\neditor = editor_close_brackets\neditor.textCursor().insertText('foo(bar)')\neditor.move_cursor(-1)\nqtbot.keyClicks(editor, '(')\nassert editor.toPlainText() == 'foo(bar())'\nassert editor.textCursor().columnNumber() == 8\neditor.move_cursor(-1)\nqtbot.keyClicks(editor, '[')\nassert editor.toPlainText() == 'foo(bar[())'\nassert editor.textCursor().columnNumber() == 8\nqtbot.keyClicks(editor, ',')\neditor.move_cursor(-1)\nqtbot.keyClicks(editor, '{')\nassert editor.toPlainText() == 'foo(bar[{},())'\nassert editor.textCursor().columnNumber() == 9\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_bracket_closing",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closebrackets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test bracket completion with existing brackets.\"\"\"\neditor = editor_close_brackets\neditor.textCursor().insertText('foo(bar(x')\nqtbot.keyClicks(editor, ')')\nassert editor.toPlainText() == 'foo(bar(x)'\nassert editor.textCursor().columnNumber() == 10\nqtbot.keyClicks(editor, ')')\nassert editor.toPlainText() == 'foo(bar(x))'\nassert editor.textCursor().columnNumber() == 11\neditor.move_cursor(-2)\nqtbot.keyClicks(editor, ')')\nassert editor.toPlainText() == 'foo(bar(x))'\nassert editor.textCursor().columnNumber() == 10\nqtbot.keyClicks(editor, ')')\nassert editor.toPlainText() == 'foo(bar(x))'\nassert editor.textCursor().columnNumber() == 11\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_activate_deactivate",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_closebrackets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test activating/desctivating close quotes editor extension.\"\"\"\neditor = editor_close_brackets\nbracket_extension = editor.editor_extensions.get(CloseBracketsExtension)\nqtbot.keyClicks(editor, '(')\nassert editor.toPlainText() == '()'\neditor.set_text('')\nbracket_extension.enabled = False\nqtbot.keyClicks(editor, '(')\nassert editor.toPlainText() == '('\neditor.set_text('')\nbracket_extension.enabled = True\nqtbot.keyClicks(editor, '(')\nassert editor.toPlainText() == '()'\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Enable/disable automatic parentheses insertion feature\"\"\"\nself.close_parentheses_enabled = enable\nbracket_extension = self.editor_extensions.get(CloseBracketsExtension)\nif bracket_extension is not None:\n    bracket_extension.enabled = enable\n"
    },
    {
        "functionName": "editor_auto_docstring",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_docstring.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up Editor with auto docstring activated.\"\"\"\napp = qapplication()\neditor = CodeEditor(parent=None)\nkwargs = {}\nkwargs['language'] = 'Python'\nkwargs['close_quotes'] = True\nkwargs['close_parentheses'] = True\neditor.setup_editor(**kwargs)\nreturn editor\npytest.fixture",
        "CUT_1": "test_runner = unittest.TextTestRunner(stream=sys.stderr)\nkwargs['testRunner'] = kwargs.pop('testRunner', test_runner)\nkwargs['exit'] = False\nTestProgram.__init__(self, *args, **kwargs)\n",
        "CUT_2": "kwargs['creationflags'] = creation_flag\nsuper(SubprocessPopen, self).__init__(*args, **kwargs)\n",
        "CUT_3": "if os.name == 'nt':\n    return zmqtunnel.paramiko_tunnel(*args, **kwargs)\nelse:\n    return openssh_tunnel(self, *args, **kwargs)\n",
        "CUT_4": "if os.name == 'nt':\n    return zmqtunnel.paramiko_tunnel(*args, **kwargs)\nelse:\n    return openssh_tunnel(self, *args, **kwargs)\n",
        "CUT_5": "\"\"\"\n    Given a dict, populate kwargs to create a generally\n    useful default setup for running subprocess processes\n    on different platforms. For example, `close_fds` is\n    set on posix and creation of a new console window is\n    disabled on Windows.\n\n    This function will alter the given kwargs and return\n    the modified dict.\n    \"\"\"\nkwargs.setdefault('close_fds', os.name == 'posix')\nif os.name == 'nt':\n    CONSOLE_CREATION_FLAGS = 0\n    CREATE_NO_WINDOW = 134217728\n    CONSOLE_CREATION_FLAGS |= CREATE_NO_WINDOW\n    kwargs.setdefault('creationflags', CONSOLE_CREATION_FLAGS)\n    if kwargs.get('env') is not None:\n        if 'SYSTEMROOT' not in map(str.upper, kwargs['env'].keys()):\n            sys_root_key = None\n            for k, v in os.environ.items():\n                if 'SYSTEMROOT' == k.upper():\n                    sys_root_key = k\n                    break\n            if sys_root_key is not None:\n                kwargs['env'].update({sys_root_key: os.environ[sys_root_key]})\nreturn kwargs\n"
    },
    {
        "functionName": "test_parse_function_definition",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_docstring.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the parse_def method of FunctionInfo class.\"\"\"\nfunc_info = FunctionInfo()\nfunc_info.parse_def(text)\nassert func_info.func_indent == indent\nassert func_info.arg_name_list == name_list\nassert func_info.arg_type_list == type_list\nassert func_info.arg_value_list == value_list\nassert func_info.return_type_annotated == rtype\npytest.mark.parametrize('text, indent, name_list, type_list, value_list, rtype'\n    , [('def foo():', '', [], [], [], None), (\n    \" def foo(arg0, arg1=':', arg2: str='-> (float, str):') ->              (float, int): \"\n    , ' ', ['arg0', 'arg1', 'arg2'], [None, None, 'str'], [None, \"':'\",\n    \"'-> (float, str):'\"], '(float, int)')])",
        "CUT_1": "\"\"\"Generate docstring.\"\"\"\ndocstring = None\nself.quote3 = quote * 3\nif quote == '\"':\n    self.quote3_other = \"'''\"\nelse:\n    self.quote3_other = '\"\"\"'\nresult = self.get_function_definition_from_below_last_line()\nif result:\n    func_def, __ = result\n    func_info = FunctionInfo()\n    func_info.parse_def(func_def)\n    if func_info.has_info:\n        func_body = self.get_function_body(func_info.func_indent)\n        if func_body:\n            func_info.parse_body(func_body)\n        if doc_type == 'Numpydoc':\n            docstring = self._generate_numpy_doc(func_info)\n        elif doc_type == 'Googledoc':\n            docstring = self._generate_google_doc(func_info)\n        elif doc_type == 'Sphinxdoc':\n            docstring = self._generate_sphinx_doc(func_info)\nreturn docstring\n",
        "CUT_2": "\"\"\"Generate docstring.\"\"\"\ndocstring = None\nself.quote3 = quote * 3\nif quote == '\"':\n    self.quote3_other = \"'''\"\nelse:\n    self.quote3_other = '\"\"\"'\nresult = self.get_function_definition_from_below_last_line()\nif result:\n    func_def, __ = result\n    func_info = FunctionInfo()\n    func_info.parse_def(func_def)\n    if func_info.has_info:\n        func_body = self.get_function_body(func_info.func_indent)\n        if func_body:\n            func_info.parse_body(func_body)\n        if doc_type == 'Numpydoc':\n            docstring = self._generate_numpy_doc(func_info)\n        elif doc_type == 'Googledoc':\n            docstring = self._generate_google_doc(func_info)\n        elif doc_type == 'Sphinxdoc':\n            docstring = self._generate_sphinx_doc(func_info)\nreturn docstring\n",
        "CUT_3": "\"\"\"Generate a docstring of sphinx type.\"\"\"\nsphinx_doc = ''\narg_names = func_info.arg_name_list\narg_types = func_info.arg_type_list\narg_values = func_info.arg_value_list\nif len(arg_names) > 0 and arg_names[0] == 'self':\n    del arg_names[0]\n    del arg_types[0]\n    del arg_values[0]\nindent1 = func_info.func_indent + self.code_editor.indent_chars\nsphinx_doc += '\\n{}\\n'.format(indent1)\narg_text = ''\nfor arg_name, arg_type, arg_value in zip(arg_names, arg_types, arg_values):\n    arg_text += '{}:param {}: DESCRIPTION'.format(indent1, arg_name)\n    if arg_value:\n        arg_value = arg_value.replace(self.quote3, self.quote3_other)\n        arg_text += ', defaults to {}\\n'.format(arg_value)\n    else:\n        arg_text += '\\n'\n    arg_text += '{}:type {}: '.format(indent1, arg_name)\n    if arg_type:\n        arg_text += '{}'.format(arg_type)\n    else:\n        arg_text += 'TYPE'\n    if arg_value:\n        arg_text += ', optional'\n    arg_text += '\\n'\nsphinx_doc += arg_text\nif func_info.raise_list:\n    for raise_type in func_info.raise_list:\n        sphinx_doc += '{}:raises {}: DESCRIPTION\\n'.format(indent1, raise_type)\nif func_info.has_yield:\n    header = '{}:yield:'.format(indent1)\nelse:\n    header = '{}:return:'.format(indent1)\nreturn_type_annotated = func_info.return_type_annotated\nif return_type_annotated:\n    return_section = '{} DESCRIPTION\\n'.format(header)\n    return_section += '{}:rtype: {}'.format(indent1, return_type_annotated)\nelse:\n    return_section = '{} DESCRIPTION\\n'.format(header)\n    return_section += '{}:rtype: TYPE'.format(indent1)\nsphinx_doc += return_section\nsphinx_doc += '\\n\\n{}{}'.format(indent1, self.quote3)\nreturn sphinx_doc\n",
        "CUT_4": "\"\"\"Generate a docstring of sphinx type.\"\"\"\nsphinx_doc = ''\narg_names = func_info.arg_name_list\narg_types = func_info.arg_type_list\narg_values = func_info.arg_value_list\nif len(arg_names) > 0 and arg_names[0] == 'self':\n    del arg_names[0]\n    del arg_types[0]\n    del arg_values[0]\nindent1 = func_info.func_indent + self.code_editor.indent_chars\nsphinx_doc += '\\n{}\\n'.format(indent1)\narg_text = ''\nfor arg_name, arg_type, arg_value in zip(arg_names, arg_types, arg_values):\n    arg_text += '{}:param {}: DESCRIPTION'.format(indent1, arg_name)\n    if arg_value:\n        arg_value = arg_value.replace(self.quote3, self.quote3_other)\n        arg_text += ', defaults to {}\\n'.format(arg_value)\n    else:\n        arg_text += '\\n'\n    arg_text += '{}:type {}: '.format(indent1, arg_name)\n    if arg_type:\n        arg_text += '{}'.format(arg_type)\n    else:\n        arg_text += 'TYPE'\n    if arg_value:\n        arg_text += ', optional'\n    arg_text += '\\n'\nsphinx_doc += arg_text\nif func_info.raise_list:\n    for raise_type in func_info.raise_list:\n        sphinx_doc += '{}:raises {}: DESCRIPTION\\n'.format(indent1, raise_type)\nif func_info.has_yield:\n    header = '{}:yield:'.format(indent1)\nelse:\n    header = '{}:return:'.format(indent1)\nreturn_type_annotated = func_info.return_type_annotated\nif return_type_annotated:\n    return_section = '{} DESCRIPTION\\n'.format(header)\n    return_section += '{}:rtype: {}'.format(indent1, return_type_annotated)\nelse:\n    return_section = '{} DESCRIPTION\\n'.format(header)\n    return_section += '{}:rtype: TYPE'.format(indent1)\nsphinx_doc += return_section\nsphinx_doc += '\\n\\n{}{}'.format(indent1, self.quote3)\nreturn sphinx_doc\n",
        "CUT_5": "\"\"\"Generate a docstring of google type.\"\"\"\ngoogle_doc = ''\narg_names = func_info.arg_name_list\narg_types = func_info.arg_type_list\narg_values = func_info.arg_value_list\nif len(arg_names) > 0 and arg_names[0] == 'self':\n    del arg_names[0]\n    del arg_types[0]\n    del arg_values[0]\nindent1 = func_info.func_indent + self.code_editor.indent_chars\nindent2 = func_info.func_indent + self.code_editor.indent_chars * 2\ngoogle_doc += '\\n{}\\n'.format(indent1)\nif len(arg_names) > 0:\n    google_doc += '\\n{0}Args:\\n'.format(indent1)\narg_text = ''\nfor arg_name, arg_type, arg_value in zip(arg_names, arg_types, arg_values):\n    arg_text += '{}{} '.format(indent2, arg_name)\n    arg_text += '('\n    if arg_type:\n        arg_text += '{}'.format(arg_type)\n    else:\n        arg_text += 'TYPE'\n    if arg_value:\n        arg_text += ', optional'\n    arg_text += '):'\n    arg_text += ' DESCRIPTION.'\n    if arg_value:\n        arg_value = arg_value.replace(self.quote3, self.quote3_other)\n        arg_text += ' Defaults to {}.\\n'.format(arg_value)\n    else:\n        arg_text += '\\n'\ngoogle_doc += arg_text\nif func_info.raise_list:\n    google_doc += '\\n{0}Raises:'.format(indent1)\n    for raise_type in func_info.raise_list:\n        google_doc += '\\n{}{}'.format(indent2, raise_type)\n        google_doc += ': DESCRIPTION.'\n    google_doc += '\\n'\ngoogle_doc += '\\n'\nif func_info.has_yield:\n    header = '{}Yields:\\n'.format(indent1)\nelse:\n    header = '{}Returns:\\n'.format(indent1)\nreturn_type_annotated = func_info.return_type_annotated\nif return_type_annotated:\n    return_section = '{}{}{}: DESCRIPTION.'.format(header, indent2,\n        return_type_annotated)\nelse:\n    return_element_type = indent2 + '{return_type}: DESCRIPTION.'\n    placeholder = return_element_type.format(return_type='TYPE')\n    return_element_name = indent2 + '{return_name} ' + '(TYPE): DESCRIPTION.'\n    try:\n        return_section = self._generate_docstring_return_section(func_info.\n            return_value_in_body, header, return_element_name,\n            return_element_type, placeholder, indent2)\n    except (ValueError, IndexError):\n        return_section = '{}{}None.'.format(header, indent2)\ngoogle_doc += return_section\ngoogle_doc += '\\n\\n{}{}'.format(indent1, self.quote3)\nreturn google_doc\n"
    },
    {
        "functionName": "test_get_function_body",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_docstring.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test get function body.\"\"\"\neditor = editor_auto_docstring\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.setPosition(0, QTextCursor.MoveAnchor)\ncursor.movePosition(QTextCursor.NextBlock)\neditor.setTextCursor(cursor)\nwriter = editor.writer_docstring\nresult = writer.get_function_body(indent)\nassert expected == result\npytest.mark.parametrize('text, indent, expected', [(\n    \"\"\"    def foo():\n\n        if 1:\n            raise ValueError\n        else:\n            return\n\n    class F:\"\"\"\n    , '    ',\n    \"\"\"\n        if 1:\n            raise ValueError\n        else:\n            return\n\"\"\"\n    ), (\"\"\"def foo():\n    return\"\"\", '', '    return')])",
        "CUT_1": "\"\"\"Write docstring to editor at mouse position.\"\"\"\nresult = self.get_function_definition_from_first_line()\neditor = self.code_editor\nif result:\n    func_text, number_of_line_func = result\n    line_number_function = self.line_number_cursor + number_of_line_func - 1\n    cursor = editor.textCursor()\n    line_number_cursor = cursor.blockNumber() + 1\n    offset = line_number_function - line_number_cursor\n    if offset > 0:\n        for __ in range(offset):\n            cursor.movePosition(QTextCursor.NextBlock)\n    else:\n        for __ in range(abs(offset)):\n            cursor.movePosition(QTextCursor.PreviousBlock)\n    cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.MoveAnchor)\n    editor.setTextCursor(cursor)\n    indent = get_indent(func_text)\n    editor.insert_text('\\n{}{}\"\"\"'.format(indent, editor.indent_chars))\n    self.write_docstring()\n",
        "CUT_2": "\"\"\"Write docstring to editor at mouse position.\"\"\"\nresult = self.get_function_definition_from_first_line()\neditor = self.code_editor\nif result:\n    func_text, number_of_line_func = result\n    line_number_function = self.line_number_cursor + number_of_line_func - 1\n    cursor = editor.textCursor()\n    line_number_cursor = cursor.blockNumber() + 1\n    offset = line_number_function - line_number_cursor\n    if offset > 0:\n        for __ in range(offset):\n            cursor.movePosition(QTextCursor.NextBlock)\n    else:\n        for __ in range(abs(offset)):\n            cursor.movePosition(QTextCursor.PreviousBlock)\n    cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.MoveAnchor)\n    editor.setTextCursor(cursor)\n    indent = get_indent(func_text)\n    editor.insert_text('\\n{}{}\"\"\"'.format(indent, editor.indent_chars))\n    self.write_docstring()\n",
        "CUT_3": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n"
    },
    {
        "functionName": "test_editor_docstring_by_shortcut",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_docstring.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test auto docstring by shortcut.\"\"\"\nCONF.set('editor', 'docstring_type', doc_type)\neditor = editor_auto_docstring\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.setPosition(0, QTextCursor.MoveAnchor)\neditor.setTextCursor(cursor)\nwriter = editor.writer_docstring\nif use_shortcut:\n    writer.write_docstring_for_shortcut()\nelse:\n    pos = editor.cursorRect().bottomRight()\n    pos = editor.mapToGlobal(pos)\n    writer.line_number_cursor = editor.get_line_number_at(pos)\n    writer.write_docstring_at_first_line_of_function()\nassert editor.toPlainText() == expected\npytest.mark.parametrize('use_shortcut', [True, False])pytest.mark.parametrize('doc_type, text, expected', [('Numpydoc', '', ''),\n    ('Numpydoc', 'if 1:\\n    ', 'if 1:\\n    '), ('Numpydoc',\n    \"\"\"async def foo():\n    raise\n    raise ValueError\n    raise ValueError(\"test\")\n    raise TypeError(\"test\")\n    yield \"\"\"\n    ,\n    \"\"\"async def foo():\n    \"\"\\\"\n    \n\n    Raises\n    ------\n    ValueError\n        DESCRIPTION.\n    TypeError\n        DESCRIPTION.\n\n    Yields\n    ------\n    None.\n\n    \"\"\\\"\n    raise\n    raise ValueError\n    raise ValueError(\"test\")\n    raise TypeError(\"test\")\n    yield \"\"\"\n    ), ('Numpydoc',\n    \"\"\"  def foo():\n      print('{}' % foo_raise Value)\n      foo_yield\"\"\",\n    \"\"\"  def foo():\n      \"\"\\\"\n      \n\n      Returns\n      -------\n      None.\n\n      \"\"\\\"\n      print('{}' % foo_raise Value)\n      foo_yield\"\"\"\n    ), ('Numpydoc',\n    \"\"\"def foo(arg, arg0, arg1: int, arg2: List[Tuple[str, float]],\n    arg3='-> (float, int):', arg4=':float, int[', arg5: str='\"\"') ->   (List[Tuple[str, float]], str, float):\n    \"\"\"\n    ,\n    \"\"\"def foo(arg, arg0, arg1: int, arg2: List[Tuple[str, float]],\n    arg3='-> (float, int):', arg4=':float, int[', arg5: str='\"\"') ->   (List[Tuple[str, float]], str, float):\n    \"\"\\\"\n    \n\n    Parameters\n    ----------\n    arg : TYPE\n        DESCRIPTION.\n    arg0 : TYPE\n        DESCRIPTION.\n    arg1 : int\n        DESCRIPTION.\n    arg2 : List[Tuple[str, float]]\n        DESCRIPTION.\n    arg3 : TYPE, optional\n        DESCRIPTION. The default is '-> (float, int):'.\n    arg4 : TYPE, optional\n        DESCRIPTION. The default is ':float, int['.\n    arg5 : str, optional\n        DESCRIPTION. The default is '\"\"'.\n\n    Returns\n    -------\n    (List[Tuple[str, float]], str, float)\n        DESCRIPTION.\n\n    \"\"\\\"\n    \"\"\"\n    ), ('Googledoc',\n    \"\"\"async def foo():\n    raise\n    raise ValueError\n    raise TypeError(\"test\")\n    yield value\n    \"\"\"\n    ,\n    \"\"\"async def foo():\n    \"\"\\\"\n    \n\n    Raises:\n        ValueError: DESCRIPTION.\n        TypeError: DESCRIPTION.\n\n    Yields:\n        value (TYPE): DESCRIPTION.\n\n    \"\"\\\"\n    raise\n    raise ValueError\n    raise TypeError(\"test\")\n    yield value\n    \"\"\"\n    ), ('Googledoc', '  def foo():\\n      ',\n    \"\"\"  def foo():\n      \"\"\\\"\n      \n\n      Returns:\n          None.\n\n      \"\"\\\"\n      \"\"\"\n    ), ('Googledoc',\n    \"\"\"def foo(arg, arg0, arg1: int, arg2: List[Tuple[str, float]],\n    arg3='-> (float, int):', arg4=':float, int[', arg5: str='\"\"') ->   (List[Tuple[str, float]], str, float):\n    \"\"\"\n    ,\n    \"\"\"def foo(arg, arg0, arg1: int, arg2: List[Tuple[str, float]],\n    arg3='-> (float, int):', arg4=':float, int[', arg5: str='\"\"') ->   (List[Tuple[str, float]], str, float):\n    \"\"\\\"\n    \n\n    Args:\n        arg (TYPE): DESCRIPTION.\n        arg0 (TYPE): DESCRIPTION.\n        arg1 (int): DESCRIPTION.\n        arg2 (List[Tuple[str, float]]): DESCRIPTION.\n        arg3 (TYPE, optional): DESCRIPTION. Defaults to '-> (float, int):'.\n        arg4 (TYPE, optional): DESCRIPTION. Defaults to ':float, int['.\n        arg5 (str, optional): DESCRIPTION. Defaults to '\"\"'.\n\n    Returns:\n        (List[Tuple[str, float]], str, float): DESCRIPTION.\n\n    \"\"\\\"\n    \"\"\"\n    ), ('Sphinxdoc',\n    \"\"\"async def foo():\n    raise\n    raise ValueError\n    raise TypeError(\"test\")\n    yield value\n    \"\"\"\n    ,\n    \"\"\"async def foo():\n    \"\"\\\"\n    \n    :raises ValueError: DESCRIPTION\n    :raises TypeError: DESCRIPTION\n    :yield: DESCRIPTION\n    :rtype: TYPE\n\n    \"\"\\\"\n    raise\n    raise ValueError\n    raise TypeError(\"test\")\n    yield value\n    \"\"\"\n    ), ('Sphinxdoc', '  def foo():\\n      ',\n    \"\"\"  def foo():\n      \"\"\\\"\n      \n      :return: DESCRIPTION\n      :rtype: TYPE\n\n      \"\"\\\"\n      \"\"\"\n    ), ('Sphinxdoc',\n    \"\"\"def foo(arg, arg0, arg1: int, arg2: List[Tuple[str, float]],\n    arg3='-> (float, int):', arg4=':float, int[', arg5: str='\"\"') ->   (List[Tuple[str, float]], str, float):\n    \"\"\"\n    ,\n    \"\"\"def foo(arg, arg0, arg1: int, arg2: List[Tuple[str, float]],\n    arg3='-> (float, int):', arg4=':float, int[', arg5: str='\"\"') ->   (List[Tuple[str, float]], str, float):\n    \"\"\\\"\n    \n    :param arg: DESCRIPTION\n    :type arg: TYPE\n    :param arg0: DESCRIPTION\n    :type arg0: TYPE\n    :param arg1: DESCRIPTION\n    :type arg1: int\n    :param arg2: DESCRIPTION\n    :type arg2: List[Tuple[str, float]]\n    :param arg3: DESCRIPTION, defaults to '-> (float, int):'\n    :type arg3: TYPE, optional\n    :param arg4: DESCRIPTION, defaults to ':float, int['\n    :type arg4: TYPE, optional\n    :param arg5: DESCRIPTION, defaults to '\"\"'\n    :type arg5: str, optional\n    :return: DESCRIPTION\n    :rtype: (List[Tuple[str, float]], str, float)\n\n    \"\"\\\"\n    \"\"\"\n    )])",
        "CUT_1": "return str(list(self))\n",
        "CUT_2": "return str(list(self))\n",
        "CUT_3": "\"\"\"\n        Return the plugin localized description.\n\n        Returns\n        -------\n        str\n            Localized description of the plugin.\n\n        Notes\n        -----\n        This is a method to be able to update localization without a restart.\n        \"\"\"\nraise NotImplementedError('A plugin description must be defined!')\n",
        "CUT_4": "\"\"\"\n        Return the plugin localized description.\n\n        Returns\n        -------\n        str\n            Localized description of the plugin.\n\n        Notes\n        -----\n        This is a method to be able to update localization without a restart.\n        \"\"\"\nraise NotImplementedError('A plugin description must be defined!')\n",
        "CUT_5": "\"\"\"Set the description for the report.\"\"\"\nself.input_description.setPlainText(description)\n"
    },
    {
        "functionName": "test_editor_docstring_below_def_by_shortcut",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_docstring.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test auto docstring below function definition by shortcut.\"\"\"\nCONF.set('editor', 'docstring_type', 'Numpydoc')\neditor = editor_auto_docstring\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.NextBlock)\ncursor.setPosition(QTextCursor.End, QTextCursor.MoveAnchor)\neditor.setTextCursor(cursor)\neditor.writer_docstring.write_docstring_for_shortcut()\nassert editor.toPlainText() == expected\npytest.mark.parametrize('text, expected', [('  def foo():\\n      ',\n    \"\"\"  def foo():\n      \"\"\\\"\n      \n\n      Returns\n      -------\n      None.\n\n      \"\"\\\"\n      \"\"\"\n    )])",
        "CUT_1": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_2": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_3": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_4": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_5": "\"\"\"Kill the text on the current line from the cursor forward\"\"\"\ncursor = self.textCursor()\ncursor.clearSelection()\ncursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)\nif not cursor.hasSelection():\n    cursor.movePosition(QTextCursor.NextBlock, QTextCursor.KeepAnchor)\nself._kill_ring.kill_cursor(cursor)\nself.setTextCursor(cursor)\nself.document_did_change()\n"
    },
    {
        "functionName": "test_editor_docstring_delayed_popup",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_docstring.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test auto docstring using delayed popup.\"\"\"\nCONF.set('editor', 'docstring_type', 'Numpydoc')\neditor = editor_auto_docstring\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.NextBlock)\ncursor.setPosition(QTextCursor.EndOfLine, QTextCursor.MoveAnchor)\neditor.setTextCursor(cursor)\nqtbot.keyPress(editor, Qt.Key_Space)\nqtbot.keyPress(editor, Qt.Key_Space)\nqtbot.keyPress(editor, Qt.Key_Space)\nqtbot.keyPress(editor, Qt.Key_Space)\nqtbot.keyPress(editor, Qt.Key_QuoteDbl)\nqtbot.keyPress(editor, Qt.Key_QuoteDbl)\nqtbot.keyPress(editor, Qt.Key_QuoteDbl)\nqtbot.wait(1000)\nqtbot.keyPress(editor.menu_docstring, key)\nqtbot.wait(1000)\nassert editor.toPlainText() == expected\npytest.mark.parametrize('text, expected, key', [('def foo():\\n',\n    \"\"\"def foo():\n    \"\"\\\"\n    \n\n    Returns\n    -------\n    None.\n\n    \"\"\\\"\"\"\"\n    , Qt.Key_Enter), ('def foo():\\n', \"\"\"def foo():\n    \"\"\\\"a\"\"\", Qt.Key_A)])",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n"
    },
    {
        "functionName": "test_editor_docstring_with_body_numpydoc",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_docstring.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test auto docstring of numpydoc when the function body is complex.\"\"\"\nCONF.set('editor', 'docstring_type', 'Numpydoc')\neditor = editor_auto_docstring\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.setPosition(0, QTextCursor.MoveAnchor)\neditor.setTextCursor(cursor)\nwriter = editor.writer_docstring\nwriter.write_docstring_for_shortcut()\nassert editor.toPlainText() == expected\npytest.mark.parametrize('text, expected', [(\n    \"\"\"  def foo():\n      raise\n      foo_raise()\n      raisefoo()\n      raise ValueError\n      is_yield()\n      raise ValueError('tt')\n      yieldfoo()\n      \traise TypeError('tt')\n      _yield\n      \"\"\"\n    ,\n    \"\"\"  def foo():\n      \"\"\\\"\n      \n\n      Raises\n      ------\n      ValueError\n          DESCRIPTION.\n      TypeError\n          DESCRIPTION.\n\n      Returns\n      -------\n      None.\n\n      \"\"\\\"\n      raise\n      foo_raise()\n      raisefoo()\n      raise ValueError\n      is_yield()\n      raise ValueError('tt')\n      yieldfoo()\n      \traise TypeError('tt')\n      _yield\n      \"\"\"\n    ), (\n    \"\"\"def foo():\n    return None\n    return \"f, b\", v1, v2, 3.0, .7, (,), {}, [ab], f(a), None, a.b, a+b, True\n    return \"f, b\", v1, v3, 420, 5., (,), {}, [ab], f(a), None, a.b, a+b, False\n    \"\"\"\n    ,\n    \"\"\"def foo():\n    \"\"\\\"\n    \n\n    Returns\n    -------\n    str\n        DESCRIPTION.\n    v1 : TYPE\n        DESCRIPTION.\n    TYPE\n        DESCRIPTION.\n    numeric\n        DESCRIPTION.\n    float\n        DESCRIPTION.\n    tuple\n        DESCRIPTION.\n    dict\n        DESCRIPTION.\n    list\n        DESCRIPTION.\n    TYPE\n        DESCRIPTION.\n    TYPE\n        DESCRIPTION.\n    TYPE\n        DESCRIPTION.\n    TYPE\n        DESCRIPTION.\n    bool\n        DESCRIPTION.\n\n    \"\"\\\"\n    return None\n    return \"f, b\", v1, v2, 3.0, .7, (,), {}, [ab], f(a), None, a.b, a+b, True\n    return \"f, b\", v1, v3, 420, 5., (,), {}, [ab], f(a), None, a.b, a+b, False\n    \"\"\"\n    ), (\"\"\"def foo():\n    return no, (ano, eo, dken)\n    \"\"\",\n    \"\"\"def foo():\n    \"\"\\\"\n    \n\n    Returns\n    -------\n    TYPE\n        DESCRIPTION.\n\n    \"\"\\\"\n    return no, (ano, eo, dken)\n    \"\"\"\n    )])",
        "CUT_1": "\"\"\"Set the description for the report.\"\"\"\nself.input_description.setPlainText(description)\n",
        "CUT_2": "\"\"\"Set the description for the report.\"\"\"\nself.input_description.setPlainText(description)\n",
        "CUT_3": "\"\"\"\n        Return the plugin localized description.\n\n        Returns\n        -------\n        str\n            Localized description of the plugin.\n\n        Notes\n        -----\n        This is a method to be able to update localization without a restart.\n        \"\"\"\nraise NotImplementedError('A plugin description must be defined!')\n",
        "CUT_4": "\"\"\"\n        Return the plugin localized description.\n\n        Returns\n        -------\n        str\n            Localized description of the plugin.\n\n        Notes\n        -----\n        This is a method to be able to update localization without a restart.\n        \"\"\"\nraise NotImplementedError('A plugin description must be defined!')\n",
        "CUT_5": "\"\"\"Return the item description text.\"\"\"\nreturn self._description\n"
    },
    {
        "functionName": "test_editor_docstring_with_body_googledoc",
        "className": null,
        "fileName": "/spyder/plugins/editor/extensions/tests/test_docstring.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test auto docstring of googledoc when the function body is complex.\"\"\"\nCONF.set('editor', 'docstring_type', 'Googledoc')\neditor = editor_auto_docstring\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.setPosition(0, QTextCursor.MoveAnchor)\neditor.setTextCursor(cursor)\nwriter = editor.writer_docstring\nwriter.write_docstring_for_shortcut()\nassert editor.toPlainText() == expected\npytest.mark.parametrize('text, expected', [(\n    \"\"\"  def foo():\n      raise\n      foo_raise()\n      raisefoo()\n      raise ValueError\n      is_yield()\n      raise ValueError('tt')\n      yieldfoo()\n      \traise TypeError('tt')\n      _yield\n      \"\"\"\n    ,\n    \"\"\"  def foo():\n      \"\"\\\"\n      \n\n      Raises:\n          ValueError: DESCRIPTION.\n          TypeError: DESCRIPTION.\n\n      Returns:\n          None.\n\n      \"\"\\\"\n      raise\n      foo_raise()\n      raisefoo()\n      raise ValueError\n      is_yield()\n      raise ValueError('tt')\n      yieldfoo()\n      \traise TypeError('tt')\n      _yield\n      \"\"\"\n    ), (\n    \"\"\"def foo():\n    return None\n    return \"f, b\", v1, v2, 3.0, .7, (,), {}, [ab], f(a), None, a.b, a+b, True\n    return \"f, b\", v1, v3, 420, 5., (,), {}, [ab], f(a), None, a.b, a+b, False\n    \"\"\"\n    ,\n    \"\"\"def foo():\n    \"\"\\\"\n    \n\n    Returns:\n        str: DESCRIPTION.\n        v1 (TYPE): DESCRIPTION.\n        TYPE: DESCRIPTION.\n        numeric: DESCRIPTION.\n        float: DESCRIPTION.\n        tuple: DESCRIPTION.\n        dict: DESCRIPTION.\n        list: DESCRIPTION.\n        TYPE: DESCRIPTION.\n        TYPE: DESCRIPTION.\n        TYPE: DESCRIPTION.\n        TYPE: DESCRIPTION.\n        bool: DESCRIPTION.\n\n    \"\"\\\"\n    return None\n    return \"f, b\", v1, v2, 3.0, .7, (,), {}, [ab], f(a), None, a.b, a+b, True\n    return \"f, b\", v1, v3, 420, 5., (,), {}, [ab], f(a), None, a.b, a+b, False\n    \"\"\"\n    ), (\"\"\"def foo():\n    return no, (ano, eo, dken)\n    \"\"\",\n    \"\"\"def foo():\n    \"\"\\\"\n    \n\n    Returns:\n        TYPE: DESCRIPTION.\n\n    \"\"\\\"\n    return no, (ano, eo, dken)\n    \"\"\"\n    )])",
        "CUT_1": "\"\"\"Set the description for the report.\"\"\"\nself.input_description.setPlainText(description)\n",
        "CUT_2": "\"\"\"Set the description for the report.\"\"\"\nself.input_description.setPlainText(description)\n",
        "CUT_3": "\"\"\"\n        Return the plugin localized description.\n\n        Returns\n        -------\n        str\n            Localized description of the plugin.\n\n        Notes\n        -----\n        This is a method to be able to update localization without a restart.\n        \"\"\"\nraise NotImplementedError('A plugin description must be defined!')\n",
        "CUT_4": "\"\"\"\n        Return the plugin localized description.\n\n        Returns\n        -------\n        str\n            Localized description of the plugin.\n\n        Notes\n        -----\n        This is a method to be able to update localization without a restart.\n        \"\"\"\nraise NotImplementedError('A plugin description must be defined!')\n",
        "CUT_5": "\"\"\"Return the item description text.\"\"\"\nreturn self._description\n"
    },
    {
        "functionName": "test_goto_uri",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_goto.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the uri search is working correctly.\"\"\"\n_, code_editor = editorbot\ncode_editor.show()\nmocker.patch.object(QDesktopServices, 'openUrl')\nparam, expected_output_1, full_file_path, expected_output_2 = params\nif full_file_path:\n    code_editor.filename = full_file_path\ncode_editor.set_text(param)\ncode_editor.moveCursor(QTextCursor.Start)\nx, y = code_editor.get_coordinates('cursor')\npoint = code_editor.calculate_real_position(QPoint(x + 23, y))\ncode_editor.moveCursor(QTextCursor.End)\nqtbot.mouseMove(code_editor, point, delay=500)\nwith qtbot.waitSignal(code_editor.sig_uri_found, timeout=3000) as blocker:\n    qtbot.keyPress(code_editor, Qt.Key_Control, delay=500)\n    args = blocker.args\n    print([param, expected_output_1])\n    print([args])\n    output_1 = args[0]\n    output_2 = code_editor.go_to_uri_from_cursor(expected_output_1)\n    assert expected_output_1 in output_1\n    assert expected_output_2 == output_2\npytest.mark.skipif(bool(os.environ.get('CI', None)), reason='Fails on CI!')pytest.mark.parametrize('params', [('file://{}\\n'.format(TEMPFILE_PATH), \n    'file://' + TEMPFILE_PATH, TEMPFILE_PATH, 'file://' + TEMPFILE_PATH), (\n    '\"file://{}\"\\n'.format(TEST_FILE_ABS), 'file://' + TEST_FILE_ABS,\n    TEST_FILE_ABS, 'file://' + TEST_FILE_ABS), ('\"file://./{}\"\\n'.format(\n    TEST_FILE_REL), 'file://./' + TEST_FILE_REL, os.path.join(TEST_FOLDER,\n    TEST_FILE_REL), 'file://./' + TEST_FILE_REL), ('\"file:///not%20there\"',\n    'file:///not%20there', '/not%20there', 'file:///not%20there'), (\n    '\"file:///not_there\"', 'file:///not_there', '/not_there',\n    'file:///not_there'), (\"\"\"\" https://google.com\\\"\n\"\"\",\n    'https://google.com', None, 'https://google.com'), (\n    '# https://google.com\"\\n', 'https://google.com', None,\n    'https://google.com'), (\"\"\"\" mailto:some@email.com\\\"\n\"\"\",\n    'mailto:some@email.com', None, 'mailto:some@email.com'), (\n    '# mailto:some@email.com\\n', 'mailto:some@email.com', None,\n    'mailto:some@email.com'), ('some@email.com\\n', 'some@email.com', None,\n    'mailto:some@email.com'), (\"\"\"# some@email.com\n\"\"\", 'some@email.com',\n    None, 'mailto:some@email.com'), ('# gl:gitlab-org/gitlab-ce#62529\\n',\n    'gl:gitlab-org/gitlab-ce#62529', None,\n    'https://gitlab.com/gitlab-org/gitlab-ce/issues/62529'), (\n    \"\"\"# bb:birkenfeld/pygments-main#1516\n\"\"\",\n    'bb:birkenfeld/pygments-main#1516', None,\n    'https://bitbucket.org/birkenfeld/pygments-main/issues/1516'), (\n    \"\"\"# gh:spyder-ide/spyder#123\n\"\"\", 'gh:spyder-ide/spyder#123', None,\n    'https://github.com/spyder-ide/spyder/issues/123'), (\n    \"\"\"# gh:spyder-ide/spyder#123\n\"\"\", 'gh:spyder-ide/spyder#123', None,\n    'https://github.com/spyder-ide/spyder/issues/123'), pytest.param((\n    '# gh-123\\n', 'gh-123', HERE,\n    'https://github.com/spyder-ide/spyder/issues/123'), marks=pytest.mark.\n    skipif(not get_git_remotes(HERE), reason='not in a git repository'))])",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_goto_uri_project_root_path",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_goto.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the uri search is working correctly.\"\"\"\n_, code_editor = editorbot\ncode_editor.show()\nmock_project_dir = str(tmpdir)\nexpected_output_path = os.path.join(mock_project_dir, 'some-file.txt')\nwith open(expected_output_path, 'w') as fh:\n    fh.write('BOOM!\\n')\ncode_editor.set_current_project_path(mock_project_dir)\ncode_editor.filename = 'foo.txt'\nmocker.patch.object(QDesktopServices, 'openUrl')\ncode_editor.set_text('file://^/some-file.txt')\ncode_editor.moveCursor(QTextCursor.Start)\nx, y = code_editor.get_coordinates('cursor')\npoint = code_editor.calculate_real_position(QPoint(x + 23, y))\ncode_editor.moveCursor(QTextCursor.End)\nqtbot.mouseMove(code_editor, point, delay=500)\nwith qtbot.waitSignal(code_editor.sig_file_uri_preprocessed, timeout=3000\n    ) as blocker:\n    qtbot.keyPress(code_editor, Qt.Key_Control, delay=500)\n    args = blocker.args\n    assert args[0] == expected_output_path\nqtbot.wait(500)\nexpected_output_path = os.path.expanduser('~/some-file.txt')\ncode_editor.set_current_project_path()\nwith qtbot.waitSignal(code_editor.sig_file_uri_preprocessed, timeout=3000\n    ) as blocker:\n    qtbot.keyPress(code_editor, Qt.Key_Control, delay=500)\n    args = blocker.args\n    assert args[0] == expected_output_path\n",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_goto_uri_message_box",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_goto.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that a message box is displayed when the shorthand issue notation is\n    used (gh-123) indicating the user that the file is not under a repository\n    \"\"\"\n_, code_editor = editorbot\ncode_editor.filename = TEMPFILE_PATH\ncode_editor._last_hover_pattern_key = 'issue'\ndef interact():\n    msgbox = code_editor.findChild(QMessageBox)\n    assert msgbox\n    qtbot.keyClick(msgbox, Qt.Key_Return)\ntimer = QTimer()\ntimer.setSingleShot(True)\ntimer.setInterval(500)\ntimer.timeout.connect(interact)\ntimer.start()\ncode_editor.go_to_uri_from_cursor('gh-123')\ncode_editor.filename = None\ncode_editor._last_hover_pattern_key = None\ncode_editor._last_hover_pattern_text = None\n",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "interact",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_goto.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "msgbox = code_editor.findChild(QMessageBox)\nassert msgbox\nqtbot.keyClick(msgbox, Qt.Key_Return)\n",
        "CUT_1": "heading = _('Error message:')\nmsgbox = QMessageBox(QMessageBox.Critical, _('Restore'), _(\n    '<b>{}</b><br><br>{}<br>{}').format(text, heading, error), parent=self)\nmsgbox.exec_()\n",
        "CUT_2": "heading = _('Error message:')\nmsgbox = QMessageBox(QMessageBox.Critical, _('Restore'), _(\n    '<b>{}</b><br><br>{}<br>{}').format(text, heading, error), parent=self)\nmsgbox.exec_()\n",
        "CUT_3": "\"\"\"Show message to restart Spyder since the DPI scale changed.\"\"\"\nself.screen.logicalDotsPerInchChanged.disconnect(self.show_dpi_change_message)\nif self.current_dpi == dpi:\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n    return\nif not self.show_dpi_message:\n    return\nwindow = self.window().windowHandle()\nif window.windowState() == Qt.WindowFullScreen and sys.platform == 'darwin':\n    return\ndismiss_box = QCheckBox(_('Hide this message during the current session'))\nmsgbox = QMessageBox(self)\nmsgbox.setIcon(QMessageBox.Warning)\nmsgbox.setText(_(\n    \"A monitor scale change was detected. <br><br>We recommend restarting Spyder to ensure that it's properly displayed. If you don't want to do that, please be sure to activate the option<br><br><tt>Enable auto high DPI scaling</tt><br><br>in <tt>Preferences > General > Interface</tt>, in case Spyder is not displayed correctly.<br><br>Do you want to restart Spyder?\"\n    ))\nrestart_button = msgbox.addButton(_('Restart now'), QMessageBox.NoRole)\ndismiss_button = msgbox.addButton(_('Dismiss'), QMessageBox.NoRole)\nmsgbox.setCheckBox(dismiss_box)\nmsgbox.setDefaultButton(dismiss_button)\nmsgbox.exec_()\nif dismiss_box.isChecked():\n    self.show_dpi_message = False\nif msgbox.clickedButton() == restart_button:\n    CONF.set('main', 'normal_screen_resolution', False)\n    CONF.set('main', 'high_dpi_scaling', True)\n    CONF.set('main', 'high_dpi_custom_scale_factor', False)\n    self.restart()\nelse:\n    self.current_dpi = dpi\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n",
        "CUT_4": "\"\"\"Show message to restart Spyder since the DPI scale changed.\"\"\"\nself.screen.logicalDotsPerInchChanged.disconnect(self.show_dpi_change_message)\nif self.current_dpi == dpi:\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n    return\nif not self.show_dpi_message:\n    return\nwindow = self.window().windowHandle()\nif window.windowState() == Qt.WindowFullScreen and sys.platform == 'darwin':\n    return\ndismiss_box = QCheckBox(_('Hide this message during the current session'))\nmsgbox = QMessageBox(self)\nmsgbox.setIcon(QMessageBox.Warning)\nmsgbox.setText(_(\n    \"A monitor scale change was detected. <br><br>We recommend restarting Spyder to ensure that it's properly displayed. If you don't want to do that, please be sure to activate the option<br><br><tt>Enable auto high DPI scaling</tt><br><br>in <tt>Preferences > General > Interface</tt>, in case Spyder is not displayed correctly.<br><br>Do you want to restart Spyder?\"\n    ))\nrestart_button = msgbox.addButton(_('Restart now'), QMessageBox.NoRole)\ndismiss_button = msgbox.addButton(_('Dismiss'), QMessageBox.NoRole)\nmsgbox.setCheckBox(dismiss_box)\nmsgbox.setDefaultButton(dismiss_button)\nmsgbox.exec_()\nif dismiss_box.isChecked():\n    self.show_dpi_message = False\nif msgbox.clickedButton() == restart_button:\n    CONF.set('main', 'normal_screen_resolution', False)\n    CONF.set('main', 'high_dpi_scaling', True)\n    CONF.set('main', 'high_dpi_custom_scale_factor', False)\n    self.restart()\nelse:\n    self.current_dpi = dpi\n    self.screen.logicalDotsPerInchChanged.connect(self.show_dpi_change_message)\n",
        "CUT_5": "\"\"\"Revert file from disk.\"\"\"\nindex = self.get_stack_index()\nfinfo = self.data[index]\nlogger.debug('Reverting {}'.format(finfo.filename))\nfilename = finfo.filename\nif finfo.editor.document().isModified():\n    self.msgbox = QMessageBox(QMessageBox.Warning, self.title, _(\n        'All changes to <b>%s</b> will be lost.<br>Do you want to revert file from disk?'\n        ) % osp.basename(filename), QMessageBox.Yes | QMessageBox.No, self)\n    answer = self.msgbox.exec_()\n    if answer != QMessageBox.Yes:\n        return\nself.reload(index)\n"
    },
    {
        "functionName": "test_pattern_highlight_regression",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_goto.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Fix regression on spyder-ide/spyder#11376.\"\"\"\n_, code_editor = editorbot\ncode_editor.show()\ncode_editor.set_text(\"'''\\ngl-\")\nqtbot.wait(500)\ncode_editor.moveCursor(QTextCursor.End)\nqtbot.wait(500)\nqtbot.keyClick(code_editor, Qt.Key_1)\nqtbot.wait(1000)\n",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "super().__init__(code_editor)\nself._editor = code_editor\nself._left_padding = 6\nself._right_padding = 3\n"
    },
    {
        "functionName": "test_hide_calltip",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_hints_and_calltips.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that calltips are hidden when a matching ')' is found.\"\"\"\ncode_editor, _ = lsp_codeeditor\ncode_editor.show()\ncode_editor.raise_()\ncode_editor.setFocus()\ntext = \"\"\"a = \"sometext {}\"\nprint(a.format\"\"\"\ncode_editor.set_text(text)\ncode_editor.go_to_line(2)\ncode_editor.move_cursor(14)\ncalltip = code_editor.calltip_widget\nassert not calltip.isVisible()\nwith qtbot.waitSignal(code_editor.sig_signature_invoked, timeout=30000):\n    qtbot.keyClicks(code_editor, '(', delay=3000)\nqtbot.waitUntil(lambda : calltip.isVisible(), timeout=3000)\nqtbot.keyClicks(code_editor, '\"hello\"')\nqtbot.keyClicks(code_editor, ')', delay=330)\nassert calltip.isVisible()\nqtbot.keyClicks(code_editor, ')', delay=330)\nqtbot.waitUntil(lambda : not calltip.isVisible(), timeout=3000)\nqtbot.keyClick(code_editor, Qt.Key_Enter, delay=330)\nassert not calltip.isVisible()\npytest.mark.slowpytest.mark.secondpytest.mark.skipif(sys.platform == 'darwin' and PY2, reason=\n    'Fails on Mac and Python 2')",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "super().__init__(code_editor)\nself._editor = code_editor\nself._left_padding = 6\nself._right_padding = 3\n"
    },
    {
        "functionName": "test_get_calltips",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_hints_and_calltips.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the editor is returning hints.\"\"\"\ncode_editor, _ = lsp_codeeditor\nparam, expected_output_text = params\ncode_editor.set_text(param)\ncode_editor.moveCursor(QTextCursor.End)\ncode_editor.calltip_widget.hide()\nbracket_extension = code_editor.editor_extensions.get(CloseBracketsExtension)\nwith qtbot.waitSignal(code_editor.sig_signature_invoked, timeout=30000\n    ) as blocker:\n    qtbot.keyPress(code_editor, Qt.Key_ParenLeft, delay=1000)\n    qtbot.wait(2000)\n    args = blocker.args\n    print('args:', [args])\n    output_text = args[0]['signatures']['label']\n    assert expected_output_text in output_text\n    code_editor.calltip_widget.hide()\nbracket_extension.enable = False\nwith qtbot.waitSignal(code_editor.sig_signature_invoked, timeout=30000\n    ) as blocker:\n    qtbot.keyPress(code_editor, Qt.Key_ParenLeft, delay=1000)\n    qtbot.wait(2000)\n    args = blocker.args\n    print('args:', [args])\n    output_text = args[0]['signatures']['label']\n    assert expected_output_text in output_text\n    code_editor.calltip_widget.hide()\nbracket_extension.enable = True\npytest.mark.slowpytest.mark.secondpytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on Win')pytest.mark.parametrize('params', [('dict', 'dict'), ('type', 'type'), (\n    '\"\".format', '-> str'), (TEST_TEXT, TEST_SIG)])",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_get_hints",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_hints_and_calltips.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the editor is returning hover hints.\"\"\"\ncode_editor, _ = lsp_codeeditor\nparam, expected_output_text = params\ncode_editor.set_text(param)\ncode_editor.moveCursor(QTextCursor.End)\nqtbot.keyPress(code_editor, Qt.Key_Left)\nx, y = code_editor.get_coordinates('cursor')\npoint = code_editor.calculate_real_position(QPoint(x, y))\nwith qtbot.waitSignal(code_editor.sig_display_object_info, timeout=30000\n    ) as blocker:\n    qtbot.mouseMove(code_editor, point)\n    qtbot.mouseClick(code_editor, Qt.LeftButton, pos=point)\n    qtbot.waitUntil(lambda : code_editor.tooltip_widget.isVisible(),\n        timeout=10000)\n    args = blocker.args\n    print('args:', [args])\n    output_text = args[0]\n    assert expected_output_text in output_text\n    code_editor.tooltip_widget.hide()\n    captured = capsys.readouterr()\n    assert captured.err == ''\npytest.mark.slowpytest.mark.secondpytest.mark.skipif(sys.platform == 'darwin', reason='Fails on Mac')pytest.mark.parametrize('params', [('\"\".format', '-> str'), ('import math',\n    'module'), (TEST_TEXT, TEST_DOCSTRING)])",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_get_hints_not_triggered",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_hints_and_calltips.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the editor is not returning hover hints for empty docs.\"\"\"\ncode_editor, _ = lsp_codeeditor\ncode_editor.set_text(\"\"\"def test():\n    pass\n\ntest\"\"\")\ncode_editor.moveCursor(QTextCursor.End)\nqtbot.keyPress(code_editor, Qt.Key_Left)\nx, y = code_editor.get_coordinates('cursor')\npoint = code_editor.calculate_real_position(QPoint(x, y))\nwith qtbot.waitSignal(code_editor.sig_display_object_info, timeout=30000):\n    qtbot.mouseMove(code_editor, point)\n    qtbot.mouseClick(code_editor, Qt.LeftButton, pos=point)\n    qtbot.wait(1000)\n    assert not code_editor.tooltip_widget.isVisible()\npytest.mark.slowpytest.mark.secondpytest.mark.skipif(sys.platform == 'darwin', reason='Fails on Mac')",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_ignore_warnings",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_warnings.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the editor is ignoring some warnings.\"\"\"\neditor, manager = lsp_codeeditor\neditor.set_text(TEXT)\nCONF.set('lsp-server', 'pydocstyle/ignore', 'D100')\nCONF.set('lsp-server', 'pycodestyle/ignore', 'E261')\nmanager.update_configuration()\nqtbot.wait(2000)\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_change()\nqtbot.wait(2000)\nwarnings = editor.get_current_warnings()\nexpected = [['D103: Missing docstring in public function', 1], [\n    'W293 blank line contains whitespace', 2], [\"undefined name 's'\", 5], [\n    \"undefined name 'undefined_function'\", 7], [\n    'W292 no newline at end of file', 7], [\n    'E305 expected 2 blank lines after class or function definition, found 0',\n    7]]\nCONF.set('lsp-server', 'pydocstyle/ignore', '')\nCONF.set('lsp-server', 'pycodestyle/ignore', '')\nmanager.update_configuration()\nqtbot.wait(2000)\nassert warnings == expected\npytest.mark.slowpytest.mark.second",
        "CUT_1": "CONF.set('lsp-server', 'pycodestyle', True)\nCONF.set('lsp-server', 'pydocstyle', True)\nCONF.set('lsp-server', 'stdio', is_stdio)\nos.environ['SPY_TEST_USE_INTROSPECTION'] = 'True'\nmanager = LanguageServerPlugin(parent=MainWindowMock())\neditor = manager.main.editor\nwith qtbot_module.waitSignal(editor.sig_lsp_initialized, timeout=30000):\n    manager.start_client('python')\ncapabilities = editor.completion_capabilities['python']\nassert all([(option in SERVER_CAPABILITES) for option in capabilities.keys()])\ndef teardown():\n    manager.shutdown()\n    os.environ['SPY_TEST_USE_INTROSPECTION'] = 'False'\n    CONF.set('lsp-server', 'pycodestyle', False)\n    CONF.set('lsp-server', 'pydocstyle', False)\nrequest.addfinalizer(teardown)\nreturn manager\npytest.fixture(scope='module')",
        "CUT_2": "@pytest.fixture(scope='module')\ndef wrapper(qtbot_module, request):\n    CONF.set('lsp-server', 'pycodestyle', True)\n    CONF.set('lsp-server', 'pydocstyle', True)\n    CONF.set('lsp-server', 'stdio', is_stdio)\n    os.environ['SPY_TEST_USE_INTROSPECTION'] = 'True'\n    manager = LanguageServerPlugin(parent=MainWindowMock())\n    editor = manager.main.editor\n    with qtbot_module.waitSignal(editor.sig_lsp_initialized, timeout=30000):\n        manager.start_client('python')\n    capabilities = editor.completion_capabilities['python']\n    assert all([(option in SERVER_CAPABILITES) for option in capabilities.\n        keys()])\n\n    def teardown():\n        manager.shutdown()\n        os.environ['SPY_TEST_USE_INTROSPECTION'] = 'False'\n        CONF.set('lsp-server', 'pycodestyle', False)\n        CONF.set('lsp-server', 'pydocstyle', False)\n    request.addfinalizer(teardown)\n    return manager\nreturn wrapper\n",
        "CUT_3": "manager.shutdown()\nos.environ['SPY_TEST_USE_INTROSPECTION'] = 'False'\nCONF.set('lsp-server', 'pycodestyle', False)\nCONF.set('lsp-server', 'pydocstyle', False)\n",
        "CUT_4": "CONF.set('lsp-server', 'pycodestyle', True)\nCONF.set('lsp-server', 'pydocstyle', True)\nCONF.set('lsp-server', 'stdio', False)\nCONF.set('lsp-server', 'code_snippets', False)\nos.environ['SPY_TEST_USE_INTROSPECTION'] = 'True'\nmain = MainWindowMock()\ncompletions = CompletionManager(main, ['lsp'])\ncompletions.start()\nwith qtbot_module.waitSignal(main.editor.sig_lsp_initialized, timeout=30000):\n    completions.start_client('python')\ncompletions.language_status['python']['lsp'] = True\ndef teardown():\n    completions.shutdown()\n    os.environ['SPY_TEST_USE_INTROSPECTION'] = 'False'\n    CONF.set('lsp-server', 'pycodestyle', False)\n    CONF.set('lsp-server', 'pydocstyle', False)\nrequest.addfinalizer(teardown)\nreturn completions\npytest.fixture(scope='function')",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_adding_warnings",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_warnings.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that warnings are saved in the editor blocks.\"\"\"\neditor, _ = lsp_codeeditor\neditor.set_text(TEXT)\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_change()\nqtbot.wait(2000)\nblock = editor.textCursor().block()\nline_count = editor.document().blockCount()\nwarnings = []\nfor i in range(line_count):\n    data = block.userData()\n    if data:\n        for analysis in data.code_analysis:\n            warnings.append((i + 1, analysis[-1]))\n    block = block.next()\nexpected_warnings = {(1): ['D100', 'D103'], (2): ['W293'], (3): ['E261'], (\n    5): ['undefined name'], (7): ['undefined name', 'W292', 'E305']}\nfor i, warning in warnings:\n    assert any([(expected in warning) for expected in expected_warnings[i]])\npytest.mark.slowpytest.mark.second",
        "CUT_1": "\"\"\"\n        Get all warnings for the current editor and return\n        a list with the message and line number.\n        \"\"\"\nblock = self.document().firstBlock()\nline_count = self.document().blockCount()\nwarnings = []\nwhile True:\n    data = block.userData()\n    if data and data.code_analysis:\n        for warning in data.code_analysis:\n            warnings.append([warning[-1], block.blockNumber() + 1])\n    if block.blockNumber() + 1 == line_count:\n        break\n    block = block.next()\nreturn warnings\n",
        "CUT_2": "\"\"\"\n        Get all warnings for the current editor and return\n        a list with the message and line number.\n        \"\"\"\nblock = self.document().firstBlock()\nline_count = self.document().blockCount()\nwarnings = []\nwhile True:\n    data = block.userData()\n    if data and data.code_analysis:\n        for warning in data.code_analysis:\n            warnings.append([warning[-1], block.blockNumber() + 1])\n    if block.blockNumber() + 1 == line_count:\n        break\n    block = block.next()\nreturn warnings\n",
        "CUT_3": "\"\"\"\n        Go to next code warning message and return new cursor position.\n        \"\"\"\nblock = self.textCursor().block()\nline_count = self.document().blockCount()\nfor _ in range(line_count):\n    line_number = block.blockNumber() + 1\n    if line_number < line_count:\n        block = block.next()\n    else:\n        block = self.document().firstBlock()\n    data = block.userData()\n    if data and data.code_analysis:\n        line_number = block.blockNumber() + 1\n        self.go_to_line(line_number)\n        self.show_code_analysis_results(line_number, data)\n        return self.get_position('cursor')\n",
        "CUT_4": "\"\"\"\n        Go to next code warning message and return new cursor position.\n        \"\"\"\nblock = self.textCursor().block()\nline_count = self.document().blockCount()\nfor _ in range(line_count):\n    line_number = block.blockNumber() + 1\n    if line_number < line_count:\n        block = block.next()\n    else:\n        block = self.document().firstBlock()\n    data = block.userData()\n    if data and data.code_analysis:\n        line_number = block.blockNumber() + 1\n        self.go_to_line(line_number)\n        self.show_code_analysis_results(line_number, data)\n        return self.get_position('cursor')\n",
        "CUT_5": "\"\"\"\n        Go to previous code warning message and return new cursor position.\n        \"\"\"\nblock = self.textCursor().block()\nline_count = self.document().blockCount()\nfor _ in range(line_count):\n    line_number = block.blockNumber() + 1\n    if line_number > 1:\n        block = block.previous()\n    else:\n        block = self.document().lastBlock()\n    data = block.userData()\n    if data and data.code_analysis:\n        line_number = block.blockNumber() + 1\n        self.go_to_line(line_number)\n        self.show_code_analysis_results(line_number, data)\n        return self.get_position('cursor')\n"
    },
    {
        "functionName": "test_move_warnings",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_warnings.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that moving to next/previous warnings is working.\"\"\"\neditor, _ = lsp_codeeditor\neditor.set_text(TEXT)\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_change()\nqtbot.wait(2000)\neditor.go_to_next_warning()\nassert 2 == editor.get_cursor_line_number()\neditor.go_to_next_warning()\nassert 3 == editor.get_cursor_line_number()\neditor.go_to_previous_warning()\nassert 2 == editor.get_cursor_line_number()\neditor.go_to_line(7)\neditor.go_to_next_warning()\nassert 1 == editor.get_cursor_line_number()\neditor.go_to_previous_warning()\nassert 7 == editor.get_cursor_line_number()\npytest.mark.slowpytest.mark.second",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "return self._editor.get_cursor_line_number()\n"
    },
    {
        "functionName": "test_get_warnings",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_warnings.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the editor is returning the right list of warnings.\"\"\"\neditor, _ = lsp_codeeditor\neditor.set_text(TEXT)\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_change()\nqtbot.wait(2000)\nwarnings = editor.get_current_warnings()\nexpected = [['D100: Missing docstring in public module', 1], [\n    'D103: Missing docstring in public function', 1], [\n    'W293 blank line contains whitespace', 2], [\n    'E261 at least two spaces before inline comment', 3], [\n    \"undefined name 's'\", 5], [\"undefined name 'undefined_function'\", 7], [\n    'W292 no newline at end of file', 7], [\n    'E305 expected 2 blank lines after class or function definition, found 0',\n    7]]\nassert warnings == expected\npytest.mark.slowpytest.mark.second",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.toggle_comment()\nSlot()"
    },
    {
        "functionName": "test_update_warnings_after_delete_line",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_warnings.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that code style warnings are correctly updated after deleting a line\n    in the Editor.\n\n    Regression test for spyder-ide/spyder#9299.\n    \"\"\"\neditor, _ = lsp_codeeditor\neditor.set_text(TEXT)\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_change()\nqtbot.wait(2000)\neditor.go_to_line(2)\neditor.delete_line()\nqtbot.waitSignal(editor.lsp_response_signal, timeout=30000)\nexpected = [['D100: Missing docstring in public module', 1], [\n    'D103: Missing docstring in public function', 1], [\n    'E261 at least two spaces before inline comment', 2], [\n    \"undefined name 's'\", 4], [\"undefined name 'undefined_function'\", 6], [\n    'W292 no newline at end of file', 6], [\n    'E305 expected 2 blank lines after class or function definition, found 0',\n    6]]\nassert editor.get_current_warnings() == expected\npytest.mark.slowpytest.mark.second",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"CodeEditor instance with LSP services activated.\"\"\"\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.sig_perform_completion_request.connect(lsp_plugin.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\nlsp_plugin.register_file('python', 'test.py', editor)\ncapabilities = lsp_plugin.main.editor.completion_capabilities['python']\neditor.start_completion_services()\neditor.register_completion_capabilities(capabilities)\nwith qtbot_module.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_open()\ndef teardown():\n    editor.completion_widget.hide()\n    editor.tooltip_widget.hide()\n    editor.hide()\n    sys_stream = capsys.readouterr()\n    sys_err = sys_stream.err\n    if PY2:\n        sys_err = to_text_string(sys_err).encode('utf-8')\n    assert sys_err == ''\nrequest.addfinalizer(teardown)\nlsp_plugin = lsp_plugin.get_client('lsp')\neditor.show()\nreturn editor, lsp_plugin\npytest.fixture"
    },
    {
        "functionName": "test_update_warnings_after_closequotes",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_warnings.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that code errors are correctly updated after activating closequotes\n    in the Editor.\n\n    Regression test for spyder-ide/spyder#9323.\n    \"\"\"\neditor, _ = lsp_codeeditor\neditor.textCursor().insertText(\"print('test)\\n\")\nexpected = [['EOL while scanning string literal', 1]]\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_change()\nqtbot.wait(2000)\nassert editor.get_current_warnings() == expected\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.move_cursor(-2)\n    qtbot.keyPress(editor, Qt.Key_Apostrophe)\n    assert editor.toPlainText() == \"print('test')\\n\"\nqtbot.wait(2000)\nexpected = [['D100: Missing docstring in public module', 1]]\nassert editor.get_current_warnings() == expected\npytest.mark.slowpytest.mark.second",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"CodeEditor instance with LSP services activated.\"\"\"\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.sig_perform_completion_request.connect(lsp_plugin.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\nlsp_plugin.register_file('python', 'test.py', editor)\ncapabilities = lsp_plugin.main.editor.completion_capabilities['python']\neditor.start_completion_services()\neditor.register_completion_capabilities(capabilities)\nwith qtbot_module.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_open()\ndef teardown():\n    editor.completion_widget.hide()\n    editor.tooltip_widget.hide()\n    editor.hide()\n    sys_stream = capsys.readouterr()\n    sys_err = sys_stream.err\n    if PY2:\n        sys_err = to_text_string(sys_err).encode('utf-8')\n    assert sys_err == ''\nrequest.addfinalizer(teardown)\nlsp_plugin = lsp_plugin.get_client('lsp')\neditor.show()\nreturn editor, lsp_plugin\npytest.fixture",
        "CUT_4": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_update_warnings_after_closebrackets",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_warnings.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that code errors are correctly updated after activating closebrackets\n    in the Editor.\n\n    Regression test for spyder-ide/spyder#9323.\n    \"\"\"\neditor, _ = lsp_codeeditor\neditor.textCursor().insertText(\"print('test'\\n\")\nexpected = [['unexpected EOF while parsing', 1], [\n    'E901 TokenError: EOF in multi-line statement', 2]]\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_change()\nqtbot.wait(2000)\nassert editor.get_current_warnings() == expected\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.move_cursor(-1)\n    qtbot.keyPress(editor, Qt.Key_ParenRight)\n    assert editor.toPlainText() == \"print('test')\\n\"\nqtbot.wait(2000)\nexpected = [['D100: Missing docstring in public module', 1]]\nassert editor.get_current_warnings() == expected\npytest.mark.slowpytest.mark.second",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"CodeEditor instance with LSP services activated.\"\"\"\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.sig_perform_completion_request.connect(lsp_plugin.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\nlsp_plugin.register_file('python', 'test.py', editor)\ncapabilities = lsp_plugin.main.editor.completion_capabilities['python']\neditor.start_completion_services()\neditor.register_completion_capabilities(capabilities)\nwith qtbot_module.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_open()\ndef teardown():\n    editor.completion_widget.hide()\n    editor.tooltip_widget.hide()\n    editor.hide()\n    sys_stream = capsys.readouterr()\n    sys_err = sys_stream.err\n    if PY2:\n        sys_err = to_text_string(sys_err).encode('utf-8')\n    assert sys_err == ''\nrequest.addfinalizer(teardown)\nlsp_plugin = lsp_plugin.get_client('lsp')\neditor.show()\nreturn editor, lsp_plugin\npytest.fixture",
        "CUT_4": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "get_tree_elements",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Get elements present in the Outline tree widget.\"\"\"\nroot_item = treewidget.get_top_level_items()[0]\nroot_ref = root_item.ref\nfilename = osp.basename(root_ref.name)\nroot_tree = {filename: []}\nstack = [(root_tree[filename], node) for node in root_ref.children]\nwhile len(stack) > 0:\n    parent_tree, node = stack.pop(0)\n    this_tree = {node.name: []}\n    parent_tree.append(this_tree)\n    this_stack = [(this_tree[node.name], child) for child in node.children]\n    stack = this_stack + stack\nreturn root_tree\n",
        "CUT_1": "self.id = node.id\nself.index = node.index\nself.path = node.path\nself.children = node.children\nself.status = node.status\nself.node = node.node\nself.parent = node.parent\nself.node.update_info(self.name, self.kind, self.position[0] + 1)\nself.node.ref = self\nfor child in self.children:\n    child.parent = self\nif self.parent is not None:\n    self.parent.replace_node(self.index, self)\n",
        "CUT_2": "self.id = node.id\nself.index = node.index\nself.path = node.path\nself.children = node.children\nself.status = node.status\nself.node = node.node\nself.parent = node.parent\nself.node.update_info(self.name, self.kind, self.position[0] + 1)\nself.node.ref = self\nfor child in self.children:\n    child.parent = self\nif self.parent is not None:\n    self.parent.replace_node(self.index, self)\n",
        "CUT_3": "from_keyword = False\nif isinstance(node, tree_nodes.Keyword):\n    from_keyword = True\n    if node.value in {'if', 'elif', 'with', 'while'}:\n        node, end_line = __handle_skip(stack, 2)\n    elif node.value in {'except'}:\n        first_node = stack[0]\n        if isinstance(first_node, tree_nodes.Operator):\n            node, end_line = __handle_skip(stack, 1)\n        else:\n            node, end_line = __handle_skip(stack, 2)\n    elif node.value in {'for'}:\n        node, end_line = __handle_skip(stack, 4)\n    elif node.value in {'else'}:\n        node, end_line = __handle_skip(stack, 1)\nreturn end_line, from_keyword, node, stack\n",
        "CUT_4": "self.children[index] = node\n",
        "CUT_5": "self.children[index] = node\n"
    },
    {
        "functionName": "test_files",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create and save some python codes and text in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\nfilename1 = osp.join(tmpdir.strpath, 'foo1.py')\nwith open(filename1, 'w') as f:\n    f.write('# -*- coding: utf-8 -*-\\ndef foo:\\n    print(Hello World!)\\n')\nfilename2 = osp.join(tmpdir.strpath, 'text1.txt')\nwith open(filename2, 'w') as f:\n    f.write('This is a simple text file for\\ntesting the Outline Explorer.\\n')\nfilename3 = osp.join(tmpdir.strpath, 'foo2.py')\nwith open(filename3, 'w') as f:\n    f.write('# -*- coding: utf-8 -*-\\n# ---- a comment\\n')\nreturn [filename1, filename2, filename3]\npytest.fixture(scope='module')",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_3": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_4": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_5": "\"\"\"Create a new Python script\"\"\"\ntext = os.linesep.join(['# -*- coding: utf-8 -*-', '', ''])\ntry:\n    encoding.write(to_text_string(text), fname, 'utf-8')\nexcept EnvironmentError as error:\n    QMessageBox.critical(_('Save Error'), _(\n        \"<b>Unable to save file '%s'</b><br><br>Error message:<br>%s\") % (\n        osp.basename(fname), str(error)))\n"
    },
    {
        "functionName": "outlineexplorer",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up an OutlineExplorerWidget.\"\"\"\noutlineexplorer = OutlineExplorerWidget(show_fullpath=False, show_all_files\n    =True, group_cells=True, show_comments=True, sort_files_alphabetically=\n    False, display_variables=True)\noutlineexplorer.setFixedSize(400, 350)\nqtbot.addWidget(outlineexplorer)\noutlineexplorer.show()\nreturn outlineexplorer\npytest.fixture",
        "CUT_1": "self.outlineexplorer = outlineexplorer\n",
        "CUT_2": "self.outlineexplorer = outlineexplorer\n",
        "CUT_3": "self.outlineexplorer = outlineexplorer\nfor editorstack in self.editorstacks:\n    editorstack.set_outlineexplorer(self.outlineexplorer.explorer)\nself.outlineexplorer.explorer.edit_goto.connect(lambda filenames, goto,\n    word: self.load(filenames=filenames, goto=goto, word=word, editorwindow\n    =self))\nself.outlineexplorer.explorer.edit.connect(lambda filenames: self.load(\n    filenames=filenames, editorwindow=self))\n",
        "CUT_4": "self.outlineexplorer = outlineexplorer\nfor editorstack in self.editorstacks:\n    editorstack.set_outlineexplorer(self.outlineexplorer.explorer)\nself.outlineexplorer.explorer.edit_goto.connect(lambda filenames, goto,\n    word: self.load(filenames=filenames, goto=goto, word=word, editorwindow\n    =self))\nself.outlineexplorer.explorer.edit.connect(lambda filenames: self.load(\n    filenames=filenames, editorwindow=self))\n",
        "CUT_5": "SpyderPluginWidget.__init__(self, parent)\nshow_fullpath = self.get_option('show_fullpath')\nshow_all_files = self.get_option('show_all_files')\ngroup_cells = self.get_option('group_cells')\nshow_comments = self.get_option('show_comments')\nsort_files_alphabetically = self.get_option('sort_files_alphabetically')\nfollow_cursor = self.get_option('follow_cursor')\ndisplay_variables = self.get_option('display_variables')\nself.explorer = OutlineExplorerWidget(self, show_fullpath=show_fullpath,\n    show_all_files=show_all_files, group_cells=group_cells, show_comments=\n    show_comments, sort_files_alphabetically=sort_files_alphabetically,\n    display_variables=display_variables, follow_cursor=follow_cursor,\n    options_button=self.options_button)\nself.explorer.sig_update_configuration.connect(self.\n    trigger_completion_config_update)\nlayout = QVBoxLayout()\nlayout.addWidget(self.explorer)\nself.setLayout(layout)\nself.explorer.treewidget.header().hide()\nself.load_config()\n"
    },
    {
        "functionName": "lsp_codeeditor_outline",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor, _ = lsp_codeeditor\neditor.oe_proxy = OutlineExplorerProxyEditor(editor, editor.filename)\noutlineexplorer.register_editor(editor.oe_proxy)\noutlineexplorer.set_current_editor(editor.oe_proxy, update=False, clear=False)\nreturn editor, outlineexplorer\npytest.fixture",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "self.outlineexplorer = outlineexplorer\n",
        "CUT_4": "self.outlineexplorer = outlineexplorer\n",
        "CUT_5": "if clear:\n    self.remove_editor(editor)\nif editor is not None:\n    self.treewidget.set_current_editor(editor, update)\n"
    },
    {
        "functionName": "editorstack",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "def _create_editorstack(files):\n    editorstack = editor.EditorStack(None, [])\n    editorstack.set_find_widget(Mock())\n    editorstack.set_io_actions(Mock(), Mock(), Mock(), Mock())\n    editorstack.analysis_timer = Mock()\n    editorstack.save_dialog_on_tests = True\n    editorstack.set_outlineexplorer(outlineexplorer)\n    qtbot.addWidget(editorstack)\n    editorstack.show()\n    for index, file in enumerate(files):\n        focus = index == 0\n        editorstack.load(file, set_current=focus)\n    return editorstack\nreturn _create_editorstack\npytest.fixture",
        "CUT_1": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "_create_editorstack",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editorstack = editor.EditorStack(None, [])\neditorstack.set_find_widget(Mock())\neditorstack.set_io_actions(Mock(), Mock(), Mock(), Mock())\neditorstack.analysis_timer = Mock()\neditorstack.save_dialog_on_tests = True\neditorstack.set_outlineexplorer(outlineexplorer)\nqtbot.addWidget(editorstack)\neditorstack.show()\nfor index, file in enumerate(files):\n    focus = index == 0\n    editorstack.load(file, set_current=focus)\nreturn editorstack\n",
        "CUT_1": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "test_load_files",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the content of the outline explorer is updated correctly\n    after a file is loaded in the editor.\n    \"\"\"\neditorstack = editorstack([])\ntreewidget = outlineexplorer.treewidget\nexpected_result = [['foo1.py'], ['foo1.py', 'text1.txt'], ['foo1.py',\n    'text1.txt', 'foo2.py']]\nfor index, file in enumerate(test_files):\n    editorstack.load(file)\n    assert editorstack.get_current_filename() == file\n    editorstack.get_stack_index() == index\n    results = [item.text(0) for item in treewidget.get_visible_items()]\n    assert results == expected_result[index]\n    assert editorstack.get_stack_index() == index\n",
        "CUT_1": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_5": "for editorstack in self.editorstacks:\n    if str(id(editorstack)) != editorstack_id_str:\n        editorstack.blockSignals(True)\n        index = editorstack.get_index_from_filename(filename)\n        editorstack.close_file(index, force=True)\n        editorstack.blockSignals(False)\nSlot(str, str)"
    },
    {
        "functionName": "test_close_editor",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the content of the outline explorer is empty after the\n    editorstack has been closed.\n\n    Regression test for spyder-ide/spyder#7798.\n    \"\"\"\neditorstack = editorstack(test_files)\ntreewidget = outlineexplorer.treewidget\nassert treewidget.get_visible_items()\neditorstack.close()\nassert not treewidget.get_visible_items()\n",
        "CUT_1": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_2": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "test_close_a_file",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the content of the outline explorer is updated corrrectly\n    after a file has been closed in the editorstack.\n\n    Regression test for spyder-ide/spyder#7798.\n    \"\"\"\neditorstack = editorstack(test_files)\ntreewidget = outlineexplorer.treewidget\neditorstack.close_file(index=1)\nresults = [item.text(0) for item in treewidget.get_visible_items()]\nassert results == ['foo1.py', 'foo2.py']\n",
        "CUT_1": "for editorstack in self.editorstacks:\n    if str(id(editorstack)) != editorstack_id_str:\n        editorstack.blockSignals(True)\n        index = editorstack.get_index_from_filename(filename)\n        editorstack.close_file(index, force=True)\n        editorstack.blockSignals(False)\nSlot(str, str)",
        "CUT_2": "for editorstack in self.editorstacks:\n    if str(id(editorstack)) != editorstack_id_str:\n        editorstack.blockSignals(True)\n        index = editorstack.get_index_from_filename(filename)\n        editorstack.close_file(index, force=True)\n        editorstack.blockSignals(False)\nSlot(str, str)",
        "CUT_3": "for editorstack in self.editorstacks:\n    if str(id(editorstack)) != editorstack_id_str:\n        editorstack.blockSignals(True)\n        index = editorstack.get_index_from_filename(filename)\n        editorstack.close_file(index, force=True)\n        editorstack.blockSignals(False)\nSlot(str, str)",
        "CUT_4": "for editorstack in self.editorstacks:\n    if str(id(editorstack)) != editorstack_id_str:\n        editorstack.blockSignals(True)\n        index = editorstack.get_index_from_filename(filename)\n        editorstack.close_file(index, force=True)\n        editorstack.blockSignals(False)\nSlot(str, str)",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n"
    },
    {
        "functionName": "test_sort_file_alphabetically",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the option to sort the files in alphabetical order in the\n    outline explorer is working as expected.\n\n    This feature was introduced in spyder-ide/spyder#8015.\n    \"\"\"\neditorstack = editorstack(test_files)\ntreewidget = outlineexplorer.treewidget\nresults = [item.text(0) for item in treewidget.get_visible_items()]\nassert results == ['foo1.py', 'text1.txt', 'foo2.py']\ntreewidget.toggle_sort_files_alphabetically(True)\nresults = [item.text(0) for item in treewidget.get_visible_items()]\nassert results == ['foo1.py', 'foo2.py', 'text1.txt']\n",
        "CUT_1": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_2": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_3": "QWidget.__init__(self, parent)\nvlayout = QVBoxLayout()\nself.setLayout(vlayout)\nself.treewidget = FilteredDirView(self)\nself.treewidget.setup_view()\nself.treewidget.set_root_path(osp.dirname(osp.abspath(__file__)))\nself.treewidget.set_folder_names(['variableexplorer'])\nself.treewidget.setup_project_view()\nvlayout.addWidget(self.treewidget)\n",
        "CUT_4": "QWidget.__init__(self, parent)\nvlayout = QVBoxLayout()\nself.setLayout(vlayout)\nself.treewidget = FilteredDirView(self)\nself.treewidget.setup_view()\nself.treewidget.set_root_path(osp.dirname(osp.abspath(__file__)))\nself.treewidget.set_folder_names(['variableexplorer'])\nself.treewidget.setup_project_view()\nvlayout.addWidget(self.treewidget)\n",
        "CUT_5": "\"\"\"Register plugin in Spyder's main window\"\"\"\nipyconsole = self.main.ipyconsole\ntreewidget = self.fileexplorer.treewidget\nself.add_dockwidget()\nself.fileexplorer.sig_open_file.connect(self.main.open_file)\nself.register_widget_shortcuts(treewidget)\ntreewidget.sig_edit.connect(self.main.editor.load)\ntreewidget.sig_removed.connect(self.main.editor.removed)\ntreewidget.sig_removed_tree.connect(self.main.editor.removed_tree)\ntreewidget.sig_renamed.connect(self.main.editor.renamed)\ntreewidget.sig_renamed_tree.connect(self.main.editor.renamed_tree)\ntreewidget.sig_create_module.connect(self.main.editor.new)\ntreewidget.sig_new_file.connect(lambda t: self.main.editor.new(text=t))\ntreewidget.sig_open_interpreter.connect(ipyconsole.create_client_from_path)\ntreewidget.redirect_stdio.connect(self.main.redirect_internalshell_stdio)\ntreewidget.sig_run.connect(lambda fname: ipyconsole.run_script(fname, osp.\n    dirname(fname), '', False, False, False, True, False))\ntreewidget.sig_dir_opened.connect(self.sig_dir_opened)\n"
    },
    {
        "functionName": "test_sync_file_order",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the order of the files in the Outline Explorer is updated when\n    tabs are moved in the EditorStack.\n\n    This feature was introduced in spyder-ide/spyder#8015.\n    \"\"\"\neditorstack = editorstack(test_files)\ntreewidget = outlineexplorer.treewidget\nresults = [item.text(0) for item in treewidget.get_visible_items()]\nassert results == ['foo1.py', 'text1.txt', 'foo2.py']\neditorstack.tabs.tabBar().moveTab(0, 1)\nresults = [item.text(0) for item in treewidget.get_visible_items()]\nassert results == ['text1.txt', 'foo1.py', 'foo2.py']\n",
        "CUT_1": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_2": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nresults = editorstack.get_todo_results()\nstate = self.get_option('todo_list') and results is not None and len(results)\nif state is not None:\n    self.todo_list_action.setEnabled(state)\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nresults = editorstack.get_todo_results()\nstate = self.get_option('todo_list') and results is not None and len(results)\nif state is not None:\n    self.todo_list_action.setEnabled(state)\n",
        "CUT_5": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n"
    },
    {
        "functionName": "test_toggle_off_show_all_files",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that toggling off the option to show all files in the Outline Explorer\n    hide all root file items but the one corresponding to the currently\n    selected Editor and assert that the remaning root file item is\n    expanded correctly.\n    \"\"\"\neditorstack = editorstack(test_files)\ntreewidget = outlineexplorer.treewidget\nassert editorstack.get_stack_index() == 0\ntreewidget.toggle_show_all_files(False)\nqtbot.wait(500)\nresults = [item.text(0) for item in treewidget.get_visible_items()]\nassert results == ['foo1.py']\npytest.mark.skipif(not sys.platform == 'darwin', reason=\n    'Fails on Linux and Windows')",
        "CUT_1": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_2": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_3": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_4": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_5": "\"\"\"Register plugin in Spyder's main window\"\"\"\nipyconsole = self.main.ipyconsole\ntreewidget = self.fileexplorer.treewidget\nself.add_dockwidget()\nself.fileexplorer.sig_open_file.connect(self.main.open_file)\nself.register_widget_shortcuts(treewidget)\ntreewidget.sig_edit.connect(self.main.editor.load)\ntreewidget.sig_removed.connect(self.main.editor.removed)\ntreewidget.sig_removed_tree.connect(self.main.editor.removed_tree)\ntreewidget.sig_renamed.connect(self.main.editor.renamed)\ntreewidget.sig_renamed_tree.connect(self.main.editor.renamed_tree)\ntreewidget.sig_create_module.connect(self.main.editor.new)\ntreewidget.sig_new_file.connect(lambda t: self.main.editor.new(text=t))\ntreewidget.sig_open_interpreter.connect(ipyconsole.create_client_from_path)\ntreewidget.redirect_stdio.connect(self.main.redirect_internalshell_stdio)\ntreewidget.sig_run.connect(lambda fname: ipyconsole.run_script(fname, osp.\n    dirname(fname), '', False, False, False, True, False))\ntreewidget.sig_dir_opened.connect(self.sig_dir_opened)\n"
    },
    {
        "functionName": "test_single_file_sync",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the content of the Outline Explorer is updated correctly\n    when the current Editor in the Editorstack changes.\n    \"\"\"\neditorstack = editorstack(test_files)\ntreewidget = outlineexplorer.treewidget\ntreewidget.toggle_show_all_files(False)\nassert editorstack.get_stack_index() == 0\nwith qtbot.waitSignal(editorstack.editor_focus_changed):\n    editorstack.tabs.setCurrentIndex(2)\nresults = [item.text(0) for item in treewidget.get_visible_items()]\nassert results == ['foo2.py']\npytest.mark.skipif(sys.platform.startswith('linux'), reason='Fails on Linux')",
        "CUT_1": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "test_toggle_on_show_all_files",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that toggling back the option to show all files, after the\n    order of the files in the Editorstack was changed while it was in single\n    file mode, show all the root file items in the correct order.\n    \"\"\"\neditorstack = editorstack(test_files)\ntreewidget = outlineexplorer.treewidget\ntreewidget.toggle_show_all_files(False)\neditorstack.tabs.tabBar().moveTab(0, 1)\ntreewidget.toggle_show_all_files(True)\nresults = [item.text(0) for item in treewidget.get_visible_items()]\nassert results == ['text1.txt', 'foo1.py', 'foo2.py']\n",
        "CUT_1": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_2": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_3": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_4": "\"\"\"\n        Return outline explorer options\n        \"\"\"\nreturn dict(show_fullpath=self.treewidget.show_fullpath, show_all_files=\n    self.treewidget.show_all_files, group_cells=self.treewidget.group_cells,\n    display_variables=self.treewidget.display_variables, follow_cursor=self\n    .treewidget.follow_cursor, show_comments=self.treewidget.show_comments,\n    sort_files_alphabetically=self.treewidget.sort_files_alphabetically,\n    expanded_state=self.treewidget.get_expanded_state(), scrollbar_position\n    =self.treewidget.get_scrollbar_position(), visibility=self.isVisible())\n",
        "CUT_5": "QWidget.__init__(self, parent)\nvlayout = QVBoxLayout()\nself.setLayout(vlayout)\nself.treewidget = FilteredDirView(self)\nself.treewidget.setup_view()\nself.treewidget.set_root_path(osp.dirname(osp.abspath(__file__)))\nself.treewidget.set_folder_names(['variableexplorer'])\nself.treewidget.setup_project_view()\nvlayout.addWidget(self.treewidget)\n"
    },
    {
        "functionName": "test_editor_outlineexplorer",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests that the outline explorer reacts to editor changes.\"\"\"\ncode_editor, outlineexplorer = lsp_codeeditor_outline\ntreewidget = outlineexplorer.treewidget\ncase_info = CASES['text']\nfilename = case_info['file']\ntree_file = case_info['tree']\nwith open(filename, 'r') as f:\n    lines = f.read()\nwith open(tree_file, 'r') as f:\n    trees = json.load(f)\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(False)\ncode_editor.set_text('')\ncode_editor.go_to_line(1)\ncode_editor.set_text(lines)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.request_symbols()\ntree = trees[0]\nroot_tree = get_tree_elements(treewidget)\nassert root_tree == tree\ncode_editor.go_to_line(14)\ncursor = code_editor.textCursor()\nstart = code_editor.get_position_line_number(13, -1)\nend = code_editor.get_position_line_number(17, 0)\ncursor.setPosition(start)\ncursor.setPosition(end, QTextCursor.KeepAnchor)\ncode_editor.setTextCursor(cursor)\ncode_editor.cut()\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(treewidget.sig_tree_updated, timeout=30000):\n    code_editor.request_symbols()\ntree = trees[1]\nroot_tree = get_tree_elements(treewidget)\nassert root_tree == tree\ncode_editor.go_to_line(36)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    qtbot.keyPress(code_editor, Qt.Key_Return)\n    qtbot.keyPress(code_editor, Qt.Key_Return)\nqtbot.keyPress(code_editor, Qt.Key_Up)\ncode_editor.paste()\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(treewidget.sig_tree_updated, timeout=30000):\n    code_editor.request_symbols()\ntree = trees[2]\nroot_tree = get_tree_elements(treewidget)\nassert root_tree == tree\ncode_editor.go_to_line(56)\ncursor = code_editor.textCursor()\nstart = code_editor.get_position_line_number(55, -1)\nend = code_editor.get_position_line_number(57, -1)\ncursor.setPosition(start)\ncursor.setPosition(end, QTextCursor.KeepAnchor)\ncode_editor.setTextCursor(cursor)\ncode_editor.cut()\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(treewidget.sig_tree_updated, timeout=30000):\n    code_editor.request_symbols()\ntree = trees[3]\nroot_tree = get_tree_elements(treewidget)\nassert root_tree == tree\ncode_editor.go_to_line(49)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    qtbot.keyPress(code_editor, Qt.Key_Return)\n    qtbot.keyPress(code_editor, Qt.Key_Return)\nqtbot.keyPress(code_editor, Qt.Key_Up)\ncode_editor.paste()\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(treewidget.sig_tree_updated, timeout=30000):\n    code_editor.request_symbols()\ntree = trees[4]\nroot_tree = get_tree_elements(treewidget)\nassert root_tree == tree\ncode_editor.go_to_line(48)\ncursor = code_editor.textCursor()\ncursor.movePosition(QTextCursor.EndOfBlock)\ncode_editor.setTextCursor(cursor)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    qtbot.keyPress(code_editor, Qt.Key_Return)\n    qtbot.keyClicks(code_editor, 'self.y = None')\n    qtbot.keyPress(code_editor, Qt.Key_Return)\nwith qtbot.waitSignal(treewidget.sig_tree_updated, timeout=30000):\n    code_editor.request_symbols()\ntree = trees[5]\nroot_tree = get_tree_elements(treewidget)\nassert root_tree == tree\npytest.mark.slowpytest.mark.second",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_empty_file",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor_and_outline.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the outline explorer is updated correctly when\n    it's associated file is empty.\n    \"\"\"\ncode_editor, outlineexplorer = lsp_codeeditor_outline\ntreewidget = outlineexplorer.treewidget\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(False)\ncode_editor.set_text('')\ncode_editor.go_to_line(1)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.request_symbols()\nassert not outlineexplorer.loading_widget.isSpinning()\ncode_editor.set_text(\"\"\"\ndef foo():\n    a = 10\n    return a\n\"\"\")\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(treewidget.sig_tree_updated, timeout=30000):\n    code_editor.request_symbols()\nroot_tree = get_tree_elements(treewidget)\nassert root_tree == {'test.py': [{'foo': [{'a': []}]}]}\ncode_editor.selectAll()\nqtbot.keyPress(code_editor, Qt.Key_Delete)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(treewidget.sig_tree_updated, timeout=30000):\n    code_editor.request_symbols()\nroot_tree = get_tree_elements(treewidget)\nassert root_tree == {'test.py': []}\nassert not outlineexplorer.loading_widget.isSpinning()\npytest.mark.slowpytest.mark.second",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "add_files",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editorstack.close_action.setEnabled(False)\neditorstack.set_find_widget(Mock())\neditorstack.set_io_actions(Mock(), Mock(), Mock(), Mock())\neditorstack.new('foo.py', 'utf-8', \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\")\neditorstack.new('secondtab.py', 'utf-8', 'print(spam)')\nwith open(__file__) as f:\n    text = f.read()\neditorstack.new(__file__, 'utf-8', text)\n",
        "CUT_1": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_2": "return Mock()\n",
        "CUT_3": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n"
    },
    {
        "functionName": "base_editor_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack = editor.EditorStack(None, [])\neditor_stack.set_find_widget(Mock())\neditor_stack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nreturn editor_stack, qtbot\npytest.fixture",
        "CUT_1": "return Mock()\n",
        "CUT_2": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_3": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_4": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_5": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)"
    },
    {
        "functionName": "editor_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Set up EditorStack with CodeEditors containing some Python code.\n    The cursor is at the empty line below the code.\n    \"\"\"\neditor_stack, qtbot = base_editor_bot\nshow_save_dialog = request.node.get_closest_marker('show_save_dialog')\nif show_save_dialog:\n    editor_stack.save_dialog_on_tests = True\nqtbot.addWidget(editor_stack)\nadd_files(editor_stack)\nreturn editor_stack, qtbot\npytest.fixture",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_3": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_4": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_5": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n"
    },
    {
        "functionName": "editor_splitter_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create editor splitter.\"\"\"\nes = editor_splitter = editor.EditorSplitter(None, Mock(), [], first=True)\nqtbot.addWidget(es)\nes.show()\nyield es\nes.destroy()\npytest.fixture",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_3": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture",
        "CUT_4": "return Mock()\n",
        "CUT_5": "\"\"\"Return the editor stacks for this splitter and every first child.\n\n        Note: If a splitter contains more than one splitter as a direct\n              child, only the first child's editor stack is included.\n\n        Returns:\n            List of tuples containing (EditorStack instance, orientation).\n        \"\"\"\neditorstacks = [(self.widget(0), self.orientation())]\nif self.count() > 1:\n    editorsplitter = self.widget(1)\n    editorstacks += editorsplitter.iter_editorstacks()\nreturn editorstacks\n"
    },
    {
        "functionName": "editor_splitter_layout_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create editor splitter for testing layouts.\"\"\"\nes = editor_splitter_bot\nes.plugin.clone_editorstack.side_effect = add_files\nadd_files(es.editorstack)\nreturn es\npytest.fixture",
        "CUT_1": "\"\"\"Create a splitter for dividing an editor window into panels.\n\n        Adds a new EditorStack instance to this splitter.  If it's not\n        the first splitter, clones the current EditorStack from the plugin.\n\n        Args:\n            parent: Parent widget.\n            plugin: Plugin this widget belongs to.\n            menu_actions: QActions to include from the parent.\n            first: Boolean if this is the first splitter in the editor.\n            register_editorstack_cb: Callback to register the EditorStack.\n                        Defaults to plugin.register_editorstack() to\n                        register the EditorStack with the Editor plugin.\n            unregister_editorstack_cb: Callback to unregister the EditorStack.\n                        Defaults to plugin.unregister_editorstack() to\n                        unregister the EditorStack with the Editor plugin.\n        \"\"\"\nQSplitter.__init__(self, parent)\nself.setAttribute(Qt.WA_DeleteOnClose)\nself.setChildrenCollapsible(False)\nself.toolbar_list = None\nself.menu_list = None\nself.plugin = plugin\nif register_editorstack_cb is None:\n    register_editorstack_cb = self.plugin.register_editorstack\nself.register_editorstack_cb = register_editorstack_cb\nif unregister_editorstack_cb is None:\n    unregister_editorstack_cb = self.plugin.unregister_editorstack\nself.unregister_editorstack_cb = unregister_editorstack_cb\nself.menu_actions = menu_actions\nself.editorstack = EditorStack(self, menu_actions)\nself.register_editorstack_cb(self.editorstack)\nif not first:\n    self.plugin.clone_editorstack(editorstack=self.editorstack)\nself.editorstack.destroyed.connect(lambda : self.editorstack_closed())\nself.editorstack.sig_split_vertically.connect(lambda : self.split(\n    orientation=Qt.Vertical))\nself.editorstack.sig_split_horizontally.connect(lambda : self.split(\n    orientation=Qt.Horizontal))\nself.addWidget(self.editorstack)\nif not running_under_pytest():\n    self.editorstack.set_color_scheme(plugin.get_color_scheme())\n",
        "CUT_2": "\"\"\"Create a splitter for dividing an editor window into panels.\n\n        Adds a new EditorStack instance to this splitter.  If it's not\n        the first splitter, clones the current EditorStack from the plugin.\n\n        Args:\n            parent: Parent widget.\n            plugin: Plugin this widget belongs to.\n            menu_actions: QActions to include from the parent.\n            first: Boolean if this is the first splitter in the editor.\n            register_editorstack_cb: Callback to register the EditorStack.\n                        Defaults to plugin.register_editorstack() to\n                        register the EditorStack with the Editor plugin.\n            unregister_editorstack_cb: Callback to unregister the EditorStack.\n                        Defaults to plugin.unregister_editorstack() to\n                        unregister the EditorStack with the Editor plugin.\n        \"\"\"\nQSplitter.__init__(self, parent)\nself.setAttribute(Qt.WA_DeleteOnClose)\nself.setChildrenCollapsible(False)\nself.toolbar_list = None\nself.menu_list = None\nself.plugin = plugin\nif register_editorstack_cb is None:\n    register_editorstack_cb = self.plugin.register_editorstack\nself.register_editorstack_cb = register_editorstack_cb\nif unregister_editorstack_cb is None:\n    unregister_editorstack_cb = self.plugin.unregister_editorstack\nself.unregister_editorstack_cb = unregister_editorstack_cb\nself.menu_actions = menu_actions\nself.editorstack = EditorStack(self, menu_actions)\nself.register_editorstack_cb(self.editorstack)\nif not first:\n    self.plugin.clone_editorstack(editorstack=self.editorstack)\nself.editorstack.destroyed.connect(lambda : self.editorstack_closed())\nself.editorstack.sig_split_vertically.connect(lambda : self.split(\n    orientation=Qt.Vertical))\nself.editorstack.sig_split_horizontally.connect(lambda : self.split(\n    orientation=Qt.Horizontal))\nself.addWidget(self.editorstack)\nif not running_under_pytest():\n    self.editorstack.set_color_scheme(plugin.get_color_scheme())\n",
        "CUT_3": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_4": "\"\"\"Get the current editorstack.\"\"\"\nplugin = self.ipyclient.plugin\nif plugin.main.editor is not None:\n    editor = plugin.main.editor\n    return editor.get_current_editorstack()\nraise RuntimeError('No editorstack found.')\n",
        "CUT_5": "\"\"\"Get the current editorstack.\"\"\"\nplugin = self.ipyclient.plugin\nif plugin.main.editor is not None:\n    editor = plugin.main.editor\n    return editor.get_current_editorstack()\nraise RuntimeError('No editorstack found.')\n"
    },
    {
        "functionName": "test_save_if_changed",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test EditorStack.save_if_changed().\"\"\"\neditor_stack, qtbot = editor_bot\nsave_if_changed = editor_stack.save_if_changed\nmocker.patch.object(editor.QMessageBox, 'exec_')\nmocker.patch.object(editor_stack, 'save')\nmocker.patch.object(editor_stack.autosave, 'remove_autosave_file')\neditor_stack.save.return_value = True\neditor_stack.data[0].editor.document().setModified(False)\neditor_stack.data[1].editor.document().setModified(False)\neditor_stack.data[2].editor.document().setModified(False)\nassert save_if_changed() is True\nassert not editor_stack.save.called\nassert not editor_stack.autosave.remove_autosave_file.called\neditor_stack.data[0].editor.document().setModified(True)\neditor_stack.data[1].editor.document().setModified(True)\neditor_stack.data[2].editor.document().setModified(True)\neditor.QMessageBox.exec_.return_value = editor.QMessageBox.Cancel\nassert save_if_changed(index=0, cancelable=True) is False\nassert not editor_stack.save.called\nassert not editor_stack.autosave.remove_autosave_file.called\nassert editor_stack.tabs.currentIndex() == 0\neditor.QMessageBox.exec_.return_value = editor.QMessageBox.Yes\nassert save_if_changed(index=0, cancelable=True) is True\nassert editor_stack.save.called\nassert not editor_stack.autosave.remove_autosave_file.called\neditor_stack.save.reset_mock()\neditor.QMessageBox.exec_.return_value = editor.QMessageBox.YesToAll\nassert save_if_changed() is True\nassert editor_stack.save.call_count == 3\nassert not editor_stack.autosave.remove_autosave_file.called\neditor_stack.save.reset_mock()\neditor.QMessageBox.exec_.return_value = editor.QMessageBox.No\nassert save_if_changed(index=0, cancelable=True) is True\nassert not editor_stack.save.called\nassert editor_stack.autosave.remove_autosave_file.called\neditor_stack.save.reset_mock()\neditor_stack.autosave.remove_autosave_file.reset_mock()\neditor.QMessageBox.exec_.return_value = editor.QMessageBox.NoToAll\nassert save_if_changed() is True\nassert not editor_stack.save.called\nassert editor_stack.autosave.remove_autosave_file.call_count == 3\neditor.QMessageBox.exec_.reset_mock()\neditor_stack.autosave.remove_autosave_file.reset_mock()\neditor_stack.set_tempfile_path(__file__)\neditor_stack.save.return_value = False\nassert save_if_changed(index=2, cancelable=True) is False\nassert editor_stack.save.called\nassert not editor_stack.autosave.remove_autosave_file.called\neditor.QMessageBox.exec_.assert_not_called()\npytest.mark.show_save_dialog",
        "CUT_1": "\"\"\"Ask user to save file if modified.\n\n        Args:\n            cancelable: Show Cancel button.\n            index: File to check for modification.\n\n        Returns:\n            False when save() fails or is cancelled.\n            True when save() is successful, there are no modifications,\n                or user selects No or NoToAll.\n\n        This function controls the message box prompt for saving\n        changed files.  The actual save is performed in save() for\n        each index processed. This function also removes autosave files\n        corresponding to files the user chooses not to save.\n        \"\"\"\nif index is None:\n    indexes = list(range(self.get_stack_count()))\nelse:\n    indexes = [index]\nbuttons = QMessageBox.Yes | QMessageBox.No\nif cancelable:\n    buttons |= QMessageBox.Cancel\nunsaved_nb = 0\nfor index in indexes:\n    if self.data[index].editor.document().isModified():\n        unsaved_nb += 1\nif not unsaved_nb:\n    return True\nif unsaved_nb > 1:\n    buttons |= int(QMessageBox.YesToAll | QMessageBox.NoToAll)\nyes_all = no_all = False\nfor index in indexes:\n    self.set_stack_index(index)\n    finfo = self.data[index]\n    if finfo.filename == self.tempfile_path or yes_all:\n        if not self.save(index):\n            return False\n    elif no_all:\n        self.autosave.remove_autosave_file(finfo)\n    elif finfo.editor.document().isModified() and self.save_dialog_on_tests:\n        self.msgbox = QMessageBox(QMessageBox.Question, self.title, _(\n            '<b>%s</b> has been modified.<br>Do you want to save changes?') %\n            osp.basename(finfo.filename), buttons, parent=self)\n        answer = self.msgbox.exec_()\n        if answer == QMessageBox.Yes:\n            if not self.save(index):\n                return False\n        elif answer == QMessageBox.No:\n            self.autosave.remove_autosave_file(finfo.filename)\n        elif answer == QMessageBox.YesToAll:\n            if not self.save(index):\n                return False\n            yes_all = True\n        elif answer == QMessageBox.NoToAll:\n            self.autosave.remove_autosave_file(finfo.filename)\n            no_all = True\n        elif answer == QMessageBox.Cancel:\n            return False\nreturn True\n",
        "CUT_2": "\"\"\"Ask user to save file if modified.\n\n        Args:\n            cancelable: Show Cancel button.\n            index: File to check for modification.\n\n        Returns:\n            False when save() fails or is cancelled.\n            True when save() is successful, there are no modifications,\n                or user selects No or NoToAll.\n\n        This function controls the message box prompt for saving\n        changed files.  The actual save is performed in save() for\n        each index processed. This function also removes autosave files\n        corresponding to files the user chooses not to save.\n        \"\"\"\nif index is None:\n    indexes = list(range(self.get_stack_count()))\nelse:\n    indexes = [index]\nbuttons = QMessageBox.Yes | QMessageBox.No\nif cancelable:\n    buttons |= QMessageBox.Cancel\nunsaved_nb = 0\nfor index in indexes:\n    if self.data[index].editor.document().isModified():\n        unsaved_nb += 1\nif not unsaved_nb:\n    return True\nif unsaved_nb > 1:\n    buttons |= int(QMessageBox.YesToAll | QMessageBox.NoToAll)\nyes_all = no_all = False\nfor index in indexes:\n    self.set_stack_index(index)\n    finfo = self.data[index]\n    if finfo.filename == self.tempfile_path or yes_all:\n        if not self.save(index):\n            return False\n    elif no_all:\n        self.autosave.remove_autosave_file(finfo)\n    elif finfo.editor.document().isModified() and self.save_dialog_on_tests:\n        self.msgbox = QMessageBox(QMessageBox.Question, self.title, _(\n            '<b>%s</b> has been modified.<br>Do you want to save changes?') %\n            osp.basename(finfo.filename), buttons, parent=self)\n        answer = self.msgbox.exec_()\n        if answer == QMessageBox.Yes:\n            if not self.save(index):\n                return False\n        elif answer == QMessageBox.No:\n            self.autosave.remove_autosave_file(finfo.filename)\n        elif answer == QMessageBox.YesToAll:\n            if not self.save(index):\n                return False\n            yes_all = True\n        elif answer == QMessageBox.NoToAll:\n            self.autosave.remove_autosave_file(finfo.filename)\n            no_all = True\n        elif answer == QMessageBox.Cancel:\n            return False\nreturn True\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Write text of editor to a file.\n\n        Args:\n            index: self.data index to save.  If None, defaults to\n                currentIndex().\n            force: Force save regardless of file state.\n\n        Returns:\n            True upon successful save or when file doesn't need to be saved.\n            False if save failed.\n\n        If the text isn't modified and it's not newly created, then the save\n        is aborted.  If the file hasn't been saved before, then save_as()\n        is invoked.  Otherwise, the file is written using the file name\n        currently in self.data.  This function doesn't change the file name.\n        \"\"\"\nif index is None:\n    if not self.get_stack_count():\n        return\n    index = self.get_stack_index()\nfinfo = self.data[index]\nif not (finfo.editor.document().isModified() or finfo.newly_created\n    ) and not force:\n    return True\nif not osp.isfile(finfo.filename) and not force:\n    if save_new_files:\n        return self.save_as(index=index)\n    return True\nif self.always_remove_trailing_spaces:\n    self.remove_trailing_spaces(index)\nif self.remove_trailing_newlines:\n    self.trim_trailing_newlines(index)\nif self.add_newline:\n    self.add_newline_to_file(index)\nif self.convert_eol_on_save:\n    osname_lookup = {'LF': 'posix', 'CRLF': 'nt', 'CR': 'mac'}\n    osname = osname_lookup[self.convert_eol_on_save_to]\n    self.set_os_eol_chars(osname=osname)\ntry:\n    if self.format_on_save and finfo.editor.formatting_enabled:\n        finfo.editor.sig_stop_operation_in_progress.connect(functools.\n            partial(self._save_file, finfo, index))\n        finfo.editor.format_document()\n    else:\n        self._save_file(finfo, index)\n    return True\nexcept EnvironmentError as error:\n    self.msgbox = QMessageBox(QMessageBox.Critical, _('Save Error'), _(\n        \"<b>Unable to save file '%s'</b><br><br>Error message:<br>%s\") % (\n        osp.basename(finfo.filename), str(error)), parent=self)\n    self.msgbox.exec_()\n    return False\n"
    },
    {
        "functionName": "test_save",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test EditorStack.save().\"\"\"\neditor_stack, qtbot = editor_bot\nsave = editor_stack.save\nmocker.patch.object(editor.QMessageBox, 'exec_')\nmocker.patch.object(editor.os.path, 'isfile')\nmocker.patch.object(editor.encoding, 'write')\nmocker.patch.object(editor_stack, 'save_as')\nmocker.patch.object(editor_stack.autosave, 'remove_autosave_file')\nsave_file_saved = editor_stack.file_saved\neditor_stack.file_saved = Mock()\neditor.encoding.write.return_value = 'utf-8'\neditor_stack.data[0].editor.document().setModified(False)\neditor_stack.data[0].newly_created = False\nassert save(index=0) is True\nassert not editor.encoding.write.called\nassert not editor_stack.autosave.remove_autosave_file.called\nassert editor_stack.autosave.file_hashes == {}\neditor_stack.data[0].editor.document().setModified(True)\neditor.os.path.isfile.return_value = False\neditor_stack.save_as.return_value = 'save_as_called'\nassert save(index=0) == 'save_as_called'\neditor_stack.save_as.assert_called_with(index=0)\nassert not editor.encoding.write.called\nassert not editor_stack.autosave.remove_autosave_file.called\nassert editor_stack.autosave.file_hashes == {}\neditor.os.path.isfile.return_value = True\nassert save(index=0, force=True)\nassert editor.encoding.write.called == 1\neditor_stack.file_saved.emit.assert_called_with(str(id(editor_stack)),\n    'foo.py', 'foo.py')\neditor_stack.autosave.remove_autosave_file.assert_called_with(editor_stack.\n    data[0].filename)\nexpected = {'foo.py': hash(\"\"\"a = 1\nprint(a)\n\nx = 2\n\"\"\")}\nassert editor_stack.autosave.file_hashes == expected\neditor_stack.file_saved = save_file_saved\n",
        "CUT_1": "\"\"\"Ask user to save file if modified.\n\n        Args:\n            cancelable: Show Cancel button.\n            index: File to check for modification.\n\n        Returns:\n            False when save() fails or is cancelled.\n            True when save() is successful, there are no modifications,\n                or user selects No or NoToAll.\n\n        This function controls the message box prompt for saving\n        changed files.  The actual save is performed in save() for\n        each index processed. This function also removes autosave files\n        corresponding to files the user chooses not to save.\n        \"\"\"\nif index is None:\n    indexes = list(range(self.get_stack_count()))\nelse:\n    indexes = [index]\nbuttons = QMessageBox.Yes | QMessageBox.No\nif cancelable:\n    buttons |= QMessageBox.Cancel\nunsaved_nb = 0\nfor index in indexes:\n    if self.data[index].editor.document().isModified():\n        unsaved_nb += 1\nif not unsaved_nb:\n    return True\nif unsaved_nb > 1:\n    buttons |= int(QMessageBox.YesToAll | QMessageBox.NoToAll)\nyes_all = no_all = False\nfor index in indexes:\n    self.set_stack_index(index)\n    finfo = self.data[index]\n    if finfo.filename == self.tempfile_path or yes_all:\n        if not self.save(index):\n            return False\n    elif no_all:\n        self.autosave.remove_autosave_file(finfo)\n    elif finfo.editor.document().isModified() and self.save_dialog_on_tests:\n        self.msgbox = QMessageBox(QMessageBox.Question, self.title, _(\n            '<b>%s</b> has been modified.<br>Do you want to save changes?') %\n            osp.basename(finfo.filename), buttons, parent=self)\n        answer = self.msgbox.exec_()\n        if answer == QMessageBox.Yes:\n            if not self.save(index):\n                return False\n        elif answer == QMessageBox.No:\n            self.autosave.remove_autosave_file(finfo.filename)\n        elif answer == QMessageBox.YesToAll:\n            if not self.save(index):\n                return False\n            yes_all = True\n        elif answer == QMessageBox.NoToAll:\n            self.autosave.remove_autosave_file(finfo.filename)\n            no_all = True\n        elif answer == QMessageBox.Cancel:\n            return False\nreturn True\n",
        "CUT_2": "\"\"\"Ask user to save file if modified.\n\n        Args:\n            cancelable: Show Cancel button.\n            index: File to check for modification.\n\n        Returns:\n            False when save() fails or is cancelled.\n            True when save() is successful, there are no modifications,\n                or user selects No or NoToAll.\n\n        This function controls the message box prompt for saving\n        changed files.  The actual save is performed in save() for\n        each index processed. This function also removes autosave files\n        corresponding to files the user chooses not to save.\n        \"\"\"\nif index is None:\n    indexes = list(range(self.get_stack_count()))\nelse:\n    indexes = [index]\nbuttons = QMessageBox.Yes | QMessageBox.No\nif cancelable:\n    buttons |= QMessageBox.Cancel\nunsaved_nb = 0\nfor index in indexes:\n    if self.data[index].editor.document().isModified():\n        unsaved_nb += 1\nif not unsaved_nb:\n    return True\nif unsaved_nb > 1:\n    buttons |= int(QMessageBox.YesToAll | QMessageBox.NoToAll)\nyes_all = no_all = False\nfor index in indexes:\n    self.set_stack_index(index)\n    finfo = self.data[index]\n    if finfo.filename == self.tempfile_path or yes_all:\n        if not self.save(index):\n            return False\n    elif no_all:\n        self.autosave.remove_autosave_file(finfo)\n    elif finfo.editor.document().isModified() and self.save_dialog_on_tests:\n        self.msgbox = QMessageBox(QMessageBox.Question, self.title, _(\n            '<b>%s</b> has been modified.<br>Do you want to save changes?') %\n            osp.basename(finfo.filename), buttons, parent=self)\n        answer = self.msgbox.exec_()\n        if answer == QMessageBox.Yes:\n            if not self.save(index):\n                return False\n        elif answer == QMessageBox.No:\n            self.autosave.remove_autosave_file(finfo.filename)\n        elif answer == QMessageBox.YesToAll:\n            if not self.save(index):\n                return False\n            yes_all = True\n        elif answer == QMessageBox.NoToAll:\n            self.autosave.remove_autosave_file(finfo.filename)\n            no_all = True\n        elif answer == QMessageBox.Cancel:\n            return False\nreturn True\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Write text of editor to a file.\n\n        Args:\n            index: self.data index to save.  If None, defaults to\n                currentIndex().\n            force: Force save regardless of file state.\n\n        Returns:\n            True upon successful save or when file doesn't need to be saved.\n            False if save failed.\n\n        If the text isn't modified and it's not newly created, then the save\n        is aborted.  If the file hasn't been saved before, then save_as()\n        is invoked.  Otherwise, the file is written using the file name\n        currently in self.data.  This function doesn't change the file name.\n        \"\"\"\nif index is None:\n    if not self.get_stack_count():\n        return\n    index = self.get_stack_index()\nfinfo = self.data[index]\nif not (finfo.editor.document().isModified() or finfo.newly_created\n    ) and not force:\n    return True\nif not osp.isfile(finfo.filename) and not force:\n    if save_new_files:\n        return self.save_as(index=index)\n    return True\nif self.always_remove_trailing_spaces:\n    self.remove_trailing_spaces(index)\nif self.remove_trailing_newlines:\n    self.trim_trailing_newlines(index)\nif self.add_newline:\n    self.add_newline_to_file(index)\nif self.convert_eol_on_save:\n    osname_lookup = {'LF': 'posix', 'CRLF': 'nt', 'CR': 'mac'}\n    osname = osname_lookup[self.convert_eol_on_save_to]\n    self.set_os_eol_chars(osname=osname)\ntry:\n    if self.format_on_save and finfo.editor.formatting_enabled:\n        finfo.editor.sig_stop_operation_in_progress.connect(functools.\n            partial(self._save_file, finfo, index))\n        finfo.editor.format_document()\n    else:\n        self._save_file(finfo, index)\n    return True\nexcept EnvironmentError as error:\n    self.msgbox = QMessageBox(QMessageBox.Critical, _('Save Error'), _(\n        \"<b>Unable to save file '%s'</b><br><br>Error message:<br>%s\") % (\n        osp.basename(finfo.filename), str(error)), parent=self)\n    self.msgbox.exec_()\n    return False\n"
    },
    {
        "functionName": "test_file_saved_in_other_editorstack",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test EditorStack.file_saved_in_other_editorstack().\"\"\"\nes = editor_splitter_layout_bot\nes.split()\npanel1 = es.editorstack\npanel2 = es.widget(1).editorstack\nfor i in range(3):\n    assert panel1.data[i].filename == panel2.data[i].filename\npanel1.tabs.tabBar().moveTab(0, 1)\nassert panel1.data[0].filename == panel2.data[1].filename\nassert panel1.data[1].filename == panel2.data[0].filename\nassert panel1.data[2].filename == panel2.data[2].filename\npanel2.file_saved_in_other_editorstack(panel1.data[0].filename, panel1.data\n    [0].filename)\npanel2.file_saved_in_other_editorstack(panel1.data[1].filename, panel1.data\n    [1].filename)\nassert panel1.data[0].filename == panel2.data[1].filename\nassert panel1.data[1].filename == panel2.data[0].filename\nassert panel1.data[2].filename == panel2.data[2].filename\n",
        "CUT_1": "if self.data:\n    return self.data[self.get_stack_index()].filename\n",
        "CUT_2": "if self.data:\n    return self.data[self.get_stack_index()].filename\n",
        "CUT_3": "filename = osp.abspath(filename)\nfor index, (fname, data) in enumerate(self.rdata):\n    if fname == filename:\n        return index, data\nelse:\n    return None, None\n",
        "CUT_4": "filename = osp.abspath(filename)\nfor index, (fname, data) in enumerate(self.rdata):\n    if fname == filename:\n        return index, data\nelse:\n    return None, None\n",
        "CUT_5": "\"\"\"Return the self.data index position for the filename.\n\n        Args:\n            filename: Name of the file to search for in self.data.\n\n        Returns:\n            The self.data index for the filename.  Returns None\n            if the filename is not found in self.data.\n        \"\"\"\nfixpath = lambda path: osp.normcase(osp.realpath(path))\nfor index, finfo in enumerate(self.data):\n    if fixpath(filename) == fixpath(finfo.filename):\n        return index\nreturn None\n"
    },
    {
        "functionName": "test_select_savename",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test EditorStack.select_savename().\"\"\"\neditor_stack, qtbot = editor_bot\nselect_savename = editor_stack.select_savename\nmocker.patch.object(editor, 'getsavefilename')\nsave_redirect_stdio = editor_stack.redirect_stdio\neditor_stack.redirect_stdio = Mock()\neditor.getsavefilename.return_value = '', ''\nassert select_savename(__file__) is None\neditor.getsavefilename.return_value = __file__, ''\nassert select_savename(__file__) == __file__\neditor.getsavefilename.return_value = 'mytest.py', ''\nassert select_savename(__file__) == 'mytest.py'\neditor_stack.redirect_stdio = save_redirect_stdio\n",
        "CUT_1": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture",
        "CUT_2": "self.redirect_stdio.emit(False)\nfilename, _selfilter = getopenfilename(self, _('Select Python file'),\n    getcwd_or_home(), _('Python files') + ' (*.py ; *.pyw)')\nself.redirect_stdio.emit(True)\nif filename:\n    self.analyze(filename)\nSlot()",
        "CUT_3": "self.redirect_stdio.emit(False)\nfilename, _selfilter = getopenfilename(self, _('Select Python file'),\n    getcwd_or_home(), _('Python files') + ' (*.py ; *.pyw)')\nself.redirect_stdio.emit(True)\nif filename:\n    self.analyze(filename)\nSlot()",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_save_as",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test EditorStack.save_as().\"\"\"\neditor_stack, qtbot = editor_bot\nsave_as = editor_stack.save_as\nmocker.patch.object(editor.encoding, 'write')\nmocker.patch.object(editor_stack, 'save')\nmocker.patch.object(editor_stack, 'close_file')\nmocker.patch.object(editor_stack, 'select_savename')\nmocker.patch.object(editor_stack, 'rename_in_data')\nmocker.patch.object(editor_stack, 'refresh')\nsave_file_renamed_in_data = editor_stack.file_renamed_in_data\neditor_stack.file_renamed_in_data = Mock()\neditor.encoding.write.return_value = 'utf-8'\neditor_stack.save.return_value = True\neditor_stack.select_savename.return_value = None\nassert save_as() is False\nassert not editor_stack.save.called\neditor_stack.select_savename.return_value = 'foo.py'\neditor_stack.close_file.return_value = False\nassert save_as(index=2) is None\nassert not editor_stack.save.called\neditor_stack.close_file.return_value = True\nassert save_as(index=2) is True\neditor_stack.close_file.assert_called_with(0)\nassert editor_stack.save.called\neditor_stack.rename_in_data.assert_called_with(__file__, new_filename='foo.py')\nassert editor_stack.file_renamed_in_data.emit.called == 1\nassert editor_stack.save.called == 1\nassert editor_stack.refresh.called == 1\neditor_stack.file_renamed_in_data = save_file_renamed_in_data\n",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"Save file as...\n\n        Args:\n            index: self.data index for the file to save.\n\n        Returns:\n            False if no file name was selected or if save() was unsuccessful.\n            True is save() was successful.\n\n        Gets the new file name from select_savename().  If no name is chosen,\n        then the save_as() aborts.  Otherwise, the current stack is checked\n        to see if the selected name already exists and, if so, then the tab\n        with that name is closed.\n\n        The current stack (self.data) and current tabs are updated with the\n        new name and other file info.  The text is written with the new\n        name using save() and the name change is propagated to the other stacks\n        via the file_renamed_in_data signal.\n        \"\"\"\nif index is None:\n    index = self.get_stack_index()\nfinfo = self.data[index]\noriginal_newly_created = finfo.newly_created\nfinfo.newly_created = True\noriginal_filename = finfo.filename\nfilename = self.select_savename(original_filename)\nif filename:\n    ao_index = self.has_filename(filename)\n    if ao_index is not None and ao_index != index:\n        if not self.close_file(ao_index):\n            return\n        if ao_index < index:\n            index -= 1\n    new_index = self.rename_in_data(original_filename, new_filename=filename)\n    self.file_renamed_in_data.emit(str(id(self)), original_filename, filename)\n    ok = self.save(index=new_index, force=True)\n    self.refresh(new_index)\n    self.set_stack_index(new_index)\n    return ok\nelse:\n    finfo.newly_created = original_newly_created\n    return False\n",
        "CUT_3": "\"\"\"Save file as...\n\n        Args:\n            index: self.data index for the file to save.\n\n        Returns:\n            False if no file name was selected or if save() was unsuccessful.\n            True is save() was successful.\n\n        Gets the new file name from select_savename().  If no name is chosen,\n        then the save_as() aborts.  Otherwise, the current stack is checked\n        to see if the selected name already exists and, if so, then the tab\n        with that name is closed.\n\n        The current stack (self.data) and current tabs are updated with the\n        new name and other file info.  The text is written with the new\n        name using save() and the name change is propagated to the other stacks\n        via the file_renamed_in_data signal.\n        \"\"\"\nif index is None:\n    index = self.get_stack_index()\nfinfo = self.data[index]\noriginal_newly_created = finfo.newly_created\nfinfo.newly_created = True\noriginal_filename = finfo.filename\nfilename = self.select_savename(original_filename)\nif filename:\n    ao_index = self.has_filename(filename)\n    if ao_index is not None and ao_index != index:\n        if not self.close_file(ao_index):\n            return\n        if ao_index < index:\n            index -= 1\n    new_index = self.rename_in_data(original_filename, new_filename=filename)\n    self.file_renamed_in_data.emit(str(id(self)), original_filename, filename)\n    ok = self.save(index=new_index, force=True)\n    self.refresh(new_index)\n    self.set_stack_index(new_index)\n    return ok\nelse:\n    finfo.newly_created = original_newly_created\n    return False\n",
        "CUT_4": "\"\"\"Save copy of file as...\n\n        Args:\n            index: self.data index for the file to save.\n\n        Returns:\n            False if no file name was selected or if save() was unsuccessful.\n            True is save() was successful.\n\n        Gets the new file name from select_savename().  If no name is chosen,\n        then the save_copy_as() aborts.  Otherwise, the current stack is\n        checked to see if the selected name already exists and, if so, then the\n        tab with that name is closed.\n\n        Unlike save_as(), this calls write() directly instead of using save().\n        The current file and tab aren't changed at all.  The copied file is\n        opened in a new tab.\n        \"\"\"\nif index is None:\n    index = self.get_stack_index()\nfinfo = self.data[index]\noriginal_filename = finfo.filename\nfilename = self.select_savename(original_filename)\nif filename:\n    ao_index = self.has_filename(filename)\n    if ao_index is not None and ao_index != index:\n        if not self.close_file(ao_index):\n            return\n        if ao_index < index:\n            index -= 1\n    try:\n        self._write_to_file(finfo, filename)\n        self.plugin_load.emit(filename)\n        return True\n    except EnvironmentError as error:\n        self.msgbox = QMessageBox(QMessageBox.Critical, _('Save Error'), _(\n            \"<b>Unable to save file '%s'</b><br><br>Error message:<br>%s\") %\n            (osp.basename(finfo.filename), str(error)), parent=self)\n        self.msgbox.exec_()\nelse:\n    return False\n",
        "CUT_5": "\"\"\"Save copy of file as...\n\n        Args:\n            index: self.data index for the file to save.\n\n        Returns:\n            False if no file name was selected or if save() was unsuccessful.\n            True is save() was successful.\n\n        Gets the new file name from select_savename().  If no name is chosen,\n        then the save_copy_as() aborts.  Otherwise, the current stack is\n        checked to see if the selected name already exists and, if so, then the\n        tab with that name is closed.\n\n        Unlike save_as(), this calls write() directly instead of using save().\n        The current file and tab aren't changed at all.  The copied file is\n        opened in a new tab.\n        \"\"\"\nif index is None:\n    index = self.get_stack_index()\nfinfo = self.data[index]\noriginal_filename = finfo.filename\nfilename = self.select_savename(original_filename)\nif filename:\n    ao_index = self.has_filename(filename)\n    if ao_index is not None and ao_index != index:\n        if not self.close_file(ao_index):\n            return\n        if ao_index < index:\n            index -= 1\n    try:\n        self._write_to_file(finfo, filename)\n        self.plugin_load.emit(filename)\n        return True\n    except EnvironmentError as error:\n        self.msgbox = QMessageBox(QMessageBox.Critical, _('Save Error'), _(\n            \"<b>Unable to save file '%s'</b><br><br>Error message:<br>%s\") %\n            (osp.basename(finfo.filename), str(error)), parent=self)\n        self.msgbox.exec_()\nelse:\n    return False\n"
    },
    {
        "functionName": "test_save_as_with_outline",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test EditorStack.save_as() when the outline explorer is not None.\n\n    Regression test for spyder-ide/spyder#7754.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditorstack.tabs.setCurrentIndex(1)\nassert editorstack.get_current_filename() == 'secondtab.py'\neditorstack.set_outlineexplorer(OutlineExplorerWidget())\nqtbot.addWidget(editorstack.outlineexplorer)\nfor finfo in editorstack.data:\n    editorstack.outlineexplorer.register_editor(finfo.editor.oe_proxy)\neditorstack.refresh()\nmocker.patch.object(editorstack, 'select_savename', return_value=None)\nassert editorstack.save_as() is False\nassert editorstack.get_filenames() == ['foo.py', 'secondtab.py', __file__]\nnew_filename = osp.join(tmpdir.strpath, 'foo2.py')\neditorstack.select_savename.return_value = new_filename\nassert not osp.exists(new_filename)\nassert editorstack.save_as() is True\nassert editorstack.get_filenames() == ['foo.py', new_filename, __file__]\nassert osp.exists(new_filename)\npytest.mark.show_save_dialog",
        "CUT_1": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_5": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture"
    },
    {
        "functionName": "test_save_copy_as",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test EditorStack.save_copy as().\"\"\"\neditor_stack, qtbot = editor_bot\nsave_copy_as = editor_stack.save_copy_as\nmocker.patch.object(editor.QMessageBox, 'exec_')\nmocker.patch.object(editor.encoding, 'write')\nmocker.patch.object(editor_stack, 'close_file')\nmocker.patch.object(editor_stack, 'select_savename')\nsave_plugin_load = editor_stack.plugin_load\neditor_stack.plugin_load = Mock()\neditor.encoding.write.return_value = 'utf-8'\neditor_stack.select_savename.return_value = None\nassert save_copy_as() is False\nassert not editor.encoding.write.called\neditor_stack.select_savename.return_value = 'foo.py'\neditor_stack.close_file.return_value = False\nassert save_copy_as(index=2) is None\nassert not editor.encoding.write.called\neditor_stack.close_file.return_value = True\nassert save_copy_as(index=2) is True\neditor_stack.close_file.assert_called_with(0)\nassert editor.encoding.write.called\neditor_stack.plugin_load.emit.assert_called_with('foo.py')\neditor_stack.plugin_load = save_plugin_load\n",
        "CUT_1": "\"\"\"\n    Write 'lines' to file ('filename') assuming 'encoding'\n    Return (eventually new) encoding\n    \"\"\"\nreturn write(os.linesep.join(lines), filename, encoding, mode)\n",
        "CUT_2": "\"\"\"\n    Write 'lines' to file ('filename') assuming 'encoding'\n    Return (eventually new) encoding\n    \"\"\"\nreturn write(os.linesep.join(lines), filename, encoding, mode)\n",
        "CUT_3": "\"\"\"Save *copy as* the currently edited file\"\"\"\neditorstack = self.get_current_editorstack()\neditorstack.save_copy_as()\nSlot()",
        "CUT_4": "\"\"\"Save *copy as* the currently edited file\"\"\"\neditorstack = self.get_current_editorstack()\neditorstack.save_copy_as()\nSlot()",
        "CUT_5": "\"\"\"\n    Query the filesystem for the encoding used to encode filenames\n    and environment variables.\n    \"\"\"\nencoding = sys.getfilesystemencoding()\nif encoding is None:\n    encoding = PREFERRED_ENCODING\nreturn encoding\n"
    },
    {
        "functionName": "test_save_all",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test EditorStack.save_all().\"\"\"\neditor_stack, qtbot = editor_bot\nsave_all = editor_stack.save_all\nmocker.patch.object(editor_stack, 'save')\neditor_stack.save.return_value = False\nsave_all()\nassert editor_stack.save.call_count == 3\neditor_stack.save.assert_any_call(0, save_new_files=True)\neditor_stack.save.assert_any_call(1, save_new_files=True)\neditor_stack.save.assert_any_call(2, save_new_files=True)\nwith pytest.raises(AssertionError):\n    editor_stack.save.assert_any_call(3, save_new_files=True)\n",
        "CUT_1": "\"\"\"Save all opened files\"\"\"\nself.get_current_editorstack().save_all(save_new_files=save_new_files)\nSlot()",
        "CUT_2": "\"\"\"Save all opened files\"\"\"\nself.get_current_editorstack().save_all(save_new_files=save_new_files)\nSlot()",
        "CUT_3": "\"\"\"Save all opened files.\n\n        Iterate through self.data and call save() on any modified files.\n        \"\"\"\nfor index in range(self.get_stack_count()):\n    if self.data[index].editor.document().isModified():\n        self.save(index, save_new_files=save_new_files)\n",
        "CUT_4": "\"\"\"Save all opened files.\n\n        Iterate through self.data and call save() on any modified files.\n        \"\"\"\nfor index in range(self.get_stack_count()):\n    if self.data[index].editor.document().isModified():\n        self.save(index, save_new_files=save_new_files)\n",
        "CUT_5": "\"\"\"\n        Return the bytes that compose the file.\n\n        Bytes are returned instead of str to support non utf-8 files.\n        \"\"\"\neditorstack = self.get_editorstack()\nif save_all and CONF.get('editor', 'save_all_before_run', True):\n    editorstack.save_all(save_new_files=False)\neditor = self.get_editor(filename)\nif editor is None:\n    text, _enc = encoding.read(filename)\n    return text\nreturn editor.toPlainText()\n"
    },
    {
        "functionName": "test_save_as_lsp_calls",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that EditorStack.save_as() sends the expected LSP requests.\n\n    Regression test for spyder-ide/spyder#13085.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditorstack.tabs.setCurrentIndex(1)\nassert editorstack.get_current_filename() == 'secondtab.py'\neditor = editorstack.get_current_editor()\nmocker.patch.object(editor, 'notify_close')\nmocker.patch.object(editor, 'document_did_open')\nnew_filename = osp.join(tmpdir.strpath, 'foo.py')\nmocker.patch.object(editorstack, 'select_savename', return_value=new_filename)\nassert not osp.exists(new_filename)\nassert editorstack.save_as() is True\nassert editorstack.get_filenames() == ['foo.py', new_filename, __file__]\nassert osp.exists(new_filename)\nassert editor.notify_close.call_count == 1\nassert editor.document_did_open.call_count == 1\npytest.mark.show_save_dialog",
        "CUT_1": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_5": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture"
    },
    {
        "functionName": "test_save_as_change_file_type",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_save.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test EditorStack.save_as() when changing the file type.\n\n    Regression test for spyder-ide/spyder#13085.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditorstack.tabs.setCurrentIndex(1)\nassert editorstack.get_current_filename() == 'secondtab.py'\neditor = editorstack.get_current_editor()\nmocker.patch.object(editor, 'notify_close')\neditorstack.sig_open_file = Mock()\nnew_filename = osp.join(tmpdir.strpath, 'foo.R')\nmocker.patch.object(editorstack, 'select_savename', return_value=new_filename)\nassert not osp.exists(new_filename)\nassert editorstack.save_as() is True\nassert editorstack.get_filenames() == ['foo.py', new_filename, __file__]\nassert osp.exists(new_filename)\nassert editor.language == 'R'\nassert editor.highlighter_class._lexer.name == 'S'\nassert editor.notify_close.call_count == 1\nassert editorstack.sig_open_file.emit.called == 1\ndebugger_panel = editor.panels.get(DebuggerPanel)\nassert not debugger_panel.isVisible()\npytest.mark.show_save_dialog",
        "CUT_1": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "make_indent",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_indentation.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Indent and return code.\"\"\"\neditor.go_to_line(start_line)\nif not single_line:\n    editor.moveCursor(QTextCursor.End, mode=QTextCursor.KeepAnchor)\neditor.indent()\ntext = editor.toPlainText()\nreturn to_text_string(text)\n",
        "CUT_1": "\"\"\"Indent current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.indent()\nSlot()",
        "CUT_2": "\"\"\"Indent current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.indent()\nSlot()",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n"
    },
    {
        "functionName": "make_unindent",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_indentation.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Unindent and return code.\"\"\"\neditor.go_to_line(start_line)\nif not single_line:\n    editor.moveCursor(QTextCursor.End, mode=QTextCursor.KeepAnchor)\neditor.unindent()\ntext = editor.toPlainText()\nreturn to_text_string(text)\n",
        "CUT_1": "\"\"\"Unindent current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.unindent()\nSlot()",
        "CUT_2": "\"\"\"Unindent current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.unindent()\nSlot()",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n"
    },
    {
        "functionName": "code_editor_indent_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_indentation.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Setup CodeEditor with some text useful for folding related tests.\n    \"\"\"\neditor = CodeEditor(parent=None)\nindent_chars = ' ' * 2\ntab_stop_width_spaces = 4\nlanguage = 'Python'\neditor.setup_editor(language=language, indent_chars=indent_chars,\n    tab_stop_width_spaces=tab_stop_width_spaces)\nreturn editor, qtbot\npytest.fixture",
        "CUT_1": "self.indent_chars = indent_chars\n",
        "CUT_2": "self.indent_chars = indent_chars\n",
        "CUT_3": "self.tab_stop_width_spaces = tab_stop_width_spaces\nif self.data:\n    for finfo in self.data:\n        finfo.editor.tab_stop_width_spaces = tab_stop_width_spaces\n        finfo.editor.update_tab_stop_width_spaces()\n",
        "CUT_4": "self.tab_stop_width_spaces = tab_stop_width_spaces\nif self.data:\n    for finfo in self.data:\n        finfo.editor.tab_stop_width_spaces = tab_stop_width_spaces\n        finfo.editor.update_tab_stop_width_spaces()\n",
        "CUT_5": "indent_chars = indent_chars[1:-1]\nself.indent_chars = indent_chars\nif self.data:\n    for finfo in self.data:\n        finfo.editor.set_indent_chars(indent_chars)\n"
    },
    {
        "functionName": "test_single_line_indent",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_indentation.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test indentation in a single line.\"\"\"\neditor, qtbot = code_editor_indent_bot\ntext = \"\"\"class a():\nself.b = 1\nprint(self.b)\n\n\"\"\"\nexpected = \"\"\"class a():\n  self.b = 1\nprint(self.b)\n\n\"\"\"\neditor.set_text(text)\nnew_text = make_indent(editor, start_line=2)\nassert new_text == expected\n",
        "CUT_1": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_2": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_3": "\"\"\"Update style of labels that include rich text and html links.\"\"\"\nlink = 'text-decoration:none;'\nlink_hovered = 'text-decoration:underline;'\nself._url = url\nif url:\n    QApplication.setOverrideCursor(QCursor(Qt.PointingHandCursor))\n    new_text, old_text = link_hovered, link\nelse:\n    new_text, old_text = link, link_hovered\n    QApplication.restoreOverrideCursor()\ntext = self.text()\nnew_text = text.replace(old_text, new_text)\nself.setText(new_text)\n",
        "CUT_4": "\"\"\"Update style of labels that include rich text and html links.\"\"\"\nlink = 'text-decoration:none;'\nlink_hovered = 'text-decoration:underline;'\nself._url = url\nif url:\n    QApplication.setOverrideCursor(QCursor(Qt.PointingHandCursor))\n    new_text, old_text = link_hovered, link\nelse:\n    new_text, old_text = link, link_hovered\n    QApplication.restoreOverrideCursor()\ntext = self.text()\nnew_text = text.replace(old_text, new_text)\nself.setText(new_text)\n",
        "CUT_5": "\"\"\"Edit text of current selected association.\"\"\"\nold_text = self.current_extension\nself._dlg_input.set_text(old_text)\nif self._dlg_input.exec_():\n    new_text = self._dlg_input.text()\n    if old_text != new_text:\n        values = self._data.pop(self.current_extension)\n        self._data[new_text] = values\n        self._update_extensions()\n        self._refresh()\n        for row in range(self.list_extensions.count()):\n            item = self.list_extensions.item(row)\n            if item.text() == new_text:\n                self.list_extensions.setCurrentItem(item)\n                break\n        self.check_data_changed()\n"
    },
    {
        "functionName": "test_selection_indent",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_indentation.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test indentation with selection of more than one line.\"\"\"\neditor, qtbot = code_editor_indent_bot\ntext = \"\"\"class a():\nself.b = 1\nprint(self.b)\n\n\"\"\"\nexpected = \"\"\"class a():\n  self.b = 1\n  print(self.b)\n  \n\"\"\"\neditor.set_text(text)\nnew_text = make_indent(editor, single_line=False, start_line=2)\nassert new_text == expected\n",
        "CUT_1": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_2": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_3": "\"\"\"Update style of labels that include rich text and html links.\"\"\"\nlink = 'text-decoration:none;'\nlink_hovered = 'text-decoration:underline;'\nself._url = url\nif url:\n    QApplication.setOverrideCursor(QCursor(Qt.PointingHandCursor))\n    new_text, old_text = link_hovered, link\nelse:\n    new_text, old_text = link, link_hovered\n    QApplication.restoreOverrideCursor()\ntext = self.text()\nnew_text = text.replace(old_text, new_text)\nself.setText(new_text)\n",
        "CUT_4": "\"\"\"Update style of labels that include rich text and html links.\"\"\"\nlink = 'text-decoration:none;'\nlink_hovered = 'text-decoration:underline;'\nself._url = url\nif url:\n    QApplication.setOverrideCursor(QCursor(Qt.PointingHandCursor))\n    new_text, old_text = link_hovered, link\nelse:\n    new_text, old_text = link, link_hovered\n    QApplication.restoreOverrideCursor()\ntext = self.text()\nnew_text = text.replace(old_text, new_text)\nself.setText(new_text)\n",
        "CUT_5": "\"\"\"\n        Replace an entire line with ``new_text``.\n\n        :param line_nbr: line number of the line to change.\n        :param new_text: The replacement text.\n\n        \"\"\"\neditor = self._editor\ntext_cursor = self._move_cursor_to(line_nbr)\ntext_cursor.select(text_cursor.LineUnderCursor)\ntext_cursor.insertText(new_text)\neditor.setTextCursor(text_cursor)\n"
    },
    {
        "functionName": "test_fix_indentation",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_indentation.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test fix_indentation() method.\"\"\"\neditor, qtbot = code_editor_indent_bot\noriginal = \"\"\"\t\nclass a():\t\n\tself.b = 1\n\tprint(self.b)\n\n\"\"\"\nfixed = \"\"\"  \nclass a():  \n  self.b = 1\n  print(self.b)\n\n\"\"\"\neditor.set_text(original)\neditor.fix_indentation()\nassert to_text_string(editor.toPlainText()) == fixed\nassert editor.document().isModified()\neditor.undo()\nassert to_text_string(editor.toPlainText()) == original\nassert not editor.document().isModified()\neditor.redo()\nassert to_text_string(editor.toPlainText()) == fixed\nassert editor.document().isModified()\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_single_line_unindent",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_indentation.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test unindentation in a single line.\"\"\"\neditor, qtbot = code_editor_indent_bot\ntext = \"\"\"class a():\n  self.b = 1\nprint(self.b)\n\n\"\"\"\nexpected = \"\"\"class a():\nself.b = 1\nprint(self.b)\n\n\"\"\"\neditor.set_text(text)\nnew_text = make_unindent(editor, start_line=2)\nassert new_text == expected\n",
        "CUT_1": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_2": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_3": "\"\"\"Update style of labels that include rich text and html links.\"\"\"\nlink = 'text-decoration:none;'\nlink_hovered = 'text-decoration:underline;'\nself._url = url\nif url:\n    QApplication.setOverrideCursor(QCursor(Qt.PointingHandCursor))\n    new_text, old_text = link_hovered, link\nelse:\n    new_text, old_text = link, link_hovered\n    QApplication.restoreOverrideCursor()\ntext = self.text()\nnew_text = text.replace(old_text, new_text)\nself.setText(new_text)\n",
        "CUT_4": "\"\"\"Update style of labels that include rich text and html links.\"\"\"\nlink = 'text-decoration:none;'\nlink_hovered = 'text-decoration:underline;'\nself._url = url\nif url:\n    QApplication.setOverrideCursor(QCursor(Qt.PointingHandCursor))\n    new_text, old_text = link_hovered, link\nelse:\n    new_text, old_text = link, link_hovered\n    QApplication.restoreOverrideCursor()\ntext = self.text()\nnew_text = text.replace(old_text, new_text)\nself.setText(new_text)\n",
        "CUT_5": "\"\"\"Edit text of current selected association.\"\"\"\nold_text = self.current_extension\nself._dlg_input.set_text(old_text)\nif self._dlg_input.exec_():\n    new_text = self._dlg_input.text()\n    if old_text != new_text:\n        values = self._data.pop(self.current_extension)\n        self._data[new_text] = values\n        self._update_extensions()\n        self._refresh()\n        for row in range(self.list_extensions.count()):\n            item = self.list_extensions.item(row)\n            if item.text() == new_text:\n                self.list_extensions.setCurrentItem(item)\n                break\n        self.check_data_changed()\n"
    },
    {
        "functionName": "test_selection_unindent",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_indentation.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test unindentation with selection of more than one line.\"\"\"\neditor, qtbot = code_editor_indent_bot\ntext = \"\"\"class a():\n  self.b = 1\n  print(self.b)\n  \n\"\"\"\nexpected = \"\"\"class a():\nself.b = 1\nprint(self.b)\n\n\"\"\"\neditor.set_text(text)\nnew_text = make_unindent(editor, single_line=False, start_line=2)\nassert new_text == expected\n",
        "CUT_1": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_2": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_3": "\"\"\"Update style of labels that include rich text and html links.\"\"\"\nlink = 'text-decoration:none;'\nlink_hovered = 'text-decoration:underline;'\nself._url = url\nif url:\n    QApplication.setOverrideCursor(QCursor(Qt.PointingHandCursor))\n    new_text, old_text = link_hovered, link\nelse:\n    new_text, old_text = link, link_hovered\n    QApplication.restoreOverrideCursor()\ntext = self.text()\nnew_text = text.replace(old_text, new_text)\nself.setText(new_text)\n",
        "CUT_4": "\"\"\"Update style of labels that include rich text and html links.\"\"\"\nlink = 'text-decoration:none;'\nlink_hovered = 'text-decoration:underline;'\nself._url = url\nif url:\n    QApplication.setOverrideCursor(QCursor(Qt.PointingHandCursor))\n    new_text, old_text = link_hovered, link\nelse:\n    new_text, old_text = link, link_hovered\n    QApplication.restoreOverrideCursor()\ntext = self.text()\nnew_text = text.replace(old_text, new_text)\nself.setText(new_text)\n",
        "CUT_5": "\"\"\"\n        Replace an entire line with ``new_text``.\n\n        :param line_nbr: line number of the line to change.\n        :param new_text: The replacement text.\n\n        \"\"\"\neditor = self._editor\ntext_cursor = self._move_cursor_to(line_nbr)\ntext_cursor.select(text_cursor.LineUnderCursor)\ntext_cursor.insertText(new_text)\neditor.setTextCursor(text_cursor)\n"
    },
    {
        "functionName": "test_single_line_unindent_to_grid",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_indentation.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test unindentation in a single line.\"\"\"\neditor, qtbot = code_editor_indent_bot\ntext = \"\"\"class a():\n   self.b = 1\nprint(self.b)\n\n\"\"\"\nexpected = \"\"\"class a():\n  self.b = 1\nprint(self.b)\n\n\"\"\"\neditor.set_text(text)\nnew_text = make_unindent(editor, start_line=2)\nassert new_text == expected\nexpected2 = \"\"\"class a():\nself.b = 1\nprint(self.b)\n\n\"\"\"\nnew_text2 = make_unindent(editor, start_line=2)\nassert new_text2 == expected2\n",
        "CUT_1": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_2": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "for i in range(3):\n    print(i)\n"
    },
    {
        "functionName": "test_selection_unindent_to_grid",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_indentation.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test unindentation with selection of more than one line.\"\"\"\neditor, qtbot = code_editor_indent_bot\ntext = \"\"\"class a():\n   self.b = 1\n   print(self.b)\n\n\"\"\"\nexpected = \"\"\"class a():\n  self.b = 1\n  print(self.b)\n\n\"\"\"\neditor.set_text(text)\nnew_text = make_unindent(editor, single_line=False, start_line=2)\nassert new_text == expected\nexpected2 = \"\"\"class a():\nself.b = 1\nprint(self.b)\n\n\"\"\"\nnew_text2 = make_unindent(editor, single_line=False, start_line=2)\nassert new_text2 == expected2\n",
        "CUT_1": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_2": "\"\"\"Set the filter text.\"\"\"\ntext = text.strip()\nnew_text = self.text() + text\nself.setText(new_text)\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "editorbot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = codeeditor.CodeEditor(None)\nwidget.setup_editor(linenumbers=True, markers=True, tab_mode=False, font=\n    QFont('Courier New', 10), show_blanks=True, color_scheme='Zenburn',\n    scroll_past_end=True)\nwidget.setup_editor(language='Python')\nqtbot.addWidget(widget)\nwidget.show()\nreturn qtbot, widget\npytest.fixture",
        "CUT_1": "QSplitter.__init__(self, parent)\nself.editor = CodeEditor(self)\nself.editor.setup_editor(linenumbers=True, markers=True, tab_mode=False,\n    font=QFont('Courier New', 10), show_blanks=True, color_scheme='Zenburn')\nself.addWidget(self.editor)\nself.setWindowIcon(ima.icon('spyder'))\n",
        "CUT_2": "QSplitter.__init__(self, parent)\nself.editor = CodeEditor(self)\nself.editor.setup_editor(linenumbers=True, markers=True, tab_mode=False,\n    font=QFont('Courier New', 10), show_blanks=True, color_scheme='Zenburn')\nself.addWidget(self.editor)\nself.setWindowIcon(ima.icon('spyder'))\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "test_editor_upper_to_lower",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, widget = editorbot\ntext = 'UPPERCASE'\nwidget.set_text(text)\ncursor = widget.textCursor()\ncursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor)\nwidget.setTextCursor(cursor)\nwidget.transform_to_lowercase()\nnew_text = widget.get_text('sof', 'eof')\nassert text != new_text\n",
        "CUT_1": "\"\"\"Append text to the end of the text widget\"\"\"\ncursor = self.textCursor()\ncursor.movePosition(QTextCursor.End)\ncursor.insertText(text)\nself.document_did_change()\n",
        "CUT_2": "\"\"\"Append text to the end of the text widget\"\"\"\ncursor = self.textCursor()\ncursor.movePosition(QTextCursor.End)\ncursor.insertText(text)\nself.document_did_change()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "test_editor_lower_to_upper",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, widget = editorbot\ntext = 'uppercase'\nwidget.set_text(text)\ncursor = widget.textCursor()\ncursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor)\nwidget.setTextCursor(cursor)\nwidget.transform_to_uppercase()\nnew_text = widget.get_text('sof', 'eof')\nassert text != new_text\n",
        "CUT_1": "\"\"\"Append text to the end of the text widget\"\"\"\ncursor = self.textCursor()\ncursor.movePosition(QTextCursor.End)\ncursor.insertText(text)\nself.document_did_change()\n",
        "CUT_2": "\"\"\"Append text to the end of the text widget\"\"\"\ncursor = self.textCursor()\ncursor.movePosition(QTextCursor.End)\ncursor.insertText(text)\nself.document_did_change()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "test_editor_log_lsp_handle_errors",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the lsp error handling / dialog report Python 2.\"\"\"\nqtbot, widget = editorbot\nparams = {'params': {'activeParameter': 'boo', 'signatures': {\n    'documentation': b'\\x81', 'label': 'foo', 'parameters': {'boo': {\n    'documentation': b'\\x81', 'label': 'foo'}}}}}\nwidget.process_signatures(params)\ncaptured = capsys.readouterr()\ntest_1 = 'Error when processing signature' in captured.err\ntest_2 = \"codec can't decode byte 0x81\" in captured.err\nassert test_1 or test_2\npytest.mark.skipif(PY3, reason='Test only makes sense on Python 2.')",
        "CUT_1": "return 'Boo'\nstaticmethod",
        "CUT_2": "return 'Boo'\nstaticmethod",
        "CUT_3": "params = {'textDocument': {'uri': path_as_uri(params['file'])}, 'reason':\n    params['reason']}\nreturn params\nsend_notification(method=LSPRequestTypes.DOCUMENT_WILL_SAVE)",
        "CUT_4": "params = {'textDocument': {'uri': path_as_uri(params['file'])}, 'reason':\n    params['reason']}\nreturn params\nsend_notification(method=LSPRequestTypes.DOCUMENT_WILL_SAVE)",
        "CUT_5": "params = None\nif response is not None:\n    calls = response['calls']\n    if len(calls) > 0:\n        call = calls[0]\n        callee = call['callee']\n        documentation = callee['synopsis']\n        call_label = callee['repr']\n        signatures = call['signatures']\n        arg_idx = call['arg_index']\n        parameters = []\n        names = []\n        logger.debug(signatures)\n        if len(signatures) > 0:\n            signature = signatures[0]\n            logger.debug(signature)\n            if signature['args'] is not None:\n                for arg in signature['args']:\n                    parameters.append({'label': arg['name'],\n                        'documentation': ''})\n                    names.append(arg['name'])\n            func_args = ', '.join(names)\n            call_label = '{0}({1})'.format(call_label, func_args)\n        base_signature = {'label': call_label, 'documentation':\n            documentation, 'parameters': parameters}\n        params = {'signatures': base_signature, 'activeSignature': 0,\n            'activeParameter': arg_idx, 'provider': KITE_COMPLETION}\nreturn {'params': params}\nhandles(LSPRequestTypes.DOCUMENT_SIGNATURE)"
    },
    {
        "functionName": "test_editor_rstrip_keypress",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that whitespace is removed when leaving a line.\n    \"\"\"\nqtbot, widget = editorbot\nwidget.strip_trailing_spaces_on_modify = strip_all\nwidget.set_text(input_text)\ncursor = widget.textCursor()\ncursor.movePosition(QTextCursor.End)\nwidget.setTextCursor(cursor)\nfor key in keys:\n    if isinstance(key, tuple):\n        button, position = key\n        cursor = widget.textCursor()\n        cursor.setPosition(position)\n        xypos = widget.cursorRect(cursor).center()\n        widget.mousePressEvent(QMouseEvent(QEvent.MouseButtonPress, xypos,\n            button, button, Qt.NoModifier))\n    else:\n        qtbot.keyPress(widget, key)\nassert widget.toPlainText() == expected_text\npytest.mark.skipif(PY2, reason=\"Python 2 strings don't have attached encoding.\"\n    )pytest.mark.parametrize('input_text, expected_text, keys, strip_all', [(\n    'for i in range(2): ', \"\"\"for i in range(2): \n    \n     \n    \"\"\", [Qt.\n    Key_Enter, Qt.Key_Enter, ' ', Qt.Key_Enter], False), (\n    'for i in range(2): ', \"\"\"for i in range(2):\n\n    \"\"\", [Qt.Key_Enter,\n    Qt.Key_Enter], True), ('myvar = 2 ', 'myvar = 2\\n', [Qt.Key_Enter],\n    True), (\"\"\"somecode = 1\nmyvar = 2 \nmyvar = 3\"\"\",\n    \"\"\"somecode = 1\nmyvar = 2 \nmyvar = 3\"\"\", [' ', Qt.Key_Up, Qt.Key_Up],\n    True), (\"\"\"somecode = 1\nmyvar = 2 \"\"\", \"\"\"somecode = 1\nmyvar = 2 \"\"\", [\n    Qt.Key_Left], True), ('\"\"\"This is a string with important spaces\\n    ',\n    \"\"\"\"\"\\\"This is a string with important spaces\n    \n\"\"\", [Qt.Key_Enter],\n    True), ('\"\"\"string   ', '\"\"\"string   \\n', [Qt.Key_Enter], True), (\n    \"\"\"somecode = 1\nmyvar = 2\"\"\", \"\"\"somecode = 1\nmyvar = 2\"\"\", [' ', (Qt.\n    LeftButton, 0)], True), (\"\"\"somecode = 1\nmyvar = 2\"\"\",\n    \"\"\"somecode = 1\nmyvar = 2 \"\"\", [' ', (Qt.LeftButton, 23)], True), (\n    'a=1\\na=2 \\na=3', 'a=1\\na=2 \\na=3', [(Qt.LeftButton, 6), Qt.Key_Up],\n    True), (\"\"\"def fun():\n    \"\"\\\"fun\"\"\",\n    \"\"\"def fun():\n    \"\"\\\"fun\n\n    \"\"\", [Qt.Key_Enter, Qt.Key_Enter], True),\n    (\"\"\"def fun():\n    \"\"\\\"fun\"\"\", \"\"\"def fun():\n    \"\"\\\"fun\n    \n    \"\"\",\n    [Qt.Key_Enter, Qt.Key_Enter], False), (\"('\ud83d\udeab')\", \"('\ud83d\udeab')\\n\", [Qt.\n    Key_Enter], True), ('def fun():', \"\"\"def fun():\n\n    \"\"\", [Qt.Key_Enter,\n    Qt.Key_Enter], True), ('def fun():', 'def fun():\\n\\n\\n', [Qt.Key_Enter,\n    Qt.Key_Enter, Qt.Key_Enter], True), (\n    \"\"\"def fun():\n    i = 0\n# no indent\"\"\",\n    \"\"\"def fun():\n    i = 0\n# no indent\n\"\"\", [Qt.Key_Enter], True), (\n    \"\"\"if a:\n    def b():\n        i = 1\"\"\",\n    'if a:\\n    def b():\\n        i = 1\\n\\n    ', [Qt.Key_Enter, Qt.\n    Key_Enter, Qt.Key_Backspace], True)])",
        "CUT_1": "\"\"\"Qt Override.\"\"\"\nkey = event.key()\nif key in [Qt.Key_Enter, Qt.Key_Return]:\n    self.show_editor()\nelif key in [Qt.Key_Backtab]:\n    self.parent().reset_btn.setFocus()\nelif key in [Qt.Key_Up, Qt.Key_Down, Qt.Key_Left, Qt.Key_Right]:\n    super(SnippetTable, self).keyPressEvent(event)\nelse:\n    super(SnippetTable, self).keyPressEvent(event)\n",
        "CUT_2": "\"\"\"Qt Override.\"\"\"\nkey = event.key()\nif key in [Qt.Key_Enter, Qt.Key_Return]:\n    self.show_editor()\nelif key in [Qt.Key_Backtab]:\n    self.parent().reset_btn.setFocus()\nelif key in [Qt.Key_Up, Qt.Key_Down, Qt.Key_Left, Qt.Key_Right]:\n    super(SnippetTable, self).keyPressEvent(event)\nelse:\n    super(SnippetTable, self).keyPressEvent(event)\n",
        "CUT_3": "\"\"\"Qt Override.\"\"\"\nkey = event.key()\nif key in [Qt.Key_Enter, Qt.Key_Return]:\n    self.show_editor()\nelif key in [Qt.Key_Backtab]:\n    self.parent().reset_btn.setFocus()\nelif key in [Qt.Key_Up, Qt.Key_Down, Qt.Key_Left, Qt.Key_Right]:\n    super(LSPServerTable, self).keyPressEvent(event)\nelse:\n    super(LSPServerTable, self).keyPressEvent(event)\n",
        "CUT_4": "\"\"\"Qt Override.\"\"\"\nkey = event.key()\nif key in [Qt.Key_Enter, Qt.Key_Return]:\n    self.show_editor()\nelif key in [Qt.Key_Backtab]:\n    self.parent().reset_btn.setFocus()\nelif key in [Qt.Key_Up, Qt.Key_Down, Qt.Key_Left, Qt.Key_Right]:\n    super(LSPServerTable, self).keyPressEvent(event)\nelse:\n    super(LSPServerTable, self).keyPressEvent(event)\n",
        "CUT_5": "\"\"\" \"\"\"\nkey = event.key()\nself.key_pressed = key\nkeys = [Qt.Key_Right, Qt.Key_Left, Qt.Key_Down, Qt.Key_Up, Qt.Key_Escape,\n    Qt.Key_PageUp, Qt.Key_PageDown, Qt.Key_Home, Qt.Key_End, Qt.Key_Menu]\nif key in keys:\n    if not self.is_fade_running():\n        self.sig_key_pressed.emit()\n"
    },
    {
        "functionName": "test_in_string",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that in_string works correctly.\n    \"\"\"\nqtbot, widget = editorbot\nwidget.set_text(input_text + '\\n  ')\ncursor = widget.textCursor()\nfor blanks_enabled in [True, False]:\n    widget.set_blanks_enabled(blanks_enabled)\n    cursor.setPosition(len(input_text))\n    assert cursor.position() == len(input_text)\n    assert widget.in_string(cursor) == expected_state[0]\n    cursor.setPosition(len(input_text) + 3)\n    assert widget.in_string(cursor) == expected_state[1]\npytest.mark.parametrize('input_text, expected_state', [(\"'string \", [True,\n    False]), ('\"string ', [True, False]), (\"'string \\\\\", [True, True]), (\n    '\"string \\\\', [True, True]), (\"'string \\\\ \", [True, False]), (\n    '\"string \\\\ ', [True, False]), (\"'string ' \", [False, False]), (\n    '\"string \" ', [False, False]), ('\\'string \"', [True, False]), (\n    '\"string \\'', [True, False]), ('\\'string \" ', [True, False]), (\n    '\"string \\' ', [True, False]), (\"'''string \", [True, True]), (\n    '\"\"\"string ', [True, True]), (\"'''string \\\\\", [True, True]), (\n    '\"\"\"string \\\\', [True, True]), (\"'''string \\\\ \", [True, True]), (\n    '\"\"\"string \\\\ ', [True, True]), (\"'''string ''' \", [False, False]), (\n    '\"\"\"string \"\"\" ', [False, False]), ('\\'\\'\\'string \"\"\"', [True, True]),\n    ('\"\"\"string \\'\\'\\'', [True, True]), ('\\'\\'\\'string \"\"\" ', [True, True]),\n    ('\"\"\"string \\'\\'\\' ', [True, True])])",
        "CUT_1": "return str(string)\n",
        "CUT_2": "return str(string)\n",
        "CUT_3": "\"\"\"\n    Return a unicode version of string decoded using the file system encoding.\n    \"\"\"\nif not is_string(string):\n    string = to_text_string(string.toUtf8(), 'utf-8')\nelif is_binary_string(string):\n    try:\n        unic = string.decode(FS_ENCODING)\n    except (UnicodeError, TypeError):\n        pass\n    else:\n        return unic\nreturn string\n",
        "CUT_4": "\"\"\"\n    Return a unicode version of string decoded using the file system encoding.\n    \"\"\"\nif not is_string(string):\n    string = to_text_string(string.toUtf8(), 'utf-8')\nelif is_binary_string(string):\n    try:\n        unic = string.decode(FS_ENCODING)\n    except (UnicodeError, TypeError):\n        pass\n    else:\n        return unic\nreturn string\n",
        "CUT_5": "return True, ''\n"
    },
    {
        "functionName": "test_comment",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that in_string works correctly.\n    \"\"\"\nqtbot, widget = editorbot\nwidget.set_text('import numpy')\ncursor = widget.textCursor()\ncursor.setPosition(8)\ncursor.setPosition(11, QTextCursor.KeepAnchor)\nwidget.setTextCursor(cursor)\nwidget.toggle_comment()\nassert widget.toPlainText() == '# import numpy'\nwidget.toggle_comment()\nassert widget.toPlainText() == 'import numpy'\npytest.mark.skipif(PY2, reason=\"Doesn't work with python 2 on travis.\")",
        "CUT_1": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "cursor = self.textCursor()\ncursor.setPosition(start)\ncursor.setPosition(end, QTextCursor.KeepAnchor)\nself.setTextCursor(cursor)\n"
    },
    {
        "functionName": "test_undo_return",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that we can undo a return.\"\"\"\nqtbot, editor = editorbot\ntext = 'if True:\\n    0'\nreturned_text = \"\"\"if True:\n    0\n    \"\"\"\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.setPosition(14)\neditor.setTextCursor(cursor)\nqtbot.keyPress(editor, Qt.Key_Return)\nassert editor.toPlainText() == returned_text\nqtbot.keyPress(editor, 'z', modifier=Qt.ControlModifier)\nassert editor.toPlainText() == text\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n"
    },
    {
        "functionName": "base_editor_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack = EditorStack(None, [])\neditor_stack.set_find_widget(Mock())\neditor_stack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nreturn editor_stack\npytest.fixture",
        "CUT_1": "return Mock()\n",
        "CUT_2": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_3": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_4": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_5": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)"
    },
    {
        "functionName": "editor_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    The file in the editor is `foo.py` and has not been changed.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\neditor_stack = base_editor_bot\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\nfinfo = editor_stack.new('foo.py', 'utf-8', text)\nfinfo.newly_created = False\neditor_stack.autosave.file_hashes = {'foo.py': hash(text + '\\n')}\nqtbot.addWidget(editor_stack)\nreturn editor_stack, finfo.editor\npytest.fixture",
        "CUT_1": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_2": "\"\"\"\n        Create new filename with *encoding* and *text*\n        \"\"\"\nfinfo = self.create_new_editor(filename, encoding, text, set_current=False,\n    new=True)\nfinfo.editor.set_cursor_position('eof')\nif not empty:\n    finfo.editor.insert_text(os.linesep)\nif default_content:\n    finfo.default = True\n    finfo.editor.document().setModified(False)\nreturn finfo\n",
        "CUT_3": "\"\"\"\n        Create new filename with *encoding* and *text*\n        \"\"\"\nfinfo = self.create_new_editor(filename, encoding, text, set_current=False,\n    new=True)\nfinfo.editor.set_cursor_position('eof')\nif not empty:\n    finfo.editor.insert_text(os.linesep)\nif default_content:\n    finfo.default = True\n    finfo.editor.document().setModified(False)\nreturn finfo\n",
        "CUT_4": "\"\"\"Reload file from disk.\"\"\"\nfinfo = self.data[index]\nlogger.debug('Reloading {}'.format(finfo.filename))\ntxt, finfo.encoding = encoding.read(finfo.filename)\nfinfo.lastmodified = QFileInfo(finfo.filename).lastModified()\nposition = finfo.editor.get_position('cursor')\nfinfo.editor.set_text(txt)\nfinfo.editor.document().setModified(False)\nself.autosave.file_hashes[finfo.filename] = hash(txt)\nfinfo.editor.set_cursor_position(position)\nfinfo.editor.rehighlight()\n",
        "CUT_5": "\"\"\"Reload file from disk.\"\"\"\nfinfo = self.data[index]\nlogger.debug('Reloading {}'.format(finfo.filename))\ntxt, finfo.encoding = encoding.read(finfo.filename)\nfinfo.lastmodified = QFileInfo(finfo.filename).lastModified()\nposition = finfo.editor.get_position('cursor')\nfinfo.editor.set_text(txt)\nfinfo.editor.document().setModified(False)\nself.autosave.file_hashes[finfo.filename] = hash(txt)\nfinfo.editor.set_cursor_position(position)\nfinfo.editor.rehighlight()\n"
    },
    {
        "functionName": "editor_find_replace_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack = base_editor_bot\ntext = \"\"\"spam bacon\nspam sausage\nspam egg\"\"\"\nfinfo = editor_stack.new('spam.py', 'utf-8', text)\nfind_replace = FindReplace(None, enable_replace=True)\neditor_stack.set_find_widget(find_replace)\nfind_replace.set_editor(finfo.editor)\nqtbot.addWidget(editor_stack)\nqtbot.addWidget(find_replace)\nreturn editor_stack, finfo.editor, find_replace\npytest.fixture",
        "CUT_1": "code_editor, _ = lsp_codeeditor\nfind_replace = FindReplace(None, enable_replace=True)\nfind_replace.set_editor(code_editor)\nqtbot_module.addWidget(find_replace)\ndef teardown():\n    find_replace.hide()\nrequest.addfinalizer(teardown)\nreturn code_editor, find_replace\npytest.fixture",
        "CUT_2": "return 'spam'\nspam.eggs",
        "CUT_3": "\"\"\"Create shortcuts for this widget\"\"\"\nfindnext = CONF.config_shortcut(self.find_next, context='find_replace',\n    name='Find next', parent=parent)\nfindprev = CONF.config_shortcut(self.find_previous, context='find_replace',\n    name='Find previous', parent=parent)\ntogglefind = CONF.config_shortcut(self.show, context='find_replace', name=\n    'Find text', parent=parent)\ntogglereplace = CONF.config_shortcut(self.show_replace, context=\n    'find_replace', name='Replace text', parent=parent)\nhide = CONF.config_shortcut(self.hide, context='find_replace', name=\n    'hide find and replace', parent=self)\nreturn [findnext, findprev, togglefind, togglereplace, hide]\n",
        "CUT_4": "\"\"\"Create shortcuts for this widget\"\"\"\nfindnext = CONF.config_shortcut(self.find_next, context='find_replace',\n    name='Find next', parent=parent)\nfindprev = CONF.config_shortcut(self.find_previous, context='find_replace',\n    name='Find previous', parent=parent)\ntogglefind = CONF.config_shortcut(self.show, context='find_replace', name=\n    'Find text', parent=parent)\ntogglereplace = CONF.config_shortcut(self.show_replace, context=\n    'find_replace', name='Replace text', parent=parent)\nhide = CONF.config_shortcut(self.hide, context='find_replace', name=\n    'hide find and replace', parent=self)\nreturn [findnext, findprev, togglefind, togglereplace, hide]\n",
        "CUT_5": "\"\"\"\n        Create new filename with *encoding* and *text*\n        \"\"\"\nfinfo = self.create_new_editor(filename, encoding, text, set_current=False,\n    new=True)\nfinfo.editor.set_cursor_position('eof')\nif not empty:\n    finfo.editor.insert_text(os.linesep)\nif default_content:\n    finfo.default = True\n    finfo.editor.document().setModified(False)\nreturn finfo\n"
    },
    {
        "functionName": "editor_cells_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack = base_editor_bot\ntext = \"\"\"# %%\n# 1 cell\n# print(1)\n# %%\n# 2 cell\n# print(2)\n# %%\n# 3 cell\n# print(3)\n\"\"\"\nfinfo = editor_stack.new('cells.py', 'utf-8', text)\nfind_replace = FindReplace(None, enable_replace=True)\nqtbot.addWidget(editor_stack)\nreturn editor_stack, finfo.editor\npytest.fixture",
        "CUT_1": "for i in range(3):\n    print(i)\n",
        "CUT_2": "for i in range(3):\n    print(i)\n",
        "CUT_3": "for i in range(3):\n    print(i)\n",
        "CUT_4": "for i in range(3):\n    print(i)\n",
        "CUT_5": "for i in range(3):\n    print(i)\n"
    },
    {
        "functionName": "editor_folding_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Setup CodeEditor with some text useful for folding related tests.\n    \"\"\"\neditor_stack = base_editor_bot\ntext = \"\"\"# dummy test file\nclass a():\n    self.b = 1\n    print(self.b)\n    def c():\n        print(1)\n        return\n        \n\"\"\"\nfinfo = editor_stack.new('foo.py', 'utf-8', text)\nfind_replace = FindReplace(None, enable_replace=True)\neditor_stack.set_find_widget(find_replace)\nfind_replace.set_editor(finfo.editor)\nqtbot.addWidget(editor_stack)\nqtbot.addWidget(find_replace)\nreturn editor_stack, finfo.editor, find_replace\npytest.fixture",
        "CUT_1": "code_editor, _ = lsp_codeeditor\nfind_replace = FindReplace(None, enable_replace=True)\nfind_replace.set_editor(code_editor)\nqtbot_module.addWidget(find_replace)\ndef teardown():\n    find_replace.hide()\nrequest.addfinalizer(teardown)\nreturn code_editor, find_replace\npytest.fixture",
        "CUT_2": "\"\"\"Create shortcuts for this widget\"\"\"\nfindnext = CONF.config_shortcut(self.find_next, context='find_replace',\n    name='Find next', parent=parent)\nfindprev = CONF.config_shortcut(self.find_previous, context='find_replace',\n    name='Find previous', parent=parent)\ntogglefind = CONF.config_shortcut(self.show, context='find_replace', name=\n    'Find text', parent=parent)\ntogglereplace = CONF.config_shortcut(self.show_replace, context=\n    'find_replace', name='Replace text', parent=parent)\nhide = CONF.config_shortcut(self.hide, context='find_replace', name=\n    'hide find and replace', parent=self)\nreturn [findnext, findprev, togglefind, togglereplace, hide]\n",
        "CUT_3": "\"\"\"Create shortcuts for this widget\"\"\"\nfindnext = CONF.config_shortcut(self.find_next, context='find_replace',\n    name='Find next', parent=parent)\nfindprev = CONF.config_shortcut(self.find_previous, context='find_replace',\n    name='Find previous', parent=parent)\ntogglefind = CONF.config_shortcut(self.show, context='find_replace', name=\n    'Find text', parent=parent)\ntogglereplace = CONF.config_shortcut(self.show_replace, context=\n    'find_replace', name='Replace text', parent=parent)\nhide = CONF.config_shortcut(self.hide, context='find_replace', name=\n    'hide find and replace', parent=self)\nreturn [findnext, findprev, togglefind, togglereplace, hide]\n",
        "CUT_4": "\"\"\"\n        Create new filename with *encoding* and *text*\n        \"\"\"\nfinfo = self.create_new_editor(filename, encoding, text, set_current=False,\n    new=True)\nfinfo.editor.set_cursor_position('eof')\nif not empty:\n    finfo.editor.insert_text(os.linesep)\nif default_content:\n    finfo.default = True\n    finfo.editor.document().setModified(False)\nreturn finfo\n",
        "CUT_5": "\"\"\"\n        Create new filename with *encoding* and *text*\n        \"\"\"\nfinfo = self.create_new_editor(filename, encoding, text, set_current=False,\n    new=True)\nfinfo.editor.set_cursor_position('eof')\nif not empty:\n    finfo.editor.insert_text(os.linesep)\nif default_content:\n    finfo.default = True\n    finfo.editor.document().setModified(False)\nreturn finfo\n"
    },
    {
        "functionName": "test_find_number_matches",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test for number matches in find/replace.\"\"\"\neditor_stack, editor = setup_editor\neditor_stack.find_widget.case_button.setChecked(True)\ntext = \"\"\" test \nTEST \nTest \ntesT \"\"\"\neditor.set_text(text)\neditor_stack.find_widget.search_text.add_text('test')\neditor_stack.find_widget.find(changed=False, forward=True, rehighlight=\n    False, multiline_replace_check=False)\neditor_text = editor_stack.find_widget.number_matches_text.text()\nassert editor_text == '1 of 1'\neditor_stack.find_widget.search_text.add_text('fail')\neditor_stack.find_widget.find(changed=False, forward=True, rehighlight=\n    False, multiline_replace_check=False)\neditor_text = editor_stack.find_widget.number_matches_text.text()\nassert editor_text == 'no matches'\n",
        "CUT_1": "self.find_widget = find_widget\n",
        "CUT_2": "self.find_widget = find_widget\n",
        "CUT_3": "if state:\n    self.find_widget.show()\nelse:\n    self.find_widget.hide()\nSlot(bool)",
        "CUT_4": "if state:\n    self.find_widget.show()\nelse:\n    self.find_widget.hide()\nSlot(bool)",
        "CUT_5": "\"\"\"Find slot\"\"\"\neditorstack = self.get_current_editorstack()\neditorstack.find_widget.show()\neditorstack.find_widget.search_text.setFocus()\nSlot()"
    },
    {
        "functionName": "test_move_current_line_up",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = editor_bot\neditor.go_to_line(2)\neditor.move_line_up()\nexpected_new_text = \"\"\"print(a)\na = 1\n\nx = 2\n\"\"\"\nassert editor.toPlainText() == expected_new_text\neditor.move_line_up()\nassert editor.toPlainText() == expected_new_text\neditor.go_to_line(4)\neditor.moveCursor(QTextCursor.Right, QTextCursor.MoveAnchor)\nfor i in range(2):\n    editor.moveCursor(QTextCursor.Right, QTextCursor.KeepAnchor)\neditor.move_line_up()\nexpected_new_text = \"\"\"print(a)\na = 1\nx = 2\n\n\"\"\"\nassert editor.toPlainText()[:] == expected_new_text\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_move_current_line_down",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = editor_bot\neditor.go_to_line(4)\neditor.move_line_down()\nexpected_new_text = \"\"\"a = 1\nprint(a)\n\n\nx = 2\"\"\"\nassert editor.toPlainText() == expected_new_text\neditor.move_line_down()\nassert editor.toPlainText() == expected_new_text\neditor.go_to_line(1)\neditor.moveCursor(QTextCursor.Right, QTextCursor.MoveAnchor)\nfor i in range(2):\n    editor.moveCursor(QTextCursor.Right, QTextCursor.KeepAnchor)\neditor.move_line_down()\nexpected_new_text = \"\"\"print(a)\na = 1\n\n\nx = 2\"\"\"\nassert editor.toPlainText() == expected_new_text\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_move_multiple_lines_up",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = editor_bot\neditor.go_to_line(2)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Down, QTextCursor.KeepAnchor)\ncursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor)\neditor.setTextCursor(cursor)\neditor.move_line_up()\nexpected_new_text = \"\"\"print(a)\n\na = 1\nx = 2\n\"\"\"\nassert editor.toPlainText() == expected_new_text\neditor.move_line_up()\nassert editor.toPlainText() == expected_new_text\n",
        "CUT_1": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_2": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_3": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_4": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_5": "\"\"\"Extend current selection to complete lines\"\"\"\ncursor = self.textCursor()\nstart_pos, end_pos = cursor.selectionStart(), cursor.selectionEnd()\ncursor.setPosition(start_pos)\ncursor.setPosition(end_pos, QTextCursor.KeepAnchor)\nif cursor.atBlockStart():\n    cursor.movePosition(QTextCursor.PreviousBlock, QTextCursor.KeepAnchor)\n    cursor.movePosition(QTextCursor.EndOfBlock, QTextCursor.KeepAnchor)\nself.setTextCursor(cursor)\n"
    },
    {
        "functionName": "test_copy_lines_down_up",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that copy lines down and copy lines up are working as expected.\n    \"\"\"\neditorstack, editor = editor_bot\neditorstack.show()\nmocker.patch('spyder.plugins.editor.widgets.editor.osp.isfile',\n    returned_value=True)\neditorstack.go_to_line(1)\nassert editor.get_cursor_line_column() == (0, 0)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Down, QTextCursor.KeepAnchor)\ncursor.movePosition(QTextCursor.Down, QTextCursor.KeepAnchor)\neditor.setTextCursor(cursor)\nassert editor.get_cursor_line_column() == (2, 0)\nassert editor.textCursor().selection().toPlainText() == 'a = 1\\nprint(a)\\n'\neditor.duplicate_line_down()\nqtbot.wait(100)\nassert editor.get_cursor_line_column() == (4, 0)\nassert editor.textCursor().selection().toPlainText() == 'a = 1\\nprint(a)\\n'\nassert editor.toPlainText() == 'a = 1\\nprint(a)\\n' * 2 + '\\nx = 2\\n'\neditor.duplicate_line_up()\nqtbot.wait(100)\nassert editor.get_cursor_line_column() == (4, 0)\nassert editor.textCursor().selection().toPlainText() == 'a = 1\\nprint(a)\\n'\nassert editor.toPlainText() == 'a = 1\\nprint(a)\\n' * 3 + '\\nx = 2\\n'\npytest.mark.skipif(os.name == 'nt', reason='It fails on Windows')",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n"
    },
    {
        "functionName": "test_move_multiple_lines_down",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = editor_bot\neditor.go_to_line(3)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Down, QTextCursor.KeepAnchor)\ncursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor)\neditor.setTextCursor(cursor)\neditor.move_line_down()\nexpected_new_text = \"\"\"a = 1\nprint(a)\n\n\nx = 2\"\"\"\nassert editor.toPlainText() == expected_new_text\neditor.move_line_down()\nassert editor.toPlainText() == expected_new_text\n",
        "CUT_1": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_2": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_3": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_4": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_5": "\"\"\"Extend current selection to complete lines\"\"\"\ncursor = self.textCursor()\nstart_pos, end_pos = cursor.selectionStart(), cursor.selectionEnd()\ncursor.setPosition(start_pos)\ncursor.setPosition(end_pos, QTextCursor.KeepAnchor)\nif cursor.atBlockStart():\n    cursor.movePosition(QTextCursor.PreviousBlock, QTextCursor.KeepAnchor)\n    cursor.movePosition(QTextCursor.EndOfBlock, QTextCursor.KeepAnchor)\nself.setTextCursor(cursor)\n"
    },
    {
        "functionName": "test_run_top_line",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = editor_bot\neditor.go_to_line(1)\neditor.move_cursor(3)\nwith qtbot.waitSignal(editor_stack.exec_in_extconsole) as blocker:\n    editor_stack.run_selection()\nassert blocker.signal_triggered\nassert blocker.args[0] == 'a = 1'\nassert editor.get_cursor_line_column() == (1, 0)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"CodeEditor instance with LSP services activated.\"\"\"\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.sig_perform_completion_request.connect(lsp_plugin.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\nlsp_plugin.register_file('python', 'test.py', editor)\ncapabilities = lsp_plugin.main.editor.completion_capabilities['python']\neditor.start_completion_services()\neditor.register_completion_capabilities(capabilities)\nwith qtbot_module.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_open()\ndef teardown():\n    editor.completion_widget.hide()\n    editor.tooltip_widget.hide()\n    editor.hide()\n    sys_stream = capsys.readouterr()\n    sys_err = sys_stream.err\n    if PY2:\n        sys_err = to_text_string(sys_err).encode('utf-8')\n    assert sys_err == ''\nrequest.addfinalizer(teardown)\nlsp_plugin = lsp_plugin.get_client('lsp')\neditor.show()\nreturn editor, lsp_plugin\npytest.fixture",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_run_last_nonempty_line",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = editor_bot\neditor.go_to_line(4)\nwith qtbot.waitSignal(editor_stack.exec_in_extconsole) as blocker:\n    editor_stack.run_selection()\nassert blocker.signal_triggered\nassert blocker.args[0] == 'x = 2'\nassert editor.get_cursor_line_column() == (4, 0)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"CodeEditor instance with LSP services activated.\"\"\"\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.sig_perform_completion_request.connect(lsp_plugin.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\nlsp_plugin.register_file('python', 'test.py', editor)\ncapabilities = lsp_plugin.main.editor.completion_capabilities['python']\neditor.start_completion_services()\neditor.register_completion_capabilities(capabilities)\nwith qtbot_module.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_open()\ndef teardown():\n    editor.completion_widget.hide()\n    editor.tooltip_widget.hide()\n    editor.hide()\n    sys_stream = capsys.readouterr()\n    sys_err = sys_stream.err\n    if PY2:\n        sys_err = to_text_string(sys_err).encode('utf-8')\n    assert sys_err == ''\nrequest.addfinalizer(teardown)\nlsp_plugin = lsp_plugin.get_client('lsp')\neditor.show()\nreturn editor, lsp_plugin\npytest.fixture",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_run_empty_line_in_middle",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = editor_bot\neditor.go_to_line(3)\nwith qtbot.assertNotEmitted(editor_stack.exec_in_extconsole):\n    editor_stack.run_selection()\nassert editor.get_cursor_line_column() == (3, 0)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n"
    },
    {
        "functionName": "test_run_last_line_when_empty",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = editor_bot\nwith qtbot.assertNotEmitted(editor_stack.exec_in_extconsole):\n    editor_stack.run_selection()\nassert editor.get_cursor_line_column() == (4, 0)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_run_last_line_when_nonempty",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = editor_bot\neditor.stdkey_backspace()\nold_text = editor.toPlainText()\nwith qtbot.waitSignal(editor_stack.exec_in_extconsole) as blocker:\n    editor_stack.run_selection()\nassert blocker.signal_triggered\nassert blocker.args[0] == 'x = 2'\nexpected_new_text = old_text + editor.get_line_separator()\nassert editor.toPlainText() == expected_new_text\nassert editor.get_cursor_line_column() == (4, 0)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_find_replace_case_sensitive",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = setup_editor\neditor_stack.find_widget.case_button.setChecked(True)\ntext = \"\"\" test \nTEST \nTest \ntesT \"\"\"\neditor.set_text(text)\neditor_stack.find_widget.search_text.add_text('test')\neditor_stack.find_widget.replace_text.add_text('pass')\neditor_stack.find_widget.replace_find()\neditor_stack.find_widget.replace_find()\neditor_stack.find_widget.replace_find()\neditor_stack.find_widget.replace_find()\neditor_text = editor.toPlainText()\nassert editor_text == \"\"\" pass \nTEST \nTest \ntesT \"\"\"\n",
        "CUT_1": "self.find_widget = find_widget\n",
        "CUT_2": "self.find_widget = find_widget\n",
        "CUT_3": "if state:\n    self.find_widget.show()\nelse:\n    self.find_widget.hide()\nSlot(bool)",
        "CUT_4": "if state:\n    self.find_widget.show()\nelse:\n    self.find_widget.hide()\nSlot(bool)",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n"
    },
    {
        "functionName": "test_replace_current_selected_line",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor, finder = editor_find_replace_bot\nexpected_new_text = \"\"\"ham bacon\nspam sausage\nspam egg\"\"\"\nold_text = editor.toPlainText()\nfinder.show()\nfinder.show_replace()\nqtbot.keyClicks(finder.search_text, 'spam')\nqtbot.keyClicks(finder.replace_text, 'ham')\nqtbot.keyPress(finder.replace_text, Qt.Key_Return)\nassert editor.toPlainText()[0:-1] == expected_new_text\n",
        "CUT_1": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_2": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_3": "return 'spam'\nspam.eggs",
        "CUT_4": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_5": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n"
    },
    {
        "functionName": "test_replace_enter_press",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test advance forward pressing Enter, and backwards with Shift+Enter.\"\"\"\neditor_stack, editor, finder = editor_find_replace_bot\ntext = \"\"\"  \nspam \nspam \nspam \"\"\"\neditor.set_text(text)\nfinder.show()\nfinder.search_text.add_text('spam')\nqtbot.keyPress(finder.search_text, Qt.Key_Return)\nassert editor.get_cursor_line_column() == (1, 4)\nqtbot.keyPress(finder.search_text, Qt.Key_Return)\nassert editor.get_cursor_line_column() == (2, 4)\nqtbot.keyPress(finder.search_text, Qt.Key_Return)\nassert editor.get_cursor_line_column() == (3, 4)\nqtbot.keyPress(finder.search_text, Qt.Key_Return, modifier=Qt.ShiftModifier)\nassert editor.get_cursor_line_column() == (2, 4)\nqtbot.keyPress(finder.search_text, Qt.Key_Return, modifier=Qt.ShiftModifier)\nassert editor.get_cursor_line_column() == (1, 4)\nqtbot.keyPress(finder.search_text, Qt.Key_Return, modifier=Qt.ShiftModifier)\nassert editor.get_cursor_line_column() == (3, 4)\npytest.mark.skipif(sys.platform.startswith('linux'), reason='Fails in Linux')",
        "CUT_1": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_2": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_3": "\"\"\"Qt Override.\"\"\"\nkey = event.key()\nif key in [Qt.Key_Enter, Qt.Key_Return]:\n    self.show_editor()\nelif key in [Qt.Key_Tab]:\n    self.finder.setFocus()\nelif key in [Qt.Key_Backtab]:\n    self.parent().reset_btn.setFocus()\nelif key in [Qt.Key_Up, Qt.Key_Down, Qt.Key_Left, Qt.Key_Right]:\n    super(ShortcutsTable, self).keyPressEvent(event)\nelif key not in [Qt.Key_Escape, Qt.Key_Space]:\n    text = event.text()\n    if text:\n        if re.search(VALID_FINDER_CHARS, text) is not None:\n            self.finder.setFocus()\n            self.finder.set_text(text)\nelif key in [Qt.Key_Escape]:\n    self.finder.keyPressEvent(event)\n",
        "CUT_4": "\"\"\"Qt Override.\"\"\"\nkey = event.key()\nif key in [Qt.Key_Enter, Qt.Key_Return]:\n    self.show_editor()\nelif key in [Qt.Key_Tab]:\n    self.finder.setFocus()\nelif key in [Qt.Key_Backtab]:\n    self.parent().reset_btn.setFocus()\nelif key in [Qt.Key_Up, Qt.Key_Down, Qt.Key_Left, Qt.Key_Right]:\n    super(ShortcutsTable, self).keyPressEvent(event)\nelif key not in [Qt.Key_Escape, Qt.Key_Space]:\n    text = event.text()\n    if text:\n        if re.search(VALID_FINDER_CHARS, text) is not None:\n            self.finder.setFocus()\n            self.finder.set_text(text)\nelif key in [Qt.Key_Escape]:\n    self.finder.keyPressEvent(event)\n",
        "CUT_5": "\"\"\"Event filter for search_text widget.\n\n        Emits signals when presing Enter and Shift+Enter.\n        This signals are used for search forward and backward.\n        Also, a crude hack to get tab working in the Find/Replace boxes.\n        \"\"\"\nif event.type() == QEvent.KeyPress:\n    key = event.key()\n    shift = event.modifiers() & Qt.ShiftModifier\n    if key == Qt.Key_Return:\n        if shift:\n            self.return_shift_pressed.emit()\n        else:\n            self.return_pressed.emit()\n    if key == Qt.Key_Tab:\n        if self.search_text.hasFocus():\n            self.replace_text.set_current_text(self.search_text.currentText())\n        self.focusNextChild()\nreturn super(FindReplace, self).eventFilter(widget, event)\n"
    },
    {
        "functionName": "test_replace_plain_regex",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that regex reserved characters are displayed as plain text.\"\"\"\neditor_stack, editor, finder = editor_find_replace_bot\nexpected_new_text = \"\"\".\\\\[()]*test bacon\nspam sausage\nspam egg\"\"\"\nfinder.show()\nfinder.show_replace()\nqtbot.keyClicks(finder.search_text, 'spam')\nqtbot.keyClicks(finder.replace_text, '.\\\\[()]*test')\nqtbot.keyPress(finder.replace_text, Qt.Key_Return)\nassert editor.toPlainText()[0:-1] == expected_new_text\n",
        "CUT_1": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_2": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_3": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_4": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_5": "return 'spam'\nspam.eggs"
    },
    {
        "functionName": "test_replace_invalid_regex",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Assert that replacing an invalid regexp does nothing.\"\"\"\neditor_stack, editor, finder = editor_find_replace_bot\nold_text = editor.toPlainText()\nfinder.show()\nfinder.show_replace()\nqtbot.keyClicks(finder.search_text, '\\\\')\nqtbot.keyClicks(finder.replace_text, 'anything')\nif not finder.re_button.isChecked():\n    qtbot.mouseClick(finder.re_button, Qt.LeftButton)\nqtbot.mouseClick(finder.replace_button, Qt.LeftButton)\nassert editor.toPlainText() == old_text\nqtbot.mouseClick(finder.replace_sel_button, Qt.LeftButton)\nassert editor.toPlainText() == old_text\nqtbot.mouseClick(finder.replace_all_button, Qt.LeftButton)\nassert editor.toPlainText() == old_text\nqtbot.keyClicks(finder.search_text, 'anything')\nqtbot.keyClicks(finder.replace_text, '\\\\')\nqtbot.mouseClick(finder.replace_button, Qt.LeftButton)\nassert editor.toPlainText() == old_text\nqtbot.mouseClick(finder.replace_sel_button, Qt.LeftButton)\nassert editor.toPlainText() == old_text\nqtbot.mouseClick(finder.replace_all_button, Qt.LeftButton)\nassert editor.toPlainText() == old_text\n",
        "CUT_1": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_2": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_5": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n"
    },
    {
        "functionName": "test_replace_honouring_case",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor, finder = editor_find_replace_bot\nexpected_new_text = \"\"\"Spam bacon\nSpam sausage\nSpam egg\nSpam potatoes\"\"\"\nqtbot.keyClicks(editor, 'SpaM potatoes')\nfinder.show()\nfinder.show_replace()\nqtbot.keyClicks(finder.search_text, 'Spa[a-z]')\nqtbot.keyClicks(finder.replace_text, 'Spam')\nif not finder.re_button.isChecked():\n    qtbot.mouseClick(finder.re_button, Qt.LeftButton)\nif finder.case_button.isChecked():\n    qtbot.mouseClick(finder.case_button, Qt.LeftButton)\nqtbot.mouseClick(finder.replace_all_button, Qt.LeftButton)\nassert editor.toPlainText() == expected_new_text\n",
        "CUT_1": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_2": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_3": "return 'spam'\nspam.eggs",
        "CUT_4": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_5": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n"
    },
    {
        "functionName": "test_selection_escape_characters",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor, finder = editor_find_replace_bot\nexpected_new_text = \"\"\"spam bacon\nspam sausage\nspam egg\n\\\\n \\\\t some escape characters\"\"\"\nqtbot.keyClicks(editor, '\\\\n \\\\t escape characters')\nfinder.show()\nfinder.show_replace()\nqtbot.keyClicks(finder.search_text, 'escape')\nqtbot.keyClicks(finder.replace_text, 'some escape')\ncursor = editor.textCursor()\ncursor.select(QTextCursor.LineUnderCursor)\nassert cursor.selection().toPlainText() == '\\\\n \\\\t escape characters'\nfinder.replace_find_selection()\nassert cursor.selection().toPlainText() == '\\\\n \\\\t some escape characters'\nassert editor.toPlainText() == expected_new_text\n",
        "CUT_1": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_2": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_3": "return 'spam'\nspam.eggs",
        "CUT_4": "\"\"\"Action for ESCAPE key\"\"\"\nself.clear_line()\n",
        "CUT_5": "\"\"\"Action for ESCAPE key\"\"\"\nself.clear_line()\n"
    },
    {
        "functionName": "test_selection_backslash",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor, finder = editor_find_replace_bot\nexpected_new_text = \"\"\"spam bacon\nspam sausage\nspam egg\na = r\"\\\\left\\\\{\" + \"\\\\\\\\}\\\\\\\\right\\\\n\\\"\"\"\"\ntext_to_add = 'a = r\"\\\\leeft\\\\{\" + \"\\\\\\\\}\\\\\\\\right\\\\n\"'\nqtbot.keyClicks(editor, text_to_add)\nfinder.show()\nfinder.show_replace()\nqtbot.keyClicks(finder.search_text, 'leeft')\nqtbot.keyClicks(finder.replace_text, 'left')\ncursor = editor.textCursor()\ncursor.select(QTextCursor.LineUnderCursor)\nassert cursor.selection().toPlainText() == text_to_add\nfinder.replace_find_selection()\nassert editor.toPlainText() == expected_new_text\n",
        "CUT_1": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_2": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_3": "return 'spam'\nspam.eggs",
        "CUT_4": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_5": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n"
    },
    {
        "functionName": "test_advance_cell",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack, editor = editor_cells_bot\nassert editor.get_cursor_line_column() == (10, 0)\neditor_stack.advance_cell(reverse=True)\nassert editor.get_cursor_line_column() == (6, 0)\neditor_stack.advance_cell(reverse=True)\nassert editor.get_cursor_line_column() == (3, 0)\neditor_stack.advance_cell(reverse=True)\nassert editor.get_cursor_line_column() == (0, 0)\neditor_stack.advance_cell()\nassert editor.get_cursor_line_column() == (3, 0)\neditor_stack.advance_cell()\nassert editor.get_cursor_line_column() == (6, 0)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Run current cell and advance to the next one\"\"\"\nself.run_cell()\nself.advance_cell()\n",
        "CUT_4": "\"\"\"Run current cell and advance to the next one\"\"\"\nself.run_cell()\nself.advance_cell()\n",
        "CUT_5": "self.switch_to_plugin()\neditor = self.get_current_editor()\nposition = editor.go_to_next_warning()\nfilename = self.get_current_filename()\nline, column = editor.get_cursor_line_column()\nself.add_cursor_position_to_history(filename, position, line, column)\nSlot()"
    },
    {
        "functionName": "test_get_current_word",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test getting selected valid python word.\"\"\"\neditor_stack = base_editor_bot\ntext = \"\"\"some words with non-ascii  characters\nni\u00f1o\ngar\u00e7on\n\u03b1 alpha greek\n123valid_python_word\"\"\"\nfinfo = editor_stack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editor_stack)\neditor = finfo.editor\neditor.go_to_line(1)\neditor.moveCursor(QTextCursor.EndOfWord, QTextCursor.KeepAnchor)\nassert 'some' == editor.textCursor().selectedText()\nassert editor.get_current_word() == 'some'\neditor.go_to_line(2)\neditor.moveCursor(QTextCursor.EndOfWord, QTextCursor.KeepAnchor)\nassert 'ni\u00f1o' == editor.textCursor().selectedText()\nassert editor.get_current_word() == 'ni\u00f1o'\neditor.go_to_line(3)\neditor.moveCursor(QTextCursor.EndOfWord, QTextCursor.KeepAnchor)\nassert 'gar\u00e7on' == editor.textCursor().selectedText()\nassert editor.get_current_word() == 'gar\u00e7on'\neditor.go_to_line(4)\neditor.moveCursor(QTextCursor.EndOfWord, QTextCursor.KeepAnchor)\nassert '\u03b1' == editor.textCursor().selectedText()\nassert editor.get_current_word() == '\u03b1'\neditor.go_to_line(5)\neditor.moveCursor(QTextCursor.EndOfWord, QTextCursor.KeepAnchor)\nassert '123valid_python_word' == editor.textCursor().selectedText()\nassert editor.get_current_word() == 'valid_python_word'\npytest.mark.skipif(PY2, reason='Python2 does not support unicode very well')",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "if not self.has_selected_text():\n    self.moveCursor(QTextCursor.NextCharacter, QTextCursor.KeepAnchor)\nself.remove_selected_text()\n"
    },
    {
        "functionName": "test_tab_keypress_properly_caught_find_replace",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that tab works in find/replace dialog.\n\n    Regression test for spyder-ide/spyder#3674.\n    Mock test\u2014more isolated but less flimsy.\n    \"\"\"\neditor_stack, editor, finder = editor_find_replace_bot\ntext = \"\"\"  \nspam \nspam \nspam \"\"\"\neditor.set_text(text)\nfinder.show()\nfinder.show_replace()\nfinder.focusNextChild = MagicMock(name='focusNextChild')\nqtbot.keyPress(finder.search_text, Qt.Key_Tab)\nfinder.focusNextChild.assert_called_once_with()\n",
        "CUT_1": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_2": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_3": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_4": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_5": "return 'spam'\nspam.eggs"
    },
    {
        "functionName": "test_tab_moves_focus_from_search_to_replace",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that tab works in find/replace dialog.\n\n    Regression test for spyder-ide/spyder#3674.\n    \"Real world\" test\u2014more comprehensive but potentially less robust.\n    \"\"\"\neditor_stack, editor, finder = editor_find_replace_bot\ntext = \"\"\"  \nspam \nspam \nspam \"\"\"\neditor.set_text(text)\nfinder.show()\nfinder.show_replace()\nqtbot.wait(100)\nfinder.search_text.setFocus()\nqtbot.wait(100)\nassert finder.search_text.hasFocus()\nassert not finder.replace_text.hasFocus()\nqtbot.keyPress(finder.search_text, Qt.Key_Tab)\nqtbot.wait(100)\nassert not finder.search_text.hasFocus()\nassert finder.replace_text.hasFocus()\npytest.mark.skipif(sys.platform.startswith('linux'), reason='Fails on Linux')",
        "CUT_1": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_2": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_3": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_4": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_5": "\"\"\"Qt Override.\"\"\"\nkey = event.key()\nif key in [Qt.Key_Enter, Qt.Key_Return]:\n    self.show_editor()\nelif key in [Qt.Key_Tab]:\n    self.finder.setFocus()\nelif key in [Qt.Key_Backtab]:\n    self.parent().reset_btn.setFocus()\nelif key in [Qt.Key_Up, Qt.Key_Down, Qt.Key_Left, Qt.Key_Right]:\n    super(ShortcutsTable, self).keyPressEvent(event)\nelif key not in [Qt.Key_Escape, Qt.Key_Space]:\n    text = event.text()\n    if text:\n        if re.search(VALID_FINDER_CHARS, text) is not None:\n            self.finder.setFocus()\n            self.finder.set_text(text)\nelif key in [Qt.Key_Escape]:\n    self.finder.keyPressEvent(event)\n"
    },
    {
        "functionName": "test_tab_copies_find_to_replace",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Check that text in the find box is copied to the replace box on tab\n    keypress. Regression test spyder-ide/spyder#4482.\"\"\"\neditor_stack, editor, finder = editor_find_replace_bot\nfinder.show()\nfinder.show_replace()\nfinder.search_text.setFocus()\nfinder.search_text.set_current_text('This is some test text!')\nqtbot.wait(500)\nqtbot.keyClick(finder.search_text, Qt.Key_Tab)\nassert finder.replace_text.currentText() == 'This is some test text!'\npytest.mark.skipif(os.environ.get('CI', None) is not None, reason=\n    'It fails on CIs')",
        "CUT_1": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_2": "\"\"\"Handle showing/hiding the finder widget.\"\"\"\nself.finder.text_finder.setText('')\nself.finder.setVisible(set_visible)\nself.search_button.setChecked(set_visible)\nif self.finder.isVisible():\n    self.finder.text_finder.setFocus()\nelse:\n    self.editor.setFocus()\n",
        "CUT_3": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_4": "\"\"\"Update the regex text for the variable finder.\"\"\"\nif reset or not self.finder.text():\n    text = ''\nelse:\n    text = self.finder.text().replace(' ', '').lower()\nself.proxy_model.set_filter(text)\nself.source_model.update_search_letters(text)\nif text:\n    self.sortByColumn(4, Qt.DescendingOrder)\nself.last_regex = regex\n",
        "CUT_5": "\"\"\"Qt Override.\"\"\"\nkey = event.key()\nif key in [Qt.Key_Enter, Qt.Key_Return]:\n    self.show_editor()\nelif key in [Qt.Key_Tab]:\n    self.finder.setFocus()\nelif key in [Qt.Key_Backtab]:\n    self.parent().reset_btn.setFocus()\nelif key in [Qt.Key_Up, Qt.Key_Down, Qt.Key_Left, Qt.Key_Right]:\n    super(ShortcutsTable, self).keyPressEvent(event)\nelif key not in [Qt.Key_Escape, Qt.Key_Space]:\n    text = event.text()\n    if text:\n        if re.search(VALID_FINDER_CHARS, text) is not None:\n            self.finder.setFocus()\n            self.finder.set_text(text)\nelif key in [Qt.Key_Escape]:\n    self.finder.keyPressEvent(event)\n"
    },
    {
        "functionName": "test_autosave_all",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that `autosave_all()` calls maybe_autosave() on all open buffers.\n\n    The `editor_bot` fixture is constructed with one open file and the test\n    opens another one with `new()`, so maybe_autosave should be called twice.\n    \"\"\"\neditor_stack, editor = editor_bot\neditor_stack.new('ham.py', 'utf-8', '')\nmocker.patch.object(editor_stack.autosave, 'maybe_autosave')\neditor_stack.autosave.autosave_all()\nexpected_calls = [mocker.call(0), mocker.call(1)]\nactual_calls = editor_stack.autosave.maybe_autosave.call_args_list\nassert actual_calls == expected_calls\n",
        "CUT_1": "\"\"\"Autosave all opened files where necessary.\"\"\"\nfor index in range(self.stack.get_stack_count()):\n    self.maybe_autosave(index)\n",
        "CUT_2": "\"\"\"Autosave all opened files where necessary.\"\"\"\nfor index in range(self.stack.get_stack_count()):\n    self.maybe_autosave(index)\n",
        "CUT_3": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n",
        "CUT_4": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n",
        "CUT_5": "ignored, autosave = self.data[idx]\ntry:\n    os.remove(autosave['name'])\n    self.deactivate(idx)\nexcept EnvironmentError as error:\n    text = _('Unable to discard {}').format(autosave['name'])\n    self.report_error(text, error)\n"
    },
    {
        "functionName": "test_maybe_autosave",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that maybe_autosave() saves text to correct autosave file if contents\n    are changed.\n    \"\"\"\neditor_stack, editor = editor_bot\neditor.set_text('spam\\n')\neditor_stack.autosave.maybe_autosave(0)\nautosave_filename = os.path.join(get_conf_path('autosave'), 'foo.py')\nassert open(autosave_filename).read() == 'spam\\n'\nos.remove(autosave_filename)\n",
        "CUT_1": "\"\"\"\n        Remove autosave file for specified file.\n\n        This function also updates `self.name_mapping` and `self.file_hashes`.\n        If there is no autosave file, then the function returns without doing\n        anything.\n        \"\"\"\nif filename not in self.name_mapping:\n    return\nautosave_filename = self.name_mapping[filename]\ntry:\n    os.remove(autosave_filename)\nexcept EnvironmentError as error:\n    action = _('Error while removing autosave file {}').format(\n        autosave_filename)\n    msgbox = AutosaveErrorDialog(action, error)\n    msgbox.exec_if_enabled()\ndel self.name_mapping[filename]\ndel self.file_hashes[autosave_filename]\nself.save_autosave_mapping()\nlogger.debug('Removing autosave file %s', autosave_filename)\n",
        "CUT_2": "\"\"\"\n        Remove autosave file for specified file.\n\n        This function also updates `self.name_mapping` and `self.file_hashes`.\n        If there is no autosave file, then the function returns without doing\n        anything.\n        \"\"\"\nif filename not in self.name_mapping:\n    return\nautosave_filename = self.name_mapping[filename]\ntry:\n    os.remove(autosave_filename)\nexcept EnvironmentError as error:\n    action = _('Error while removing autosave file {}').format(\n        autosave_filename)\n    msgbox = AutosaveErrorDialog(action, error)\n    msgbox.exec_if_enabled()\ndel self.name_mapping[filename]\ndel self.file_hashes[autosave_filename]\nself.save_autosave_mapping()\nlogger.debug('Removing autosave file %s', autosave_filename)\n",
        "CUT_3": "\"\"\"\n        Create unique autosave file name for specified file name.\n\n        The created autosave file name does not yet exist either in\n        `self.name_mapping` or on disk.\n\n        Args:\n            filename (str): original file name\n            autosave_dir (str): directory in which autosave files are stored\n        \"\"\"\nbasename = osp.basename(filename)\nautosave_filename = osp.join(autosave_dir, basename)\nif autosave_filename in self.name_mapping.values() or osp.exists(\n    autosave_filename):\n    counter = 0\n    root, ext = osp.splitext(basename)\n    while autosave_filename in self.name_mapping.values() or osp.exists(\n        autosave_filename):\n        counter += 1\n        autosave_basename = '{}-{}{}'.format(root, counter, ext)\n        autosave_filename = osp.join(autosave_dir, autosave_basename)\nreturn autosave_filename\n",
        "CUT_4": "\"\"\"\n        Create unique autosave file name for specified file name.\n\n        The created autosave file name does not yet exist either in\n        `self.name_mapping` or on disk.\n\n        Args:\n            filename (str): original file name\n            autosave_dir (str): directory in which autosave files are stored\n        \"\"\"\nbasename = osp.basename(filename)\nautosave_filename = osp.join(autosave_dir, basename)\nif autosave_filename in self.name_mapping.values() or osp.exists(\n    autosave_filename):\n    counter = 0\n    root, ext = osp.splitext(basename)\n    while autosave_filename in self.name_mapping.values() or osp.exists(\n        autosave_filename):\n        counter += 1\n        autosave_basename = '{}-{}{}'.format(root, counter, ext)\n        autosave_filename = osp.join(autosave_dir, autosave_basename)\nreturn autosave_filename\n",
        "CUT_5": "\"\"\"\n        Get name of autosave file for specified file name.\n\n        This function uses the dict in `self.name_mapping`. If `filename` is\n        in the mapping, then return the corresponding autosave file name.\n        Otherwise, construct a unique file name and update the mapping.\n\n        Args:\n            filename (str): original file name\n        \"\"\"\ntry:\n    autosave_filename = self.name_mapping[filename]\nexcept KeyError:\n    autosave_dir = get_conf_path('autosave')\n    if not osp.isdir(autosave_dir):\n        try:\n            os.mkdir(autosave_dir)\n        except EnvironmentError as error:\n            action = _('Error while creating autosave directory')\n            msgbox = AutosaveErrorDialog(action, error)\n            msgbox.exec_if_enabled()\n    autosave_filename = self.create_unique_autosave_filename(filename,\n        autosave_dir)\n    self.name_mapping[filename] = autosave_filename\n    self.save_autosave_mapping()\n    logger.debug('New autosave file name')\nreturn autosave_filename\n"
    },
    {
        "functionName": "test_maybe_autosave_saves_only_if_changed",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that maybe_autosave() only saves text if text has changed.\n\n    The `editor_bot` fixture creates a clean editor, so the first call to\n    `maybe_autosave()` should not autosave. After call #2 we change the text,\n    so call #2 should autosave. The text is not changed after call #2, so\n    call #3 should not autosave.\n    \"\"\"\neditor_stack, editor = editor_bot\nmocker.patch.object(editor_stack, '_write_to_file')\neditor_stack.autosave.maybe_autosave(0)\nassert editor_stack._write_to_file.call_count == 0\neditor.set_text('ham\\n')\neditor_stack.autosave.maybe_autosave(0)\nassert editor_stack._write_to_file.call_count == 1\neditor_stack.autosave.maybe_autosave(0)\nassert editor_stack._write_to_file.call_count == 1\n",
        "CUT_1": "\"\"\"Autosave all opened files where necessary.\"\"\"\nfor index in range(self.stack.get_stack_count()):\n    self.maybe_autosave(index)\n",
        "CUT_2": "\"\"\"Autosave all opened files where necessary.\"\"\"\nfor index in range(self.stack.get_stack_count()):\n    self.maybe_autosave(index)\n",
        "CUT_3": "ignored, autosave = self.data[idx]\ntry:\n    os.remove(autosave['name'])\n    self.deactivate(idx)\nexcept EnvironmentError as error:\n    text = _('Unable to discard {}').format(autosave['name'])\n    self.report_error(text, error)\n",
        "CUT_4": "ignored, autosave = self.data[idx]\ntry:\n    os.remove(autosave['name'])\n    self.deactivate(idx)\nexcept EnvironmentError as error:\n    text = _('Unable to discard {}').format(autosave['name'])\n    self.report_error(text, error)\n",
        "CUT_5": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n"
    },
    {
        "functionName": "test_maybe_autosave_does_not_save_new_files",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that maybe_autosave() does not save newly created files.\"\"\"\neditor_stack, editor = editor_bot\neditor_stack.data[0].newly_created = True\nmocker.patch.object(editor_stack, '_write_to_file')\neditor_stack.autosave.maybe_autosave(0)\neditor_stack._write_to_file.assert_not_called()\n",
        "CUT_1": "\"\"\"Autosave all opened files where necessary.\"\"\"\nfor index in range(self.stack.get_stack_count()):\n    self.maybe_autosave(index)\n",
        "CUT_2": "\"\"\"Autosave all opened files where necessary.\"\"\"\nfor index in range(self.stack.get_stack_count()):\n    self.maybe_autosave(index)\n",
        "CUT_3": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n",
        "CUT_4": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n",
        "CUT_5": "\"\"\"Save all opened files.\n\n        Iterate through self.data and call save() on any modified files.\n        \"\"\"\nfor index in range(self.get_stack_count()):\n    if self.data[index].editor.document().isModified():\n        self.save(index, save_new_files=save_new_files)\n"
    },
    {
        "functionName": "test_opening_sets_file_hash",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that opening a file sets the file hash.\"\"\"\neditor_stack = base_editor_bot\nmocker.patch('spyder.plugins.editor.widgets.editor.encoding.read',\n    return_value=('my text', 42))\nfilename = osp.realpath('/mock-filename')\neditor_stack.load(filename)\nexpected = {filename: hash('my text')}\nassert editor_stack.autosave.file_hashes == expected\n",
        "CUT_1": "\"\"\"Set the text of the editor from file *fname*\"\"\"\nself.filename = filename\ntext, _enc = encoding.read(filename)\nif language is None:\n    language = get_file_language(filename, text)\nself.set_language(language, filename)\nself.set_text(text)\n",
        "CUT_2": "\"\"\"Set the text of the editor from file *fname*\"\"\"\nself.filename = filename\ntext, _enc = encoding.read(filename)\nif language is None:\n    language = get_file_language(filename, text)\nself.set_language(language, filename)\nself.set_text(text)\n",
        "CUT_3": "\"\"\"\n        Load filename, create an editor instance and return it\n\n        This also sets the hash of the loaded file in the autosave component.\n\n        *Warning* This is loading file, creating editor but not executing\n        the source code analysis -- the analysis must be done by the editor\n        plugin (in case multiple editorstack instances are handled)\n        \"\"\"\nfilename = osp.abspath(to_text_string(filename))\nif processevents:\n    self.starting_long_process.emit(_('Loading %s...') % filename)\ntext, enc = encoding.read(filename)\nself.autosave.file_hashes[filename] = hash(text)\nfinfo = self.create_new_editor(filename, enc, text, set_current, add_where=\n    add_where)\nindex = self.data.index(finfo)\nif processevents:\n    self.ending_long_process.emit('')\nif self.isVisible(\n    ) and self.checkeolchars_enabled and sourcecode.has_mixed_eol_chars(text):\n    name = osp.basename(filename)\n    self.msgbox = QMessageBox(QMessageBox.Warning, self.title, _(\n        '<b>%s</b> contains mixed end-of-line characters.<br>Spyder will fix this automatically.'\n        ) % name, QMessageBox.Ok, self)\n    self.msgbox.exec_()\n    self.set_os_eol_chars(index)\nself.is_analysis_done = False\nself.analyze_script(index)\nreturn finfo\n",
        "CUT_4": "\"\"\"\n        Load filename, create an editor instance and return it\n\n        This also sets the hash of the loaded file in the autosave component.\n\n        *Warning* This is loading file, creating editor but not executing\n        the source code analysis -- the analysis must be done by the editor\n        plugin (in case multiple editorstack instances are handled)\n        \"\"\"\nfilename = osp.abspath(to_text_string(filename))\nif processevents:\n    self.starting_long_process.emit(_('Loading %s...') % filename)\ntext, enc = encoding.read(filename)\nself.autosave.file_hashes[filename] = hash(text)\nfinfo = self.create_new_editor(filename, enc, text, set_current, add_where=\n    add_where)\nindex = self.data.index(finfo)\nif processevents:\n    self.ending_long_process.emit('')\nif self.isVisible(\n    ) and self.checkeolchars_enabled and sourcecode.has_mixed_eol_chars(text):\n    name = osp.basename(filename)\n    self.msgbox = QMessageBox(QMessageBox.Warning, self.title, _(\n        '<b>%s</b> contains mixed end-of-line characters.<br>Spyder will fix this automatically.'\n        ) % name, QMessageBox.Ok, self)\n    self.msgbox.exec_()\n    self.set_os_eol_chars(index)\nself.is_analysis_done = False\nself.analyze_script(index)\nreturn finfo\n",
        "CUT_5": "\"\"\"\n    Read text from file ('filename')\n    Return text and encoding\n    \"\"\"\ntext, encoding = decode(open(filename, 'rb').read())\nreturn text, encoding\n"
    },
    {
        "functionName": "test_reloading_updates_file_hash",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that reloading a file updates the file hash.\"\"\"\neditor_stack = base_editor_bot\nmocker.patch('spyder.plugins.editor.widgets.editor.encoding.read',\n    side_effect=[('my text', 42), ('new text', 42)])\nfilename = osp.realpath('/mock-filename')\nfinfo = editor_stack.load(filename)\nindex = editor_stack.data.index(finfo)\neditor_stack.reload(index)\nexpected = {filename: hash('new text')}\nassert editor_stack.autosave.file_hashes == expected\n",
        "CUT_1": "\"\"\"Reload file from disk.\"\"\"\nfinfo = self.data[index]\nlogger.debug('Reloading {}'.format(finfo.filename))\ntxt, finfo.encoding = encoding.read(finfo.filename)\nfinfo.lastmodified = QFileInfo(finfo.filename).lastModified()\nposition = finfo.editor.get_position('cursor')\nfinfo.editor.set_text(txt)\nfinfo.editor.document().setModified(False)\nself.autosave.file_hashes[finfo.filename] = hash(txt)\nfinfo.editor.set_cursor_position(position)\nfinfo.editor.rehighlight()\n",
        "CUT_2": "\"\"\"Reload file from disk.\"\"\"\nfinfo = self.data[index]\nlogger.debug('Reloading {}'.format(finfo.filename))\ntxt, finfo.encoding = encoding.read(finfo.filename)\nfinfo.lastmodified = QFileInfo(finfo.filename).lastModified()\nposition = finfo.editor.get_position('cursor')\nfinfo.editor.set_text(txt)\nfinfo.editor.document().setModified(False)\nself.autosave.file_hashes[finfo.filename] = hash(txt)\nfinfo.editor.set_cursor_position(position)\nfinfo.editor.rehighlight()\n",
        "CUT_3": "\"\"\"\n        Load filename, create an editor instance and return it\n\n        This also sets the hash of the loaded file in the autosave component.\n\n        *Warning* This is loading file, creating editor but not executing\n        the source code analysis -- the analysis must be done by the editor\n        plugin (in case multiple editorstack instances are handled)\n        \"\"\"\nfilename = osp.abspath(to_text_string(filename))\nif processevents:\n    self.starting_long_process.emit(_('Loading %s...') % filename)\ntext, enc = encoding.read(filename)\nself.autosave.file_hashes[filename] = hash(text)\nfinfo = self.create_new_editor(filename, enc, text, set_current, add_where=\n    add_where)\nindex = self.data.index(finfo)\nif processevents:\n    self.ending_long_process.emit('')\nif self.isVisible(\n    ) and self.checkeolchars_enabled and sourcecode.has_mixed_eol_chars(text):\n    name = osp.basename(filename)\n    self.msgbox = QMessageBox(QMessageBox.Warning, self.title, _(\n        '<b>%s</b> contains mixed end-of-line characters.<br>Spyder will fix this automatically.'\n        ) % name, QMessageBox.Ok, self)\n    self.msgbox.exec_()\n    self.set_os_eol_chars(index)\nself.is_analysis_done = False\nself.analyze_script(index)\nreturn finfo\n",
        "CUT_4": "\"\"\"\n        Load filename, create an editor instance and return it\n\n        This also sets the hash of the loaded file in the autosave component.\n\n        *Warning* This is loading file, creating editor but not executing\n        the source code analysis -- the analysis must be done by the editor\n        plugin (in case multiple editorstack instances are handled)\n        \"\"\"\nfilename = osp.abspath(to_text_string(filename))\nif processevents:\n    self.starting_long_process.emit(_('Loading %s...') % filename)\ntext, enc = encoding.read(filename)\nself.autosave.file_hashes[filename] = hash(text)\nfinfo = self.create_new_editor(filename, enc, text, set_current, add_where=\n    add_where)\nindex = self.data.index(finfo)\nif processevents:\n    self.ending_long_process.emit('')\nif self.isVisible(\n    ) and self.checkeolchars_enabled and sourcecode.has_mixed_eol_chars(text):\n    name = osp.basename(filename)\n    self.msgbox = QMessageBox(QMessageBox.Warning, self.title, _(\n        '<b>%s</b> contains mixed end-of-line characters.<br>Spyder will fix this automatically.'\n        ) % name, QMessageBox.Ok, self)\n    self.msgbox.exec_()\n    self.set_os_eol_chars(index)\nself.is_analysis_done = False\nself.analyze_script(index)\nreturn finfo\n",
        "CUT_5": "self._write_to_file(finfo, finfo.filename)\nfile_hash = self.compute_hash(finfo)\nself.autosave.file_hashes[finfo.filename] = file_hash\nself.autosave.remove_autosave_file(finfo.filename)\nfinfo.newly_created = False\nself.encoding_changed.emit(finfo.encoding)\nfinfo.lastmodified = QFileInfo(finfo.filename).lastModified()\nself.file_saved.emit(str(id(self)), finfo.filename, finfo.filename)\nfinfo.editor.document().setModified(False)\nself.modification_changed(index=index)\nself.analyze_script(index)\nfinfo.editor.notify_save()\n"
    },
    {
        "functionName": "test_closing_removes_file_hash",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that closing a file removes the file hash.\"\"\"\neditor_stack = base_editor_bot\nmocker.patch('spyder.plugins.editor.widgets.editor.encoding.read',\n    return_value=('my text', 42))\nfilename = osp.realpath('/mock-filename')\nfinfo = editor_stack.load(filename)\nindex = editor_stack.data.index(finfo)\neditor_stack.close_file(index)\nassert editor_stack.autosave.file_hashes == {}\n",
        "CUT_1": "\"\"\"Reload file from disk.\"\"\"\nfinfo = self.data[index]\nlogger.debug('Reloading {}'.format(finfo.filename))\ntxt, finfo.encoding = encoding.read(finfo.filename)\nfinfo.lastmodified = QFileInfo(finfo.filename).lastModified()\nposition = finfo.editor.get_position('cursor')\nfinfo.editor.set_text(txt)\nfinfo.editor.document().setModified(False)\nself.autosave.file_hashes[finfo.filename] = hash(txt)\nfinfo.editor.set_cursor_position(position)\nfinfo.editor.rehighlight()\n",
        "CUT_2": "\"\"\"Reload file from disk.\"\"\"\nfinfo = self.data[index]\nlogger.debug('Reloading {}'.format(finfo.filename))\ntxt, finfo.encoding = encoding.read(finfo.filename)\nfinfo.lastmodified = QFileInfo(finfo.filename).lastModified()\nposition = finfo.editor.get_position('cursor')\nfinfo.editor.set_text(txt)\nfinfo.editor.document().setModified(False)\nself.autosave.file_hashes[finfo.filename] = hash(txt)\nfinfo.editor.set_cursor_position(position)\nfinfo.editor.rehighlight()\n",
        "CUT_3": "self._write_to_file(finfo, finfo.filename)\nfile_hash = self.compute_hash(finfo)\nself.autosave.file_hashes[finfo.filename] = file_hash\nself.autosave.remove_autosave_file(finfo.filename)\nfinfo.newly_created = False\nself.encoding_changed.emit(finfo.encoding)\nfinfo.lastmodified = QFileInfo(finfo.filename).lastModified()\nself.file_saved.emit(str(id(self)), finfo.filename, finfo.filename)\nfinfo.editor.document().setModified(False)\nself.modification_changed(index=index)\nself.analyze_script(index)\nfinfo.editor.notify_save()\n",
        "CUT_4": "self._write_to_file(finfo, finfo.filename)\nfile_hash = self.compute_hash(finfo)\nself.autosave.file_hashes[finfo.filename] = file_hash\nself.autosave.remove_autosave_file(finfo.filename)\nfinfo.newly_created = False\nself.encoding_changed.emit(finfo.encoding)\nfinfo.lastmodified = QFileInfo(finfo.filename).lastModified()\nself.file_saved.emit(str(id(self)), finfo.filename, finfo.filename)\nfinfo.editor.document().setModified(False)\nself.modification_changed(index=index)\nself.analyze_script(index)\nfinfo.editor.notify_save()\n",
        "CUT_5": "\"\"\"\n        Load filename, create an editor instance and return it\n\n        This also sets the hash of the loaded file in the autosave component.\n\n        *Warning* This is loading file, creating editor but not executing\n        the source code analysis -- the analysis must be done by the editor\n        plugin (in case multiple editorstack instances are handled)\n        \"\"\"\nfilename = osp.abspath(to_text_string(filename))\nif processevents:\n    self.starting_long_process.emit(_('Loading %s...') % filename)\ntext, enc = encoding.read(filename)\nself.autosave.file_hashes[filename] = hash(text)\nfinfo = self.create_new_editor(filename, enc, text, set_current, add_where=\n    add_where)\nindex = self.data.index(finfo)\nif processevents:\n    self.ending_long_process.emit('')\nif self.isVisible(\n    ) and self.checkeolchars_enabled and sourcecode.has_mixed_eol_chars(text):\n    name = osp.basename(filename)\n    self.msgbox = QMessageBox(QMessageBox.Warning, self.title, _(\n        '<b>%s</b> contains mixed end-of-line characters.<br>Spyder will fix this automatically.'\n        ) % name, QMessageBox.Ok, self)\n    self.msgbox.exec_()\n    self.set_os_eol_chars(index)\nself.is_analysis_done = False\nself.analyze_script(index)\nreturn finfo\n"
    },
    {
        "functionName": "test_maybe_autosave_does_not_save_after_open",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that maybe_autosave() does not save files immediately after opening.\n\n    Files should only be autosaved after the user made changes.\n    Editors use different highlighters depending on the filename, so we test\n    both Python and text files. The latter covers spyder-ide/spyder#8654.\n    \"\"\"\neditor_stack = base_editor_bot\nmocker.patch('spyder.plugins.editor.widgets.editor.encoding.read',\n    return_value=('spam\\n', 42))\neditor_stack.load(filename)\nmocker.patch.object(editor_stack, '_write_to_file')\nqtbot.wait(100)\neditor_stack.autosave.maybe_autosave(0)\neditor_stack._write_to_file.assert_not_called()\npytest.mark.parametrize('filename', ['ham.py', 'ham.txt'])",
        "CUT_1": "\"\"\"Autosave all opened files where necessary.\"\"\"\nfor index in range(self.stack.get_stack_count()):\n    self.maybe_autosave(index)\n",
        "CUT_2": "\"\"\"Autosave all opened files where necessary.\"\"\"\nfor index in range(self.stack.get_stack_count()):\n    self.maybe_autosave(index)\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\nfrom spyder.config.base import get_module_path\nspyder_dir = get_module_path('spyder')\napp = qapplication(test_time=8)\ntest = EditorPluginExample()\ntest.resize(900, 700)\ntest.show()\nimport time\nt0 = time.time()\ntest.load(osp.join(spyder_dir, 'widgets', 'collectionseditor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'editor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'explorer', 'widgets', 'explorer.py')\n    )\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'codeeditor.py')\n    )\nprint('Elapsed time: %.3f s' % (time.time() - t0))\nsys.exit(app.exec_())\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\nfrom spyder.config.base import get_module_path\nspyder_dir = get_module_path('spyder')\napp = qapplication(test_time=8)\ntest = EditorPluginExample()\ntest.resize(900, 700)\ntest.show()\nimport time\nt0 = time.time()\ntest.load(osp.join(spyder_dir, 'widgets', 'collectionseditor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'editor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'explorer', 'widgets', 'explorer.py')\n    )\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'codeeditor.py')\n    )\nprint('Elapsed time: %.3f s' % (time.time() - t0))\nsys.exit(app.exec_())\n",
        "CUT_5": "\"\"\"Set the text of the editor from file *fname*\"\"\"\nself.filename = filename\ntext, _enc = encoding.read(filename)\nif language is None:\n    language = get_file_language(filename, text)\nself.set_language(language, filename)\nself.set_text(text)\n"
    },
    {
        "functionName": "test_maybe_autosave_does_not_save_after_reload",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that maybe_autosave() does not save files immediately after reloading.\n\n    Spyder reloads the file if it has changed on disk. In that case, there is\n    no need to autosave because the contents in Spyder are identical to the\n    contents on disk.\n    \"\"\"\neditor_stack = base_editor_bot\ntxt = 'spam\\n'\neditor_stack.create_new_editor('ham.py', 'ascii', txt, set_current=True)\nmocker.patch.object(editor_stack, '_write_to_file')\nmocker.patch('spyder.plugins.editor.widgets.editor.encoding.read',\n    return_value=(txt, 'ascii'))\neditor_stack.reload(0)\neditor_stack.autosave.maybe_autosave(0)\neditor_stack._write_to_file.assert_not_called()\n",
        "CUT_1": "\"\"\"Autosave all opened files where necessary.\"\"\"\nfor index in range(self.stack.get_stack_count()):\n    self.maybe_autosave(index)\n",
        "CUT_2": "\"\"\"Autosave all opened files where necessary.\"\"\"\nfor index in range(self.stack.get_stack_count()):\n    self.maybe_autosave(index)\n",
        "CUT_3": "\"\"\"\n        Check that all characters in the new sequence are ascii or else the\n        shortcut will not work.\n        \"\"\"\ntry:\n    self.new_sequence.encode('ascii')\nexcept UnicodeEncodeError:\n    return False\nelse:\n    return True\n",
        "CUT_4": "\"\"\"\n        Check that all characters in the new sequence are ascii or else the\n        shortcut will not work.\n        \"\"\"\ntry:\n    self.new_sequence.encode('ascii')\nexcept UnicodeEncodeError:\n    return False\nelse:\n    return True\n",
        "CUT_5": "\"\"\"Add label with explanation at top of dialog window.\"\"\"\ntxt = _(\n    \"\"\"Autosave files found. What would you like to do?\n\nThis dialog will be shown again on next startup if any autosave files are not restored, moved or deleted.\"\"\"\n    )\nlabel = QLabel(txt, self)\nlabel.setWordWrap(True)\nself.layout.addWidget(label)\n"
    },
    {
        "functionName": "test_autosave_updates_name_mapping",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that maybe_autosave() updates name_mapping.\"\"\"\neditor_stack, editor = editor_bot\nassert editor_stack.autosave.name_mapping == {}\nmocker.patch.object(editor_stack, '_write_to_file')\neditor.set_text('spam\\n')\neditor_stack.autosave.maybe_autosave(0)\nexpected = {'foo.py': os.path.join(get_conf_path('autosave'), 'foo.py')}\nassert editor_stack.autosave.name_mapping == expected\n",
        "CUT_1": "\"\"\"\n        Remove autosave file for specified file.\n\n        This function also updates `self.name_mapping` and `self.file_hashes`.\n        If there is no autosave file, then the function returns without doing\n        anything.\n        \"\"\"\nif filename not in self.name_mapping:\n    return\nautosave_filename = self.name_mapping[filename]\ntry:\n    os.remove(autosave_filename)\nexcept EnvironmentError as error:\n    action = _('Error while removing autosave file {}').format(\n        autosave_filename)\n    msgbox = AutosaveErrorDialog(action, error)\n    msgbox.exec_if_enabled()\ndel self.name_mapping[filename]\ndel self.file_hashes[autosave_filename]\nself.save_autosave_mapping()\nlogger.debug('Removing autosave file %s', autosave_filename)\n",
        "CUT_2": "\"\"\"\n        Remove autosave file for specified file.\n\n        This function also updates `self.name_mapping` and `self.file_hashes`.\n        If there is no autosave file, then the function returns without doing\n        anything.\n        \"\"\"\nif filename not in self.name_mapping:\n    return\nautosave_filename = self.name_mapping[filename]\ntry:\n    os.remove(autosave_filename)\nexcept EnvironmentError as error:\n    action = _('Error while removing autosave file {}').format(\n        autosave_filename)\n    msgbox = AutosaveErrorDialog(action, error)\n    msgbox.exec_if_enabled()\ndel self.name_mapping[filename]\ndel self.file_hashes[autosave_filename]\nself.save_autosave_mapping()\nlogger.debug('Removing autosave file %s', autosave_filename)\n",
        "CUT_3": "\"\"\"\n        Get name of autosave file for specified file name.\n\n        This function uses the dict in `self.name_mapping`. If `filename` is\n        in the mapping, then return the corresponding autosave file name.\n        Otherwise, construct a unique file name and update the mapping.\n\n        Args:\n            filename (str): original file name\n        \"\"\"\ntry:\n    autosave_filename = self.name_mapping[filename]\nexcept KeyError:\n    autosave_dir = get_conf_path('autosave')\n    if not osp.isdir(autosave_dir):\n        try:\n            os.mkdir(autosave_dir)\n        except EnvironmentError as error:\n            action = _('Error while creating autosave directory')\n            msgbox = AutosaveErrorDialog(action, error)\n            msgbox.exec_if_enabled()\n    autosave_filename = self.create_unique_autosave_filename(filename,\n        autosave_dir)\n    self.name_mapping[filename] = autosave_filename\n    self.save_autosave_mapping()\n    logger.debug('New autosave file name')\nreturn autosave_filename\n",
        "CUT_4": "\"\"\"\n        Get name of autosave file for specified file name.\n\n        This function uses the dict in `self.name_mapping`. If `filename` is\n        in the mapping, then return the corresponding autosave file name.\n        Otherwise, construct a unique file name and update the mapping.\n\n        Args:\n            filename (str): original file name\n        \"\"\"\ntry:\n    autosave_filename = self.name_mapping[filename]\nexcept KeyError:\n    autosave_dir = get_conf_path('autosave')\n    if not osp.isdir(autosave_dir):\n        try:\n            os.mkdir(autosave_dir)\n        except EnvironmentError as error:\n            action = _('Error while creating autosave directory')\n            msgbox = AutosaveErrorDialog(action, error)\n            msgbox.exec_if_enabled()\n    autosave_filename = self.create_unique_autosave_filename(filename,\n        autosave_dir)\n    self.name_mapping[filename] = autosave_filename\n    self.save_autosave_mapping()\n    logger.debug('New autosave file name')\nreturn autosave_filename\n",
        "CUT_5": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n"
    },
    {
        "functionName": "test_maybe_autosave_handles_error",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that autosave() ignores errors when writing to file.\"\"\"\neditor_stack, editor = editor_bot\nmock_write = mocker.patch.object(editor_stack, '_write_to_file')\nmock_dialog = mocker.patch(\n    'spyder.plugins.editor.utils.autosave.AutosaveErrorDialog')\ntry:\n    mock_write.side_effect = PermissionError\nexcept NameError:\n    mock_write.side_effect = IOError\neditor.set_text('spam\\n')\neditor_stack.autosave.maybe_autosave(0)\nassert mock_dialog.called\n",
        "CUT_1": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n",
        "CUT_2": "\"\"\"Instruct current editorstack to autosave files where necessary.\"\"\"\nlogger.debug('Autosave triggered')\nstack = self.editor.get_current_editorstack()\nstack.autosave.autosave_all()\nself.start_autosave_timer()\n",
        "CUT_3": "ignored, autosave = self.data[idx]\ntry:\n    os.remove(autosave['name'])\n    self.deactivate(idx)\nexcept EnvironmentError as error:\n    text = _('Unable to discard {}').format(autosave['name'])\n    self.report_error(text, error)\n",
        "CUT_4": "ignored, autosave = self.data[idx]\ntry:\n    os.remove(autosave['name'])\n    self.deactivate(idx)\nexcept EnvironmentError as error:\n    text = _('Unable to discard {}').format(autosave['name'])\n    self.report_error(text, error)\n",
        "CUT_5": "orig, autosave = self.data[idx]\nif orig:\n    orig_name = orig['name']\nelse:\n    orig_name, ignored = getsavefilename(self, _(\n        'Restore autosave file to ...'), osp.basename(autosave['name']))\n    if not orig_name:\n        return\ntry:\n    try:\n        os.replace(autosave['name'], orig_name)\n    except (AttributeError, OSError):\n        shutil.copy2(autosave['name'], orig_name)\n        os.remove(autosave['name'])\n    self.deactivate(idx)\nexcept EnvironmentError as error:\n    text = _('Unable to restore {} using {}').format(orig_name, autosave[\n        'name'])\n    self.report_error(text, error)\n"
    },
    {
        "functionName": "test_remove_autosave_file",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that remove_autosave_file() removes the autosave file.\n\n    Also, test that it updates `name_mapping`.\n    \"\"\"\neditor_stack, editor = editor_bot\nautosave = editor_stack.autosave\neditor.set_text('spam\\n')\nautosave.maybe_autosave(0)\nautosave_filename = os.path.join(get_conf_path('autosave'), 'foo.py')\nassert os.access(autosave_filename, os.R_OK)\nexpected = {'foo.py': autosave_filename}\nassert autosave.name_mapping == expected\nautosave.remove_autosave_file(editor_stack.data[0].filename)\nassert not os.access(autosave_filename, os.R_OK)\nassert autosave.name_mapping == {}\n",
        "CUT_1": "\"\"\"\n        Remove autosave file for specified file.\n\n        This function also updates `self.name_mapping` and `self.file_hashes`.\n        If there is no autosave file, then the function returns without doing\n        anything.\n        \"\"\"\nif filename not in self.name_mapping:\n    return\nautosave_filename = self.name_mapping[filename]\ntry:\n    os.remove(autosave_filename)\nexcept EnvironmentError as error:\n    action = _('Error while removing autosave file {}').format(\n        autosave_filename)\n    msgbox = AutosaveErrorDialog(action, error)\n    msgbox.exec_if_enabled()\ndel self.name_mapping[filename]\ndel self.file_hashes[autosave_filename]\nself.save_autosave_mapping()\nlogger.debug('Removing autosave file %s', autosave_filename)\n",
        "CUT_2": "\"\"\"\n        Remove autosave file for specified file.\n\n        This function also updates `self.name_mapping` and `self.file_hashes`.\n        If there is no autosave file, then the function returns without doing\n        anything.\n        \"\"\"\nif filename not in self.name_mapping:\n    return\nautosave_filename = self.name_mapping[filename]\ntry:\n    os.remove(autosave_filename)\nexcept EnvironmentError as error:\n    action = _('Error while removing autosave file {}').format(\n        autosave_filename)\n    msgbox = AutosaveErrorDialog(action, error)\n    msgbox.exec_if_enabled()\ndel self.name_mapping[filename]\ndel self.file_hashes[autosave_filename]\nself.save_autosave_mapping()\nlogger.debug('Removing autosave file %s', autosave_filename)\n",
        "CUT_3": "\"\"\"\n        Get name of autosave file for specified file name.\n\n        This function uses the dict in `self.name_mapping`. If `filename` is\n        in the mapping, then return the corresponding autosave file name.\n        Otherwise, construct a unique file name and update the mapping.\n\n        Args:\n            filename (str): original file name\n        \"\"\"\ntry:\n    autosave_filename = self.name_mapping[filename]\nexcept KeyError:\n    autosave_dir = get_conf_path('autosave')\n    if not osp.isdir(autosave_dir):\n        try:\n            os.mkdir(autosave_dir)\n        except EnvironmentError as error:\n            action = _('Error while creating autosave directory')\n            msgbox = AutosaveErrorDialog(action, error)\n            msgbox.exec_if_enabled()\n    autosave_filename = self.create_unique_autosave_filename(filename,\n        autosave_dir)\n    self.name_mapping[filename] = autosave_filename\n    self.save_autosave_mapping()\n    logger.debug('New autosave file name')\nreturn autosave_filename\n",
        "CUT_4": "\"\"\"\n        Get name of autosave file for specified file name.\n\n        This function uses the dict in `self.name_mapping`. If `filename` is\n        in the mapping, then return the corresponding autosave file name.\n        Otherwise, construct a unique file name and update the mapping.\n\n        Args:\n            filename (str): original file name\n        \"\"\"\ntry:\n    autosave_filename = self.name_mapping[filename]\nexcept KeyError:\n    autosave_dir = get_conf_path('autosave')\n    if not osp.isdir(autosave_dir):\n        try:\n            os.mkdir(autosave_dir)\n        except EnvironmentError as error:\n            action = _('Error while creating autosave directory')\n            msgbox = AutosaveErrorDialog(action, error)\n            msgbox.exec_if_enabled()\n    autosave_filename = self.create_unique_autosave_filename(filename,\n        autosave_dir)\n    self.name_mapping[filename] = autosave_filename\n    self.save_autosave_mapping()\n    logger.debug('New autosave file name')\nreturn autosave_filename\n",
        "CUT_5": "\"\"\"\n        Create unique autosave file name for specified file name.\n\n        The created autosave file name does not yet exist either in\n        `self.name_mapping` or on disk.\n\n        Args:\n            filename (str): original file name\n            autosave_dir (str): directory in which autosave files are stored\n        \"\"\"\nbasename = osp.basename(filename)\nautosave_filename = osp.join(autosave_dir, basename)\nif autosave_filename in self.name_mapping.values() or osp.exists(\n    autosave_filename):\n    counter = 0\n    root, ext = osp.splitext(basename)\n    while autosave_filename in self.name_mapping.values() or osp.exists(\n        autosave_filename):\n        counter += 1\n        autosave_basename = '{}-{}{}'.format(root, counter, ext)\n        autosave_filename = osp.join(autosave_dir, autosave_basename)\nreturn autosave_filename\n"
    },
    {
        "functionName": "code_editor_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor_1.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create code editor with default Python code.\"\"\"\neditor = codeeditor.CodeEditor(parent=None)\nindent_chars = ' ' * 4\ntab_stop_width_spaces = 4\neditor.setup_editor(language='Python', indent_chars=indent_chars,\n    tab_stop_width_spaces=tab_stop_width_spaces)\neditor.linenumberarea = Mock()\nif version_info > (4,):\n    editor.sig_flags_changed = Mock()\nelse:\n    editor.get_linenumberarea_width = Mock(return_value=1)\neditor.breakpoints_changed = Mock()\nreturn editor, qtbot\npytest.fixture",
        "CUT_1": "return Mock()\n",
        "CUT_2": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture"
    },
    {
        "functionName": "copy_files_clipboard",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor_1.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Fixture to copy files/folders into the clipboard\"\"\"\nfile_paths = create_folders_files[0]\nfile_content = QMimeData()\nfile_content.setUrls([QUrl.fromLocalFile(fname) for fname in file_paths])\ncb = QApplication.clipboard()\ncb.setMimeData(file_content, mode=cb.Clipboard)\nreturn file_paths\npytest.fixture",
        "CUT_1": "\"\"\"Copy file(s)/folders(s) to clipboard.\"\"\"\nif fnames is None:\n    fnames = self.get_selected_filenames()\nif not isinstance(fnames, (tuple, list)):\n    fnames = [fnames]\ntry:\n    file_content = QMimeData()\n    file_content.setUrls([QUrl.fromLocalFile(_fn) for _fn in fnames])\n    cb = QApplication.clipboard()\n    cb.setMimeData(file_content, mode=cb.Clipboard)\nexcept Exception as e:\n    QMessageBox.critical(self, _('File/Folder copy error'), _(\n        \"\"\"Cannot copy this type of file(s) or folder(s). The error was:\n\n\"\"\"\n        ) + to_text_string(e))\nSlot()",
        "CUT_2": "\"\"\"Copy file(s)/folders(s) to clipboard.\"\"\"\nif fnames is None:\n    fnames = self.get_selected_filenames()\nif not isinstance(fnames, (tuple, list)):\n    fnames = [fnames]\ntry:\n    file_content = QMimeData()\n    file_content.setUrls([QUrl.fromLocalFile(_fn) for _fn in fnames])\n    cb = QApplication.clipboard()\n    cb.setMimeData(file_content, mode=cb.Clipboard)\nexcept Exception as e:\n    QMessageBox.critical(self, _('File/Folder copy error'), _(\n        \"\"\"Cannot copy this type of file(s) or folder(s). The error was:\n\n\"\"\"\n        ) + to_text_string(e))\nSlot()",
        "CUT_3": "\"\"\"Restore last text using callback.\"\"\"\nif self.source_is_console():\n    cb = self._last_console_cb\nelse:\n    cb = self._last_editor_cb\nif cb is None:\n    if self.get_option('plain_mode'):\n        self.switch_to_plain_text()\n    else:\n        self.switch_to_rich_text()\nelse:\n    func = cb[0]\n    args = cb[1:]\n    func(*args)\n    if get_meth_class_inst(func) is self.rich_text:\n        self.switch_to_rich_text()\n    else:\n        self.switch_to_plain_text()\n",
        "CUT_4": "\"\"\"Restore last text using callback.\"\"\"\nif self.source_is_console():\n    cb = self._last_console_cb\nelse:\n    cb = self._last_editor_cb\nif cb is None:\n    if self.get_option('plain_mode'):\n        self.switch_to_plain_text()\n    else:\n        self.switch_to_rich_text()\nelse:\n    func = cb[0]\n    args = cb[1:]\n    func(*args)\n    if get_meth_class_inst(func) is self.rich_text:\n        self.switch_to_rich_text()\n    else:\n        self.switch_to_plain_text()\n",
        "CUT_5": "\"\"\"Copy text to clipboard\"\"\"\ncliptxt = self._sel_to_text(self.selectedIndexes())\nclipboard = QApplication.clipboard()\nclipboard.setText(cliptxt)\nSlot()"
    },
    {
        "functionName": "test_format_signature",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor_1.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test signature format method.\"\"\"\nsignature = \"\"\"\n    concatenate((a1, a2, a...), [b1, b2, b...], axis={}, index=[],\n                *args, **kargs)\"\"\"\neditor, qtbot = code_editor_bot\nformat_signature = editor._format_signature(signature, parameter='(a1')\nassert \"color:#DAA520'><b>a1</b></span>\" in format_signature\nformat_signature = editor._format_signature(signature, parameter='a2')\nassert \"color:#DAA520'><b>a2</b></span>\" in format_signature\nformat_signature = editor._format_signature(signature, parameter='a...')\nprint(format_signature)\nassert \"color:#DAA520'><b>a...</b></span>\" in format_signature\nformat_signature = editor._format_signature(signature, parameter='[b1')\nassert \"color:#DAA520'><b>b1</b></span>\" in format_signature\nformat_signature = editor._format_signature(signature, parameter='b2')\nassert \"color:#DAA520'><b>b2</b></span>\" in format_signature\nformat_signature = editor._format_signature(signature, parameter='b...')\nassert \"color:#DAA520'><b>b...</b></span>\" in format_signature\nformat_signature = editor._format_signature(signature, parameter='axis')\nassert \"color:#DAA520'><b>axis</b></span>\" in format_signature\nformat_signature = editor._format_signature(signature, parameter='index')\nassert \"color:#DAA520'><b>index</b></span>\" in format_signature\nformat_signature = editor._format_signature(signature, parameter='*args')\nassert \"color:#DAA520'><b>*args</b></span>\" in format_signature\nformat_signature = editor._format_signature(signature, parameter='**kargs')\nassert \"color:#DAA520'><b>**kargs</b></span>\" in format_signature\n",
        "CUT_1": "\"\"\"\n        Create HTML template for signature.\n\n        This template will include indent after the method name, a highlight\n        color for the active parameter and highlights for special chars.\n\n        Special chars depend on the language.\n        \"\"\"\nlanguage = getattr(self, 'language', language).lower()\nactive_parameter_template = (\n    '<span style=\\'font-family:\"{font_family}\";font-size:{font_size}pt;color:{color}\\'><b>{parameter}</b></span>'\n    )\nchars_template = '<span style=\"color:{0};'.format(self._CHAR_HIGHLIGHT_COLOR\n    ) + 'font-weight:bold\">{char}</span>'\ndef handle_sub(matchobj):\n    \"\"\"\n            Handle substitution of active parameter template.\n\n            This ensures the correct highlight of the active parameter.\n            \"\"\"\n    match = matchobj.group(0)\n    new = match.replace(parameter, active_parameter_template)\n    return new\nif not isinstance(signatures, list):\n    signatures = [signatures]\nnew_signatures = []\nfor signature in signatures:\n    signature = ' '.join(signature.split())\n    signature = signature.replace('( ', '(')\n    if parameter and language == 'python':\n        escape_regex_chars = ['|', '.', '^', '$', '*', '+']\n        remove_regex_chars = ['(', ')', '{', '}', '[', ']']\n        regex_parameter = parameter\n        for regex_char in (escape_regex_chars + remove_regex_chars):\n            if regex_char in escape_regex_chars:\n                escape_char = '\\\\{char}'.format(char=regex_char)\n                regex_parameter = regex_parameter.replace(regex_char,\n                    escape_char)\n            else:\n                regex_parameter = regex_parameter.replace(regex_char, '')\n                parameter = parameter.replace(regex_char, '')\n        pattern = '[\\\\*|\\\\(|\\\\[|\\\\s](' + regex_parameter + ')[,|\\\\)|\\\\]|\\\\s|=]'\n    formatted_lines = []\n    name = signature.split('(')[0]\n    indent = ' ' * (len(name) + 1)\n    rows = textwrap.wrap(signature, width=max_width, subsequent_indent=indent)\n    for row in rows:\n        if parameter and language == 'python':\n            row = re.sub(pattern, handle_sub, row)\n        row = row.replace(' ', '&nbsp;')\n        row = row.replace('span&nbsp;', 'span ')\n        row = row.replace('{}', '{{}}')\n        if language and language == 'python':\n            for char in ['(', ')', ',', '*', '**']:\n                new_char = chars_template.format(char=char)\n                row = row.replace(char, new_char)\n        formatted_lines.append(row)\n    title_template = '<br>'.join(formatted_lines)\n    font = self.font()\n    font_size = font.pointSize()\n    font_family = font.family()\n    if parameter and language == 'python':\n        title = title_template.format(font_size=font_size, font_family=\n            font_family, color=parameter_color, parameter=parameter)\n    else:\n        title = title_template\n    new_signatures.append(title)\nreturn '<br>'.join(new_signatures)\n",
        "CUT_2": "\"\"\"\n        Create HTML template for signature.\n\n        This template will include indent after the method name, a highlight\n        color for the active parameter and highlights for special chars.\n\n        Special chars depend on the language.\n        \"\"\"\nlanguage = getattr(self, 'language', language).lower()\nactive_parameter_template = (\n    '<span style=\\'font-family:\"{font_family}\";font-size:{font_size}pt;color:{color}\\'><b>{parameter}</b></span>'\n    )\nchars_template = '<span style=\"color:{0};'.format(self._CHAR_HIGHLIGHT_COLOR\n    ) + 'font-weight:bold\">{char}</span>'\ndef handle_sub(matchobj):\n    \"\"\"\n            Handle substitution of active parameter template.\n\n            This ensures the correct highlight of the active parameter.\n            \"\"\"\n    match = matchobj.group(0)\n    new = match.replace(parameter, active_parameter_template)\n    return new\nif not isinstance(signatures, list):\n    signatures = [signatures]\nnew_signatures = []\nfor signature in signatures:\n    signature = ' '.join(signature.split())\n    signature = signature.replace('( ', '(')\n    if parameter and language == 'python':\n        escape_regex_chars = ['|', '.', '^', '$', '*', '+']\n        remove_regex_chars = ['(', ')', '{', '}', '[', ']']\n        regex_parameter = parameter\n        for regex_char in (escape_regex_chars + remove_regex_chars):\n            if regex_char in escape_regex_chars:\n                escape_char = '\\\\{char}'.format(char=regex_char)\n                regex_parameter = regex_parameter.replace(regex_char,\n                    escape_char)\n            else:\n                regex_parameter = regex_parameter.replace(regex_char, '')\n                parameter = parameter.replace(regex_char, '')\n        pattern = '[\\\\*|\\\\(|\\\\[|\\\\s](' + regex_parameter + ')[,|\\\\)|\\\\]|\\\\s|=]'\n    formatted_lines = []\n    name = signature.split('(')[0]\n    indent = ' ' * (len(name) + 1)\n    rows = textwrap.wrap(signature, width=max_width, subsequent_indent=indent)\n    for row in rows:\n        if parameter and language == 'python':\n            row = re.sub(pattern, handle_sub, row)\n        row = row.replace(' ', '&nbsp;')\n        row = row.replace('span&nbsp;', 'span ')\n        row = row.replace('{}', '{{}}')\n        if language and language == 'python':\n            for char in ['(', ')', ',', '*', '**']:\n                new_char = chars_template.format(char=char)\n                row = row.replace(char, new_char)\n        formatted_lines.append(row)\n    title_template = '<br>'.join(formatted_lines)\n    font = self.font()\n    font_size = font.pointSize()\n    font_family = font.family()\n    if parameter and language == 'python':\n        title = title_template.format(font_size=font_size, font_family=\n            font_family, color=parameter_color, parameter=parameter)\n    else:\n        title = title_template\n    new_signatures.append(title)\nreturn '<br>'.join(new_signatures)\n",
        "CUT_3": "\"\"\"Get signature from text using a given function name.\"\"\"\nsignature = ''\nargspec = getargspecfromtext(text)\nif argspec:\n    signature = name + argspec\nelse:\n    signature = getsignaturefromtext(text, name)\nreturn signature\n",
        "CUT_4": "\"\"\"Get signature from text using a given function name.\"\"\"\nsignature = ''\nargspec = getargspecfromtext(text)\nif argspec:\n    signature = name + argspec\nelse:\n    signature = getsignaturefromtext(text, name)\nreturn signature\n",
        "CUT_5": "\"\"\"Get arguments from text (object documentation)\"\"\"\nsignature = getsignaturefromtext(text, objname)\nif signature:\n    argtxt = signature[signature.find('(') + 1:-1]\n    return argtxt.split(',')\n"
    },
    {
        "functionName": "test_delete",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor_1.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test CodeEditor.delete().\"\"\"\neditor, qtbot = code_editor_bot\ntext = 'def f1(a, b):\\n'\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Start)\neditor.setTextCursor(cursor)\neditor.delete()\nassert editor.get_text_line(0) == 'ef f1(a, b):'\ncursor = editor.textCursor()\ncursor.select(QTextCursor.WordUnderCursor)\neditor.setTextCursor(cursor)\neditor.delete()\nassert editor.get_text_line(0) == ' f1(a, b):'\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.End)\neditor.setTextCursor(cursor)\neditor.delete()\nassert editor.get_text_line(0) == ' f1(a, b):'\n",
        "CUT_1": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_2": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_3": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_4": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_paste_files",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor_1.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test pasting files/folders into the editor.\"\"\"\neditor = code_editor_bot[0]\nfile_paths = copy_files_clipboard\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Start)\neditor.setTextCursor(cursor)\neditor.paste()\neditor.selectAll()\ntext = editor.toPlainText()\npath_list_in_editor = [path.strip(',\"') for path in text.splitlines()]\nassert len(file_paths) == len(path_list_in_editor)\nfor path, expected_path in zip(path_list_in_editor, file_paths):\n    assert osp.normpath(path) == osp.normpath(expected_path)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n"
    },
    {
        "functionName": "test_paste_text",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_codeeditor_1.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test pasting text into the editor.\"\"\"\neditor = code_editor_bot[0]\ntext = text.replace(osp.os.linesep, line_ending_char)\ncb = QApplication.clipboard()\ncb.setText(text, mode=cb.Clipboard)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Start)\neditor.setTextCursor(cursor)\neditor.paste()\nfor line_no, txt in enumerate(text.splitlines()):\n    assert editor.get_text_line(line_no) == txt\npytest.mark.parametrize('line_ending_char', ['\\n', '\\r\\n', '\\r'])pytest.mark.parametrize('text', [\"\"\"def fun(a, b):\n\treturn a + b\"\"\",\n    'https://www.spyder-ide.org'])",
        "CUT_1": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_2": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_3": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "status_bar",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_status.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up StatusBarWidget.\"\"\"\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nqtbot.addWidget(win)\nreturn win, statusbar\npytest.fixture",
        "CUT_1": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_2": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_3": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_4": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = TestWidget(None)\nwin.show()\nwin.load(fname)\nwin.resize(900, 700)\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_status_bar",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_status.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run StatusBarWidget.\"\"\"\nwin, statusbar = status_bar\nswidgets = []\nfor klass in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus, VCSStatus):\n    swidget = klass(win, statusbar)\n    swidgets.append(swidget)\nassert win\nassert len(swidgets) == 5\n",
        "CUT_1": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_2": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_3": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_4": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = TestWidget(None)\nwin.show()\nwin.load(fname)\nwin.resize(900, 700)\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "reset_emits",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_bookmarks.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Reset signal mocks.\"\"\"\neditor.sig_bookmarks_changed.reset_mock()\n",
        "CUT_1": "\"\"\"Emit signal to update bookmarks.\"\"\"\nself.sig_bookmarks_changed.emit()\n",
        "CUT_2": "\"\"\"Emit signal to update bookmarks.\"\"\"\nself.sig_bookmarks_changed.emit()\n",
        "CUT_3": "\"\"\"Restore signal handlers to their original settings.\"\"\"\nsignal.signal(signal.SIGINT, self.original_sigint)\nsignal.signal(signal.SIGTERM, self.original_sigterm)\nif os.name == 'nt':\n    signal.signal(signal.SIGBREAK, self.original_sigbreak)\n",
        "CUT_4": "\"\"\"Restore signal handlers to their original settings.\"\"\"\nsignal.signal(signal.SIGINT, self.original_sigint)\nsignal.signal(signal.SIGTERM, self.original_sigterm)\nif os.name == 'nt':\n    signal.signal(signal.SIGBREAK, self.original_sigbreak)\n",
        "CUT_5": "self.original_sigint = signal.getsignal(signal.SIGINT)\nself.original_sigterm = signal.getsignal(signal.SIGTERM)\nsignal.signal(signal.SIGINT, self.exit_gracefully)\nsignal.signal(signal.SIGTERM, self.exit_gracefully)\nif os.name == 'nt':\n    self.original_sigbreak = signal.getsignal(signal.SIGBREAK)\n    signal.signal(signal.SIGBREAK, self.exit_gracefully)\n"
    },
    {
        "functionName": "editor_assert_helper",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_bookmarks.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Run the tests for call to add_remove_breakpoint.\n\n    Args:\n        editor (CodeEditor): CodeEditor instance.\n        block (QTextBlock): Block of text.\n        bm (list): A list containing slots and columns of bookmarks\n        emits (bool): Boolean to test if signals were emitted?\n    \"\"\"\ndata = block.userData()\nassert data.bookmarks == bm\nif emits:\n    editor.sig_bookmarks_changed.emit.assert_called_with()\nelse:\n    editor.sig_bookmarks_changed.emit.assert_not_called()\n",
        "CUT_1": "\"\"\"Emit signal to update bookmarks.\"\"\"\nself.sig_bookmarks_changed.emit()\n",
        "CUT_2": "\"\"\"Emit signal to update bookmarks.\"\"\"\nself.sig_bookmarks_changed.emit()\n",
        "CUT_3": "\"\"\"Add bookmark to current block's userData.\"\"\"\nif line is None:\n    line, column = self.get_cursor_line_column()\nblock = self.document().findBlockByNumber(line)\ndata = block.userData()\nif not data:\n    data = BlockUserData(self)\nif slot_num not in data.bookmarks:\n    data.bookmarks.append((slot_num, column))\nblock.setUserData(data)\nself.sig_bookmarks_changed.emit()\n",
        "CUT_4": "\"\"\"Add bookmark to current block's userData.\"\"\"\nif line is None:\n    line, column = self.get_cursor_line_column()\nblock = self.document().findBlockByNumber(line)\ndata = block.userData()\nif not data:\n    data = BlockUserData(self)\nif slot_num not in data.bookmarks:\n    data.bookmarks.append((slot_num, column))\nblock.setUserData(data)\nself.sig_bookmarks_changed.emit()\n",
        "CUT_5": "\"\"\"Get bookmarks by going over all blocks.\"\"\"\nbookmarks = {}\nblock = self.document().firstBlock()\nfor line_number in range(0, self.document().blockCount()):\n    data = block.userData()\n    if data and data.bookmarks:\n        for slot_num, column in data.bookmarks:\n            bookmarks[slot_num] = [line_number, column]\n    block = block.next()\nreturn bookmarks\n"
    },
    {
        "functionName": "code_editor_bookmarks",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_bookmarks.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create code editor with default Python code.\"\"\"\neditor = codeeditor.CodeEditor(parent=None)\nindent_chars = ' ' * 4\ntab_stop_width_spaces = 4\neditor.setup_editor(language='Python', indent_chars=indent_chars,\n    tab_stop_width_spaces=tab_stop_width_spaces)\neditor.sig_bookmarks_changed = Mock()\ntext = \"\"\"def f1(a, b):\n\"Double quote string.\"\n\n    c = a * b\n    return c\n\"\"\"\neditor.set_text(text)\nreturn editor, qtbot\npytest.fixture",
        "CUT_1": "self.tab_stop_width_spaces = tab_stop_width_spaces\nif self.data:\n    for finfo in self.data:\n        finfo.editor.tab_stop_width_spaces = tab_stop_width_spaces\n        finfo.editor.update_tab_stop_width_spaces()\n",
        "CUT_2": "self.tab_stop_width_spaces = tab_stop_width_spaces\nif self.data:\n    for finfo in self.data:\n        finfo.editor.tab_stop_width_spaces = tab_stop_width_spaces\n        finfo.editor.update_tab_stop_width_spaces()\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "self.indent_chars = indent_chars\n"
    },
    {
        "functionName": "test_add_bookmark",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_bookmarks.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test CodeEditor.add_bookmark. Adds bookmark data to Textblock.\"\"\"\neditor, __ = code_editor_bookmarks\neditor.go_to_line(1)\nblock = editor.textCursor().block()\nreset_emits(editor)\neditor.add_bookmark(1)\neditor_assert_helper(editor, block, bm=[(1, 0)], emits=True)\nreset_emits(editor)\neditor.go_to_line(4)\nblock = editor.textCursor().block()\neditor.add_bookmark(1)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Right, n=2)\neditor.setTextCursor(cursor)\neditor.add_bookmark(2)\neditor_assert_helper(editor, block, bm=[(1, 0), (2, 2)], emits=True)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Bookmark current position to given slot.\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.add_bookmark(slot_num)\n",
        "CUT_4": "\"\"\"Bookmark current position to given slot.\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.add_bookmark(slot_num)\n",
        "CUT_5": "\"\"\"\n    Gets the list of ParenthesisInfo for specific text block.\n\n    :param editor: Code editor instance\n    :param block: block to parse\n    \"\"\"\ndef list_symbols(editor, block, character):\n    \"\"\"\n        Retuns  a list of symbols found in the block text\n\n        :param editor: code editor instance\n        :param block: block to parse\n        :param character: character to look for.\n        \"\"\"\n    text = block.text()\n    symbols = []\n    cursor = QTextCursor(block)\n    cursor.movePosition(cursor.StartOfBlock)\n    pos = text.find(character, 0)\n    cursor.movePosition(cursor.Right, cursor.MoveAnchor, pos)\n    while pos != -1:\n        if not TextHelper(editor).is_comment_or_string(cursor):\n            info = ParenthesisInfo(pos, character)\n            symbols.append(info)\n        pos = text.find(character, pos + 1)\n        cursor.movePosition(cursor.StartOfBlock)\n        cursor.movePosition(cursor.Right, cursor.MoveAnchor, pos)\n    return symbols\nparentheses = sorted(list_symbols(editor, block, '(') + list_symbols(editor,\n    block, ')'), key=lambda x: x.position)\nsquare_brackets = sorted(list_symbols(editor, block, '[') + list_symbols(\n    editor, block, ']'), key=lambda x: x.position)\nbraces = sorted(list_symbols(editor, block, '{') + list_symbols(editor,\n    block, '}'), key=lambda x: x.position)\nreturn parentheses, square_brackets, braces\n"
    },
    {
        "functionName": "test_get_bookmarks",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_bookmarks.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test CodeEditor.get_bookmarks. Returns data found in textblocks.\"\"\"\neditor, __ = code_editor_bookmarks\ngb = editor.get_bookmarks\nassert gb() == {}\nbm = {(1): ('filename', 1, 0), (2): ('filename', 3, 5), (3): ('filename', 4, 3)\n    }\neditor.set_bookmarks(bm)\nassert gb() == {(1): [1, 0], (2): [3, 5], (3): [4, 3]}\n",
        "CUT_1": "\"\"\"\n        Create a history tab for `filename`.\n\n        Parameters\n        ----------\n        filename: str\n            History filename.\n        \"\"\"\nfilename = encoding.to_unicode_from_fs(filename)\nif filename in self.filenames:\n    return\neditor = SimpleCodeEditor(self)\nlanguage = 'py' if osp.splitext(filename)[1] == '.py' else 'bat'\neditor.setup_editor(linenumbers=self.get_option('line_numbers'), language=\n    language, color_scheme=self.get_option('color_scheme_name'), font=self.\n    font, wrap=self.get_option('wrap'))\neditor.setReadOnly(True)\neditor.set_text(self.get_filename_text(filename))\neditor.set_cursor_position('eof')\nself.find_widget.set_editor(editor)\nindex = self.tabwidget.addTab(editor, osp.basename(filename))\nself.filenames.append(filename)\nself.editors.append(editor)\nself.tabwidget.setCurrentIndex(index)\nself.tabwidget.setTabToolTip(index, filename)\neditor.sig_focus_changed.connect(lambda : self.sig_focus_changed.emit())\n",
        "CUT_2": "\"\"\"\n        Create a history tab for `filename`.\n\n        Parameters\n        ----------\n        filename: str\n            History filename.\n        \"\"\"\nfilename = encoding.to_unicode_from_fs(filename)\nif filename in self.filenames:\n    return\neditor = SimpleCodeEditor(self)\nlanguage = 'py' if osp.splitext(filename)[1] == '.py' else 'bat'\neditor.setup_editor(linenumbers=self.get_option('line_numbers'), language=\n    language, color_scheme=self.get_option('color_scheme_name'), font=self.\n    font, wrap=self.get_option('wrap'))\neditor.setReadOnly(True)\neditor.set_text(self.get_filename_text(filename))\neditor.set_cursor_position('eof')\nself.find_widget.set_editor(editor)\nindex = self.tabwidget.addTab(editor, osp.basename(filename))\nself.filenames.append(filename)\nself.editors.append(editor)\nself.tabwidget.setCurrentIndex(index)\nself.tabwidget.setTabToolTip(index, filename)\neditor.sig_focus_changed.connect(lambda : self.sig_focus_changed.emit())\n",
        "CUT_3": "self.editor.set_text_from_file(filename)\nself.setWindowTitle('%s - %s (%s)' % (_('Editor'), osp.basename(filename),\n    osp.dirname(filename)))\nself.editor.hide_tooltip()\n",
        "CUT_4": "self.editor.set_text_from_file(filename)\nself.setWindowTitle('%s - %s (%s)' % (_('Editor'), osp.basename(filename),\n    osp.dirname(filename)))\nself.editor.hide_tooltip()\n",
        "CUT_5": "\"\"\"Return if filename is in the editor stack.\n\n        Args:\n            filename: Name of the file to search for.  If filename is None,\n                then checks if any file is open.\n\n        Returns:\n            True: If filename is None and a file is open.\n            False: If filename is None and no files are open.\n            None: If filename is not None and the file isn't found.\n            integer: Index of file name in editor stack.\n        \"\"\"\nif filename is None:\n    return len(self.data) > 0\nelse:\n    return self.has_filename(filename)\n"
    },
    {
        "functionName": "test_clear_bookmarks",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_bookmarks.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test CodeEditor.clear_bookmarks. Remove bookmarks from all blocks.\"\"\"\neditor, __ = code_editor_bookmarks\nassert len(list(editor.blockuserdata_list())) == 1\nbm = {(1): ('filename', 1, 0), (2): ('filename', 3, 5)}\neditor.set_bookmarks(bm)\nassert editor.get_bookmarks() == {(1): [1, 0], (2): [3, 5]}\nassert len(list(editor.blockuserdata_list())) == 3\neditor.clear_bookmarks()\nassert editor.get_bookmarks() == {}\nassert len(list(editor.blockuserdata_list())) == 3\nfor data in editor.blockuserdata_list():\n    assert not data.bookmarks\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Clear bookmarks for all blocks.\"\"\"\nself.bookmarks = {}\nfor data in self.blockuserdata_list():\n    data.bookmarks = []\n",
        "CUT_4": "\"\"\"Clear bookmarks for all blocks.\"\"\"\nself.bookmarks = {}\nfor data in self.blockuserdata_list():\n    data.bookmarks = []\n",
        "CUT_5": "\"\"\"Clear breakpoints\"\"\"\nself.breakpoints = []\nfor data in self.editor.blockuserdata_list():\n    data.breakpoint = False\nself.editor.sig_breakpoints_changed.emit()\nself.editor.sig_flags_changed.emit()\n"
    },
    {
        "functionName": "test_update_bookmarks",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_bookmarks.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test CodeEditor.update_bookmarks. Check if signal is emitted.\"\"\"\neditor, __ = code_editor_bookmarks\nreset_emits(editor)\neditor.sig_bookmarks_changed.emit.assert_not_called()\neditor.textCursor().insertBlock()\neditor.sig_bookmarks_changed.emit.assert_called_with()\n",
        "CUT_1": "\"\"\"Emit signal to update bookmarks.\"\"\"\nself.sig_bookmarks_changed.emit()\n",
        "CUT_2": "\"\"\"Emit signal to update bookmarks.\"\"\"\nself.sig_bookmarks_changed.emit()\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_save_bookmark",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_bookmarks.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test Plugin.save_bookmark.\n\n    Test saving of bookmarks by looking at data in blocks. Reassignment\n    should remove data from old block and put it in new.\n    \"\"\"\neditor, _, _ = editor_plugin_open_files(None, None)\neditorstack = editor.get_current_editorstack()\nedtr = editorstack.get_current_editor()\ncursor = edtr.textCursor()\neditor.save_bookmark(1)\nbookmarks = edtr.document().findBlockByNumber(0).userData().bookmarks\nassert bookmarks == [(1, 0)]\ncursor.movePosition(QTextCursor.Down, n=1)\ncursor.movePosition(QTextCursor.Right, n=2)\nedtr.setTextCursor(cursor)\neditor.save_bookmark(1)\nbookmarks = edtr.document().findBlockByNumber(1).userData().bookmarks\nassert bookmarks == [(1, 2)]\nbookmarks = edtr.document().findBlockByNumber(0).userData().bookmarks\nassert bookmarks == []\n",
        "CUT_1": "\"\"\"Bookmarks list has changed.\"\"\"\nbookmarks = self.editor.get_bookmarks()\nif self.editor.bookmarks != bookmarks:\n    self.editor.bookmarks = bookmarks\n    self.sig_save_bookmarks.emit(self.filename, repr(bookmarks))\n",
        "CUT_2": "\"\"\"Bookmarks list has changed.\"\"\"\nbookmarks = self.editor.get_bookmarks()\nif self.editor.bookmarks != bookmarks:\n    self.editor.bookmarks = bookmarks\n    self.sig_save_bookmarks.emit(self.filename, repr(bookmarks))\n",
        "CUT_3": "\"\"\"Get bookmarks by going over all blocks.\"\"\"\nbookmarks = {}\nblock = self.document().firstBlock()\nfor line_number in range(0, self.document().blockCount()):\n    data = block.userData()\n    if data and data.bookmarks:\n        for slot_num, column in data.bookmarks:\n            bookmarks[slot_num] = [line_number, column]\n    block = block.next()\nreturn bookmarks\n",
        "CUT_4": "\"\"\"Get bookmarks by going over all blocks.\"\"\"\nbookmarks = {}\nblock = self.document().firstBlock()\nfor line_number in range(0, self.document().blockCount()):\n    data = block.userData()\n    if data and data.bookmarks:\n        for slot_num, column in data.bookmarks:\n            bookmarks[slot_num] = [line_number, column]\n    block = block.next()\nreturn bookmarks\n",
        "CUT_5": "\"\"\"Clear bookmarks for all blocks.\"\"\"\nself.bookmarks = {}\nfor data in self.blockuserdata_list():\n    data.bookmarks = []\n"
    },
    {
        "functionName": "test_load_bookmark",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_bookmarks.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that loading a bookmark works.\n\n    Check this by saving and loading bookmarks and checking for cursor\n    position. Also over multiple files.\n    \"\"\"\neditor, _, _ = editor_plugin_open_files(None, None)\neditorstack = editor.get_current_editorstack()\nedtr = editorstack.get_current_editor()\ncursor = edtr.textCursor()\neditor.save_bookmark(1)\ncursor.movePosition(QTextCursor.Down, n=1)\ncursor.movePosition(QTextCursor.Right, n=4)\nedtr.setTextCursor(cursor)\nassert edtr.get_cursor_line_column() != (0, 0)\neditor.load_bookmark(1)\nassert edtr.get_cursor_line_column() == (0, 0)\ncursor.movePosition(QTextCursor.Down, n=1)\ncursor.movePosition(QTextCursor.Right, n=19)\nedtr.setTextCursor(cursor)\neditor.save_bookmark(2)\nedtr.stdkey_backspace()\nedtr.stdkey_backspace()\neditor.load_bookmark(2)\nassert edtr.get_cursor_line_column() == (1, 18)\neditor.save_bookmark(2)\neditorstack.tabs.setCurrentIndex(1)\neditor.load_bookmark(2)\nassert editorstack.tabs.currentIndex() == 0\n",
        "CUT_1": "\"\"\"Kill the text on the current line from the cursor forward\"\"\"\ncursor = self.textCursor()\ncursor.clearSelection()\ncursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)\nif not cursor.hasSelection():\n    cursor.movePosition(QTextCursor.NextBlock, QTextCursor.KeepAnchor)\nself._kill_ring.kill_cursor(cursor)\nself.setTextCursor(cursor)\nself.document_did_change()\n",
        "CUT_2": "\"\"\"Kill the text on the current line from the cursor forward\"\"\"\ncursor = self.textCursor()\ncursor.clearSelection()\ncursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)\nif not cursor.hasSelection():\n    cursor.movePosition(QTextCursor.NextBlock, QTextCursor.KeepAnchor)\nself._kill_ring.kill_cursor(cursor)\nself.setTextCursor(cursor)\nself.document_did_change()\n",
        "CUT_3": "\"\"\"Remove trailing spaces\"\"\"\ncursor = self.textCursor()\ncursor.beginEditBlock()\ncursor.movePosition(QTextCursor.Start)\nwhile True:\n    cursor.movePosition(QTextCursor.EndOfBlock)\n    text = to_text_string(cursor.block().text())\n    length = len(text) - len(text.rstrip())\n    if length > 0:\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, length)\n        cursor.removeSelectedText()\n    if cursor.atEnd():\n        break\n    cursor.movePosition(QTextCursor.NextBlock)\ncursor.endEditBlock()\nself.document_did_change()\n",
        "CUT_4": "\"\"\"Remove trailing spaces\"\"\"\ncursor = self.textCursor()\ncursor.beginEditBlock()\ncursor.movePosition(QTextCursor.Start)\nwhile True:\n    cursor.movePosition(QTextCursor.EndOfBlock)\n    text = to_text_string(cursor.block().text())\n    length = len(text) - len(text.rstrip())\n    if length > 0:\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, length)\n        cursor.removeSelectedText()\n    if cursor.atEnd():\n        break\n    cursor.movePosition(QTextCursor.NextBlock)\ncursor.endEditBlock()\nself.document_did_change()\n",
        "CUT_5": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n"
    },
    {
        "functionName": "construct_editor",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_panels.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "app = qapplication()\neditor = CodeEditor(parent=None)\nkwargs['language'] = 'Python'\neditor.setup_editor(*args, **kwargs)\nreturn editor\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "if os.name == 'nt':\n    return zmqtunnel.paramiko_tunnel(*args, **kwargs)\nelse:\n    return openssh_tunnel(self, *args, **kwargs)\n",
        "CUT_4": "if os.name == 'nt':\n    return zmqtunnel.paramiko_tunnel(*args, **kwargs)\nelse:\n    return openssh_tunnel(self, *args, **kwargs)\n",
        "CUT_5": "editor = CodeEditor(parent=None)\neditor.setup_editor(language='Python', tab_mode=False, markers=True,\n    close_quotes=True, close_parentheses=True, color_scheme='spyder/dark',\n    font=QFont('Monospace', 10), automatic_completions=True,\n    automatic_completions_after_chars=1, automatic_completions_after_ms=200,\n    folding=False)\neditor.resize(640, 480)\nreturn editor\n"
    },
    {
        "functionName": "test_activate_panels",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_panels.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test activate/deactivate of editors Panels.\n\n    Also test that the panel is added to the editor.\n    \"\"\"\nkwargs = {}\nkwargs[setting] = state\neditor = construct_editor(**kwargs)\nfound = False\nfor panel in editor.panels:\n    if isinstance(panel, panelclass):\n        assert panel.enabled == state\n        found = True\nassert found\npytest.mark.parametrize('state', [True, False])pytest.mark.parametrize('setting, panelclass', [('linenumbers',\n    LineNumberArea), ('edge_line', EdgeLine), ('scrollflagarea',\n    ScrollFlagArea), ('indent_guides', IndentationGuide)])",
        "CUT_1": "\"\"\"\n        Installs a panel on the editor.\n\n        :param panel: Panel to install\n        :param position: Position where the panel must be installed.\n        :return: The installed panel\n        \"\"\"\nassert panel is not None\npos_to_string = {Panel.Position.BOTTOM: 'bottom', Panel.Position.LEFT:\n    'left', Panel.Position.RIGHT: 'right', Panel.Position.TOP: 'top', Panel\n    .Position.FLOATING: 'floating'}\nlogger.debug('adding panel %s at %s' % (panel.name, pos_to_string[position]))\npanel.order_in_zone = len(self._panels[position])\nself._panels[position][panel.name] = panel\npanel.position = position\npanel.on_install(self.editor)\nlogger.debug('panel %s installed' % panel.name)\nreturn panel\n",
        "CUT_2": "\"\"\"\n        Installs a panel on the editor.\n\n        :param panel: Panel to install\n        :param position: Position where the panel must be installed.\n        :return: The installed panel\n        \"\"\"\nassert panel is not None\npos_to_string = {Panel.Position.BOTTOM: 'bottom', Panel.Position.LEFT:\n    'left', Panel.Position.RIGHT: 'right', Panel.Position.TOP: 'top', Panel\n    .Position.FLOATING: 'floating'}\nlogger.debug('adding panel %s at %s' % (panel.name, pos_to_string[position]))\npanel.order_in_zone = len(self._panels[position])\nself._panels[position][panel.name] = panel\npanel.position = position\npanel.on_install(self.editor)\nlogger.debug('panel %s installed' % panel.name)\nreturn panel\n",
        "CUT_3": "\"\"\"\n        Removes the specified panel.\n\n        :param name_or_klass: Name or class of the panel to remove.\n        :return: The removed panel\n        \"\"\"\nlogger.debug('removing panel %s' % name_or_klass)\npanel = self.get(name_or_klass)\npanel.on_uninstall()\npanel.hide()\npanel.setParent(None)\nreturn self._panels[panel.position].pop(panel.name, None)\n",
        "CUT_4": "\"\"\"\n        Removes the specified panel.\n\n        :param name_or_klass: Name or class of the panel to remove.\n        :return: The removed panel\n        \"\"\"\nlogger.debug('removing panel %s' % name_or_klass)\npanel = self.get(name_or_klass)\npanel.on_uninstall()\npanel.hide()\npanel.setParent(None)\nreturn self._panels[panel.position].pop(panel.name, None)\n",
        "CUT_5": "\"\"\"Update foating panels.\"\"\"\ncrect = self.editor.contentsRect()\npanels = self.panels_for_zone(Panel.Position.FLOATING)\nfor panel in panels:\n    if not panel.isVisible():\n        continue\n    panel.set_geometry(crect)\n"
    },
    {
        "functionName": "editor_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Set up EditorStack with CodeEditors containing some Python code.\n    The cursor is at the empty line below the code.\n    \"\"\"\neditorstack = EditorStack(None, [])\neditorstack.set_find_widget(Mock())\neditorstack.set_io_actions(Mock(), Mock(), Mock(), Mock())\neditorstack.close_action.setEnabled(False)\neditorstack.new('foo.py', 'utf-8', \"\"\"Line1\nLine2\nLine3\nLine4\"\"\")\nqtbot.addWidget(editorstack)\neditorstack.show()\neditorstack.go_to_line(1)\nreturn editorstack, qtbot\npytest.fixture",
        "CUT_1": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "test_default_keybinding_values",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Assert that the default Spyder keybindings for the keyboard shorcuts\n    are as expected. This is required because we do not use the keybindings\n    saved in Spyder's config to simulate the user keyboard action, due to\n    the fact that it is complicated to convert and pass reliably a sequence\n    of key strings to qtbot.keyClicks.\n    \"\"\"\nassert CONF.get_shortcut('editor', 'start of document') == 'Ctrl+Home'\nassert CONF.get_shortcut('editor', 'end of document') == 'Ctrl+End'\nassert CONF.get_shortcut('editor', 'delete') == 'Del'\nassert CONF.get_shortcut('editor', 'undo') == 'Ctrl+Z'\nassert CONF.get_shortcut('editor', 'redo') == 'Ctrl+Shift+Z'\nassert CONF.get_shortcut('editor', 'copy') == 'Ctrl+C'\nassert CONF.get_shortcut('editor', 'paste') == 'Ctrl+V'\nassert CONF.get_shortcut('editor', 'cut') == 'Ctrl+X'\nassert CONF.get_shortcut('editor', 'select all') == 'Ctrl+A'\nassert CONF.get_shortcut('editor', 'delete line') == 'Ctrl+D'\nassert CONF.get_shortcut('editor', 'transform to lowercase') == 'Ctrl+U'\nassert CONF.get_shortcut('editor', 'transform to uppercase') == 'Ctrl+Shift+U'\nassert CONF.get_shortcut('editor', 'go to line') == 'Ctrl+L'\nassert CONF.get_shortcut('editor', 'next word') == 'Ctrl+Right'\nassert CONF.get_shortcut('editor', 'previous word') == 'Ctrl+Left'\n",
        "CUT_1": "self.key = CONF.get_shortcut(self.context, self.name)\n",
        "CUT_2": "self.key = CONF.get_shortcut(self.context, self.name)\n",
        "CUT_3": "\"\"\"Setup context menu\"\"\"\nself.undo_action = create_action(self, _('Undo'), icon=ima.icon('undo'),\n    shortcut=CONF.get_shortcut('editor', 'undo'), triggered=self.undo)\nself.redo_action = create_action(self, _('Redo'), icon=ima.icon('redo'),\n    shortcut=CONF.get_shortcut('editor', 'redo'), triggered=self.redo)\nself.cut_action = create_action(self, _('Cut'), icon=ima.icon('editcut'),\n    shortcut=CONF.get_shortcut('editor', 'cut'), triggered=self.cut)\nself.copy_action = create_action(self, _('Copy'), icon=ima.icon('editcopy'),\n    shortcut=CONF.get_shortcut('editor', 'copy'), triggered=self.copy)\nself.paste_action = create_action(self, _('Paste'), icon=ima.icon(\n    'editpaste'), shortcut=CONF.get_shortcut('editor', 'paste'), triggered=\n    self.paste)\nselectall_action = create_action(self, _('Select All'), icon=ima.icon(\n    'selectall'), shortcut=CONF.get_shortcut('editor', 'select all'),\n    triggered=self.selectAll)\ntoggle_comment_action = create_action(self, _('Comment') + '/' + _(\n    'Uncomment'), icon=ima.icon('comment'), shortcut=CONF.get_shortcut(\n    'editor', 'toggle comment'), triggered=self.toggle_comment)\nself.clear_all_output_action = create_action(self, _('Clear all ouput'),\n    icon=ima.icon('ipython_console'), triggered=self.clear_all_output)\nself.ipynb_convert_action = create_action(self, _(\n    'Convert to Python script'), icon=ima.icon('python'), triggered=self.\n    convert_notebook)\nself.gotodef_action = create_action(self, _('Go to definition'), shortcut=\n    CONF.get_shortcut('editor', 'go to definition'), triggered=self.\n    go_to_definition_from_cursor)\nself.run_cell_action = create_action(self, _('Run cell'), icon=ima.icon(\n    'run_cell'), shortcut=CONF.get_shortcut('editor', 'run cell'),\n    triggered=self.sig_run_cell.emit)\nself.run_cell_and_advance_action = create_action(self, _(\n    'Run cell and advance'), icon=ima.icon('run_cell'), shortcut=CONF.\n    get_shortcut('editor', 'run cell and advance'), triggered=self.\n    sig_run_cell_and_advance.emit)\nself.re_run_last_cell_action = create_action(self, _('Re-run last cell'),\n    icon=ima.icon('run_cell'), shortcut=CONF.get_shortcut('editor',\n    're-run last cell'), triggered=self.sig_re_run_last_cell.emit)\nself.run_selection_action = create_action(self, _(\n    'Run &selection or current line'), icon=ima.icon('run_selection'),\n    shortcut=CONF.get_shortcut('editor', 'run selection'), triggered=self.\n    sig_run_selection.emit)\nself.debug_cell_action = create_action(self, _('Debug cell'), icon=ima.icon\n    ('debug_cell'), shortcut=CONF.get_shortcut('editor', 'debug cell'),\n    triggered=self.sig_debug_cell.emit)\nzoom_in_action = create_action(self, _('Zoom in'), icon=ima.icon('zoom_in'),\n    shortcut=QKeySequence(QKeySequence.ZoomIn), triggered=self.zoom_in.emit)\nzoom_out_action = create_action(self, _('Zoom out'), icon=ima.icon(\n    'zoom_out'), shortcut=QKeySequence(QKeySequence.ZoomOut), triggered=\n    self.zoom_out.emit)\nzoom_reset_action = create_action(self, _('Zoom reset'), shortcut=\n    QKeySequence('Ctrl+0'), triggered=self.zoom_reset.emit)\nwriter = self.writer_docstring\nself.docstring_action = create_action(self, _('Generate docstring'),\n    shortcut=CONF.get_shortcut('editor', 'docstring'), triggered=writer.\n    write_docstring_at_first_line_of_function)\nformatter = CONF.get('lsp-server', 'formatting')\nself.format_action = create_action(self, _(\n    'Format file or selection with {0}').format(formatter.capitalize()),\n    shortcut=CONF.get_shortcut('editor', 'autoformatting'), triggered=self.\n    format_document_or_range)\nself.format_action.setEnabled(False)\nself.menu = QMenu(self)\nactions_1 = [self.run_cell_action, self.run_cell_and_advance_action, self.\n    re_run_last_cell_action, self.run_selection_action, self.gotodef_action,\n    None, self.undo_action, self.redo_action, None, self.cut_action, self.\n    copy_action, self.paste_action, selectall_action]\nactions_2 = [None, zoom_in_action, zoom_out_action, zoom_reset_action, None,\n    toggle_comment_action, self.docstring_action, self.format_action]\nif nbformat is not None:\n    nb_actions = [self.clear_all_output_action, self.ipynb_convert_action, None\n        ]\n    actions = actions_1 + nb_actions + actions_2\n    add_actions(self.menu, actions)\nelse:\n    actions = actions_1 + actions_2\n    add_actions(self.menu, actions)\nself.readonly_menu = QMenu(self)\nadd_actions(self.readonly_menu, (self.copy_action, None, selectall_action,\n    self.gotodef_action))\n",
        "CUT_4": "\"\"\"Setup context menu\"\"\"\nself.undo_action = create_action(self, _('Undo'), icon=ima.icon('undo'),\n    shortcut=CONF.get_shortcut('editor', 'undo'), triggered=self.undo)\nself.redo_action = create_action(self, _('Redo'), icon=ima.icon('redo'),\n    shortcut=CONF.get_shortcut('editor', 'redo'), triggered=self.redo)\nself.cut_action = create_action(self, _('Cut'), icon=ima.icon('editcut'),\n    shortcut=CONF.get_shortcut('editor', 'cut'), triggered=self.cut)\nself.copy_action = create_action(self, _('Copy'), icon=ima.icon('editcopy'),\n    shortcut=CONF.get_shortcut('editor', 'copy'), triggered=self.copy)\nself.paste_action = create_action(self, _('Paste'), icon=ima.icon(\n    'editpaste'), shortcut=CONF.get_shortcut('editor', 'paste'), triggered=\n    self.paste)\nselectall_action = create_action(self, _('Select All'), icon=ima.icon(\n    'selectall'), shortcut=CONF.get_shortcut('editor', 'select all'),\n    triggered=self.selectAll)\ntoggle_comment_action = create_action(self, _('Comment') + '/' + _(\n    'Uncomment'), icon=ima.icon('comment'), shortcut=CONF.get_shortcut(\n    'editor', 'toggle comment'), triggered=self.toggle_comment)\nself.clear_all_output_action = create_action(self, _('Clear all ouput'),\n    icon=ima.icon('ipython_console'), triggered=self.clear_all_output)\nself.ipynb_convert_action = create_action(self, _(\n    'Convert to Python script'), icon=ima.icon('python'), triggered=self.\n    convert_notebook)\nself.gotodef_action = create_action(self, _('Go to definition'), shortcut=\n    CONF.get_shortcut('editor', 'go to definition'), triggered=self.\n    go_to_definition_from_cursor)\nself.run_cell_action = create_action(self, _('Run cell'), icon=ima.icon(\n    'run_cell'), shortcut=CONF.get_shortcut('editor', 'run cell'),\n    triggered=self.sig_run_cell.emit)\nself.run_cell_and_advance_action = create_action(self, _(\n    'Run cell and advance'), icon=ima.icon('run_cell'), shortcut=CONF.\n    get_shortcut('editor', 'run cell and advance'), triggered=self.\n    sig_run_cell_and_advance.emit)\nself.re_run_last_cell_action = create_action(self, _('Re-run last cell'),\n    icon=ima.icon('run_cell'), shortcut=CONF.get_shortcut('editor',\n    're-run last cell'), triggered=self.sig_re_run_last_cell.emit)\nself.run_selection_action = create_action(self, _(\n    'Run &selection or current line'), icon=ima.icon('run_selection'),\n    shortcut=CONF.get_shortcut('editor', 'run selection'), triggered=self.\n    sig_run_selection.emit)\nself.debug_cell_action = create_action(self, _('Debug cell'), icon=ima.icon\n    ('debug_cell'), shortcut=CONF.get_shortcut('editor', 'debug cell'),\n    triggered=self.sig_debug_cell.emit)\nzoom_in_action = create_action(self, _('Zoom in'), icon=ima.icon('zoom_in'),\n    shortcut=QKeySequence(QKeySequence.ZoomIn), triggered=self.zoom_in.emit)\nzoom_out_action = create_action(self, _('Zoom out'), icon=ima.icon(\n    'zoom_out'), shortcut=QKeySequence(QKeySequence.ZoomOut), triggered=\n    self.zoom_out.emit)\nzoom_reset_action = create_action(self, _('Zoom reset'), shortcut=\n    QKeySequence('Ctrl+0'), triggered=self.zoom_reset.emit)\nwriter = self.writer_docstring\nself.docstring_action = create_action(self, _('Generate docstring'),\n    shortcut=CONF.get_shortcut('editor', 'docstring'), triggered=writer.\n    write_docstring_at_first_line_of_function)\nformatter = CONF.get('lsp-server', 'formatting')\nself.format_action = create_action(self, _(\n    'Format file or selection with {0}').format(formatter.capitalize()),\n    shortcut=CONF.get_shortcut('editor', 'autoformatting'), triggered=self.\n    format_document_or_range)\nself.format_action.setEnabled(False)\nself.menu = QMenu(self)\nactions_1 = [self.run_cell_action, self.run_cell_and_advance_action, self.\n    re_run_last_cell_action, self.run_selection_action, self.gotodef_action,\n    None, self.undo_action, self.redo_action, None, self.cut_action, self.\n    copy_action, self.paste_action, selectall_action]\nactions_2 = [None, zoom_in_action, zoom_out_action, zoom_reset_action, None,\n    toggle_comment_action, self.docstring_action, self.format_action]\nif nbformat is not None:\n    nb_actions = [self.clear_all_output_action, self.ipynb_convert_action, None\n        ]\n    actions = actions_1 + nb_actions + actions_2\n    add_actions(self.menu, actions)\nelse:\n    actions = actions_1 + actions_2\n    add_actions(self.menu, actions)\nself.readonly_menu = QMenu(self)\nadd_actions(self.readonly_menu, (self.copy_action, None, selectall_action,\n    self.gotodef_action))\n",
        "CUT_5": "\"\"\"Action for Ctrl+Space\"\"\"\npass\n"
    },
    {
        "functionName": "test_start_and_end_of_document_shortcuts",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the start of document and end of document shortcut are working\n    as expected.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\nassert editor.get_cursor_line_column() == (0, 0)\nqtbot.keyClick(editor, Qt.Key_End, modifier=Qt.ControlModifier)\nassert editor.get_cursor_line_column() == (4, 0)\nqtbot.keyClick(editor, Qt.Key_Home, modifier=Qt.ControlModifier)\nassert editor.get_cursor_line_column() == (0, 0)\npytest.mark.skipif(sys.platform.startswith('linux') and os.environ.get('CI'\n    ) is not None, reason=\n    'It fails on Linux due to the lack of a proper X server.')",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_del_undo_redo_shortcuts",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the undo and redo keyboard shortcuts are working as expected\n    with the default Spyder keybindings.\n\n    Regression test for spyder-ide/spyder#7743.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\nqtbot.keyClick(editor, Qt.Key_Delete)\nassert editor.toPlainText() == \"\"\"ine1\nLine2\nLine3\nLine4\n\"\"\"\nqtbot.keyClick(editor, Qt.Key_Z, modifier=Qt.ControlModifier)\nassert editor.toPlainText() == \"\"\"Line1\nLine2\nLine3\nLine4\n\"\"\"\nqtbot.keyClick(editor, Qt.Key_Z, modifier=Qt.ControlModifier | Qt.ShiftModifier\n    )\nassert editor.toPlainText() == \"\"\"ine1\nLine2\nLine3\nLine4\n\"\"\"\nqtbot.keyClick(editor, Qt.Key_Z, modifier=Qt.ControlModifier)\nassert editor.toPlainText() == \"\"\"Line1\nLine2\nLine3\nLine4\n\"\"\"\npytest.mark.skipif(sys.platform.startswith('linux') and os.environ.get('CI'\n    ) is not None, reason=\n    'It fails on Linux due to the lack of a proper X server.')",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_copy_cut_paste_shortcuts",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the copy, cut, and paste keyboard shortcuts are working as\n    expected with the default Spyder keybindings.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\nQApplication.clipboard().clear()\nqtbot.keyClick(editor, Qt.Key_End, modifier=Qt.ShiftModifier)\nassert editor.get_selected_text() == 'Line1'\nqtbot.keyClick(editor, Qt.Key_C, modifier=Qt.ControlModifier)\nassert QApplication.clipboard().text() == 'Line1'\nqtbot.keyClick(editor, Qt.Key_Home)\nqtbot.keyClick(editor, Qt.Key_V, modifier=Qt.ControlModifier)\nassert editor.toPlainText() == \"\"\"Line1Line1\nLine2\nLine3\nLine4\n\"\"\"\nqtbot.keyClick(editor, Qt.Key_Home)\nqtbot.keyClick(editor, Qt.Key_End, modifier=Qt.ShiftModifier)\nassert editor.get_selected_text() == 'Line1Line1'\nqtbot.keyClick(editor, Qt.Key_X, modifier=Qt.ControlModifier)\nassert QApplication.clipboard().text() == 'Line1Line1'\nassert editor.toPlainText() == \"\"\"\nLine2\nLine3\nLine4\n\"\"\"\npytest.mark.skipif(sys.platform.startswith('linux') and os.environ.get('CI'\n    ) is not None, reason=\n    'It fails on Linux due to the lack of a proper X server.')",
        "CUT_1": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_select_all_shortcut",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the select all keyboard shortcut is working as\n    expected with the default Spyder keybindings.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\nqtbot.keyClick(editor, Qt.Key_A, modifier=Qt.ControlModifier)\nassert editor.get_selected_text() == \"\"\"Line1\nLine2\nLine3\nLine4\n\"\"\"\npytest.mark.skipif(sys.platform.startswith('linux') and os.environ.get('CI'\n    ) is not None, reason=\n    'It fails on Linux due to the lack of a proper X server.')",
        "CUT_1": "\"\"\"Get editor for filename and set it as the current editor.\"\"\"\neditorstack = self.get_editorstack()\nif editorstack is None:\n    return None\nif not filename:\n    return None\nindex = editorstack.has_filename(filename)\nif index is None:\n    return None\nreturn editorstack.data[index].editor\n",
        "CUT_2": "\"\"\"Get editor for filename and set it as the current editor.\"\"\"\neditorstack = self.get_editorstack()\nif editorstack is None:\n    return None\nif not filename:\n    return None\nindex = editorstack.has_filename(filename)\nif index is None:\n    return None\nreturn editorstack.data[index].editor\n",
        "CUT_3": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n"
    },
    {
        "functionName": "test_delete_line_shortcut",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the delete line keyboard shortcut is working as\n    expected with the default Spyder keybindings.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\neditor.go_to_line(2)\nqtbot.keyClick(editor, Qt.Key_D, modifier=Qt.ControlModifier)\nassert editor.toPlainText() == \"\"\"Line1\nLine3\nLine4\n\"\"\"\npytest.mark.skipif(sys.platform.startswith('linux') and os.environ.get('CI'\n    ) is not None, reason=\n    'It fails on Linux due to the lack of a proper X server.')pytest.mark.no_xvfb",
        "CUT_1": "\"\"\"Get editor for filename and set it as the current editor.\"\"\"\neditorstack = self.get_editorstack()\nif editorstack is None:\n    return None\nif not filename:\n    return None\nindex = editorstack.has_filename(filename)\nif index is None:\n    return None\nreturn editorstack.data[index].editor\n",
        "CUT_2": "\"\"\"Get editor for filename and set it as the current editor.\"\"\"\neditorstack = self.get_editorstack()\nif editorstack is None:\n    return None\nif not filename:\n    return None\nindex = editorstack.has_filename(filename)\nif index is None:\n    return None\nreturn editorstack.data[index].editor\n",
        "CUT_3": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_4": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_go_to_line_shortcut",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the go to line keyboard shortcut is working\n    as expected with the default Spyder keybindings.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\nqtbot.keyClick(editor, Qt.Key_Home, modifier=Qt.ControlModifier)\nmocker.patch.object(GoToLineDialog, 'exec_', return_value=True)\nmocker.patch.object(GoToLineDialog, 'get_line_number', return_value=3)\nqtbot.keyClick(editor, Qt.Key_L, modifier=Qt.ControlModifier)\nassert editor.get_cursor_line_column() == (2, 0)\npytest.mark.skipif(sys.platform.startswith('linux') and os.environ.get('CI'\n    ) is not None, reason=\n    'It fails on Linux due to the lack of a proper X server.')pytest.mark.no_xvfb",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_3": "\"\"\"Execute the GoToLineDialog dialog box\"\"\"\ndlg = GoToLineDialog(self)\nif dlg.exec_():\n    self.go_to_line(dlg.get_line_number())\n",
        "CUT_4": "\"\"\"Execute the GoToLineDialog dialog box\"\"\"\ndlg = GoToLineDialog(self)\nif dlg.exec_():\n    self.go_to_line(dlg.get_line_number())\n",
        "CUT_5": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n"
    },
    {
        "functionName": "test_transform_to_lowercase_shortcut",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the transform to lowercase shorcut is working as expected with\n    the default Spyder keybindings.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\nqtbot.keyClick(editor, Qt.Key_A, modifier=Qt.ControlModifier)\nqtbot.keyClick(editor, Qt.Key_U, modifier=Qt.ControlModifier)\nassert editor.toPlainText() == \"\"\"line1\nline2\nline3\nline4\n\"\"\"\npytest.mark.skipif(sys.platform.startswith('linux') and os.environ.get('CI'\n    ) is not None, reason=\n    'It fails on Linux due to the lack of a proper X server.')pytest.mark.no_xvfb",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_5": "\"\"\"Change current line or selection to lowercase.\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.transform_to_lowercase()\nSlot()"
    },
    {
        "functionName": "test_transform_to_uppercase_shortcut",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the transform to uppercase shorcuts is working as expected with\n    the default Spyder keybindings.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\nqtbot.keyClick(editor, Qt.Key_A, modifier=Qt.ControlModifier)\nqtbot.keyClick(editor, Qt.Key_U, modifier=Qt.ControlModifier | Qt.ShiftModifier\n    )\nassert editor.toPlainText() == \"\"\"LINE1\nLINE2\nLINE3\nLINE4\n\"\"\"\npytest.mark.skipif(sys.platform.startswith('linux') and os.environ.get('CI'\n    ) is not None, reason=\n    'It fails on Linux due to the lack of a proper X server.')pytest.mark.no_xvfb",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_5": "\"\"\"Override Qt method to process keypress.\"\"\"\ntext, key = event.text(), event.key()\nalt = event.modifiers() & Qt.AltModifier\nshift = event.modifiers() & Qt.ShiftModifier\nctrl = event.modifiers() & Qt.ControlModifier\naltgr = event.modifiers() and key == Qt.Key_AltGr\nneo2_level4 = key == 0\nmodifier = shift or ctrl or alt or altgr or neo2_level4\nif key in (Qt.Key_Return, Qt.Key_Enter, Qt.Key_Tab):\n    item = self.currentItem()\n    if item is None:\n        item = self.item(0)\n    if self.is_up_to_date(item=item):\n        self.item_selected(item=item)\n    else:\n        self.hide()\n        self.textedit.keyPressEvent(event)\nelif key == Qt.Key_Escape:\n    self.hide()\nelif key in (Qt.Key_Left, Qt.Key_Right) or text in ('.', ':'):\n    self.hide()\n    self.textedit.keyPressEvent(event)\nelif key in (Qt.Key_Up, Qt.Key_Down, Qt.Key_PageUp, Qt.Key_PageDown, Qt.\n    Key_Home, Qt.Key_End) and not modifier:\n    self.textedit._completions_hint_idle = True\n    if key == Qt.Key_Up and self.currentRow() == 0:\n        self.setCurrentRow(self.count() - 1)\n    elif key == Qt.Key_Down and self.currentRow() == self.count() - 1:\n        self.setCurrentRow(0)\n    else:\n        QListWidget.keyPressEvent(self, event)\nelif len(text) or key == Qt.Key_Backspace:\n    self.textedit.keyPressEvent(event)\n    self.update_current(new=False)\nelif modifier:\n    self.textedit.keyPressEvent(event)\nelse:\n    self.hide()\n    QListWidget.keyPressEvent(self, event)\n"
    },
    {
        "functionName": "test_next_and_previous_word_shortcuts",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the next word and previous word shortcuts are working as\n    expected with the default Spyder keybindings.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\nassert editor.get_cursor_line_column() == (0, 0)\nqtbot.keyClick(editor, Qt.Key_Right, modifier=Qt.ControlModifier)\nassert editor.get_cursor_line_column() == (0, 5)\nqtbot.keyClick(editor, Qt.Key_Right, modifier=Qt.ControlModifier)\nassert editor.get_cursor_line_column() == (1, 0)\nqtbot.keyClick(editor, Qt.Key_Right, modifier=Qt.ControlModifier)\nassert editor.get_cursor_line_column() == (1, 5)\nqtbot.keyClick(editor, Qt.Key_Left, modifier=Qt.ControlModifier)\nassert editor.get_cursor_line_column() == (1, 0)\nqtbot.keyClick(editor, Qt.Key_Left, modifier=Qt.ControlModifier)\nassert editor.get_cursor_line_column() == (0, 5)\nqtbot.keyClick(editor, Qt.Key_Left, modifier=Qt.ControlModifier)\nassert editor.get_cursor_line_column() == (0, 0)\npytest.mark.skipif(sys.platform.startswith('linux') and os.environ.get('CI'\n    ) is not None, reason=\n    'It fails on Linux due to the lack of a proper X server.')pytest.mark.no_xvfb",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\" \"\"\"\nkey = event.key()\nself.key_pressed = key\nkeys = [Qt.Key_Right, Qt.Key_Left, Qt.Key_Down, Qt.Key_Up, Qt.Key_Escape,\n    Qt.Key_PageUp, Qt.Key_PageDown, Qt.Key_Home, Qt.Key_End, Qt.Key_Menu]\nif key in keys:\n    if not self.is_fade_running():\n        self.sig_key_pressed.emit()\n",
        "CUT_4": "\"\"\" \"\"\"\nkey = event.key()\nself.key_pressed = key\nkeys = [Qt.Key_Right, Qt.Key_Left, Qt.Key_Down, Qt.Key_Up, Qt.Key_Escape,\n    Qt.Key_PageUp, Qt.Key_PageDown, Qt.Key_Home, Qt.Key_End, Qt.Key_Menu]\nif key in keys:\n    if not self.is_fade_running():\n        self.sig_key_pressed.emit()\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_builtin_shift_del_and_ins",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the builtin key sequences Ctrl+Ins, Shit+Del and Shift+Ins result\n    in copy, cut and paste actions in Windows and Linux.\n\n    Regression test for spyder-ide/spyder#5035, spyder-ide/spyder#4947, and\n    spyder-ide/spyder#5973.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\nQApplication.clipboard().clear()\nqtbot.keyClick(editor, Qt.Key_End, modifier=Qt.ShiftModifier)\nassert editor.get_selected_text() == 'Line1'\nqtbot.keyClick(editor, Qt.Key_Insert, modifier=Qt.ControlModifier)\nassert QApplication.clipboard().text() == 'Line1'\nqtbot.keyClick(editor, Qt.Key_End)\nqtbot.keyClick(editor, Qt.Key_Insert, modifier=Qt.ShiftModifier)\nassert editor.toPlainText() == \"\"\"Line1Line1\nLine2\nLine3\nLine4\n\"\"\"\nqtbot.keyClick(editor, Qt.Key_Home, modifier=Qt.ShiftModifier)\nassert editor.get_selected_text() == 'Line1Line1'\nqtbot.keyClick(editor, Qt.Key_Delete, modifier=Qt.ShiftModifier)\nassert QApplication.clipboard().text() == 'Line1Line1'\nassert editor.toPlainText() == \"\"\"\nLine2\nLine3\nLine4\n\"\"\"\npytest.mark.skipif(sys.platform == 'darwin', reason='Not valid in macOS')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"Override Qt method to process keypress.\"\"\"\ntext, key = event.text(), event.key()\nalt = event.modifiers() & Qt.AltModifier\nshift = event.modifiers() & Qt.ShiftModifier\nctrl = event.modifiers() & Qt.ControlModifier\naltgr = event.modifiers() and key == Qt.Key_AltGr\nneo2_level4 = key == 0\nmodifier = shift or ctrl or alt or altgr or neo2_level4\nif key in (Qt.Key_Return, Qt.Key_Enter, Qt.Key_Tab):\n    item = self.currentItem()\n    if item is None:\n        item = self.item(0)\n    if self.is_up_to_date(item=item):\n        self.item_selected(item=item)\n    else:\n        self.hide()\n        self.textedit.keyPressEvent(event)\nelif key == Qt.Key_Escape:\n    self.hide()\nelif key in (Qt.Key_Left, Qt.Key_Right) or text in ('.', ':'):\n    self.hide()\n    self.textedit.keyPressEvent(event)\nelif key in (Qt.Key_Up, Qt.Key_Down, Qt.Key_PageUp, Qt.Key_PageDown, Qt.\n    Key_Home, Qt.Key_End) and not modifier:\n    self.textedit._completions_hint_idle = True\n    if key == Qt.Key_Up and self.currentRow() == 0:\n        self.setCurrentRow(self.count() - 1)\n    elif key == Qt.Key_Down and self.currentRow() == self.count() - 1:\n        self.setCurrentRow(0)\n    else:\n        QListWidget.keyPressEvent(self, event)\nelif len(text) or key == Qt.Key_Backspace:\n    self.textedit.keyPressEvent(event)\n    self.update_current(new=False)\nelif modifier:\n    self.textedit.keyPressEvent(event)\nelse:\n    self.hide()\n    QListWidget.keyPressEvent(self, event)\n",
        "CUT_5": "\"\"\"Override Qt method to process keypress.\"\"\"\ntext, key = event.text(), event.key()\nalt = event.modifiers() & Qt.AltModifier\nshift = event.modifiers() & Qt.ShiftModifier\nctrl = event.modifiers() & Qt.ControlModifier\naltgr = event.modifiers() and key == Qt.Key_AltGr\nneo2_level4 = key == 0\nmodifier = shift or ctrl or alt or altgr or neo2_level4\nif key in (Qt.Key_Return, Qt.Key_Enter, Qt.Key_Tab):\n    item = self.currentItem()\n    if item is None:\n        item = self.item(0)\n    if self.is_up_to_date(item=item):\n        self.item_selected(item=item)\n    else:\n        self.hide()\n        self.textedit.keyPressEvent(event)\nelif key == Qt.Key_Escape:\n    self.hide()\nelif key in (Qt.Key_Left, Qt.Key_Right) or text in ('.', ':'):\n    self.hide()\n    self.textedit.keyPressEvent(event)\nelif key in (Qt.Key_Up, Qt.Key_Down, Qt.Key_PageUp, Qt.Key_PageDown, Qt.\n    Key_Home, Qt.Key_End) and not modifier:\n    self.textedit._completions_hint_idle = True\n    if key == Qt.Key_Up and self.currentRow() == 0:\n        self.setCurrentRow(self.count() - 1)\n    elif key == Qt.Key_Down and self.currentRow() == self.count() - 1:\n        self.setCurrentRow(0)\n    else:\n        QListWidget.keyPressEvent(self, event)\nelif len(text) or key == Qt.Key_Backspace:\n    self.textedit.keyPressEvent(event)\n    self.update_current(new=False)\nelif modifier:\n    self.textedit.keyPressEvent(event)\nelse:\n    self.hide()\n    QListWidget.keyPressEvent(self, event)\n"
    },
    {
        "functionName": "test_builtin_undo_redo",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_shortcuts.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the builtin key sequence Alt+Backspace, Ctrl+Y and\n    Alt+Shift+Backspace result in, respectively, an undo, redo and redo action\n    in Windows.\n    \"\"\"\neditorstack, qtbot = editor_bot\neditor = editorstack.get_current_editor()\nqtbot.keyClicks(editor, 'Something')\nqtbot.keyClick(editor, Qt.Key_Return)\nassert editor.toPlainText() == \"\"\"Something\nLine1\nLine2\nLine3\nLine4\n\"\"\"\nqtbot.keyClick(editor, Qt.Key_Backspace, modifier=Qt.AltModifier)\nassert editor.toPlainText() == \"\"\"SomethingLine1\nLine2\nLine3\nLine4\n\"\"\"\nqtbot.keyClick(editor, Qt.Key_Backspace, modifier=Qt.AltModifier)\nassert editor.toPlainText() == \"\"\"Line1\nLine2\nLine3\nLine4\n\"\"\"\nqtbot.keyClick(editor, Qt.Key_Backspace, modifier=Qt.AltModifier | Qt.\n    ShiftModifier)\nassert editor.toPlainText() == \"\"\"SomethingLine1\nLine2\nLine3\nLine4\n\"\"\"\nqtbot.keyClick(editor, Qt.Key_Y, modifier=Qt.ControlModifier)\nassert editor.toPlainText() == \"\"\"Something\nLine1\nLine2\nLine3\nLine4\n\"\"\"\npytest.mark.skipif(os.name != 'nt', reason='Only valid in Windows system')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n",
        "CUT_5": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n"
    },
    {
        "functionName": "set_executable_config_helper",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if executable is None:\n    CONF.set('main_interpreter', 'default', True)\n    CONF.set('main_interpreter', 'custom', False)\n    CONF.set('main_interpreter', 'custom_interpreter', sys.executable)\n    CONF.set('main_interpreter', 'custom_interpreters_list', [sys.executable])\n    CONF.set('main_interpreter', 'executable', sys.executable)\nelse:\n    CONF.set('main_interpreter', 'default', False)\n    CONF.set('main_interpreter', 'custom', True)\n    CONF.set('main_interpreter', 'custom_interpreter', executable)\n    CONF.set('main_interpreter', 'custom_interpreters_list', [executable])\n    CONF.set('main_interpreter', 'executable', executable)\n",
        "CUT_1": "if CONF.get('main_interpreter', 'default'):\n    return sys.executable\nelse:\n    return CONF.get('main_interpreter', 'custom_interpreter')\n",
        "CUT_2": "if CONF.get('main_interpreter', 'default'):\n    return sys.executable\nelse:\n    return CONF.get('main_interpreter', 'custom_interpreter')\n",
        "CUT_3": "\"\"\"Open external console\"\"\"\nif systerm:\n    try:\n        if CONF.get('main_interpreter', 'default'):\n            executable = get_python_executable()\n        else:\n            executable = CONF.get('main_interpreter', 'executable')\n        programs.run_python_script_in_terminal(fname, wdir, args, interact,\n            debug, python_args, executable)\n    except NotImplementedError:\n        QMessageBox.critical(self, _('Run'), _(\n            'Running an external system terminal is not supported on platform %s.'\n            ) % os.name)\n",
        "CUT_4": "\"\"\"Open external console\"\"\"\nif systerm:\n    try:\n        if CONF.get('main_interpreter', 'default'):\n            executable = get_python_executable()\n        else:\n            executable = CONF.get('main_interpreter', 'executable')\n        programs.run_python_script_in_terminal(fname, wdir, args, interact,\n            debug, python_args, executable)\n    except NotImplementedError:\n        QMessageBox.critical(self, _('Run'), _(\n            'Running an external system terminal is not supported on platform %s.'\n            ) % os.name)\n",
        "CUT_5": "\"\"\"Command to start kernels\"\"\"\nif CONF.get('main_interpreter', 'default'):\n    pyexec = get_python_executable()\nelse:\n    pyexec = CONF.get('main_interpreter', 'executable')\n    if not is_python_interpreter(pyexec):\n        pyexec = get_python_executable()\n        CONF.set('main_interpreter', 'executable', '')\n        CONF.set('main_interpreter', 'default', True)\n        CONF.set('main_interpreter', 'custom', False)\nis_different = is_different_interpreter(pyexec)\nif is_different and is_conda_env(pyexec=pyexec):\n    kernel_cmd = [get_activation_script(), get_conda_activation_script(\n        pyexec), get_conda_env_path(pyexec), pyexec, '{connection_file}']\nelse:\n    kernel_cmd = [pyexec, '-m', 'spyder_kernels.console', '-f',\n        '{connection_file}']\nlogger.info('Kernel command: {}'.format(kernel_cmd))\nreturn kernel_cmd\nproperty"
    },
    {
        "functionName": "test_space_completion",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Validate completion's space character handling.\"\"\"\ncode_editor, _ = lsp_codeeditor\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(False)\nCONF.set('editor', 'completions_wait_for_ms', 0)\ncompletion = code_editor.completion_widget\ncode_editor.go_to_line(1)\nqtbot.keyClicks(code_editor, 'from numpy ')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert 'import' in [x['label'] for x in sig.args[0]]\nassert code_editor.toPlainText() == 'from numpy import'\nassert not completion.isVisible()\ncode_editor.toggle_automatic_completions(True)\ncode_editor.toggle_code_snippets(True)\npytest.mark.slowpytest.mark.first",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_hide_widget_completion",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Validate hiding completion widget after a delimeter or operator.\"\"\"\ncode_editor, _ = lsp_codeeditor\ncompletion = code_editor.completion_widget\ndelimiters = ['(', ')', '[', ']', '{', '}', ',', ':', ';', '@', '=', '->',\n    '+=', '-=', '*=', '/=', '//=', '%=', '@=', '&=', '|=', '^=', '>>=',\n    '<<=', '**=']\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(False)\ncode_editor.set_text('')\ncode_editor.completion_widget.hide()\ncode_editor.go_to_line(1)\nqtbot.keyClicks(code_editor, 'from numpy import ')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000):\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert completion.isHidden() is False\ndelimiter = random.choice(delimiters)\nprint(delimiter)\nqtbot.keyClicks(code_editor, delimiter)\nqtbot.wait(1000)\nassert completion.isHidden() is True\ncode_editor.toggle_automatic_completions(True)\ncode_editor.toggle_code_snippets(True)\npytest.mark.slowpytest.mark.firstpytest.mark.skipif(bool(os.environ.get('CI', None)), reason='Fails on CI!')",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_automatic_completions",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test on-the-fly completions.\"\"\"\ncode_editor, _ = lsp_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_code_snippets(False)\ncode_editor.go_to_line(1)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, 'f')\nassert 'from' in [x['label'] for x in sig.args[0]]\nqtbot.keyClicks(code_editor, 'rom')\nstop = False\nwhile not stop:\n    try:\n        with qtbot.waitSignal(completion.sig_show_completions, timeout=5000\n            ) as sig:\n            pass\n        code_editor.completion_widget.hide()\n    except Exception:\n        stop = True\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, ' n')\nassert 'ntpath' in [x['label'] for x in sig.args[0]]\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, 'ump')\nassert 'numpy' in [x['label'] for x in sig.args[0]]\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, 'y')\nstop = False\nwhile not stop:\n    try:\n        with qtbot.waitSignal(completion.sig_show_completions, timeout=5000\n            ) as sig:\n            pass\n        code_editor.completion_widget.hide()\n    except Exception:\n        stop = True\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, ' imp')\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert code_editor.toPlainText() == 'from numpy import'\nstop = False\nwhile not stop:\n    try:\n        with qtbot.waitSignal(completion.sig_show_completions, timeout=5000\n            ) as sig:\n            pass\n        code_editor.completion_widget.hide()\n    except Exception:\n        stop = True\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, ' r')\nassert 'random' in [x['label'] for x in sig.args[0]]\ncode_editor.toggle_code_snippets(True)\npytest.mark.slowpytest.mark.firstpytest.mark.skipif(os.environ.get('CI') and (PY2 and os.name != 'nt'),\n    reason='Fails on CI with Mac/Linux and Python 2')",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_automatic_completions_tab_bug",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test on-the-fly completions.\n\n    Autocompletions should not be invoked when Tab/Backtab is pressed.\n\n    See: spyder-ide/spyder#11625\n    \"\"\"\ncode_editor, _ = lsp_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_code_snippets(False)\ncode_editor.set_text('x = 1')\ncode_editor.set_cursor_position('sol')\ntry:\n    with qtbot.waitSignal(completion.sig_show_completions, timeout=5000):\n        qtbot.keyPress(code_editor, Qt.Key_Tab)\n    assert False\nexcept pytestqt.exceptions.TimeoutError:\n    pass\ntry:\n    with qtbot.waitSignal(completion.sig_show_completions, timeout=5000):\n        qtbot.keyPress(code_editor, Qt.Key_Backtab)\n    assert False\nexcept pytestqt.exceptions.TimeoutError:\n    pass\npytest.mark.slowpytest.mark.first",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_automatic_completions_space_bug",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that completions are not invoked when pressing the space key.\"\"\"\ncode_editor, _ = lsp_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_code_snippets(False)\ncode_editor.set_text('x = 1')\ncode_editor.set_cursor_position('sol')\nqtbot.keyPress(code_editor, Qt.Key_Right)\ntry:\n    with qtbot.waitSignal(completion.sig_show_completions, timeout=5000):\n        qtbot.keyPress(code_editor, Qt.Key_Space)\n    assert False\nexcept pytestqt.exceptions.TimeoutError:\n    pass\npytest.mark.slowpytest.mark.first",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_automatic_completions_parens_bug",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test on-the-fly completions.\n\n    Autocompletions for variables don't work inside function calls.\n    Note: Don't mark this as first because it fails on Windows.\n\n    See: spyder-ide/spyder#10448\n    \"\"\"\ncode_editor, _ = lsp_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_code_snippets(False)\ncode_editor.set_text(\"\"\"my_list = [1, 2, 3]\nlist_copy = list((my))\"\"\")\ncursor = code_editor.textCursor()\ncode_editor.moveCursor(cursor.End)\nqtbot.keyPress(code_editor, Qt.Key_Left)\nqtbot.keyPress(code_editor, Qt.Key_Left)\nqtbot.wait(500)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=5000) as sig:\n    qtbot.keyClicks(code_editor, '_')\nassert 'my_list' in [x['label'] for x in sig.args[0]]\ncode_editor.set_text(\"\"\"my_dic = {1: 1, 2: 2}\nonesee = 1\none = my_dic[on]\"\"\")\ncursor = code_editor.textCursor()\ncode_editor.moveCursor(cursor.End)\nqtbot.keyPress(code_editor, Qt.Key_Left)\nqtbot.wait(500)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=5000) as sig:\n    qtbot.keyClicks(code_editor, 'e')\nassert 'onesee' in [x['label'] for x in sig.args[0]]\ncode_editor.set_text(\"\"\"my_dic = {1: 1, 2: 2}\nonesee = 1\none = {on}\"\"\")\ncursor = code_editor.textCursor()\ncode_editor.moveCursor(cursor.End)\nqtbot.keyPress(code_editor, Qt.Key_Left)\nqtbot.wait(500)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=5000) as sig:\n    qtbot.keyClicks(code_editor, 'e')\nassert 'onesee' in [x['label'] for x in sig.args[0]]\npytest.mark.slow",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_completions",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Exercise code completion in several ways.\"\"\"\ncode_editor, _ = lsp_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(False)\ncode_editor.go_to_line(1)\nqtbot.keyClicks(code_editor, 'from _')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert '__future__' in [x['label'] for x in sig.args[0]]\ncode_editor.set_text('')\ncode_editor.go_to_line(1)\nqtbot.keyClicks(code_editor, '_foo = 1;_foom = 2;_fo')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\ncompletions = [x['label'] for x in sig.args[0]]\nassert '_foo' in completions\nassert '_foom' in completions\ncode_editor.set_text('')\ncode_editor.go_to_line(1)\nqtbot.keyClicks(code_editor, 'import mat')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert 'math' in [x['label'] for x in sig.args[0]]\nqtbot.keyPress(completion, Qt.Key_Enter, delay=300)\nassert code_editor.toPlainText() == 'import math'\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyClicks(code_editor, 'math.h')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nif PY2:\n    assert 'hypot(x, y)' in [x['label'] for x in sig.args[0]]\nelse:\n    assert [x['label'] for x in sig.args[0]][0] in ['hypot(x, y)',\n        'hypot(*coordinates)']\nassert code_editor.toPlainText() == \"\"\"import math\nmath.hypot\"\"\"\nqtbot.keyPress(code_editor, Qt.Key_Escape)\ntry:\n    with qtbot.waitSignal(completion.sig_show_completions, timeout=10000\n        ) as sig:\n        qtbot.keyPress(code_editor, Qt.Key_Tab)\nexcept pytestqt.exceptions.TimeoutError:\n    pass\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyClicks(code_editor, 'math.h(')\nqtbot.keyPress(code_editor, Qt.Key_Left, delay=300)\nqtbot.keyClicks(code_editor, 'y')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nif PY2:\n    assert 'hypot(x, y)' in [x['label'] for x in sig.args[0]]\nelse:\n    assert [x['label'] for x in sig.args[0]][0] in ['hypot(x, y)',\n        'hypot(*coordinates)']\nqtbot.keyPress(code_editor, Qt.Key_Right, delay=300)\nqtbot.keyPress(code_editor, Qt.Key_Right, delay=300)\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nassert code_editor.toPlainText() == \"\"\"import math\nmath.hypot\nmath.hypot()\n\"\"\"\nqtbot.keyClicks(code_editor, 'math.a')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert 'asin(x)' in [x['label'] for x in sig.args[0]]\nassert 'acos(x)' == completion.completion_list[0]['label']\nqtbot.keyClicks(completion, 's')\ndata = completion.item(0).data(Qt.UserRole)\nassert 'asin' == data['insertText']\nqtbot.keyPress(completion, Qt.Key_Enter, delay=300)\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nassert code_editor.toPlainText() == \"\"\"import math\nmath.hypot\nmath.hypot()\nmath.asin\n\"\"\"\nqtbot.keyClicks(code_editor, 'math.f')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert completion.count() == 6\nassert 'floor(x)' in [x['label'] for x in sig.args[0]]\nqtbot.keyClicks(completion, 'l')\nassert completion.count() == 1\nqtbot.keyPress(completion, Qt.Key_Backspace)\nassert completion.count() == 6\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nassert code_editor.toPlainText() == \"\"\"import math\nmath.hypot\nmath.hypot()\nmath.asin\nmath.f\n\"\"\"\nqtbot.keyClicks(code_editor, 'math.a')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\n    qtbot.keyPress(code_editor, 's')\nassert 'asin(x)' in [x['label'] for x in sig.args[0]]\nqtbot.keyPress(completion, Qt.Key_Enter, delay=300)\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nassert code_editor.toPlainText() == \"\"\"import math\nmath.hypot\nmath.hypot()\nmath.asin\nmath.f\nmath.asin\n\"\"\"\nqtbot.keyClicks(code_editor, 'math.aangle')\nfor i in range(len('angle')):\n    qtbot.keyClick(code_editor, Qt.Key_Left)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\n    qtbot.keyPress(code_editor, 's')\nassert 'asin(x)' in [x['label'] for x in sig.args[0]]\nqtbot.keyPress(completion, Qt.Key_Enter, delay=300)\nfor i in range(len('angle')):\n    qtbot.keyClick(code_editor, Qt.Key_Right)\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nassert code_editor.toPlainText() == \"\"\"import math\nmath.hypot\nmath.hypot()\nmath.asin\nmath.f\nmath.asin\nmath.asinangle\n\"\"\"\nqtbot.keyClicks(code_editor, 'math.a')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\ntry:\n    with qtbot.waitSignal(completion.sig_show_completions, timeout=5000\n        ) as sig:\n        qtbot.keyPress(code_editor, Qt.Key_Tab)\n        qtbot.keyPress(code_editor, Qt.Key_Backspace)\n        qtbot.keyPress(code_editor, Qt.Key_Escape)\n    raise RuntimeError('The signal should not have been received!')\nexcept pytestqt.exceptions.TimeoutError:\n    pass\ntry:\n    with qtbot.waitSignal(completion.sig_show_completions, timeout=5000\n        ) as sig:\n        qtbot.keyPress(code_editor, Qt.Key_Tab)\n        qtbot.keyPress(code_editor, Qt.Key_Return)\n    raise RuntimeError('The signal should not have been received!')\nexcept pytestqt.exceptions.TimeoutError:\n    pass\nassert code_editor.toPlainText() == \"\"\"import math\nmath.hypot\nmath.hypot()\nmath.asin\nmath.f\nmath.asin\nmath.asinangle\nmath.\n\"\"\"\ncode_editor.toggle_automatic_completions(True)\ncode_editor.toggle_code_snippets(True)\npytest.mark.slowpytest.mark.first",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_code_snippets",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert rtree_available\ncode_editor, lsp = lsp_codeeditor\ncompletion = code_editor.completion_widget\nsnippets = code_editor.editor_extensions.get('SnippetsExtension')\nCONF.set('lsp-server', 'code_snippets', True)\nlsp.update_configuration()\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(True)\ncode_editor.go_to_line(1)\ntext = \"\"\"\n    def test_func(xlonger, y1, some_z):\n        pass\n    \"\"\"\ntext = textwrap.dedent(text)\ncode_editor.insert_text(text)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyClicks(code_editor, 'test_')\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert 'test_func(xlonger, y1, some_z)' in {x['label'] for x in sig.args[0]}\nexpected_insert = 'test_func(${1:xlonger}, ${2:y1}, ${3:some_z})$0'\ninsert = sig.args[0][0]\nassert expected_insert == insert['insertText']\nassert snippets.is_snippet_active\nassert code_editor.has_selected_text()\ncursor = code_editor.textCursor()\narg1 = cursor.selectedText()\nassert 'xlonger' == arg1\nassert snippets.active_snippet == 1\nqtbot.keyPress(code_editor, Qt.Key_Tab)\ncursor = code_editor.textCursor()\narg2 = cursor.selectedText()\nassert 'y1' == arg2\nassert snippets.active_snippet == 2\nqtbot.keyPress(code_editor, Qt.Key_Tab)\ncursor = code_editor.textCursor()\narg2 = cursor.selectedText()\nassert 'some_z' == arg2\nassert snippets.active_snippet == 3\nqtbot.keyPress(code_editor, Qt.Key_Tab)\nassert not snippets.is_snippet_active\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyClicks(code_editor, 'test_')\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nqtbot.keyClicks(code_editor, 'arg1')\nqtbot.wait(5000)\nfor _ in range(0, 3):\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert not snippets.is_snippet_active\ncursor = code_editor.textCursor()\ncursor.movePosition(QTextCursor.StartOfBlock)\ncursor.movePosition(QTextCursor.EndOfBlock, mode=QTextCursor.KeepAnchor)\ntext1 = cursor.selectedText()\nassert text1 == 'test_func(arg1, y1, some_z)'\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyClicks(code_editor, 'test_')\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nqtbot.keyPress(code_editor, Qt.Key_Tab)\nassert snippets.active_snippet == 2\nqtbot.keyPress(code_editor, Qt.Key_Right, delay=300)\nqtbot.keyClicks(code_editor, '_var')\nqtbot.keyPress(code_editor, Qt.Key_Up, delay=300)\nqtbot.keyPress(code_editor, Qt.Key_Down, delay=300)\ncursor = code_editor.textCursor()\ncursor.movePosition(QTextCursor.StartOfBlock)\ncursor.movePosition(QTextCursor.EndOfBlock, mode=QTextCursor.KeepAnchor)\ntext1 = cursor.selectedText()\nassert text1 == 'test_func(xlonger, y1_var, some_z)'\ncursor.movePosition(QTextCursor.EndOfBlock)\ncode_editor.setTextCursor(cursor)\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyClicks(code_editor, 'test_')\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nfor _ in range(0, 2):\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert snippets.active_snippet == 3\nqtbot.keyPress(code_editor, Qt.Key_Left, delay=300)\nqtbot.keyClicks(code_editor, 's')\nqtbot.keyPress(code_editor, Qt.Key_Tab)\nassert not snippets.is_snippet_active\ncursor = code_editor.textCursor()\ncursor.movePosition(QTextCursor.StartOfBlock)\ncursor.movePosition(QTextCursor.EndOfBlock, mode=QTextCursor.KeepAnchor)\ntext1 = cursor.selectedText()\nassert text1 == 'test_func(xlonger, y1, ssome_z)'\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyClicks(code_editor, 'test_')\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert snippets.active_snippet == 1\nqtbot.keyPress(code_editor, Qt.Key_Left, delay=300)\nqtbot.keyPress(code_editor, Qt.Key_Backspace, delay=300)\nassert len(snippets.snippets_map) == 3\nqtbot.keyPress(code_editor, Qt.Key_Tab)\ncursor = code_editor.textCursor()\narg1 = cursor.selectedText()\nassert 'some_z' == arg1\nwith qtbot.waitSignal(code_editor.sig_undo, timeout=10000) as sig:\n    code_editor.undo()\nassert len(snippets.snippets_map) == 4\nfor _ in range(0, 2):\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\ncursor = code_editor.textCursor()\narg1 = cursor.selectedText()\nassert 'some_z' == arg1\nwith qtbot.waitSignal(code_editor.sig_redo, timeout=10000) as sig:\n    code_editor.redo()\nassert len(snippets.snippets_map) == 3\nfor _ in range(0, 3):\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nqtbot.keyPress(code_editor, Qt.Key_Right)\nqtbot.keyPress(code_editor, Qt.Key_Enter)\nqtbot.keyPress(code_editor, Qt.Key_Backspace)\nqtbot.keyClicks(code_editor, 'test_')\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nqtbot.keyPress(code_editor, Qt.Key_Left, delay=300)\nqtbot.keyPress(code_editor, Qt.Key_Right, delay=300)\nqtbot.keyPress(code_editor, Qt.Key_Backspace)\nfor _ in range(0, 3):\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\ncursor = code_editor.textCursor()\ncursor.movePosition(QTextCursor.StartOfBlock)\ncursor.movePosition(QTextCursor.EndOfBlock, mode=QTextCursor.KeepAnchor)\ntext1 = cursor.selectedText()\nassert text1 == 'test_func(longer, y1, some_z)'\nCONF.set('lsp-server', 'code_snippets', False)\nlsp.update_configuration()\ncode_editor.toggle_automatic_completions(True)\ncode_editor.toggle_code_snippets(True)\npytest.mark.slowpytest.mark.firstpytest.mark.skipif(not rtree_available or PY2 or os.name == 'nt', reason=\n    'Only works if rtree is installed')",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_kite_code_snippets",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test kite code snippets completions without initial placeholder.\n\n    See spyder-ide/spyder#10971\n    \"\"\"\nassert rtree_available\ncode_editor, kite = kite_codeeditor\ncompletion = code_editor.completion_widget\nsnippets = code_editor.editor_extensions.get('SnippetsExtension')\nCONF.set('lsp-server', 'code_snippets', True)\nCONF.set('kite', 'enable', True)\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(True)\nkite.update_configuration()\ncode_editor.go_to_line(1)\nqtbot.keyClicks(code_editor, 'import numpy as np')\nqtbot.keyPress(code_editor, Qt.Key_Return)\nqtbot.keyClicks(code_editor, 'np.sin')\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert 'sin(' + '\u2026' + ')' in {x['label'] for x in sig.args[0]}\nexpected_insert = 'sin($1)$0'\ninsert = sig.args[0][0]\nassert expected_insert == insert['insertText']\nqtbot.wait(500)\nqtbot.keyPress(completion, Qt.Key_Tab)\nassert snippets.is_snippet_active\ncursor = code_editor.textCursor()\narg1 = cursor.selectedText()\nassert '' == arg1\nassert snippets.active_snippet == 1\ncode_editor.set_cursor_position('eol')\nqtbot.keyPress(code_editor, Qt.Key_Left)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig2:\n    code_editor.do_completion()\nassert '<x>)' in {x['label'] for x in sig2.args[0]}\nexpected_insert = '${1:[x]})$0'\ninsert = sig2.args[0][0]\nassert expected_insert == insert['textEdit']['newText']\nqtbot.keyPress(completion, Qt.Key_Tab)\ncode_editor.set_cursor_position('eol')\nqtbot.keyPress(code_editor, Qt.Key_Enter)\nassert not snippets.is_snippet_active\ncursor = code_editor.textCursor()\ncursor.movePosition(QTextCursor.PreviousBlock)\ncursor.movePosition(QTextCursor.StartOfBlock)\ncursor.movePosition(QTextCursor.EndOfBlock, mode=QTextCursor.KeepAnchor)\ntext1 = cursor.selectedText()\nassert text1 == 'np.sin([x])'\nCONF.set('lsp-server', 'code_snippets', False)\nCONF.set('kite', 'enable', False)\nkite.update_configuration()\ncode_editor.toggle_automatic_completions(True)\ncode_editor.toggle_code_snippets(True)\npytest.mark.slowpytest.mark.skipif(not rtree_available or not check_if_kite_installed() or \n    not check_if_kite_running(), reason=\n    \"Only works if rtree is installed.It's not meant to be run without kite installed and runnning\"\n    )",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_completion_order",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "code_editor, _ = lsp_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_automatic_completions(False)\ncode_editor.go_to_line(1)\nqtbot.keyClicks(code_editor, 'impo')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nfirst_completion = sig.args[0][0]\nassert first_completion['insertText'] == 'import'\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyClicks(code_editor, 'Impo')\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nfirst_completion = sig.args[0][0]\nassert first_completion['insertText'] == 'ImportError'\npytest.mark.slowpytest.mark.first",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "super().__init__(code_editor)\nself._editor = code_editor\nself._left_padding = 6\nself._right_padding = 3\n"
    },
    {
        "functionName": "test_fallback_completions",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "code_editor, _ = fallback_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(False)\ncode_editor.go_to_line(1)\nqtbot.keyClicks(code_editor, '# some comment and whole words')\ncode_editor.document_did_change()\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=1000)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, 'wh')\n    qtbot.keyPress(code_editor, Qt.Key_Tab, delay=300)\nassert all({x['insertText'].startswith('wh') for x in sig.args[0]})\nfor _ in range(2):\n    qtbot.keyPress(code_editor, Qt.Key_Backspace)\nqtbot.keyClicks(code_editor, 'another')\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, 'a')\n    qtbot.keyPress(code_editor, Qt.Key_Tab, delay=300)\nword_set = {x['insertText'] for x in sig.args[0]}\nassert 'another' in word_set\nassert 'assert' in word_set\nfor _ in range(3):\n    qtbot.keyPress(code_editor, Qt.Key_Backspace)\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, 'a')\n    qtbot.keyPress(code_editor, Qt.Key_Tab, delay=300)\nword_set = {x['insertText'] for x in sig.args[0]}\nassert 'another' not in word_set\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    code_editor.append(\"'\ud83d\ude12 foobar'\")\n    qtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\n    qtbot.keyClicks(code_editor, 'foob')\n    qtbot.keyPress(code_editor, Qt.Key_Tab, delay=300)\nword_set = {x['insertText'] for x in sig.args[0]}\nassert 'foobar' in word_set\ncode_editor.toggle_automatic_completions(True)\ncode_editor.toggle_code_snippets(True)\npytest.mark.slowpytest.mark.firstpytest.mark.skipif(not sys.platform.startswith('linux') or PY2, reason=\n    'Only works on Linux and Python 3')",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_text_snippet_completions",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "code_editor, _ = snippets_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(False)\ncode_editor.go_to_line(1)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, 'f')\n    qtbot.keyPress(code_editor, Qt.Key_Tab, delay=300)\nassert all({(x['sortText'][1] in {'for', 'from'}) for x in sig.args[0]})\ncode_editor.toggle_automatic_completions(True)\ncode_editor.toggle_code_snippets(True)\npytest.mark.slowpytest.mark.first",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_kite_textEdit_completions",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test textEdit completions such as those returned by the Kite provider.\n\n    This mocks out the completions response, and does not test the Kite\n    provider directly.\n    \"\"\"\ncode_editor, mock_response = mock_completions_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(False)\ncode_editor.go_to_line(1)\nqtbot.keyClicks(code_editor, 'my_dict.')\nmock_response.side_effect = lambda lang, method, params: {'params': [{\n    'kind': CompletionItemKind.TEXT, 'label': '[\"dict-key\"]', 'textEdit': {\n    'newText': '[\"dict-key\"]', 'range': {'start': 7, 'end': 8}},\n    'filterText': '', 'sortText': '', 'documentation': '', 'provider':\n    KITE_COMPLETION}]\n    } if method == LSPRequestTypes.DOCUMENT_COMPLETION else None\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab, delay=300)\nmock_response.side_effect = None\nassert '[\"dict-key\"]' in [x['label'] for x in sig.args[0]]\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nassert code_editor.toPlainText() == 'my_dict[\"dict-key\"]\\n'\ncode_editor.toggle_automatic_completions(True)\ncode_editor.toggle_code_snippets(True)\npytest.mark.slowpytest.mark.first",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_completions_extra_paths",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Exercise code completion when adding extra paths.\"\"\"\ncode_editor, lsp_plugin = lsp_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(False)\ntemp_content = \"\"\"\ndef spam():\n    pass\n\"\"\"\nCONF.set('main', 'spyder_pythonpath', [])\nlsp_plugin.update_configuration()\nqtbot.wait(500)\nqtbot.keyClicks(code_editor, 'import foo')\nqtbot.keyPress(code_editor, Qt.Key_Enter)\nqtbot.keyClicks(code_editor, 'foo.s')\ncode_editor.document_did_change()\nqtbot.keyPress(code_editor, Qt.Key_Tab)\nqtbot.wait(500)\nassert code_editor.toPlainText() == 'import foo\\nfoo.s'\np = tmpdir.mkdir('extra_path')\nextra_paths = [str(p)]\np = p.join('foo.py')\np.write(temp_content)\nprint(extra_paths)\nCONF.set('main', 'spyder_pythonpath', extra_paths)\nlsp_plugin.update_configuration()\ncode_editor.document_did_change()\nqtbot.wait(500)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert 'spam()' in [x['label'] for x in sig.args[0]]\nassert code_editor.toPlainText() == \"\"\"import foo\nfoo.spam\"\"\"\nCONF.set('main', 'spyder_pythonpath', [])\nlsp_plugin.update_configuration()\nqtbot.wait(500)\npytest.mark.slowpytest.mark.firstpytest.mark.skipif(os.name == 'nt', reason='Hangs on Windows')",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "super().__init__(code_editor)\nself._editor = code_editor\nself._left_padding = 6\nself._right_padding = 3\n"
    },
    {
        "functionName": "test_completions_environment",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_introspection.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Exercise code completion when adding extra paths.\"\"\"\ncode_editor, lsp_plugin = lsp_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_automatic_completions(False)\ncode_editor.toggle_code_snippets(False)\nconda_envs_path = os.path.dirname(sys.prefix)\nconda_jedi_env = os.path.join(conda_envs_path, 'jedi-test-env')\nif os.name == 'nt':\n    py_exe = os.path.join(conda_jedi_env, 'python.exe')\nelse:\n    py_exe = os.path.join(conda_jedi_env, 'bin', 'python')\nprint(sys.executable)\nprint(py_exe)\nassert os.path.isfile(py_exe)\nset_executable_config_helper()\nlsp_plugin.update_configuration()\nqtbot.keyClicks(code_editor, 'import flas')\nqtbot.keyPress(code_editor, Qt.Key_Tab)\nqtbot.wait(2000)\nassert code_editor.toPlainText() == 'import flas'\nset_executable_config_helper(py_exe)\nlsp_plugin.update_configuration()\ncode_editor.set_text('')\nqtbot.keyClicks(code_editor, 'import flas')\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyPress(code_editor, Qt.Key_Tab)\nassert 'flask' in [x['label'] for x in sig.args[0]]\nassert code_editor.toPlainText() == 'import flask'\nset_executable_config_helper()\nlsp_plugin.update_configuration()\npytest.mark.slowpytest.mark.firstpytest.mark.skipif(os.environ.get('CI') is None, reason='Run tests only on CI.'\n    )",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "super().__init__(code_editor)\nself._editor = code_editor\nself._left_padding = 6\nself._right_padding = 3\n"
    },
    {
        "functionName": "construct_editor",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "app = qapplication()\neditor = CodeEditor(parent=None)\neditor.setup_editor(language='Python')\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.End)\neditor.setTextCursor(cursor)\nreturn editor\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_4": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_5": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n"
    },
    {
        "functionName": "test_no_auto_colon_after_simple_statement",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor('x = 1')\nassert editor.autoinsert_colons() == False\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n"
    },
    {
        "functionName": "test_auto_colon_after_if_statement",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor('if x == 1')\nassert editor.autoinsert_colons() == True\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n"
    },
    {
        "functionName": "test_no_auto_colon_if_not_at_end_of_line",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor('if x == 1')\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Left)\neditor.setTextCursor(cursor)\nassert editor.autoinsert_colons() == False\n",
        "CUT_1": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_2": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_3": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_4": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_5": "\"\"\"Kill the text on the current line from the cursor forward\"\"\"\ncursor = self.textCursor()\ncursor.clearSelection()\ncursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)\nif not cursor.hasSelection():\n    cursor.movePosition(QTextCursor.NextBlock, QTextCursor.KeepAnchor)\nself._kill_ring.kill_cursor(cursor)\nself.setTextCursor(cursor)\nself.document_did_change()\n"
    },
    {
        "functionName": "test_no_auto_colon_if_unterminated_string",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor(\"if x == '1\")\nassert editor.autoinsert_colons() == False\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n"
    },
    {
        "functionName": "test_no_auto_colon_in_comment",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor('if x == 1 # comment')\nassert editor.autoinsert_colons() == False\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.toggle_comment()\nSlot()",
        "CUT_4": "\"\"\"Comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.toggle_comment()\nSlot()",
        "CUT_5": "\"\"\"Block comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.blockcomment()\nSlot()"
    },
    {
        "functionName": "test_no_auto_colon_if_already_ends_in_colon",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor('if x == 1:')\nassert editor.autoinsert_colons() == False\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n"
    },
    {
        "functionName": "test_no_auto_colon_if_ends_in_backslash",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor('if x == 1 \\\\')\nassert editor.autoinsert_colons() == False\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n"
    },
    {
        "functionName": "test_no_auto_colon_in_one_line_if_statement",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor('if x < 0: x = 0')\nassert editor.autoinsert_colons() == False\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n"
    },
    {
        "functionName": "test_auto_colon_even_if_colon_inside_brackets",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor(\"if text[:-1].endswith('bla')\")\nassert editor.autoinsert_colons() == True\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"\n        Run profiler.\n\n        Notes\n        -----\n        This method will check if the file on the editor can be saved first.\n        \"\"\"\neditor = self.get_plugin(Plugins.Editor)\nif editor.save():\n    self.switch_to_plugin()\n    self.analyze(editor.get_current_filename())\n"
    },
    {
        "functionName": "test_no_auto_colon_in_listcomp_over_two_lines",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor(\"\"\"ns = [ n for ns in range(10) \n if n < 5 ]\"\"\")\nassert editor.autoinsert_colons() == False\n",
        "CUT_1": "\"\"\"Set the value of a variable\"\"\"\nns = self._get_reference_namespace(name)\nns[name] = value\nself.log.debug(ns)\n",
        "CUT_2": "\"\"\"Remove a variable\"\"\"\nns = self._get_reference_namespace(name)\nns.pop(name)\n",
        "CUT_3": "\"\"\"Copy a variable\"\"\"\nns = self._get_reference_namespace(orig_name)\nns[new_name] = ns[orig_name]\n",
        "CUT_4": "\"\"\"Get the value of a variable\"\"\"\nns = self._get_current_namespace()\nself._do_publish_pdb_state = False\nreturn ns[name]\n",
        "CUT_5": "\"\"\"\n        Return current namespace\n\n        This is globals() if not debugging, or a dictionary containing\n        both locals() and globals() for current frame when debugging\n        \"\"\"\nns = {}\nif self._running_namespace is None:\n    ns.update(self._mglobals())\nelse:\n    running_globals, running_locals = self._running_namespace\n    ns.update(running_globals)\n    if running_locals is not None:\n        ns.update(running_locals)\nif self._pdb_frame is not None:\n    ns.update(self._pdb_locals)\nif with_magics:\n    line_magics = self.shell.magics_manager.magics['line']\n    cell_magics = self.shell.magics_manager.magics['cell']\n    ns.update(line_magics)\n    ns.update(cell_magics)\nreturn ns\n"
    },
    {
        "functionName": "test_auto_colon_even_if_colon_inside_quotes",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor(\"if text == ':'\")\nassert editor.autoinsert_colons() == True\npytest.mark.xfail",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n"
    },
    {
        "functionName": "test_no_auto_colon_in_listcomp_over_three_lines",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor(\"\"\"ns = [ n \n for ns in range(10) \n if n < 5 ]\"\"\")\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Up)\ncursor.movePosition(QTextCursor.EndOfLine)\neditor.setTextCursor(cursor)\nassert editor.autoinsert_colons() == False\npytest.mark.xfail",
        "CUT_1": "\"\"\"Kill the text on the current line from the cursor forward\"\"\"\ncursor = self.textCursor()\ncursor.clearSelection()\ncursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)\nif not cursor.hasSelection():\n    cursor.movePosition(QTextCursor.NextBlock, QTextCursor.KeepAnchor)\nself._kill_ring.kill_cursor(cursor)\nself.setTextCursor(cursor)\nself.document_did_change()\n",
        "CUT_2": "\"\"\"Kill the text on the current line from the cursor forward\"\"\"\ncursor = self.textCursor()\ncursor.clearSelection()\ncursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)\nif not cursor.hasSelection():\n    cursor.movePosition(QTextCursor.NextBlock, QTextCursor.KeepAnchor)\nself._kill_ring.kill_cursor(cursor)\nself.setTextCursor(cursor)\nself.document_did_change()\n",
        "CUT_3": "\"\"\"Remove trailing spaces\"\"\"\ncursor = self.textCursor()\ncursor.beginEditBlock()\ncursor.movePosition(QTextCursor.Start)\nwhile True:\n    cursor.movePosition(QTextCursor.EndOfBlock)\n    text = to_text_string(cursor.block().text())\n    length = len(text) - len(text.rstrip())\n    if length > 0:\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, length)\n        cursor.removeSelectedText()\n    if cursor.atEnd():\n        break\n    cursor.movePosition(QTextCursor.NextBlock)\ncursor.endEditBlock()\nself.document_did_change()\n",
        "CUT_4": "\"\"\"Remove trailing spaces\"\"\"\ncursor = self.textCursor()\ncursor.beginEditBlock()\ncursor.movePosition(QTextCursor.Start)\nwhile True:\n    cursor.movePosition(QTextCursor.EndOfBlock)\n    text = to_text_string(cursor.block().text())\n    length = len(text) - len(text.rstrip())\n    if length > 0:\n        cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, length)\n        cursor.removeSelectedText()\n    if cursor.atEnd():\n        break\n    cursor.movePosition(QTextCursor.NextBlock)\ncursor.endEditBlock()\nself.document_did_change()\n",
        "CUT_5": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n"
    },
    {
        "functionName": "test_auto_colon_in_two_if_statements_on_one_line",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autocolon.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor = construct_editor('if x < 0: x = 0; if x == 0')\nassert editor.autoinsert_colons() == True\npytest.mark.xfail",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n"
    },
    {
        "functionName": "editor_stack",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack = EditorStack(None, [])\neditor_stack.set_find_widget(Mock())\neditor_stack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nreturn editor_stack\n",
        "CUT_1": "return Mock()\n",
        "CUT_2": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_3": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_4": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_5": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)"
    },
    {
        "functionName": "editor_splitter_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create editor splitter.\"\"\"\nes = EditorSplitter(None, Mock(), [], first=True)\nqtbot.addWidget(es)\nes.resize(640, 480)\nes.show()\nreturn es\npytest.fixture",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture",
        "CUT_3": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_4": "return Mock()\n",
        "CUT_5": "\"\"\"Return the editor stacks for this splitter and every first child.\n\n        Note: If a splitter contains more than one splitter as a direct\n              child, only the first child's editor stack is included.\n\n        Returns:\n            List of tuples containing (EditorStack instance, orientation).\n        \"\"\"\neditorstacks = [(self.widget(0), self.orientation())]\nif self.count() > 1:\n    editorsplitter = self.widget(1)\n    editorstacks += editorsplitter.iter_editorstacks()\nreturn editorstacks\n"
    },
    {
        "functionName": "editor_splitter_lsp",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = \"\"\"\n    import sys\n    \"\"\"\ncompletions = lsp_plugin\ndef report_file_open(options):\n    filename = options['filename']\n    language = options['language']\n    callback = options['codeeditor']\n    completions.register_file(language.lower(), filename, callback)\n    capabilities = completions.main.editor.completion_capabilities['python']\n    callback.start_completion_services()\n    callback.register_completion_capabilities(capabilities)\n    with qtbot_module.waitSignal(callback.lsp_response_signal, timeout=30000):\n        callback.document_did_open()\ndef register_editorstack(editorstack):\n    editorstack.sig_perform_completion_request.connect(completions.send_request\n        )\n    editorstack.sig_open_file.connect(report_file_open)\n    capabilities = completions.main.editor.completion_capabilities['python']\n    editorstack.register_completion_capabilities(capabilities, 'python')\ndef clone(editorstack, template=None):\n    editor_stack = EditorStack(None, [])\n    editor_stack.set_find_widget(Mock())\n    editor_stack.set_io_actions(Mock(), Mock(), Mock(), Mock())\n    editorsplitter.editorstack.new('test.py', 'utf-8', text)\nmock_plugin = Mock()\neditorsplitter = EditorSplitter(None, mock_plugin, [],\n    register_editorstack_cb=register_editorstack)\neditorsplitter.editorstack.set_find_widget(Mock())\neditorsplitter.editorstack.set_io_actions(Mock(), Mock(), Mock(), Mock())\neditorsplitter.editorstack.new('test.py', 'utf-8', text)\nmock_plugin.clone_editorstack.side_effect = partial(clone, template=\n    editorsplitter.editorstack)\nqtbot_module.addWidget(editorsplitter)\neditorsplitter.resize(640, 480)\neditorsplitter.show()\ndef teardown():\n    editorsplitter.hide()\n    editorsplitter.close()\nrequest.addfinalizer(teardown)\nlsp = completions.get_client('lsp')\nreturn editorsplitter, lsp\npytest.fixture",
        "CUT_1": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_2": "return Mock()\n",
        "CUT_3": "\"\"\"Create and attach a new EditorSplitter to the current EditorSplitter.\n\n        The new EditorSplitter widget will contain an EditorStack that\n        is a clone of the current EditorStack.\n\n        A single EditorSplitter instance can be split multiple times, but the\n        orientation will be the same for all the direct splits.  If one of\n        the child splits is split, then that split can have a different\n        orientation.\n        \"\"\"\nself.setOrientation(orientation)\nself.editorstack.set_orientation(orientation)\neditorsplitter = EditorSplitter(self.parent(), self.plugin, self.\n    menu_actions, register_editorstack_cb=self.register_editorstack_cb,\n    unregister_editorstack_cb=self.unregister_editorstack_cb)\nself.addWidget(editorsplitter)\neditorsplitter.destroyed.connect(lambda : self.editorsplitter_closed())\ncurrent_editor = editorsplitter.editorstack.get_current_editor()\nif current_editor is not None:\n    current_editor.setFocus()\n",
        "CUT_4": "\"\"\"Create and attach a new EditorSplitter to the current EditorSplitter.\n\n        The new EditorSplitter widget will contain an EditorStack that\n        is a clone of the current EditorStack.\n\n        A single EditorSplitter instance can be split multiple times, but the\n        orientation will be the same for all the direct splits.  If one of\n        the child splits is split, then that split can have a different\n        orientation.\n        \"\"\"\nself.setOrientation(orientation)\nself.editorstack.set_orientation(orientation)\neditorsplitter = EditorSplitter(self.parent(), self.plugin, self.\n    menu_actions, register_editorstack_cb=self.register_editorstack_cb,\n    unregister_editorstack_cb=self.unregister_editorstack_cb)\nself.addWidget(editorsplitter)\neditorsplitter.destroyed.connect(lambda : self.editorsplitter_closed())\ncurrent_editor = editorsplitter.editorstack.get_current_editor()\nif current_editor is not None:\n    current_editor.setFocus()\n",
        "CUT_5": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture"
    },
    {
        "functionName": "report_file_open",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "filename = options['filename']\nlanguage = options['language']\ncallback = options['codeeditor']\ncompletions.register_file(language.lower(), filename, callback)\ncapabilities = completions.main.editor.completion_capabilities['python']\ncallback.start_completion_services()\ncallback.register_completion_capabilities(capabilities)\nwith qtbot_module.waitSignal(callback.lsp_response_signal, timeout=30000):\n    callback.document_did_open()\n",
        "CUT_1": "\"\"\"Report that a file was opened to the completion manager.\"\"\"\nfilename = options['filename']\nlanguage = options['language']\ncodeeditor = options['codeeditor']\nstatus = self.main.completions.start_client(language.lower())\nself.main.completions.register_file(language.lower(), filename, codeeditor)\nif status:\n    if language.lower() in self.completion_capabilities:\n        codeeditor.register_completion_capabilities(self.\n            completion_capabilities[language.lower()])\n        codeeditor.start_completion_services()\n    elif self.main.completions.is_fallback_only(language.lower()):\n        codeeditor.start_completion_services()\nelif codeeditor.language == language.lower():\n    logger.debug('Setting {0} completions off'.format(filename))\n    codeeditor.completions_available = False\nSlot(dict)",
        "CUT_2": "\"\"\"Report that a file was opened to the completion manager.\"\"\"\nfilename = options['filename']\nlanguage = options['language']\ncodeeditor = options['codeeditor']\nstatus = self.main.completions.start_client(language.lower())\nself.main.completions.register_file(language.lower(), filename, codeeditor)\nif status:\n    if language.lower() in self.completion_capabilities:\n        codeeditor.register_completion_capabilities(self.\n            completion_capabilities[language.lower()])\n        codeeditor.start_completion_services()\n    elif self.main.completions.is_fallback_only(language.lower()):\n        codeeditor.start_completion_services()\nelif codeeditor.language == language.lower():\n    logger.debug('Setting {0} completions off'.format(filename))\n    codeeditor.completions_available = False\nSlot(dict)",
        "CUT_3": "self.base.server_activate(self)\nif self.callback:\n    self.callback(self)\n",
        "CUT_4": "self.base.server_activate(self)\nif self.callback:\n    self.callback(self)\n",
        "CUT_5": "\"\"\"\n        Save help text.\n\n        Parameters\n        ----------\n        callback: callable\n            Method to call on save.\n        \"\"\"\nif self.source_is_console():\n    self._last_console_cb = callback\nelse:\n    self._last_editor_cb = callback\n"
    },
    {
        "functionName": "register_editorstack",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editorstack.sig_perform_completion_request.connect(completions.send_request)\neditorstack.sig_open_file.connect(report_file_open)\ncapabilities = completions.main.editor.completion_capabilities['python']\neditorstack.register_completion_capabilities(capabilities, 'python')\n",
        "CUT_1": "self.editorstacks.append(editorstack)\nself.register_widget_shortcuts(editorstack)\nif self.isAncestorOf(editorstack):\n    self.set_last_focus_editorstack(self, editorstack)\n    editorstack.set_closable(len(self.editorstacks) > 1)\n    if self.outlineexplorer is not None:\n        editorstack.set_outlineexplorer(self.outlineexplorer.explorer)\n    editorstack.set_find_widget(self.find_widget)\n    editorstack.reset_statusbar.connect(self.readwrite_status.hide)\n    editorstack.reset_statusbar.connect(self.encoding_status.hide)\n    editorstack.reset_statusbar.connect(self.cursorpos_status.hide)\n    editorstack.readonly_changed.connect(self.readwrite_status.update_readonly)\n    editorstack.encoding_changed.connect(self.encoding_status.update_encoding)\n    editorstack.sig_editor_cursor_position_changed.connect(self.\n        cursorpos_status.update_cursor_position)\n    editorstack.sig_editor_cursor_position_changed.connect(self.\n        current_editor_cursor_changed)\n    editorstack.sig_refresh_eol_chars.connect(self.eol_status.update_eol)\n    editorstack.current_file_changed.connect(self.vcs_status.update_vcs)\n    editorstack.file_saved.connect(self.vcs_status.update_vcs_state)\neditorstack.set_io_actions(self.new_action, self.open_action, self.\n    save_action, self.revert_action)\neditorstack.set_tempfile_path(self.TEMPFILE_PATH)\nsettings = ('set_todolist_enabled', 'todo_list'), ('set_blanks_enabled',\n    'blank_spaces'), ('set_underline_errors_enabled', 'underline_errors'), (\n    'set_scrollpastend_enabled', 'scroll_past_end'), ('set_linenumbers_enabled'\n    , 'line_numbers'), ('set_edgeline_enabled', 'edge_line'), (\n    'set_edgeline_columns', 'edge_line_columns'), ('set_indent_guides',\n    'indent_guides'), ('set_code_folding_enabled', 'code_folding'), (\n    'set_focus_to_editor', 'focus_to_editor'), ('set_run_cell_copy',\n    'run_cell_copy'), ('set_close_parentheses_enabled', 'close_parentheses'), (\n    'set_close_quotes_enabled', 'close_quotes'), ('set_add_colons_enabled',\n    'add_colons'), ('set_auto_unindent_enabled', 'auto_unindent'), (\n    'set_indent_chars', 'indent_chars'), ('set_tab_stop_width_spaces',\n    'tab_stop_width_spaces'), ('set_wrap_enabled', 'wrap'), (\n    'set_tabmode_enabled', 'tab_always_indent'), ('set_stripmode_enabled',\n    'strip_trailing_spaces_on_modify'), ('set_intelligent_backspace_enabled',\n    'intelligent_backspace'), ('set_automatic_completions_enabled',\n    'automatic_completions'), ('set_automatic_completions_after_chars',\n    'automatic_completions_after_chars'), ('set_automatic_completions_after_ms'\n    , 'automatic_completions_after_ms'), ('set_completions_hint_enabled',\n    'completions_hint'), ('set_completions_hint_after_ms',\n    'completions_hint_after_ms'), ('set_highlight_current_line_enabled',\n    'highlight_current_line'), ('set_highlight_current_cell_enabled',\n    'highlight_current_cell'), ('set_occurrence_highlighting_enabled',\n    'occurrence_highlighting'), ('set_occurrence_highlighting_timeout',\n    'occurrence_highlighting/timeout'), ('set_checkeolchars_enabled',\n    'check_eol_chars'), ('set_tabbar_visible', 'show_tab_bar'), (\n    'set_classfunc_dropdown_visible', 'show_class_func_dropdown'), (\n    'set_always_remove_trailing_spaces', 'always_remove_trailing_spaces'), (\n    'set_remove_trailing_newlines', 'always_remove_trailing_newlines'), (\n    'set_add_newline', 'add_newline'), ('set_convert_eol_on_save',\n    'convert_eol_on_save'), ('set_convert_eol_on_save_to',\n    'convert_eol_on_save_to')\nfor method, setting in settings:\n    getattr(editorstack, method)(self.get_option(setting))\neditorstack.set_help_enabled(CONF.get('help', 'connect/editor'))\neditorstack.set_hover_hints_enabled(CONF.get('lsp-server',\n    'enable_hover_hints'))\neditorstack.set_format_on_save(CONF.get('lsp-server', 'format_on_save'))\ncolor_scheme = self.get_color_scheme()\neditorstack.set_default_font(self.get_font(), color_scheme)\neditorstack.starting_long_process.connect(self.starting_long_process)\neditorstack.ending_long_process.connect(self.ending_long_process)\neditorstack.sig_option_changed.connect(self.sig_option_changed)\neditorstack.redirect_stdio.connect(lambda state: self.redirect_stdio.emit(\n    state))\neditorstack.exec_in_extconsole.connect(lambda text, option: self.\n    exec_in_extconsole.emit(text, option))\neditorstack.run_cell_in_ipyclient.connect(lambda code, cell_name, filename,\n    run_cell_copy: self.run_cell_in_ipyclient.emit(code, cell_name,\n    filename, run_cell_copy))\neditorstack.debug_cell_in_ipyclient.connect(lambda code, cell_name,\n    filename, run_cell_copy: self.debug_cell_in_ipyclient.emit(code,\n    cell_name, filename, run_cell_copy))\neditorstack.update_plugin_title.connect(lambda : self.\n    sig_update_plugin_title.emit())\neditorstack.editor_focus_changed.connect(self.save_focus_editorstack)\neditorstack.editor_focus_changed.connect(self.main.plugin_focus_changed)\neditorstack.editor_focus_changed.connect(self.sig_editor_focus_changed)\neditorstack.zoom_in.connect(lambda : self.zoom(1))\neditorstack.zoom_out.connect(lambda : self.zoom(-1))\neditorstack.zoom_reset.connect(lambda : self.zoom(0))\neditorstack.sig_open_file.connect(self.report_open_file)\neditorstack.sig_new_file.connect(lambda s: self.new(text=s))\neditorstack.sig_new_file[()].connect(self.new)\neditorstack.sig_close_file.connect(self.close_file_in_all_editorstacks)\neditorstack.sig_close_file.connect(self.remove_file_cursor_history)\neditorstack.file_saved.connect(self.file_saved_in_editorstack)\neditorstack.file_renamed_in_data.connect(self.\n    file_renamed_in_data_in_editorstack)\neditorstack.opened_files_list_changed.connect(self.opened_files_list_changed)\neditorstack.active_languages_stats.connect(self.update_active_languages)\neditorstack.sig_go_to_definition.connect(lambda fname, line, col: self.load\n    (fname, line, start_column=col))\neditorstack.sig_perform_completion_request.connect(self.send_completion_request\n    )\neditorstack.todo_results_changed.connect(self.todo_results_changed)\neditorstack.update_code_analysis_actions.connect(self.\n    update_code_analysis_actions)\neditorstack.update_code_analysis_actions.connect(self.update_todo_actions)\neditorstack.refresh_file_dependent_actions.connect(self.\n    refresh_file_dependent_actions)\neditorstack.refresh_save_all_action.connect(self.refresh_save_all_action)\neditorstack.sig_refresh_eol_chars.connect(self.refresh_eol_chars)\neditorstack.sig_refresh_formatting.connect(self.refresh_formatting)\neditorstack.sig_breakpoints_saved.connect(self.breakpoints_saved)\neditorstack.text_changed_at.connect(self.text_changed_at)\neditorstack.current_file_changed.connect(self.current_file_changed)\neditorstack.plugin_load.connect(self.load)\neditorstack.plugin_load[()].connect(self.load)\neditorstack.edit_goto.connect(self.load)\neditorstack.sig_save_as.connect(self.save_as)\neditorstack.sig_prev_edit_pos.connect(self.go_to_last_edit_location)\neditorstack.sig_prev_cursor.connect(self.go_to_previous_cursor_position)\neditorstack.sig_next_cursor.connect(self.go_to_next_cursor_position)\neditorstack.sig_prev_warning.connect(self.go_to_previous_warning)\neditorstack.sig_next_warning.connect(self.go_to_next_warning)\neditorstack.sig_save_bookmark.connect(self.save_bookmark)\neditorstack.sig_load_bookmark.connect(self.load_bookmark)\neditorstack.sig_save_bookmarks.connect(self.save_bookmarks)\neditorstack.sig_help_requested.connect(self.sig_help_requested)\nself.autosave.register_autosave_for_stack(editorstack.autosave)\n",
        "CUT_2": "self.editorstacks.append(editorstack)\nself.register_widget_shortcuts(editorstack)\nif self.isAncestorOf(editorstack):\n    self.set_last_focus_editorstack(self, editorstack)\n    editorstack.set_closable(len(self.editorstacks) > 1)\n    if self.outlineexplorer is not None:\n        editorstack.set_outlineexplorer(self.outlineexplorer.explorer)\n    editorstack.set_find_widget(self.find_widget)\n    editorstack.reset_statusbar.connect(self.readwrite_status.hide)\n    editorstack.reset_statusbar.connect(self.encoding_status.hide)\n    editorstack.reset_statusbar.connect(self.cursorpos_status.hide)\n    editorstack.readonly_changed.connect(self.readwrite_status.update_readonly)\n    editorstack.encoding_changed.connect(self.encoding_status.update_encoding)\n    editorstack.sig_editor_cursor_position_changed.connect(self.\n        cursorpos_status.update_cursor_position)\n    editorstack.sig_editor_cursor_position_changed.connect(self.\n        current_editor_cursor_changed)\n    editorstack.sig_refresh_eol_chars.connect(self.eol_status.update_eol)\n    editorstack.current_file_changed.connect(self.vcs_status.update_vcs)\n    editorstack.file_saved.connect(self.vcs_status.update_vcs_state)\neditorstack.set_io_actions(self.new_action, self.open_action, self.\n    save_action, self.revert_action)\neditorstack.set_tempfile_path(self.TEMPFILE_PATH)\nsettings = ('set_todolist_enabled', 'todo_list'), ('set_blanks_enabled',\n    'blank_spaces'), ('set_underline_errors_enabled', 'underline_errors'), (\n    'set_scrollpastend_enabled', 'scroll_past_end'), ('set_linenumbers_enabled'\n    , 'line_numbers'), ('set_edgeline_enabled', 'edge_line'), (\n    'set_edgeline_columns', 'edge_line_columns'), ('set_indent_guides',\n    'indent_guides'), ('set_code_folding_enabled', 'code_folding'), (\n    'set_focus_to_editor', 'focus_to_editor'), ('set_run_cell_copy',\n    'run_cell_copy'), ('set_close_parentheses_enabled', 'close_parentheses'), (\n    'set_close_quotes_enabled', 'close_quotes'), ('set_add_colons_enabled',\n    'add_colons'), ('set_auto_unindent_enabled', 'auto_unindent'), (\n    'set_indent_chars', 'indent_chars'), ('set_tab_stop_width_spaces',\n    'tab_stop_width_spaces'), ('set_wrap_enabled', 'wrap'), (\n    'set_tabmode_enabled', 'tab_always_indent'), ('set_stripmode_enabled',\n    'strip_trailing_spaces_on_modify'), ('set_intelligent_backspace_enabled',\n    'intelligent_backspace'), ('set_automatic_completions_enabled',\n    'automatic_completions'), ('set_automatic_completions_after_chars',\n    'automatic_completions_after_chars'), ('set_automatic_completions_after_ms'\n    , 'automatic_completions_after_ms'), ('set_completions_hint_enabled',\n    'completions_hint'), ('set_completions_hint_after_ms',\n    'completions_hint_after_ms'), ('set_highlight_current_line_enabled',\n    'highlight_current_line'), ('set_highlight_current_cell_enabled',\n    'highlight_current_cell'), ('set_occurrence_highlighting_enabled',\n    'occurrence_highlighting'), ('set_occurrence_highlighting_timeout',\n    'occurrence_highlighting/timeout'), ('set_checkeolchars_enabled',\n    'check_eol_chars'), ('set_tabbar_visible', 'show_tab_bar'), (\n    'set_classfunc_dropdown_visible', 'show_class_func_dropdown'), (\n    'set_always_remove_trailing_spaces', 'always_remove_trailing_spaces'), (\n    'set_remove_trailing_newlines', 'always_remove_trailing_newlines'), (\n    'set_add_newline', 'add_newline'), ('set_convert_eol_on_save',\n    'convert_eol_on_save'), ('set_convert_eol_on_save_to',\n    'convert_eol_on_save_to')\nfor method, setting in settings:\n    getattr(editorstack, method)(self.get_option(setting))\neditorstack.set_help_enabled(CONF.get('help', 'connect/editor'))\neditorstack.set_hover_hints_enabled(CONF.get('lsp-server',\n    'enable_hover_hints'))\neditorstack.set_format_on_save(CONF.get('lsp-server', 'format_on_save'))\ncolor_scheme = self.get_color_scheme()\neditorstack.set_default_font(self.get_font(), color_scheme)\neditorstack.starting_long_process.connect(self.starting_long_process)\neditorstack.ending_long_process.connect(self.ending_long_process)\neditorstack.sig_option_changed.connect(self.sig_option_changed)\neditorstack.redirect_stdio.connect(lambda state: self.redirect_stdio.emit(\n    state))\neditorstack.exec_in_extconsole.connect(lambda text, option: self.\n    exec_in_extconsole.emit(text, option))\neditorstack.run_cell_in_ipyclient.connect(lambda code, cell_name, filename,\n    run_cell_copy: self.run_cell_in_ipyclient.emit(code, cell_name,\n    filename, run_cell_copy))\neditorstack.debug_cell_in_ipyclient.connect(lambda code, cell_name,\n    filename, run_cell_copy: self.debug_cell_in_ipyclient.emit(code,\n    cell_name, filename, run_cell_copy))\neditorstack.update_plugin_title.connect(lambda : self.\n    sig_update_plugin_title.emit())\neditorstack.editor_focus_changed.connect(self.save_focus_editorstack)\neditorstack.editor_focus_changed.connect(self.main.plugin_focus_changed)\neditorstack.editor_focus_changed.connect(self.sig_editor_focus_changed)\neditorstack.zoom_in.connect(lambda : self.zoom(1))\neditorstack.zoom_out.connect(lambda : self.zoom(-1))\neditorstack.zoom_reset.connect(lambda : self.zoom(0))\neditorstack.sig_open_file.connect(self.report_open_file)\neditorstack.sig_new_file.connect(lambda s: self.new(text=s))\neditorstack.sig_new_file[()].connect(self.new)\neditorstack.sig_close_file.connect(self.close_file_in_all_editorstacks)\neditorstack.sig_close_file.connect(self.remove_file_cursor_history)\neditorstack.file_saved.connect(self.file_saved_in_editorstack)\neditorstack.file_renamed_in_data.connect(self.\n    file_renamed_in_data_in_editorstack)\neditorstack.opened_files_list_changed.connect(self.opened_files_list_changed)\neditorstack.active_languages_stats.connect(self.update_active_languages)\neditorstack.sig_go_to_definition.connect(lambda fname, line, col: self.load\n    (fname, line, start_column=col))\neditorstack.sig_perform_completion_request.connect(self.send_completion_request\n    )\neditorstack.todo_results_changed.connect(self.todo_results_changed)\neditorstack.update_code_analysis_actions.connect(self.\n    update_code_analysis_actions)\neditorstack.update_code_analysis_actions.connect(self.update_todo_actions)\neditorstack.refresh_file_dependent_actions.connect(self.\n    refresh_file_dependent_actions)\neditorstack.refresh_save_all_action.connect(self.refresh_save_all_action)\neditorstack.sig_refresh_eol_chars.connect(self.refresh_eol_chars)\neditorstack.sig_refresh_formatting.connect(self.refresh_formatting)\neditorstack.sig_breakpoints_saved.connect(self.breakpoints_saved)\neditorstack.text_changed_at.connect(self.text_changed_at)\neditorstack.current_file_changed.connect(self.current_file_changed)\neditorstack.plugin_load.connect(self.load)\neditorstack.plugin_load[()].connect(self.load)\neditorstack.edit_goto.connect(self.load)\neditorstack.sig_save_as.connect(self.save_as)\neditorstack.sig_prev_edit_pos.connect(self.go_to_last_edit_location)\neditorstack.sig_prev_cursor.connect(self.go_to_previous_cursor_position)\neditorstack.sig_next_cursor.connect(self.go_to_next_cursor_position)\neditorstack.sig_prev_warning.connect(self.go_to_previous_warning)\neditorstack.sig_next_warning.connect(self.go_to_next_warning)\neditorstack.sig_save_bookmark.connect(self.save_bookmark)\neditorstack.sig_load_bookmark.connect(self.load_bookmark)\neditorstack.sig_save_bookmarks.connect(self.save_bookmarks)\neditorstack.sig_help_requested.connect(self.sig_help_requested)\nself.autosave.register_autosave_for_stack(editorstack.autosave)\n",
        "CUT_3": "\"\"\"\n        Register completion server capabilities in all editorstacks.\n\n        Parameters\n        ----------\n        capabilities: dict\n            Capabilities supported by a language server.\n        language: str\n            Programming language for the language server (it has to be\n            in small caps).\n        \"\"\"\nlogger.debug('Completion server capabilities for {!s} are: {!r}'.format(\n    language, capabilities))\nself.completion_capabilities[language] = dict(capabilities)\nfor editorstack in self.editorstacks:\n    editorstack.register_completion_capabilities(capabilities, language)\nself.start_completion_services(language)\nSlot(dict, str)",
        "CUT_4": "\"\"\"\n        Register completion server capabilities in all editorstacks.\n\n        Parameters\n        ----------\n        capabilities: dict\n            Capabilities supported by a language server.\n        language: str\n            Programming language for the language server (it has to be\n            in small caps).\n        \"\"\"\nlogger.debug('Completion server capabilities for {!s} are: {!r}'.format(\n    language, capabilities))\nself.completion_capabilities[language] = dict(capabilities)\nfor editorstack in self.editorstacks:\n    editorstack.register_completion_capabilities(capabilities, language)\nself.start_completion_services(language)\nSlot(dict, str)",
        "CUT_5": "self.editorstacks.append(editorstack)\nlogger.debug('EditorWidget.register_editorstack: %r' % editorstack)\nself.__print_editorstacks()\nself.plugin.last_focus_editorstack[self.parent()] = editorstack\neditorstack.set_closable(len(self.editorstacks) > 1)\neditorstack.set_outlineexplorer(self.outlineexplorer)\neditorstack.set_find_widget(self.find_widget)\neditorstack.reset_statusbar.connect(self.readwrite_status.hide)\neditorstack.reset_statusbar.connect(self.encoding_status.hide)\neditorstack.reset_statusbar.connect(self.cursorpos_status.hide)\neditorstack.readonly_changed.connect(self.readwrite_status.update_readonly)\neditorstack.encoding_changed.connect(self.encoding_status.update_encoding)\neditorstack.sig_editor_cursor_position_changed.connect(self.\n    cursorpos_status.update_cursor_position)\neditorstack.sig_refresh_eol_chars.connect(self.eol_status.update_eol)\nself.plugin.register_editorstack(editorstack)\noe_btn = create_toolbutton(self)\noe_btn.setDefaultAction(self.outlineexplorer.visibility_action)\neditorstack.add_corner_widgets_to_tabbar([5, oe_btn])\n"
    },
    {
        "functionName": "clone",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editor_stack = EditorStack(None, [])\neditor_stack.set_find_widget(Mock())\neditor_stack.set_io_actions(Mock(), Mock(), Mock(), Mock())\neditorsplitter.editorstack.new('test.py', 'utf-8', text)\n",
        "CUT_1": "return Mock()\n",
        "CUT_2": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_3": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_4": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_5": "\"\"\"Handle hover response.\"\"\"\nif running_under_pytest():\n    try:\n        from unittest.mock import Mock\n    except ImportError:\n        from mock import Mock\n    if isinstance(contents, Mock):\n        return\ntry:\n    content = contents['params']\n    if isinstance(content, list):\n        return\n    self.sig_display_object_info.emit(content, self._request_hover_clicked)\n    if content is not None and self._show_hint and self._last_point:\n        word = self._last_hover_word\n        content = content.replace('\\xa0', ' ')\n        self.show_hint(content, inspect_word=word, at_point=self._last_point)\n        self._last_point = None\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing hover')\nhandles(LSPRequestTypes.DOCUMENT_HOVER)"
    },
    {
        "functionName": "teardown",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "editorsplitter.hide()\neditorsplitter.close()\n",
        "CUT_1": "\"\"\"Create and attach a new EditorSplitter to the current EditorSplitter.\n\n        The new EditorSplitter widget will contain an EditorStack that\n        is a clone of the current EditorStack.\n\n        A single EditorSplitter instance can be split multiple times, but the\n        orientation will be the same for all the direct splits.  If one of\n        the child splits is split, then that split can have a different\n        orientation.\n        \"\"\"\nself.setOrientation(orientation)\nself.editorstack.set_orientation(orientation)\neditorsplitter = EditorSplitter(self.parent(), self.plugin, self.\n    menu_actions, register_editorstack_cb=self.register_editorstack_cb,\n    unregister_editorstack_cb=self.unregister_editorstack_cb)\nself.addWidget(editorsplitter)\neditorsplitter.destroyed.connect(lambda : self.editorsplitter_closed())\ncurrent_editor = editorsplitter.editorstack.get_current_editor()\nif current_editor is not None:\n    current_editor.setFocus()\n",
        "CUT_2": "\"\"\"Create and attach a new EditorSplitter to the current EditorSplitter.\n\n        The new EditorSplitter widget will contain an EditorStack that\n        is a clone of the current EditorStack.\n\n        A single EditorSplitter instance can be split multiple times, but the\n        orientation will be the same for all the direct splits.  If one of\n        the child splits is split, then that split can have a different\n        orientation.\n        \"\"\"\nself.setOrientation(orientation)\nself.editorstack.set_orientation(orientation)\neditorsplitter = EditorSplitter(self.parent(), self.plugin, self.\n    menu_actions, register_editorstack_cb=self.register_editorstack_cb,\n    unregister_editorstack_cb=self.unregister_editorstack_cb)\nself.addWidget(editorsplitter)\neditorsplitter.destroyed.connect(lambda : self.editorsplitter_closed())\ncurrent_editor = editorsplitter.editorstack.get_current_editor()\nif current_editor is not None:\n    current_editor.setFocus()\n",
        "CUT_3": "self.hide()\n",
        "CUT_4": "self.hide()\n",
        "CUT_5": "QSplitter.__init__(self, parent)\nself.setAttribute(Qt.WA_DeleteOnClose)\nstatusbar = parent.statusBar()\nself.vcs_status = VCSStatus(self, statusbar)\nself.cursorpos_status = CursorPositionStatus(self, statusbar)\nself.encoding_status = EncodingStatus(self, statusbar)\nself.eol_status = EOLStatus(self, statusbar)\nself.readwrite_status = ReadWriteStatus(self, statusbar)\nself.editorstacks = []\nself.plugin = plugin\nself.find_widget = FindReplace(self, enable_replace=True)\nself.plugin.register_widget_shortcuts(self.find_widget)\nself.find_widget.hide()\nself.outlineexplorer = OutlineExplorerWidget(self, show_fullpath=\n    outline_explorer_options['show_fullpath'], show_all_files=\n    outline_explorer_options['show_all_files'], group_cells=\n    outline_explorer_options['group_cells'], show_comments=\n    outline_explorer_options['show_comments'], sort_files_alphabetically=\n    outline_explorer_options['sort_files_alphabetically'])\nself.outlineexplorer.edit_goto.connect(lambda filenames, goto, word: plugin\n    .load(filenames=filenames, goto=goto, word=word, editorwindow=self.\n    parent()))\neditor_widgets = QWidget(self)\neditor_layout = QVBoxLayout()\neditor_layout.setContentsMargins(0, 0, 0, 0)\neditor_widgets.setLayout(editor_layout)\neditorsplitter = EditorSplitter(self, plugin, menu_actions,\n    register_editorstack_cb=self.register_editorstack,\n    unregister_editorstack_cb=self.unregister_editorstack)\nself.editorsplitter = editorsplitter\neditor_layout.addWidget(editorsplitter)\neditor_layout.addWidget(self.find_widget)\nsplitter = QSplitter(self)\nsplitter.setContentsMargins(0, 0, 0, 0)\nsplitter.addWidget(editor_widgets)\nsplitter.addWidget(self.outlineexplorer)\nsplitter.setStretchFactor(0, 5)\nsplitter.setStretchFactor(1, 1)\n"
    },
    {
        "functionName": "editor_splitter_layout_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create editor splitter for testing layouts.\"\"\"\nes = editor_splitter_bot\ndef clone(editorstack):\n    editorstack.close_action.setEnabled(False)\n    editorstack.set_find_widget(Mock())\n    editorstack.set_io_actions(Mock(), Mock(), Mock(), Mock())\n    editorstack.new('foo.py', 'utf-8', 'a = 1\\nprint(a)\\n\\nx = 2')\n    editorstack.new('layout_test.py', 'utf-8', 'print(spam)')\n    with open(__file__) as f:\n        text = f.read()\n    editorstack.new(__file__, 'utf-8', text)\nes.plugin.clone_editorstack.side_effect = clone\nclone(es.editorstack)\nreturn es\npytest.fixture",
        "CUT_1": "\"\"\"\n    Set up EditorStack with CodeEditor containing some Python code.\n    The cursor is at the empty line below the code.\n    Returns tuple with EditorStack and CodeEditor.\n    \"\"\"\ntext = \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\"\neditorStack = EditorStack(None, [])\neditorStack.set_find_widget(FindReplace(editorStack))\neditorStack.set_io_actions(Mock(), Mock(), Mock(), Mock())\nfinfo = editorStack.new('foo.py', 'utf-8', text)\nqtbot.addWidget(editorStack)\nreturn editorStack, finfo.editor\npytest.fixture",
        "CUT_2": "return Mock()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n"
    },
    {
        "functionName": "test_init",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\"Test __init__.\"\"\"\nes = editor_splitter_bot\nassert es.orientation() == Qt.Horizontal\nassert es.testAttribute(Qt.WA_DeleteOnClose)\nassert not es.childrenCollapsible()\nassert not es.toolbar_list\nassert not es.menu_list\nassert es.register_editorstack_cb == es.plugin.register_editorstack\nassert es.unregister_editorstack_cb == es.plugin.unregister_editorstack\nassert not es.menu_actions\nassert es.editorstack.menu_actions != []\nassert isinstance(es.editorstack, EditorStack)\nes.plugin.register_editorstack.assert_called_with(es.editorstack)\nes.plugin.unregister_editorstack.assert_not_called()\nes.plugin.clone_editorstack.assert_not_called()\nassert es.count() == 1\nassert es.widget(0) == es.editorstack\n",
        "CUT_1": "\"\"\"Create a splitter for dividing an editor window into panels.\n\n        Adds a new EditorStack instance to this splitter.  If it's not\n        the first splitter, clones the current EditorStack from the plugin.\n\n        Args:\n            parent: Parent widget.\n            plugin: Plugin this widget belongs to.\n            menu_actions: QActions to include from the parent.\n            first: Boolean if this is the first splitter in the editor.\n            register_editorstack_cb: Callback to register the EditorStack.\n                        Defaults to plugin.register_editorstack() to\n                        register the EditorStack with the Editor plugin.\n            unregister_editorstack_cb: Callback to unregister the EditorStack.\n                        Defaults to plugin.unregister_editorstack() to\n                        unregister the EditorStack with the Editor plugin.\n        \"\"\"\nQSplitter.__init__(self, parent)\nself.setAttribute(Qt.WA_DeleteOnClose)\nself.setChildrenCollapsible(False)\nself.toolbar_list = None\nself.menu_list = None\nself.plugin = plugin\nif register_editorstack_cb is None:\n    register_editorstack_cb = self.plugin.register_editorstack\nself.register_editorstack_cb = register_editorstack_cb\nif unregister_editorstack_cb is None:\n    unregister_editorstack_cb = self.plugin.unregister_editorstack\nself.unregister_editorstack_cb = unregister_editorstack_cb\nself.menu_actions = menu_actions\nself.editorstack = EditorStack(self, menu_actions)\nself.register_editorstack_cb(self.editorstack)\nif not first:\n    self.plugin.clone_editorstack(editorstack=self.editorstack)\nself.editorstack.destroyed.connect(lambda : self.editorstack_closed())\nself.editorstack.sig_split_vertically.connect(lambda : self.split(\n    orientation=Qt.Vertical))\nself.editorstack.sig_split_horizontally.connect(lambda : self.split(\n    orientation=Qt.Horizontal))\nself.addWidget(self.editorstack)\nif not running_under_pytest():\n    self.editorstack.set_color_scheme(plugin.get_color_scheme())\n",
        "CUT_2": "\"\"\"Create a splitter for dividing an editor window into panels.\n\n        Adds a new EditorStack instance to this splitter.  If it's not\n        the first splitter, clones the current EditorStack from the plugin.\n\n        Args:\n            parent: Parent widget.\n            plugin: Plugin this widget belongs to.\n            menu_actions: QActions to include from the parent.\n            first: Boolean if this is the first splitter in the editor.\n            register_editorstack_cb: Callback to register the EditorStack.\n                        Defaults to plugin.register_editorstack() to\n                        register the EditorStack with the Editor plugin.\n            unregister_editorstack_cb: Callback to unregister the EditorStack.\n                        Defaults to plugin.unregister_editorstack() to\n                        unregister the EditorStack with the Editor plugin.\n        \"\"\"\nQSplitter.__init__(self, parent)\nself.setAttribute(Qt.WA_DeleteOnClose)\nself.setChildrenCollapsible(False)\nself.toolbar_list = None\nself.menu_list = None\nself.plugin = plugin\nif register_editorstack_cb is None:\n    register_editorstack_cb = self.plugin.register_editorstack\nself.register_editorstack_cb = register_editorstack_cb\nif unregister_editorstack_cb is None:\n    unregister_editorstack_cb = self.plugin.unregister_editorstack\nself.unregister_editorstack_cb = unregister_editorstack_cb\nself.menu_actions = menu_actions\nself.editorstack = EditorStack(self, menu_actions)\nself.register_editorstack_cb(self.editorstack)\nif not first:\n    self.plugin.clone_editorstack(editorstack=self.editorstack)\nself.editorstack.destroyed.connect(lambda : self.editorstack_closed())\nself.editorstack.sig_split_vertically.connect(lambda : self.split(\n    orientation=Qt.Vertical))\nself.editorstack.sig_split_horizontally.connect(lambda : self.split(\n    orientation=Qt.Horizontal))\nself.addWidget(self.editorstack)\nif not running_under_pytest():\n    self.editorstack.set_color_scheme(plugin.get_color_scheme())\n",
        "CUT_3": "\"\"\"Start the code analysis.\"\"\"\nfilename = str(self.filecombo.currentText())\nself.process = QProcess(self)\nself.process.setProcessChannelMode(QProcess.SeparateChannels)\nself.process.setWorkingDirectory(getcwd_or_home())\nself.process.readyReadStandardOutput.connect(self.read_output)\nself.process.readyReadStandardError.connect(lambda : self.read_output(error\n    =True))\nself.process.finished.connect(lambda ec, es=QProcess.ExitStatus: self.\n    finished(ec, es))\nself.stop_button.clicked.connect(self.process.kill)\nself.output = ''\nself.error_output = ''\nif PYLINT_VER is not None:\n    pylint_args = ['-m', 'pylint', '--output-format=text',\n        \"--msg-template='{msg_id}:{symbol}:{line:3d},{column}: {msg}'\"]\npylintrc_path = self.get_pylintrc_path(filename=filename)\nif pylintrc_path is not None:\n    pylint_args += ['--rcfile={}'.format(pylintrc_path)]\npylint_args.append(filename)\nprocessEnvironment = QProcessEnvironment()\nprocessEnvironment.insert('PYTHONIOENCODING', 'utf8')\nself.process.setProcessEnvironment(processEnvironment)\nself.process.start(sys.executable, pylint_args)\nrunning = self.process.waitForStarted()\nself.set_running_state(running)\nif not running:\n    QMessageBox.critical(self, _('Error'), _('Process failed to start'))\nSlot()",
        "CUT_4": "\"\"\"Start the code analysis.\"\"\"\nfilename = str(self.filecombo.currentText())\nself.process = QProcess(self)\nself.process.setProcessChannelMode(QProcess.SeparateChannels)\nself.process.setWorkingDirectory(getcwd_or_home())\nself.process.readyReadStandardOutput.connect(self.read_output)\nself.process.readyReadStandardError.connect(lambda : self.read_output(error\n    =True))\nself.process.finished.connect(lambda ec, es=QProcess.ExitStatus: self.\n    finished(ec, es))\nself.stop_button.clicked.connect(self.process.kill)\nself.output = ''\nself.error_output = ''\nif PYLINT_VER is not None:\n    pylint_args = ['-m', 'pylint', '--output-format=text',\n        \"--msg-template='{msg_id}:{symbol}:{line:3d},{column}: {msg}'\"]\npylintrc_path = self.get_pylintrc_path(filename=filename)\nif pylintrc_path is not None:\n    pylint_args += ['--rcfile={}'.format(pylintrc_path)]\npylint_args.append(filename)\nprocessEnvironment = QProcessEnvironment()\nprocessEnvironment.insert('PYTHONIOENCODING', 'utf8')\nself.process.setProcessEnvironment(processEnvironment)\nself.process.start(sys.executable, pylint_args)\nrunning = self.process.waitForStarted()\nself.set_running_state(running)\nif not running:\n    QMessageBox.critical(self, _('Error'), _('Process failed to start'))\nSlot()",
        "CUT_5": "logger.debug('EditorWidget.unregister_editorstack: %r' % editorstack)\nself.plugin.unregister_editorstack(editorstack)\nself.editorstacks.pop(self.editorstacks.index(editorstack))\nself.__print_editorstacks()\n"
    },
    {
        "functionName": "test_close",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the inteface for closing the editor splitters.\"\"\"\nes = editor_splitter_bot\nes.split()\nesw1 = es.widget(1)\nesw1.editorstack.set_closable(True)\nassert es.count() == 2\nassert esw1.count() == 1\nesw1.split()\nesw1w1 = esw1.widget(1)\nesw1w1.editorstack.set_closable(True)\nassert es.count() == 2\nassert esw1.count() == 2\nassert esw1w1.count() == 1\nesw1.split()\nesw1w2 = esw1.widget(2)\nesw1w2.editorstack.set_closable(True)\nassert es.count() == 2\nassert esw1.count() == 3\nassert esw1w1.count() == esw1w2.count() == 1\nassert es.isVisible()\nassert esw1.isVisible()\nassert esw1w1.isVisible()\nassert esw1w2.isVisible()\nwith qtbot.waitSignal(esw1.editorstack.destroyed, timeout=1000):\n    esw1.editorstack.close_split()\nassert es.count() == 2\nassert esw1.count() == 2\nassert esw1.editorstack is None\nassert es.isVisible()\nassert esw1.isVisible()\nassert esw1w1.isVisible()\nassert esw1w2.isVisible()\nwith qtbot.waitSignal(esw1w1.destroyed, timeout=1000):\n    esw1w1.editorstack.close_split()\nwith pytest.raises(RuntimeError):\n    esw1w1.count()\nassert es.count() == 2\nassert esw1.count() == 1\nassert es.isVisible()\nassert esw1.isVisible()\nassert esw1w2.isVisible()\nwith qtbot.waitSignal(esw1.destroyed, timeout=1000):\n    esw1w2.editorstack.close_split()\nwith pytest.raises(RuntimeError):\n    esw1.count()\nwith pytest.raises(RuntimeError):\n    esw1w2.count()\nassert es.isVisible()\nassert es.count() == 1\nes.editorstack.close_split()\nassert es.isVisible()\nassert es.count() == 1\n",
        "CUT_1": "return self.tabs.count()\n",
        "CUT_2": "return self.tabs.count()\n",
        "CUT_3": "return self.stack.count()\n",
        "CUT_4": "return self.stack.count()\n",
        "CUT_5": "logger.debug(\"method 'editorsplitter_closed':\")\nlogger.debug('    self  : %r' % self)\ntry:\n    close_splitter = self.count() == 1 and self.editorstack is None\nexcept RuntimeError:\n    return\nif close_splitter:\n    self.close()\n    return\nelif self.count() == 2 and self.editorstack:\n    self.editorstack.reset_orientation()\nself.__give_focus_to_remaining_editor()\n"
    },
    {
        "functionName": "test_split",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test split() that adds new splitters to this instance.\"\"\"\nes = editor_splitter_layout_bot\nes.split()\nassert es.orientation() == Qt.Vertical\nassert not es.editorstack.horsplit_action.isEnabled()\nassert es.editorstack.versplit_action.isEnabled()\nassert es.count() == 2\nassert isinstance(es.widget(1), EditorSplitter)\nassert es.widget(1).count() == 1\nassert es.widget(1).editorstack == es.widget(1).widget(0)\nes.widget(1).plugin.clone_editorstack.assert_called_with(editorstack=es.\n    widget(1).editorstack)\nes.editorstack.sig_split_horizontally.emit()\nassert es.orientation() == Qt.Horizontal\nassert es.editorstack.horsplit_action.isEnabled()\nassert not es.editorstack.versplit_action.isEnabled()\nassert es.count() == 3\nassert isinstance(es.widget(2), EditorSplitter)\nassert es.widget(1).count() == 1\nassert es.widget(2).count() == 1\nes1 = es.widget(1)\nes1.editorstack.sig_split_vertically.emit()\nassert es.orientation() == Qt.Horizontal\nassert es1.orientation() == Qt.Vertical\nassert not es1.editorstack.horsplit_action.isEnabled()\nassert es1.editorstack.versplit_action.isEnabled()\nassert es1.count() == 2\nassert isinstance(es1.widget(0), EditorStack)\nassert isinstance(es1.widget(1), EditorSplitter)\nassert not es1.widget(1).isHidden()\n",
        "CUT_1": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_2": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_filename()\n",
        "CUT_5": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_finfo()\n"
    },
    {
        "functionName": "test_iter_editorstacks",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test iter_editorstacks.\"\"\"\nes = editor_splitter_bot\nes_iter = es.iter_editorstacks\nassert es_iter() == [(es.editorstack, es.orientation())]\nes.split(Qt.Vertical)\nesw1 = es.widget(1)\nassert es_iter() == [(es.editorstack, es.orientation()), (esw1.editorstack,\n    esw1.orientation())]\nes.split(Qt.Horizontal)\nassert es_iter() == [(es.editorstack, es.orientation()), (esw1.editorstack,\n    esw1.orientation())]\nesw1.split(Qt.Vertical)\nesw1w1 = es.widget(1).widget(1)\nassert es_iter() == [(es.editorstack, es.orientation()), (esw1.editorstack,\n    esw1.orientation()), (esw1w1.editorstack, esw1w1.orientation())]\n",
        "CUT_1": "self.horsplit_action.setEnabled(orientation == Qt.Horizontal)\nself.versplit_action.setEnabled(orientation == Qt.Vertical)\n",
        "CUT_2": "self.horsplit_action.setEnabled(orientation == Qt.Horizontal)\nself.versplit_action.setEnabled(orientation == Qt.Vertical)\n",
        "CUT_3": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_4": "editorstack = self.get_current_editorstack()\nif editorstack is not None:\n    return editorstack.get_current_editor()\n",
        "CUT_5": "\"\"\"Return the layout state for this splitter and its children.\n\n        Record the current state, including file names and current line\n        numbers, of the splitter panels.\n\n        Returns:\n            A dictionary containing keys {hexstate, sizes, splitsettings}.\n                hexstate: String of saveState() for self.\n                sizes: List for size() for self.\n                splitsettings: List of tuples of the form\n                       (orientation, cfname, clines) for each EditorSplitter\n                       and its EditorStack.\n                           orientation: orientation() for the editor\n                                 splitter (which may be a child of self).\n                           cfname: EditorStack current file name.\n                           clines: Current line number for each file in the\n                               EditorStack.\n        \"\"\"\nsplitsettings = []\nfor editorstack, orientation in self.iter_editorstacks():\n    clines = []\n    cfname = ''\n    orientation = False\n    if hasattr(editorstack, 'data'):\n        clines = [finfo.editor.get_cursor_line_number() for finfo in\n            editorstack.data]\n        cfname = editorstack.get_current_filename()\n    splitsettings.append((orientation == Qt.Vertical, cfname, clines))\nreturn dict(hexstate=qbytearray_to_str(self.saveState()), sizes=self.sizes(\n    ), splitsettings=splitsettings)\n"
    },
    {
        "functionName": "test_get_layout_settings",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test get_layout_settings().\"\"\"\nes = editor_splitter_bot\nsetting = es.get_layout_settings()\nassert setting['splitsettings'] == [(False, None, [])]\nstack1 = editor_stack()\nstack1.new('foo.py', 'utf-8', \"\"\"a = 1\nprint(a)\n\nx = 2\"\"\")\nstack1.new('layout_test.py', 'utf-8', 'spam egg\\n')\nstack2 = editor_stack()\nstack2.new('test.py', 'utf-8', 'test text')\nmocker.patch.object(EditorSplitter, 'iter_editorstacks')\nEditorSplitter.iter_editorstacks.return_value = [(stack1, Qt.Vertical), (\n    stack2, Qt.Horizontal)]\nsetting = es.get_layout_settings()\nassert setting['hexstate']\nassert setting['sizes'] == es.sizes()\nassert setting['splitsettings'] == [(False, 'foo.py', [5, 3]), (False,\n    'test.py', [2])]\n",
        "CUT_1": "\"\"\"\n        Create a form field.\n        \"\"\"\nlabel = ' '.join(setting.split('_')).capitalize()\nif isinstance(value, (list, dict)):\n    widget = self._create_combobox(setting, label, value)\nelif isinstance(value, str):\n    if value.lower() in ['y', 'yes', 'true', 'n', 'no', 'false']:\n        widget = self._create_checkbox(setting, label, default=value)\n    else:\n        default = None if self._is_jinja(setting) else value\n        widget = self._create_textbox(setting, label, default=default)\nelse:\n    raise Exception(\"Cookiecutter option '{}'cannot be processed\".format(\n        setting))\nself._widgets[setting] = label, widget\nreturn label, widget\n",
        "CUT_2": "\"\"\"\n        Create a form field.\n        \"\"\"\nlabel = ' '.join(setting.split('_')).capitalize()\nif isinstance(value, (list, dict)):\n    widget = self._create_combobox(setting, label, value)\nelif isinstance(value, str):\n    if value.lower() in ['y', 'yes', 'true', 'n', 'no', 'false']:\n        widget = self._create_checkbox(setting, label, default=value)\n    else:\n        default = None if self._is_jinja(setting) else value\n        widget = self._create_textbox(setting, label, default=default)\nelse:\n    raise Exception(\"Cookiecutter option '{}'cannot be processed\".format(\n        setting))\nself._widgets[setting] = label, widget\nreturn label, widget\n",
        "CUT_3": "\"\"\"Return layout state\"\"\"\nsplitsettings = self.editorwidget.editorsplitter.get_layout_settings()\nreturn dict(size=(self.window_size.width(), self.window_size.height()), pos\n    =(self.pos().x(), self.pos().y()), is_maximized=self.isMaximized(),\n    is_fullscreen=self.isFullScreen(), hexstate=qbytearray_to_str(self.\n    saveState()), splitsettings=splitsettings)\n",
        "CUT_4": "\"\"\"Return layout state\"\"\"\nsplitsettings = self.editorwidget.editorsplitter.get_layout_settings()\nreturn dict(size=(self.window_size.width(), self.window_size.height()), pos\n    =(self.pos().x(), self.pos().y()), is_maximized=self.isMaximized(),\n    is_fullscreen=self.isFullScreen(), hexstate=qbytearray_to_str(self.\n    saveState()), splitsettings=splitsettings)\n",
        "CUT_5": "\"\"\"\n        Setup the widget using options.\n        \"\"\"\nself._cookiecutter_settings = cookiecutter_settings\nself._check_jinja_options()\nfor setting, value in self._cookiecutter_settings.items():\n    if not setting.startswith(('__', '_')):\n        label, widget = self._create_field(setting, value)\n        self._form_layout.addRow(label, widget)\nself.render()\n"
    },
    {
        "functionName": "test_set_layout_settings_dont_goto",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test set_layout_settings().\"\"\"\nes = editor_splitter_layout_bot\nlinecount = es.editorstack.data[2].editor.get_cursor_line_number()\nstate = '000000ff000000010000000200000231000001ff00ffffffff010000000200'\nsizes = [561, 511]\nsplitsettings = [(False, 'layout_test.py', [2, 1, 52]), (False, 'foo.py', [\n    3, 2, 125]), (False, __file__, [1, 1, 1])]\nnew_settings = {'hexstate': state, 'sizes': sizes, 'splitsettings':\n    splitsettings}\nget_settings = es.get_layout_settings()\nassert es.count() == 1\nassert get_settings['hexstate'] != state\nassert get_settings['splitsettings'] != splitsettings\nassert es.set_layout_settings({'spam': 'test'}) is None\nes.set_layout_settings(new_settings, dont_goto=True)\nget_settings = es.get_layout_settings()\nassert es.count() == 2\nassert es.widget(1).count() == 2\nassert es.widget(1).widget(1).count() == 1\nassert get_settings['hexstate'] == state\nassert get_settings['splitsettings'] == [(False, 'foo.py', [5, 2, linecount\n    ]), (False, 'foo.py', [5, 2, linecount]), (False, 'foo.py', [5, 2,\n    linecount])]\n",
        "CUT_1": "\"\"\"Return layout state\"\"\"\nsplitsettings = self.editorwidget.editorsplitter.get_layout_settings()\nreturn dict(size=(self.window_size.width(), self.window_size.height()), pos\n    =(self.pos().x(), self.pos().y()), is_maximized=self.isMaximized(),\n    is_fullscreen=self.isFullScreen(), hexstate=qbytearray_to_str(self.\n    saveState()), splitsettings=splitsettings)\n",
        "CUT_2": "\"\"\"Return layout state\"\"\"\nsplitsettings = self.editorwidget.editorsplitter.get_layout_settings()\nreturn dict(size=(self.window_size.width(), self.window_size.height()), pos\n    =(self.pos().x(), self.pos().y()), is_maximized=self.isMaximized(),\n    is_fullscreen=self.isFullScreen(), hexstate=qbytearray_to_str(self.\n    saveState()), splitsettings=splitsettings)\n",
        "CUT_3": "\"\"\"Return the layout state for this splitter and its children.\n\n        Record the current state, including file names and current line\n        numbers, of the splitter panels.\n\n        Returns:\n            A dictionary containing keys {hexstate, sizes, splitsettings}.\n                hexstate: String of saveState() for self.\n                sizes: List for size() for self.\n                splitsettings: List of tuples of the form\n                       (orientation, cfname, clines) for each EditorSplitter\n                       and its EditorStack.\n                           orientation: orientation() for the editor\n                                 splitter (which may be a child of self).\n                           cfname: EditorStack current file name.\n                           clines: Current line number for each file in the\n                               EditorStack.\n        \"\"\"\nsplitsettings = []\nfor editorstack, orientation in self.iter_editorstacks():\n    clines = []\n    cfname = ''\n    orientation = False\n    if hasattr(editorstack, 'data'):\n        clines = [finfo.editor.get_cursor_line_number() for finfo in\n            editorstack.data]\n        cfname = editorstack.get_current_filename()\n    splitsettings.append((orientation == Qt.Vertical, cfname, clines))\nreturn dict(hexstate=qbytearray_to_str(self.saveState()), sizes=self.sizes(\n    ), splitsettings=splitsettings)\n",
        "CUT_4": "\"\"\"Return the layout state for this splitter and its children.\n\n        Record the current state, including file names and current line\n        numbers, of the splitter panels.\n\n        Returns:\n            A dictionary containing keys {hexstate, sizes, splitsettings}.\n                hexstate: String of saveState() for self.\n                sizes: List for size() for self.\n                splitsettings: List of tuples of the form\n                       (orientation, cfname, clines) for each EditorSplitter\n                       and its EditorStack.\n                           orientation: orientation() for the editor\n                                 splitter (which may be a child of self).\n                           cfname: EditorStack current file name.\n                           clines: Current line number for each file in the\n                               EditorStack.\n        \"\"\"\nsplitsettings = []\nfor editorstack, orientation in self.iter_editorstacks():\n    clines = []\n    cfname = ''\n    orientation = False\n    if hasattr(editorstack, 'data'):\n        clines = [finfo.editor.get_cursor_line_number() for finfo in\n            editorstack.data]\n        cfname = editorstack.get_current_filename()\n    splitsettings.append((orientation == Qt.Vertical, cfname, clines))\nreturn dict(hexstate=qbytearray_to_str(self.saveState()), sizes=self.sizes(\n    ), splitsettings=splitsettings)\n",
        "CUT_5": "\"\"\"Restore layout state\"\"\"\nsize = settings.get('size')\nif size is not None:\n    self.resize(QSize(*size))\n    self.window_size = self.size()\npos = settings.get('pos')\nif pos is not None:\n    self.move(QPoint(*pos))\nhexstate = settings.get('hexstate')\nif hexstate is not None:\n    self.restoreState(QByteArray().fromHex(str(hexstate).encode('utf-8')))\nif settings.get('is_maximized'):\n    self.setWindowState(Qt.WindowMaximized)\nif settings.get('is_fullscreen'):\n    self.setWindowState(Qt.WindowFullScreen)\nsplitsettings = settings.get('splitsettings')\nif splitsettings is not None:\n    self.editorwidget.editorsplitter.set_layout_settings(splitsettings)\n"
    },
    {
        "functionName": "test_set_layout_settings_goto",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test set_layout_settings().\"\"\"\nes = editor_splitter_layout_bot\nstate = '000000ff000000010000000200000231000001ff00ffffffff010000000200'\nsizes = [561, 511]\nsplitsettings = [(False, 'layout_test.py', [2, 1, 52]), (False, 'foo.py', [\n    3, 2, 125]), (False, __file__, [1, 1, 1])]\nnew_settings = {'hexstate': state, 'sizes': sizes, 'splitsettings':\n    splitsettings}\nes.set_layout_settings(new_settings, dont_goto=None)\nget_settings = es.get_layout_settings()\nassert get_settings['splitsettings'] == [(False, 'foo.py', [2, 1, 52]), (\n    False, 'foo.py', [3, 2, 125]), (False, 'foo.py', [1, 1, 1])]\n",
        "CUT_1": "\"\"\"Return layout state\"\"\"\nsplitsettings = self.editorwidget.editorsplitter.get_layout_settings()\nreturn dict(size=(self.window_size.width(), self.window_size.height()), pos\n    =(self.pos().x(), self.pos().y()), is_maximized=self.isMaximized(),\n    is_fullscreen=self.isFullScreen(), hexstate=qbytearray_to_str(self.\n    saveState()), splitsettings=splitsettings)\n",
        "CUT_2": "\"\"\"Return layout state\"\"\"\nsplitsettings = self.editorwidget.editorsplitter.get_layout_settings()\nreturn dict(size=(self.window_size.width(), self.window_size.height()), pos\n    =(self.pos().x(), self.pos().y()), is_maximized=self.isMaximized(),\n    is_fullscreen=self.isFullScreen(), hexstate=qbytearray_to_str(self.\n    saveState()), splitsettings=splitsettings)\n",
        "CUT_3": "\"\"\"Return the layout state for this splitter and its children.\n\n        Record the current state, including file names and current line\n        numbers, of the splitter panels.\n\n        Returns:\n            A dictionary containing keys {hexstate, sizes, splitsettings}.\n                hexstate: String of saveState() for self.\n                sizes: List for size() for self.\n                splitsettings: List of tuples of the form\n                       (orientation, cfname, clines) for each EditorSplitter\n                       and its EditorStack.\n                           orientation: orientation() for the editor\n                                 splitter (which may be a child of self).\n                           cfname: EditorStack current file name.\n                           clines: Current line number for each file in the\n                               EditorStack.\n        \"\"\"\nsplitsettings = []\nfor editorstack, orientation in self.iter_editorstacks():\n    clines = []\n    cfname = ''\n    orientation = False\n    if hasattr(editorstack, 'data'):\n        clines = [finfo.editor.get_cursor_line_number() for finfo in\n            editorstack.data]\n        cfname = editorstack.get_current_filename()\n    splitsettings.append((orientation == Qt.Vertical, cfname, clines))\nreturn dict(hexstate=qbytearray_to_str(self.saveState()), sizes=self.sizes(\n    ), splitsettings=splitsettings)\n",
        "CUT_4": "\"\"\"Return the layout state for this splitter and its children.\n\n        Record the current state, including file names and current line\n        numbers, of the splitter panels.\n\n        Returns:\n            A dictionary containing keys {hexstate, sizes, splitsettings}.\n                hexstate: String of saveState() for self.\n                sizes: List for size() for self.\n                splitsettings: List of tuples of the form\n                       (orientation, cfname, clines) for each EditorSplitter\n                       and its EditorStack.\n                           orientation: orientation() for the editor\n                                 splitter (which may be a child of self).\n                           cfname: EditorStack current file name.\n                           clines: Current line number for each file in the\n                               EditorStack.\n        \"\"\"\nsplitsettings = []\nfor editorstack, orientation in self.iter_editorstacks():\n    clines = []\n    cfname = ''\n    orientation = False\n    if hasattr(editorstack, 'data'):\n        clines = [finfo.editor.get_cursor_line_number() for finfo in\n            editorstack.data]\n        cfname = editorstack.get_current_filename()\n    splitsettings.append((orientation == Qt.Vertical, cfname, clines))\nreturn dict(hexstate=qbytearray_to_str(self.saveState()), sizes=self.sizes(\n    ), splitsettings=splitsettings)\n",
        "CUT_5": "\"\"\"Restore layout state for the splitter panels.\n\n        Apply the settings to restore a saved layout within the editor.  If\n        the splitsettings key doesn't exist, then return without restoring\n        any settings.\n\n        The current EditorSplitter (self) calls split() for each element\n        in split_settings, thus recreating the splitter panels from the saved\n        state.  split() also clones the editorstack, which is then\n        iterated over to restore the saved line numbers on each file.\n\n        The size and positioning of each splitter panel is restored from\n        hexstate.\n\n        Args:\n            settings: A dictionary with keys {hexstate, sizes, orientation}\n                    that define the layout for the EditorSplitter panels.\n            dont_goto: Defaults to None, which positions the cursor to the\n                    end of the editor.  If there's a value, positions the\n                    cursor on the saved line number for each editor.\n        \"\"\"\nsplitsettings = settings.get('splitsettings')\nif splitsettings is None:\n    return\nsplitter = self\neditor = None\nfor index, (is_vertical, cfname, clines) in enumerate(splitsettings):\n    if index > 0:\n        splitter.split(Qt.Vertical if is_vertical else Qt.Horizontal)\n        splitter = splitter.widget(1)\n    editorstack = splitter.widget(0)\n    for index, finfo in enumerate(editorstack.data):\n        editor = finfo.editor\n        if dont_goto is not None:\n            pass\n        else:\n            try:\n                editor.go_to_line(clines[index])\n            except IndexError:\n                pass\nhexstate = settings.get('hexstate')\nif hexstate is not None:\n    self.restoreState(QByteArray().fromHex(str(hexstate).encode('utf-8')))\nsizes = settings.get('sizes')\nif sizes is not None:\n    self.setSizes(sizes)\nif editor is not None:\n    editor.clearFocus()\n    editor.setFocus()\n"
    },
    {
        "functionName": "test_lsp_splitter_close",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_editorsplitter.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test for spyder-ide/spyder#9341.\"\"\"\neditorsplitter, lsp_manager = editor_splitter_lsp\neditorsplitter.split()\nlsp_files = lsp_manager.clients['python']['instance'].watched_files\neditor = editorsplitter.editorstack.get_current_editor()\npath = pathlib.Path(osp.abspath(editor.filename)).as_uri()\nassert len(lsp_files[path]) == 2\neditorstacks = editorsplitter.iter_editorstacks()\nassert len(editorstacks) == 2\nlast_editorstack = editorstacks[0][0]\nlast_editorstack.close()\nlsp_files = lsp_manager.clients['python']['instance'].watched_files\nassert len(lsp_files[path]) == 1\npytest.mark.slowpytest.mark.firstpytest.mark.skipif(os.name == 'nt', reason='Makes other tests fail on Windows')",
        "CUT_1": "\"\"\"Create and attach a new EditorSplitter to the current EditorSplitter.\n\n        The new EditorSplitter widget will contain an EditorStack that\n        is a clone of the current EditorStack.\n\n        A single EditorSplitter instance can be split multiple times, but the\n        orientation will be the same for all the direct splits.  If one of\n        the child splits is split, then that split can have a different\n        orientation.\n        \"\"\"\nself.setOrientation(orientation)\nself.editorstack.set_orientation(orientation)\neditorsplitter = EditorSplitter(self.parent(), self.plugin, self.\n    menu_actions, register_editorstack_cb=self.register_editorstack_cb,\n    unregister_editorstack_cb=self.unregister_editorstack_cb)\nself.addWidget(editorsplitter)\neditorsplitter.destroyed.connect(lambda : self.editorsplitter_closed())\ncurrent_editor = editorsplitter.editorstack.get_current_editor()\nif current_editor is not None:\n    current_editor.setFocus()\n",
        "CUT_2": "\"\"\"Create and attach a new EditorSplitter to the current EditorSplitter.\n\n        The new EditorSplitter widget will contain an EditorStack that\n        is a clone of the current EditorStack.\n\n        A single EditorSplitter instance can be split multiple times, but the\n        orientation will be the same for all the direct splits.  If one of\n        the child splits is split, then that split can have a different\n        orientation.\n        \"\"\"\nself.setOrientation(orientation)\nself.editorstack.set_orientation(orientation)\neditorsplitter = EditorSplitter(self.parent(), self.plugin, self.\n    menu_actions, register_editorstack_cb=self.register_editorstack_cb,\n    unregister_editorstack_cb=self.unregister_editorstack_cb)\nself.addWidget(editorsplitter)\neditorsplitter.destroyed.connect(lambda : self.editorsplitter_closed())\ncurrent_editor = editorsplitter.editorstack.get_current_editor()\nif current_editor is not None:\n    current_editor.setFocus()\n",
        "CUT_3": "\"\"\"Return the editor stacks for this splitter and every first child.\n\n        Note: If a splitter contains more than one splitter as a direct\n              child, only the first child's editor stack is included.\n\n        Returns:\n            List of tuples containing (EditorStack instance, orientation).\n        \"\"\"\neditorstacks = [(self.widget(0), self.orientation())]\nif self.count() > 1:\n    editorsplitter = self.widget(1)\n    editorstacks += editorsplitter.iter_editorstacks()\nreturn editorstacks\n",
        "CUT_4": "\"\"\"Return the editor stacks for this splitter and every first child.\n\n        Note: If a splitter contains more than one splitter as a direct\n              child, only the first child's editor stack is included.\n\n        Returns:\n            List of tuples containing (EditorStack instance, orientation).\n        \"\"\"\neditorstacks = [(self.widget(0), self.orientation())]\nif self.count() > 1:\n    editorsplitter = self.widget(1)\n    editorstacks += editorsplitter.iter_editorstacks()\nreturn editorstacks\n",
        "CUT_5": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n"
    },
    {
        "functionName": "get_indent_fix",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Return text with last line's indentation fixed.\"\"\"\napp = qapplication()\neditor = CodeEditor(parent=None)\neditor.setup_editor(language=language, indent_chars=indent_chars,\n    tab_stop_width_spaces=tab_stop_width_spaces)\neditor.set_text(text)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.End)\nif sol:\n    lines = text.splitlines(True)\n    repeat = len(lines[-1].lstrip())\n    cursor.movePosition(QTextCursor.Left, n=repeat)\neditor.setTextCursor(cursor)\neditor.fix_indent(forward=forward)\nreturn to_text_string(editor.toPlainText())\n",
        "CUT_1": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_2": "\"\"\"Control how to automatically insert quotes in various situations.\"\"\"\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\nlast_three = self.editor.get_text('sol', 'cursor')[-3:]\nlast_two = self.editor.get_text('sol', 'cursor')[-2:]\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{0}'.format(char, text))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif self.editor.in_comment():\n    self.editor.insert_text(char)\nelif len(trailing_text) > 0 and not unmatched_quotes_in_line(line_to_cursor\n    ) == char and not trailing_text[0] in (',', ':', ';', ')', ']', '}'):\n    self.editor.insert_text(char)\nelif unmatched_quotes_in_line(line_text) and not last_three == 3 * char:\n    self.editor.insert_text(char)\nelif self.editor.next_char() == char:\n    cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor, 1)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_three == 3 * char:\n    self.editor.insert_text(3 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter, QTextCursor.\n        KeepAnchor, 3)\n    cursor.clearSelection()\n    self.editor.setTextCursor(cursor)\nelif last_two == 2 * char:\n    self.editor.insert_text(char)\n    self.editor.delayed_popup_docstring()\nelse:\n    self.editor.insert_text(2 * char)\n    cursor = self.editor.textCursor()\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    self.editor.setTextCursor(cursor)\n",
        "CUT_3": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_4": "\"\"\"Control automatic insertation of brackets in various situations.\"\"\"\npair = self.BRACKETS_PAIR[char]\nline_text = self.editor.get_text('sol', 'eol')\nline_to_cursor = self.editor.get_text('sol', 'cursor')\ncursor = self.editor.textCursor()\ntrailing_text = self.editor.get_text('cursor', 'eol').strip()\nif self.editor.has_selected_text():\n    text = self.editor.get_selected_text()\n    self.editor.insert_text('{0}{1}{2}'.format(pair[0], text, pair[1]))\n    cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)\n    cursor.movePosition(QTextCursor.Left, QTextCursor.KeepAnchor, len(text))\n    self.editor.setTextCursor(cursor)\nelif char in self.BRACKETS_LEFT:\n    if not trailing_text or trailing_text[0\n        ] in self.BRACKETS_RIGHT or trailing_text[0] in [',', ':', ';']:\n        self.editor.insert_text(pair)\n        cursor.movePosition(QTextCursor.PreviousCharacter)\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n    if char in self.editor.signature_completion_characters:\n        self.editor.request_signature()\nelif char in self.BRACKETS_RIGHT:\n    if self.editor.next_char() == char and not self.editor.textCursor(\n        ).atBlockEnd() and not self.unmatched_brackets_in_line(cursor.block\n        ().text(), char, autoinsert=True):\n        cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.\n            KeepAnchor, 1)\n        cursor.clearSelection()\n        self.editor.setTextCursor(cursor)\n    else:\n        self.editor.insert_text(char)\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_simple_tuple",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix('this_tuple = (1, 2)\\n')\nassert text == 'this_tuple = (1, 2)\\n'\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_4": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_5": "\"\"\"\n        Convert text address into QUrl object.\n\n        Parameters\n        ----------\n        text: str\n            Url address.\n        \"\"\"\nif text != 'about:blank':\n    text += '.html'\nif text.startswith('/'):\n    text = text[1:]\nreturn QUrl(self.home_url.toString() + text)\n"
    },
    {
        "functionName": "test_def_with_newline",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix(\"\"\"\ndef function():\n\"\"\")\nassert text == \"\"\"\ndef function():\n    \"\"\", repr(text)\n",
        "CUT_1": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_2": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_3": "return self.text\n",
        "CUT_4": "return self.text\n",
        "CUT_5": "return self.__get_name('def', text)\n"
    },
    {
        "functionName": "test_def_with_indented_comment",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix(\"\"\"def function():\n    # Comment\n\"\"\")\nassert text == \"\"\"def function():\n    # Comment\n    \"\"\", repr(text)\n",
        "CUT_1": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_2": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_3": "\"\"\"Implement highlight specific for Fortran77.\"\"\"\ntext = to_text_string(text)\nif text.startswith(('c', 'C')):\n    self.setFormat(0, qstring_length(text), self.formats['comment'])\n    self.highlight_extras(text)\nelse:\n    FortranSH.highlight_block(self, text)\n    self.setFormat(0, 5, self.formats['comment'])\n    self.setFormat(73, max([73, qstring_length(text)]), self.formats['comment']\n        )\n",
        "CUT_4": "\"\"\"Implement highlight specific for Fortran77.\"\"\"\ntext = to_text_string(text)\nif text.startswith(('c', 'C')):\n    self.setFormat(0, qstring_length(text), self.formats['comment'])\n    self.highlight_extras(text)\nelse:\n    FortranSH.highlight_block(self, text)\n    self.setFormat(0, 5, self.formats['comment'])\n    self.setFormat(73, max([73, qstring_length(text)]), self.formats['comment']\n        )\n",
        "CUT_5": "return self.text\n"
    },
    {
        "functionName": "test_brackets_alone",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix(\"\"\"def function():\n    print []\n\"\"\")\nassert text == \"\"\"def function():\n    print []\n    \"\"\", repr(text)\n",
        "CUT_1": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_2": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_3": "return self.text\n",
        "CUT_4": "return self.text\n",
        "CUT_5": "for i in range(3):\n    print(i)\n"
    },
    {
        "functionName": "test_simple_def",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix('def function():\\n')\nassert text == 'def function():\\n    ', repr(text)\n",
        "CUT_1": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_2": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_3": "return self.text\n",
        "CUT_4": "return self.text\n",
        "CUT_5": "return self.__get_name('def', text)\n"
    },
    {
        "functionName": "test_open_parenthesis",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix('open_parenthesis(\\n')\nassert text == 'open_parenthesis(\\n    ', repr(text)\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_4": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_5": "\"\"\"\n        Convert text address into QUrl object.\n\n        Parameters\n        ----------\n        text: str\n            Url address.\n        \"\"\"\nif text != 'about:blank':\n    text += '.html'\nif text.startswith('/'):\n    text = text[1:]\nreturn QUrl(self.home_url.toString() + text)\n"
    },
    {
        "functionName": "test_open_bracket",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix('open_bracket[\\n')\nassert text == 'open_bracket[\\n    ', repr(text)\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_4": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_5": "\"\"\"\n        Convert text address into QUrl object.\n\n        Parameters\n        ----------\n        text: str\n            Url address.\n        \"\"\"\nif text != 'about:blank':\n    text += '.html'\nif text.startswith('/'):\n    text = text[1:]\nreturn QUrl(self.home_url.toString() + text)\n"
    },
    {
        "functionName": "test_open_curly",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix('open_curly{\\n')\nassert text == 'open_curly{\\n    ', repr(text)\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_4": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_5": "\"\"\"\n        Convert text address into QUrl object.\n\n        Parameters\n        ----------\n        text: str\n            Url address.\n        \"\"\"\nif text != 'about:blank':\n    text += '.html'\nif text.startswith('/'):\n    text = text[1:]\nreturn QUrl(self.home_url.toString() + text)\n"
    },
    {
        "functionName": "test_align_on_parenthesis",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix('parenthesis_w_item = (1,\\n')\nassert text == 'parenthesis_w_item = (1,\\n                      ', repr(text)\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_4": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_5": "\"\"\"\n        Convert text address into QUrl object.\n\n        Parameters\n        ----------\n        text: str\n            Url address.\n        \"\"\"\nif text != 'about:blank':\n    text += '.html'\nif text.startswith('/'):\n    text = text[1:]\nreturn QUrl(self.home_url.toString() + text)\n"
    },
    {
        "functionName": "test_align_on_bracket",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix('bracket_w_item = [1,\\n')\nassert text == 'bracket_w_item = [1,\\n                  ', repr(text)\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_4": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_5": "\"\"\"\n        Convert text address into QUrl object.\n\n        Parameters\n        ----------\n        text: str\n            Url address.\n        \"\"\"\nif text != 'about:blank':\n    text += '.html'\nif text.startswith('/'):\n    text = text[1:]\nreturn QUrl(self.home_url.toString() + text)\n"
    },
    {
        "functionName": "test_align_on_curly",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix('curly_w_item = {1,\\n')\nassert text == 'curly_w_item = {1,\\n                ', repr(text)\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_4": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n",
        "CUT_5": "\"\"\"\n        Convert text address into QUrl object.\n\n        Parameters\n        ----------\n        text: str\n            Url address.\n        \"\"\"\nif text != 'about:blank':\n    text += '.html'\nif text.startswith('/'):\n    text = text[1:]\nreturn QUrl(self.home_url.toString() + text)\n"
    },
    {
        "functionName": "test_keep_unindent",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = \"\"\"    def foo(bar):\n        generic = bar\n    \n    keep_unindent\n\"\"\"\ncorrect_text = \"\"\"    def foo(bar):\n        generic = bar\n    \n    keep_unindent\n\"\"\"\ntext = get_indent_fix(text, sol=True)\nassert text == correct_text, repr(text)\n",
        "CUT_1": "\"\"\"Detect if text has mixed EOL characters\"\"\"\neol_chars = get_eol_chars(text)\nif eol_chars is None:\n    return False\ncorrect_text = eol_chars.join((text + eol_chars).splitlines())\nreturn repr(correct_text) != repr(text)\n",
        "CUT_2": "\"\"\"Detect if text has mixed EOL characters\"\"\"\neol_chars = get_eol_chars(text)\nif eol_chars is None:\n    return False\ncorrect_text = eol_chars.join((text + eol_chars).splitlines())\nreturn repr(correct_text) != repr(text)\n",
        "CUT_3": "return self.text\n",
        "CUT_4": "return self.text\n",
        "CUT_5": "\"\"\"\n        Update the color scheme of the preview editor and adds text.\n\n        Note\n        ----\n        'index' is needed, because this is triggered by a signal that sends\n        the selected index.\n        \"\"\"\ntext = \"\"\"\"\"\\\"A string\"\"\\\"\n\n# A comment\n\nclass Foo(object):\n    def __init__(self):\n        bar = 42\n        print(bar)\n\"\"\"\nif scheme_name is None:\n    scheme_name = self.current_scheme\nself.preview_editor.setup_editor(font=get_font(), color_scheme=scheme_name,\n    show_blanks=False, scroll_past_end=False)\nself.preview_editor.set_language('Python')\nself.preview_editor.set_text(text)\n"
    },
    {
        "functionName": "test_keep_unindent_fix_indent",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = \"\"\"    for x in range(n):\n        increment += 1\n  \n  keep_unindent\n\"\"\"\ncorrect_text = \"\"\"    for x in range(n):\n        increment += 1\n  \n    keep_unindent\n\"\"\"\ntext = get_indent_fix(text, sol=True)\nassert text == correct_text, repr(text)\n",
        "CUT_1": "\"\"\"Detect if text has mixed EOL characters\"\"\"\neol_chars = get_eol_chars(text)\nif eol_chars is None:\n    return False\ncorrect_text = eol_chars.join((text + eol_chars).splitlines())\nreturn repr(correct_text) != repr(text)\n",
        "CUT_2": "\"\"\"Detect if text has mixed EOL characters\"\"\"\neol_chars = get_eol_chars(text)\nif eol_chars is None:\n    return False\ncorrect_text = eol_chars.join((text + eol_chars).splitlines())\nreturn repr(correct_text) != repr(text)\n",
        "CUT_3": "return self.text\n",
        "CUT_4": "return self.text\n",
        "CUT_5": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n"
    },
    {
        "functionName": "test_keep_unindent_if_blank",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = \"\"\"    def f(x):\n        return x\n\n\"\"\"\ntext = get_indent_fix(text)\nassert text == \"\"\"    def f(x):\n        return x\n\n\"\"\", repr(text)\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"Return modified text\"\"\"\nreturn self.text\n",
        "CUT_4": "\"\"\"Return modified text\"\"\"\nreturn self.text\n",
        "CUT_5": "\"\"\"Return line indentation (character number).\"\"\"\ntext = to_text_string(self.document().findBlockByNumber(block_nb).text())\ntext = text.replace('\\t', ' ' * self.tab_stop_width_spaces)\nreturn len(text) - len(text.lstrip())\n"
    },
    {
        "functionName": "test_first_line",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix('import numpy')\nassert text == 'import numpy', repr(text)\n",
        "CUT_1": "\"\"\"Return True if variable is a NumPy array\"\"\"\ntry:\n    import numpy\n    return isinstance(var, numpy.ndarray)\nexcept:\n    return False\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "return self.text\n",
        "CUT_4": "\"\"\"Return NumPy data type associated to obj\n    Return None if NumPy is not available\n    or if obj is not a NumPy array or scalar\"\"\"\nif ndarray is not FakeObject:\n    import numpy as np\n    if isinstance(obj, np.generic) or isinstance(obj, np.ndarray):\n        try:\n            return obj.dtype.type\n        except (AttributeError, RuntimeError):\n            return\n",
        "CUT_5": "\"\"\"\n        Set `text` of the document.\n\n        Parameters\n        ----------\n        text: str\n            Text to set.\n        \"\"\"\nself.setPlainText(text)\n"
    },
    {
        "functionName": "test_indentation_with_spaces",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [(\"tags = ['(a)', '(b)', '(c)']\\n\",\n    \"tags = ['(a)', '(b)', '(c)']\\n\", 'test_commented_brackets'), (\n    \"\"\"s = a[(a['a'] == l) & (a['a'] == 1)]['a']\n\"\"\",\n    \"s = a[(a['a'] == l) & (a['a'] == 1)]['a']\\n\", 'test_balanced_brackets'\n    ), (\"\"\"a = (a  #  some comment\n\"\"\", 'a = (a  #  some comment\\n     ',\n    'test_inline_comment'), ('len(a) == 1\\n', 'len(a) == 1\\n',\n    'test_balanced_brackets_not_ending_in_bracket'), ('x = f(\\n',\n    'x = f(\\n      ', 'test_short_open_bracket_not_hanging_indent'), (\n    \"\"\"def some_func():\n    return 10\n\"\"\",\n    \"\"\"def some_func():\n    return 10\n\"\"\", 'test_return'), (\n    \"\"\"def some_func():\n    returns = 10\n\"\"\",\n    \"\"\"def some_func():\n    returns = 10\n    \"\"\", 'test_return_not_keyword'\n    ), ('foo = 1  # Comment open parenthesis (\\n',\n    \"\"\"foo = 1  # Comment open parenthesis (\n\"\"\",\n    'test_comment_with parenthesis')]\nfor text_input, expected, comment in text_input_expected_comment:\n    text = get_indent_fix(text_input)\n    assert text == expected, comment\n",
        "CUT_1": "return self.def_type in (self.COMMENT, self.CELL)\n",
        "CUT_2": "return self.def_type in (self.COMMENT, self.CELL)\n",
        "CUT_3": "\"\"\"Return comment string\"\"\"\nreturn to_text_string(self.comments_edt.text())\n",
        "CUT_4": "\"\"\"Return comment string\"\"\"\nreturn to_text_string(self.comments_edt.text())\n",
        "CUT_5": "\"\"\"Implement highlight specific for Fortran77.\"\"\"\ntext = to_text_string(text)\nif text.startswith(('c', 'C')):\n    self.setFormat(0, qstring_length(text), self.formats['comment'])\n    self.highlight_extras(text)\nelse:\n    FortranSH.highlight_block(self, text)\n    self.setFormat(0, 5, self.formats['comment'])\n    self.setFormat(73, max([73, qstring_length(text)]), self.formats['comment']\n        )\n"
    },
    {
        "functionName": "test_def_with_unindented_comment",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix(\"\"\"def function():\n# Comment\n\"\"\")\nassert text == \"\"\"def function():\n# Comment\n\"\"\", repr(text)\n",
        "CUT_1": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_2": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_3": "\"\"\"Implement highlight specific for Fortran77.\"\"\"\ntext = to_text_string(text)\nif text.startswith(('c', 'C')):\n    self.setFormat(0, qstring_length(text), self.formats['comment'])\n    self.highlight_extras(text)\nelse:\n    FortranSH.highlight_block(self, text)\n    self.setFormat(0, 5, self.formats['comment'])\n    self.setFormat(73, max([73, qstring_length(text)]), self.formats['comment']\n        )\n",
        "CUT_4": "\"\"\"Implement highlight specific for Fortran77.\"\"\"\ntext = to_text_string(text)\nif text.startswith(('c', 'C')):\n    self.setFormat(0, qstring_length(text), self.formats['comment'])\n    self.highlight_extras(text)\nelse:\n    FortranSH.highlight_block(self, text)\n    self.setFormat(0, 5, self.formats['comment'])\n    self.setFormat(73, max([73, qstring_length(text)]), self.formats['comment']\n        )\n",
        "CUT_5": "return self.text\n"
    },
    {
        "functionName": "test_issue_5606",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [(\n    \"\"\"if True:\n    print(str(str('foo' \n+ str('bar'))))\"\"\",\n    \"\"\"if True:\n    print(str(str('foo' \n                  + str('bar'))))\"\"\",\n    'Before + 1'), (\"\"\"if True:\n    print(str(str('foo' +\n str('bar'))))\"\"\",\n    \"\"\"if True:\n    print(str(str('foo' +\n                  str('bar'))))\"\"\",\n    'After + 1'), (\"\"\"if True:\n    print(str(str(str('foo') \n+ 'bar')))\"\"\",\n    \"\"\"if True:\n    print(str(str(str('foo') \n                  + 'bar')))\"\"\",\n    'Before + 2'), (\"\"\"if True:\n    print(str(str(str('foo') +\n 'bar')))\"\"\",\n    \"\"\"if True:\n    print(str(str(str('foo') +\n                  'bar')))\"\"\",\n    'After + 2'), (\n    \"\"\"if True:\n    some_long_variable_name = (\n'foo' + 'bar')\"\"\",\n    \"\"\"if True:\n    some_long_variable_name = (\n        'foo' + 'bar')\"\"\",\n    'Open paren case'), (\n    \"\"\"if True:\n    (print(str(('Long string ' + 'Yeah')\n.format(some_long_variable_name))\"\"\"\n    ,\n    \"\"\"if True:\n    (print(str(('Long string ' + 'Yeah')\n               .format(some_long_variable_name))\"\"\"\n    , 'Before . 1'), (\n    \"\"\"if True:\n    (print(str(('Long string ' + 'Yeah').\nformat(some_long_variable_name))\"\"\"\n    ,\n    \"\"\"if True:\n    (print(str(('Long string ' + 'Yeah').\n               format(some_long_variable_name))\"\"\"\n    , 'After . 1')]\nfor text_input, expected, comment in text_input_expected_comment:\n    text = get_indent_fix(text_input)\n    assert text == expected, comment\n",
        "CUT_1": "return str(self)\n",
        "CUT_2": "return str(self)\n",
        "CUT_3": "return str(string)\n",
        "CUT_4": "return str(string)\n",
        "CUT_5": "return str(list(self))\n"
    },
    {
        "functionName": "test_issue_7377",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [(\"print('#1 w(Earth) =', w)\\n\",\n    \"print('#1 w(Earth) =', w)\\n\", 'Indentation made'), (\n    \"\"\"print('1 w(Earth) =', w)\n\"\"\", \"print('1 w(Earth) =', w)\\n\",\n    'Indentation made')]\nfor text_input, expected, comment in text_input_expected_comment:\n    text = get_indent_fix(text_input)\n    assert text == expected, comment\n",
        "CUT_1": "for i in range(3):\n    print(i)\n",
        "CUT_2": "for i in range(3):\n    print(i)\n",
        "CUT_3": "for i in range(3):\n    print(i)\n",
        "CUT_4": "for i in range(3):\n    print(i)\n",
        "CUT_5": "for i in range(3):\n    print(i)\n"
    },
    {
        "functionName": "test_issue_887",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [('df = pd.read_csv(fpath,\\n' +\n    \"\"\"                 # HINT indexing begins with 0\n\"\"\" +\n    '                 header=0, # headers 1st row\\n' +\n    \"\"\"                 index_col=0, #timestamps 1st column\n\"\"\" +\n    '                 # specify as seconds to recognize as epoch timestamp...\\n'\n     + \"\"\"                 # it's local time (i.e...)\n\"\"\" +\n    '                 # (section 9.10.3, http://......)\\n' +\n    \"\"\"                 date_parser=lambda x: pd.to_datetime(x, units='s'),\n\"\"\"\n     + '            parse_dates=True)', 'df = pd.read_csv(fpath,\\n' +\n    \"\"\"                 # HINT indexing begins with 0\n\"\"\" +\n    '                 header=0, # headers 1st row\\n' +\n    \"\"\"                 index_col=0, #timestamps 1st column\n\"\"\" +\n    '                 # specify as seconds to recognize as epoch timestamp...\\n'\n     + \"\"\"                 # it's local time (i.e...)\n\"\"\" +\n    '                 # (section 9.10.3, http://......)\\n' +\n    \"\"\"                 date_parser=lambda x: pd.to_datetime(x, units='s'),\n\"\"\"\n     + '                 parse_dates=True)', 'Indentation made'), (\n    \"\"\"df = pd.read_csv(fpath,\n\"\"\" +\n    '                 # HINT indexing begins with 0\\n' +\n    \"\"\"                 header=0, # headers 1st row\n\"\"\" +\n    '                 index_col=0, #timestamps 1st column\\n' +\n    \"\"\"                 # specify as seconds to recognize as epoch timestamp...\n\"\"\"\n     + \"                 # it's local time (i.e...)\\n\" +\n    \"\"\"                 # (section 9.10.3, http://......)\n\"\"\" +\n    \"                 #date_parser=lambda x: pd.to_datetime(x, units='s'),\\n\" +\n    '            parse_dates=True)', \"\"\"df = pd.read_csv(fpath,\n\"\"\" +\n    '                 # HINT indexing begins with 0\\n' +\n    \"\"\"                 header=0, # headers 1st row\n\"\"\" +\n    '                 index_col=0, #timestamps 1st column\\n' +\n    \"\"\"                 # specify as seconds to recognize as epoch timestamp...\n\"\"\"\n     + \"                 # it's local time (i.e...)\\n\" +\n    \"\"\"                 # (section 9.10.3, http://......)\n\"\"\" +\n    \"                 #date_parser=lambda x: pd.to_datetime(x, units='s'),\\n\" +\n    '                 parse_dates=True)', 'Indentation made')]\nfor text_input, expected, comment in text_input_expected_comment:\n    text = get_indent_fix(text_input)\n    assert text == expected, comment\n",
        "CUT_1": "\"\"\"Load a pickle file as a dictionary\"\"\"\ntry:\n    if pd:\n        return pd.read_pickle(filename), None\n    else:\n        with open(filename, 'rb') as fid:\n            data = pickle.load(fid)\n        return data, None\nexcept Exception as err:\n    return None, str(err)\n",
        "CUT_2": "\"\"\"Return the value of the DataFrame.\"\"\"\ntry:\n    value = self.df.iat[row, column]\nexcept OutOfBoundsDatetime:\n    value = self.df.iloc[:, (column)].astype(str).iat[row]\nexcept:\n    value = self.df.iloc[row, column]\nreturn value\n",
        "CUT_3": "\"\"\"Return the value of the DataFrame.\"\"\"\ntry:\n    value = self.df.iat[row, column]\nexcept OutOfBoundsDatetime:\n    value = self.df.iloc[:, (column)].astype(str).iat[row]\nexcept:\n    value = self.df.iloc[row, column]\nreturn value\n",
        "CUT_4": "logger.debug('Headers: {0}'.format(headers))\nheaders = headers.split(b'\\r\\n')\nheader_dict = dict([x.split(b': ') for x in headers])\nreturn header_dict\n",
        "CUT_5": "logger.debug('Headers: {0}'.format(headers))\nheaders = headers.split(b'\\r\\n')\nheader_dict = dict([x.split(b': ') for x in headers])\nreturn header_dict\n"
    },
    {
        "functionName": "test_keywords",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [('def func():\\n', 'def func():\\n    ',\n    'function declaration'), ('def function(\\n',\n    \"\"\"def function(\n        \"\"\", 'partial function declaration'), (\n    'def f(\\n', 'def f(\\n        ',\n    'partial function declaration with short name'), (\n    \"\"\"def func(): return\n\"\"\", 'def func(): return\\n', 'single line return'\n    ), (\"\"\"def func():\n    if True:\n        return\n\"\"\",\n    \"\"\"def func():\n    if True:\n        return\n    \"\"\",\n    'return in if block'), (\"\"\"if True:\n    varname = multipass\n\"\"\",\n    \"\"\"if True:\n    varname = multipass\n    \"\"\",\n    'endswith pass, but not keyword'), (\"\"\"def func():\n    return()\n\"\"\",\n    \"\"\"def func():\n    return()\n\"\"\", 'no space between return and bracket'),\n    ('for i in range(\\n', 'for i in range(\\n        ', 'partial for')]\nfor text_input, expected, comment in text_input_expected_comment:\n    text = get_indent_fix(text_input)\n    assert text == expected, comment\n",
        "CUT_1": "\"\"\" \"\"\"\nfor func in funcs:\n    func()\n",
        "CUT_2": "\"\"\" \"\"\"\nfor func in funcs:\n    func()\n",
        "CUT_3": "\"\"\"Return function name\"\"\"\nif PY2:\n    return func.func_name\nelse:\n    return func.__name__\n",
        "CUT_4": "\"\"\"Return function name\"\"\"\nif PY2:\n    return func.func_name\nelse:\n    return func.__name__\n",
        "CUT_5": "\"\"\"Return function name\"\"\"\nif PY2:\n    return func.func_name\nelse:\n    return func.__name__\n"
    },
    {
        "functionName": "test_hanging_indentation_without_block",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [('function(\\n', 'function(\\n    ',\n    'function call'), ('f(\\n', 'f(\\n  ', 'function call with short name'),\n    (\"\"\"def f():\n    return \\\\\n\"\"\", \"\"\"def f():\n    return \\\\\n        \"\"\",\n    'line cont. return'), ('def f():\\n    return lambda: \\\\\\n',\n    \"\"\"def f():\n    return lambda: \\\\\n        \"\"\", 'return but indent')]\nfor text_input, expected, comment in text_input_expected_comment:\n    text = get_indent_fix(text_input)\n    assert text == expected, comment\n",
        "CUT_1": "\"\"\"Debug a single function call.\n\n        Return the result of the function call.\n        \"\"\"\nwith DebugWrapper(self):\n    super(SpyderPdb, self).runcall(*args, **kwds)\n",
        "CUT_2": "return self.__get_name('def', text)\n",
        "CUT_3": "return self.__get_name('def', text)\n",
        "CUT_4": "\"\"\"This function docstring.\"\"\"\nreturn True\n",
        "CUT_5": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n"
    },
    {
        "functionName": "test_no_hanging_indentation",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [(\"f('(')\\n\", \"f('(')\\n\",\n    'open bracket in string'), (\"f('def f(')\", \"f('def f(')\",\n    'keyword in string'), (\"'a(a,'\\n\", \"'a(a,'\\n\", 'bracket in string'), (\n    \"\"\"def f():\n    return()\n\"\"\", \"\"\"def f():\n    return()\n\"\"\",\n    'return without space after'), (\"print('#1 w(Earth) =', w)\\n\",\n    \"print('#1 w(Earth) =', w)\\n\", '# in string')]\nfor text_input, expected, comment in text_input_expected_comment:\n    text = get_indent_fix(text_input)\n    assert text == expected, comment\n",
        "CUT_1": "return str(string)\n",
        "CUT_2": "return str(string)\n",
        "CUT_3": "\"\"\"Return comment string\"\"\"\nreturn to_text_string(self.comments_edt.text())\n",
        "CUT_4": "\"\"\"Return comment string\"\"\"\nreturn to_text_string(self.comments_edt.text())\n",
        "CUT_5": "\"\"\"\n    Return a unicode version of string decoded using the file system encoding.\n    \"\"\"\nif not is_string(string):\n    string = to_text_string(string.toUtf8(), 'utf-8')\nelif is_binary_string(string):\n    try:\n        unic = string.decode(FS_ENCODING)\n    except (UnicodeError, TypeError):\n        pass\n    else:\n        return unic\nreturn string\n"
    },
    {
        "functionName": "test_unintent_in_block",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = get_indent_fix(\"\"\"def f(x):\n    if True:\n        return\n\"\"\")\nassert text == \"\"\"def f(x):\n    if True:\n        return\n    \"\"\", repr(text)\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_4": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_5": "return self.__get_name('def', text)\n"
    },
    {
        "functionName": "test_multi_line_lists",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [(\"\"\"[\n    (\"\",\n     \"\",\n     \"\")\n\"\"\",\n    \"\"\"[\n    (\"\",\n     \"\",\n     \"\")\n    \"\"\", 'multiline args'), (\n    \"\"\"[\n    (\"\",\n     \"\",\n     \"\"),\n\"\"\",\n    \"\"\"[\n    (\"\",\n     \"\",\n     \"\"),\n    \"\"\", 'multiline args with comma')]\nfor text_input, expected, comment in text_input_expected_comment:\n    text = get_indent_fix(text_input)\n    assert text == expected, comment\n",
        "CUT_1": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\nraise NotImplementedError\n",
        "CUT_2": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\nraise NotImplementedError\n",
        "CUT_3": "\"\"\"Return comment string\"\"\"\nreturn to_text_string(self.comments_edt.text())\n",
        "CUT_4": "\"\"\"Return comment string\"\"\"\nreturn to_text_string(self.comments_edt.text())\n",
        "CUT_5": "\"\"\"Implement highlight specific for Fortran77.\"\"\"\ntext = to_text_string(text)\nif text.startswith(('c', 'C')):\n    self.setFormat(0, qstring_length(text), self.formats['comment'])\n    self.highlight_extras(text)\nelse:\n    FortranSH.highlight_block(self, text)\n    self.setFormat(0, 5, self.formats['comment'])\n    self.setFormat(73, max([73, qstring_length(text)]), self.formats['comment']\n        )\n"
    },
    {
        "functionName": "test_string_literals",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [(\"'''\\n\", \"'''\\n\",\n    'bare opening triple-quote'), (\"\"\"def f():\n    '''\n\"\"\",\n    \"\"\"def f():\n    '''\n    \"\"\",\n    'opening triple-quote in function declaration'), (\"'''Docstring'''\\n\",\n    \"'''Docstring'''\\n\", 'triple-quoted string literal'), ('', '', ''), ('',\n    '', '')]\nfor text_input, expected, comment in text_input_expected_comment:\n    text = get_indent_fix(text_input)\n    assert text == expected, comment\n",
        "CUT_1": "\"\"\"Return True if there are only triple quotes in text.\"\"\"\ndocstring_triggers = ['\"\"\"', 'r\"\"\"', \"'''\", \"r'''\"]\nif text.lstrip() in docstring_triggers:\n    return True\nreturn False\nstaticmethod",
        "CUT_2": "\"\"\"Return True if there are only triple quotes in text.\"\"\"\ndocstring_triggers = ['\"\"\"', 'r\"\"\"', \"'''\", \"r'''\"]\nif text.lstrip() in docstring_triggers:\n    return True\nreturn False\nstaticmethod",
        "CUT_3": "\"\"\"This function docstring.\"\"\"\nreturn True\n",
        "CUT_4": "\"\"\"Return comment string\"\"\"\nreturn to_text_string(self.comments_edt.text())\n",
        "CUT_5": "\"\"\"Return comment string\"\"\"\nreturn to_text_string(self.comments_edt.text())\n"
    },
    {
        "functionName": "test_indentation_with_tabs",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [('this_tuple = (1, 2)\\n',\n    'this_tuple = (1, 2)\\n', 'simple tuple'), (\"\"\"\ndef function():\n\"\"\",\n    \"\"\"\ndef function():\n\t\"\"\", 'def with new line'), (\n    \"\"\"def function():\n\t# Comment\n\"\"\", \"\"\"def function():\n\t# Comment\n\t\"\"\",\n    'test with indented comment'), (\"\"\"def function():\n\tprint []\n\"\"\",\n    \"\"\"def function():\n\tprint []\n\t\"\"\", 'test brackets alone'), (\n    '\\nsome_long_name = {\\n', '\\nsome_long_name = {\\n\\t',\n    'indentation after opening bracket'), ('def function():\\n',\n    \"\"\"def function():\n\t\"\"\", 'test simple def'), ('open_parenthesis(\\n',\n    'open_parenthesis(\\n\\t', 'open parenthesis'), (\n    \"\"\"tags = ['(a)', '(b)', '(c)']\n\"\"\", \"tags = ['(a)', '(b)', '(c)']\\n\",\n    'test_commented_brackets'), (\n    \"\"\"s = a[(a['a'] == l) & (a['a'] == 1)]['a']\n\"\"\",\n    \"s = a[(a['a'] == l) & (a['a'] == 1)]['a']\\n\", 'test_balanced_brackets'\n    ), (\"\"\"def some_func():\n\treturn 10\n\"\"\",\n    \"\"\"def some_func():\n\treturn 10\n\"\"\", 'test_return'), (\n    \"\"\"def some_func():\n\treturns = 10\n\"\"\",\n    \"\"\"def some_func():\n\treturns = 10\n\t\"\"\", 'test_return_not_keyword'), (\n    'def function():\\n# Comment\\n', 'def function():\\n# Comment\\n',\n    'test_def_with_unindented_comment')]\nfor text_input, expected, comment in text_input_expected_comment:\n    for tab_stop_width_spaces in [1, 2, 3, 4, 5, 6, 7, 8]:\n        text = get_indent_fix(text_input, indent_chars='\\t',\n            tab_stop_width_spaces=tab_stop_width_spaces)\n        assert text == expected, comment\n",
        "CUT_1": "return self.__get_name('def', text)\n",
        "CUT_2": "return self.__get_name('def', text)\n",
        "CUT_3": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_4": "\"\"\"Return True if text is the beginning of the function definition.\"\"\"\nif isinstance(text, str) or isinstance(text, unicode):\n    function_prefix = ['def', 'async def']\n    text = text.lstrip()\n    for prefix in function_prefix:\n        if text.startswith(prefix):\n            return True\nreturn False\n",
        "CUT_5": "\"\"\"This function docstring.\"\"\"\nreturn True\n"
    },
    {
        "functionName": "test_indentation_with_tabs_parenthesis",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Simple parenthesis indentation test with different tab stop widths.\"\"\"\ntext_input_expected_tab = [('print(\\n)', 'print(\\n\\t)', 1), ('print(\\n)',\n    'print(\\n\\t)', 2), ('print(\\n)', 'print(\\n\\t\\t)', 3), ('print(\\n)',\n    'print(\\n\\t  )', 4), ('print(\\n)', 'print(\\n\\t )', 5), ('print(\\n)',\n    'print(\\n\\t)', 6), ('print(\\n)', 'print(\\n      )', 7), ('print(\\n)',\n    'print(\\n      )', 8), (\"\"\"a = (a  #  some comment\n\"\"\",\n    'a = (a  #  some comment\\n\\t ', 4)]\nfor text_input, expected, tab_stop_width_spaces in text_input_expected_tab:\n    text = get_indent_fix(text_input, indent_chars='\\t',\n        tab_stop_width_spaces=tab_stop_width_spaces)\n    assert text == expected, tab_stop_width_spaces\n",
        "CUT_1": "for i in range(3):\n    print(i)\n",
        "CUT_2": "for i in range(3):\n    print(i)\n",
        "CUT_3": "for i in range(3):\n    print(i)\n",
        "CUT_4": "for i in range(3):\n    print(i)\n",
        "CUT_5": "for i in range(3):\n    print(i)\n"
    },
    {
        "functionName": "test_unindentation_with_tabs",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input = '\\tx = 1'\nexpected_text = 'x = 1'\nfor tab_stop_width_spaces in [1, 2, 3, 4, 5, 6, 7, 8]:\n    text = get_indent_fix(text_input, indent_chars='\\t',\n        tab_stop_width_spaces=tab_stop_width_spaces, forward=False)\n    assert text == expected_text\n",
        "CUT_1": "self.tab_stop_width_spaces = tab_stop_width_spaces\nself.update_tab_stop_width_spaces()\n",
        "CUT_2": "self.tab_stop_width_spaces = tab_stop_width_spaces\nself.update_tab_stop_width_spaces()\n",
        "CUT_3": "self.tab_stop_width_spaces = tab_stop_width_spaces\nif self.data:\n    for finfo in self.data:\n        finfo.editor.tab_stop_width_spaces = tab_stop_width_spaces\n        finfo.editor.update_tab_stop_width_spaces()\n",
        "CUT_4": "self.tab_stop_width_spaces = tab_stop_width_spaces\nif self.data:\n    for finfo in self.data:\n        finfo.editor.tab_stop_width_spaces = tab_stop_width_spaces\n        finfo.editor.update_tab_stop_width_spaces()\n",
        "CUT_5": "self.setTabStopWidth(self.fontMetrics().width(' ' * self.tab_stop_width_spaces)\n    )\n"
    },
    {
        "functionName": "test_simple_indentation",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autoindent.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text_input_expected_comment = [('hola\\n', 'hola\\n', 'witout indentation'),\n    ('  hola\\n', '  hola\\n  ', 'some indentation'), ('\\thola\\n',\n    '\\thola\\n\\t', 'tab indentation'), ('  hola(\\n', '  hola(\\n  ',\n    'line with parenthesis')]\nfor text_input, text_expected, comment in text_input_expected_comment:\n    text = get_indent_fix(text_input, language=None)\n    assert text == text_expected, comment\n",
        "CUT_1": "\"\"\"\n        Simply preserve the indentation-level of the previous line.\n        \"\"\"\ncursor = self.textCursor()\nblock_nb = cursor.blockNumber()\nprev_block = self.document().findBlockByNumber(block_nb - 1)\nprevline = to_text_string(prev_block.text())\nindentation = re.match('\\\\s*', prevline).group()\nif not forward:\n    indentation = indentation[len(self.indent_chars):]\ncursor.insertText(indentation)\nreturn False\n",
        "CUT_2": "\"\"\"\n        Simply preserve the indentation-level of the previous line.\n        \"\"\"\ncursor = self.textCursor()\nblock_nb = cursor.blockNumber()\nprev_block = self.document().findBlockByNumber(block_nb - 1)\nprevline = to_text_string(prev_block.text())\nindentation = re.match('\\\\s*', prevline).group()\nif not forward:\n    indentation = indentation[len(self.indent_chars):]\ncursor.insertText(indentation)\nreturn False\n",
        "CUT_3": "\"\"\"Return line indentation (character number).\"\"\"\ntext = to_text_string(self.document().findBlockByNumber(block_nb).text())\ntext = text.replace('\\t', ' ' * self.tab_stop_width_spaces)\nreturn len(text) - len(text.lstrip())\n",
        "CUT_4": "\"\"\"Return line indentation (character number).\"\"\"\ntext = to_text_string(self.document().findBlockByNumber(block_nb).text())\ntext = text.replace('\\t', ' ' * self.tab_stop_width_spaces)\nreturn len(text) - len(text.lstrip())\n",
        "CUT_5": "\"\"\"\n        Returns the indent level of the specified line.\n\n        :param line_nbr: Number of the line to get indentation (1 base).\n            Pass None to use the current line number. Note that you can also\n            pass a QTextBlock instance instead of an int.\n        :return: Number of spaces that makes the indentation level of the\n                 current line\n        \"\"\"\nif line_nbr is None:\n    line_nbr = self.current_line_nbr()\nelif isinstance(line_nbr, QTextBlock):\n    line_nbr = line_nbr.blockNumber()\nline = self.line_text(line_nbr)\nindentation = len(line) - len(line.lstrip())\nreturn indentation\n"
    },
    {
        "functionName": "reset_emits",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_breakpoints.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Reset signal mocks.\"\"\"\nif version_info > (4,):\n    editor.sig_flags_changed.reset_mock()\neditor.sig_breakpoints_changed.reset_mock()\n",
        "CUT_1": "\"\"\"Clear breakpoints\"\"\"\nself.breakpoints = []\nfor data in self.editor.blockuserdata_list():\n    data.breakpoint = False\nself.editor.sig_breakpoints_changed.emit()\nself.editor.sig_flags_changed.emit()\n",
        "CUT_2": "\"\"\"Clear breakpoints\"\"\"\nself.breakpoints = []\nfor data in self.editor.blockuserdata_list():\n    data.breakpoint = False\nself.editor.sig_breakpoints_changed.emit()\nself.editor.sig_flags_changed.emit()\n",
        "CUT_3": "\"\"\"Update breakpoints\"\"\"\nself.editor.sig_breakpoints_changed.emit()\n",
        "CUT_4": "\"\"\"Update breakpoints\"\"\"\nself.editor.sig_breakpoints_changed.emit()\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "editor_assert_helper",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_breakpoints.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run the tests for call to add_remove_breakpoint.\n\n    Args:\n        editor: CodeEditor instance.\n        block: Block of text.\n        bp: Is breakpoint active?\n        bpc: Condition set for breakpoint.\n        emits: Boolean to test if signals were emitted?\n    \"\"\"\ndata = block.userData()\nassert data.breakpoint == bp\nassert data.breakpoint_condition == bpc\nif emits:\n    if version_info > (4,):\n        editor.sig_flags_changed.emit.assert_called_with()\n    editor.sig_breakpoints_changed.emit.assert_called_with()\nelse:\n    if version_info > (4,):\n        editor.sig_flags_changed.emit.assert_not_called()\n    editor.sig_breakpoints_changed.emit.assert_not_called()\n",
        "CUT_1": "\"\"\"Add/remove breakpoint.\"\"\"\nif not self.editor.is_python_like():\n    return\nif line_number is None:\n    block = self.editor.textCursor().block()\nelse:\n    block = self.editor.document().findBlockByNumber(line_number - 1)\ndata = block.userData()\nif not data:\n    data = BlockUserData(self.editor)\n    data.breakpoint = True\nelif not edit_condition:\n    data.breakpoint = not data.breakpoint\n    data.breakpoint_condition = None\nif condition is not None:\n    data.breakpoint_condition = condition\nif edit_condition:\n    condition = data.breakpoint_condition\n    condition, valid = QInputDialog.getText(self.editor, _('Breakpoint'), _\n        ('Condition:'), QLineEdit.Normal, condition)\n    if not valid:\n        return\n    data.breakpoint = True\n    data.breakpoint_condition = str(condition) if condition else None\nif data.breakpoint:\n    text = to_text_string(block.text()).strip()\n    if len(text) == 0 or text.startswith(('#', '\"', \"'\")):\n        data.breakpoint = False\nblock.setUserData(data)\nself.editor.sig_flags_changed.emit()\nself.editor.sig_breakpoints_changed.emit()\n",
        "CUT_2": "\"\"\"Add/remove breakpoint.\"\"\"\nif not self.editor.is_python_like():\n    return\nif line_number is None:\n    block = self.editor.textCursor().block()\nelse:\n    block = self.editor.document().findBlockByNumber(line_number - 1)\ndata = block.userData()\nif not data:\n    data = BlockUserData(self.editor)\n    data.breakpoint = True\nelif not edit_condition:\n    data.breakpoint = not data.breakpoint\n    data.breakpoint_condition = None\nif condition is not None:\n    data.breakpoint_condition = condition\nif edit_condition:\n    condition = data.breakpoint_condition\n    condition, valid = QInputDialog.getText(self.editor, _('Breakpoint'), _\n        ('Condition:'), QLineEdit.Normal, condition)\n    if not valid:\n        return\n    data.breakpoint = True\n    data.breakpoint_condition = str(condition) if condition else None\nif data.breakpoint:\n    text = to_text_string(block.text()).strip()\n    if len(text) == 0 or text.startswith(('#', '\"', \"'\")):\n        data.breakpoint = False\nblock.setUserData(data)\nself.editor.sig_flags_changed.emit()\nself.editor.sig_breakpoints_changed.emit()\n",
        "CUT_3": "\"\"\"Clear breakpoints\"\"\"\nself.breakpoints = []\nfor data in self.editor.blockuserdata_list():\n    data.breakpoint = False\nself.editor.sig_breakpoints_changed.emit()\nself.editor.sig_flags_changed.emit()\n",
        "CUT_4": "\"\"\"Clear breakpoints\"\"\"\nself.breakpoints = []\nfor data in self.editor.blockuserdata_list():\n    data.breakpoint = False\nself.editor.sig_breakpoints_changed.emit()\nself.editor.sig_flags_changed.emit()\n",
        "CUT_5": "\"\"\"Update breakpoints\"\"\"\nself.editor.sig_breakpoints_changed.emit()\n"
    },
    {
        "functionName": "code_editor_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_breakpoints.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create code editor with default Python code.\"\"\"\neditor = codeeditor.CodeEditor(parent=None)\nindent_chars = ' ' * 4\ntab_stop_width_spaces = 4\neditor.setup_editor(language='Python', indent_chars=indent_chars,\n    tab_stop_width_spaces=tab_stop_width_spaces)\nif version_info > (4,):\n    editor.sig_flags_changed = Mock()\nelse:\n    editor.get_linenumberarea_width = Mock(return_value=1)\neditor.sig_breakpoints_changed = Mock()\ntext = \"\"\"def f1(a, b):\n\"Double quote string.\"\n\n    c = a * b\n    return c\n\"\"\"\neditor.set_text(text)\nreturn editor, qtbot\npytest.fixture",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_4": "return Mock()\n",
        "CUT_5": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture"
    },
    {
        "functionName": "test_add_remove_breakpoint",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_breakpoints.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test CodeEditor.add_remove_breakpoint().\"\"\"\neditor, qtbot = code_editor_bot\narb = editor.debugger.toogle_breakpoint\nmocker.patch.object(debugger.QInputDialog, 'getText')\neditor.go_to_line(1)\nblock = editor.textCursor().block()\neditor.set_language(None)\nreset_emits(editor)\narb()\nassert block\nif version_info > (4,):\n    editor.sig_flags_changed.emit.assert_not_called()\neditor.sig_breakpoints_changed.emit.assert_not_called()\neditor.set_language('Python')\nreset_emits(editor)\narb()\neditor_assert_helper(editor, block, bp=True, bpc=None, emits=True)\nreset_emits(editor)\narb()\neditor_assert_helper(editor, block, bp=False, bpc=None, emits=True)\nreset_emits(editor)\neditor.go_to_line(3)\nblock = editor.textCursor().block()\narb()\neditor_assert_helper(editor, block, bp=False, bpc=None, emits=True)\nreset_emits(editor)\nblock = editor.document().findBlockByNumber(3)\narb(line_number=4, condition='a > 50')\neditor_assert_helper(editor, block, bp=True, bpc='a > 50', emits=True)\nreset_emits(editor)\ndebugger.QInputDialog.getText.return_value = 'a == 42', False\narb(line_number=4, edit_condition=True)\neditor_assert_helper(editor, block, bp=True, bpc='a > 50', emits=False)\ndebugger.QInputDialog.getText.return_value = 'a == 42', True\nreset_emits(editor)\narb(line_number=4, edit_condition=True)\neditor_assert_helper(editor, block, bp=True, bpc='a == 42', emits=True)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Block comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.blockcomment()\nSlot()",
        "CUT_4": "\"\"\"Block comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.blockcomment()\nSlot()",
        "CUT_5": "\"\"\"Toggle the current fold trigger.\"\"\"\nblock = self.editor.textCursor().block()\nblock = self.find_parent_scope(block)\nself.toggle_fold_trigger(block)\n"
    },
    {
        "functionName": "test_add_remove_breakpoint_with_edit_condition",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_breakpoints.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test add/remove breakpoint with edit_condition.\"\"\"\neditor, qtbot = code_editor_bot\narb = editor.debugger.toogle_breakpoint\nmocker.patch.object(debugger.QInputDialog, 'getText')\nlinenumber = 5\nblock = editor.document().findBlockByNumber(linenumber - 1)\nreset_emits(editor)\ndebugger.QInputDialog.getText.return_value = 'b == 1', False\narb(line_number=linenumber, edit_condition=True)\ndata = block.userData()\nassert not data\nif version_info > (4,):\n    editor.sig_flags_changed.emit.assert_not_called()\neditor.sig_breakpoints_changed.emit.assert_not_called()\nreset_emits(editor)\ndebugger.QInputDialog.getText.return_value = 'b == 1', True\narb(line_number=linenumber, edit_condition=True)\neditor_assert_helper(editor, block, bp=True, bpc='b == 1', emits=True)\nreset_emits(editor)\ndebugger.QInputDialog.getText.return_value = 'b == 9', False\narb(line_number=linenumber, edit_condition=True)\neditor_assert_helper(editor, block, bp=True, bpc='b == 1', emits=False)\nreset_emits(editor)\narb(line_number=linenumber)\neditor_assert_helper(editor, block, bp=False, bpc=None, emits=True)\nreset_emits(editor)\ndebugger.QInputDialog.getText.return_value = 'b == 9', False\narb(line_number=linenumber, edit_condition=True)\neditor_assert_helper(editor, block, bp=False, bpc=None, emits=False)\n",
        "CUT_1": "\"\"\"Set conditional breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint(edit_condition=True)\n",
        "CUT_2": "\"\"\"Set conditional breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint(edit_condition=True)\n",
        "CUT_3": "\"\"\"Override Qt method\n\n        Add/remove breakpoints by single click.\n        \"\"\"\nline_number = self.editor.get_linenumber_from_mouse_event(event)\nshift = event.modifiers() & Qt.ShiftModifier\nself.editor.debugger.toogle_breakpoint(line_number, edit_condition=shift)\n",
        "CUT_4": "\"\"\"Override Qt method\n\n        Add/remove breakpoints by single click.\n        \"\"\"\nline_number = self.editor.get_linenumber_from_mouse_event(event)\nshift = event.modifiers() & Qt.ShiftModifier\nself.editor.debugger.toogle_breakpoint(line_number, edit_condition=shift)\n",
        "CUT_5": "\"\"\"Set/clear breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint()\n"
    },
    {
        "functionName": "test_get_breakpoints",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_breakpoints.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test CodeEditor.get_breakpoints.\"\"\"\neditor, qtbot = code_editor_bot\narb = editor.debugger.toogle_breakpoint\ngb = editor.debugger.get_breakpoints\nassert gb() == []\nbp = [(1, None), (3, None), (4, 'a > 1'), (5, 'c == 10')]\neditor.debugger.set_breakpoints(bp)\nassert gb() == [(1, None), (4, 'a > 1'), (5, 'c == 10')]\narb(line_number=1, condition='a < b')\narb(line_number=4)\nassert gb() == [(5, 'c == 10')]\n",
        "CUT_1": "\"\"\"Set/clear breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint()\n",
        "CUT_2": "\"\"\"Set/clear breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint()\n",
        "CUT_3": "\"\"\"Get a debugger for a given filename.\"\"\"\ndebugger = pdb.Pdb()\nfilename = debugger.canonic(filename)\ndebugger._wait_for_mainpyfile = 1\ndebugger.mainpyfile = filename\ndebugger._user_requested_quit = 0\nif os.name == 'nt':\n    filename = filename.replace('\\\\', '/')\nreturn debugger, filename\n",
        "CUT_4": "\"\"\"Set breakpoints\"\"\"\nself.clear_breakpoints()\nfor line_number, condition in breakpoints:\n    self.toogle_breakpoint(line_number, condition)\nself.breakpoints = self.get_breakpoints()\n",
        "CUT_5": "\"\"\"Set breakpoints\"\"\"\nself.clear_breakpoints()\nfor line_number, condition in breakpoints:\n    self.toogle_breakpoint(line_number, condition)\nself.breakpoints = self.get_breakpoints()\n"
    },
    {
        "functionName": "test_clear_breakpoints",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_breakpoints.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test CodeEditor.clear_breakpoints.\"\"\"\neditor, qtbot = code_editor_bot\nassert len(list(editor.blockuserdata_list())) == 1\nbp = [(1, None), (4, None)]\neditor.debugger.set_breakpoints(bp)\nassert editor.debugger.get_breakpoints() == bp\nassert len(list(editor.blockuserdata_list())) == 2\neditor.debugger.clear_breakpoints()\nassert editor.debugger.get_breakpoints() == []\nassert len(list(editor.blockuserdata_list())) == 2\nfor data in editor.blockuserdata_list():\n    assert not data.breakpoint\n",
        "CUT_1": "\"\"\"Set/clear breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint()\n",
        "CUT_2": "\"\"\"Set/clear breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint()\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Clear breakpoints\"\"\"\nself.breakpoints = []\nfor data in self.editor.blockuserdata_list():\n    data.breakpoint = False\nself.editor.sig_breakpoints_changed.emit()\nself.editor.sig_flags_changed.emit()\n"
    },
    {
        "functionName": "test_set_breakpoints",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_breakpoints.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test CodeEditor.set_breakpoints.\"\"\"\neditor, qtbot = code_editor_bot\neditor.debugger.set_breakpoints([])\nassert editor.debugger.get_breakpoints() == []\nbp = [(1, 'a > b'), (4, None)]\neditor.debugger.set_breakpoints(bp)\nassert editor.debugger.get_breakpoints() == bp\nassert list(editor.blockuserdata_list())[0].breakpoint\nbp = [(1, None), (5, 'c == 50')]\neditor.debugger.set_breakpoints(bp)\nassert editor.debugger.get_breakpoints() == bp\nassert list(editor.blockuserdata_list())[0].breakpoint\n",
        "CUT_1": "\"\"\"Set/clear breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint()\n",
        "CUT_2": "\"\"\"Set/clear breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint()\n",
        "CUT_3": "\"\"\"Get a debugger for a given filename.\"\"\"\ndebugger = pdb.Pdb()\nfilename = debugger.canonic(filename)\ndebugger._wait_for_mainpyfile = 1\ndebugger.mainpyfile = filename\ndebugger._user_requested_quit = 0\nif os.name == 'nt':\n    filename = filename.replace('\\\\', '/')\nreturn debugger, filename\n",
        "CUT_4": "\"\"\"Set conditional breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint(edit_condition=True)\n",
        "CUT_5": "\"\"\"Set conditional breakpoint\"\"\"\nif self.data:\n    editor = self.get_current_editor()\n    editor.debugger.toogle_breakpoint(edit_condition=True)\n"
    },
    {
        "functionName": "test_update_breakpoints",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_breakpoints.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test CodeEditor.update_breakpoints.\"\"\"\neditor, qtbot = code_editor_bot\nreset_emits(editor)\neditor.sig_breakpoints_changed.emit.assert_not_called()\neditor.textCursor().insertBlock()\neditor.sig_breakpoints_changed.emit.assert_called_with()\n",
        "CUT_1": "\"\"\"Update breakpoints\"\"\"\nself.editor.sig_breakpoints_changed.emit()\n",
        "CUT_2": "\"\"\"Update breakpoints\"\"\"\nself.editor.sig_breakpoints_changed.emit()\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Clear breakpoints\"\"\"\nself.breakpoints = []\nfor data in self.editor.blockuserdata_list():\n    data.breakpoint = False\nself.editor.sig_breakpoints_changed.emit()\nself.editor.sig_flags_changed.emit()\n"
    },
    {
        "functionName": "get_formatter_values",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_formatting.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "suffix = 'range' if range_fmt else 'result'\noriginal_file = osp.join(ASSETS, 'original_file.py')\nformatted_file = osp.join(ASSETS, '{0}_{1}.py'.format(formatter, suffix))\nwith open(original_file, 'r') as f:\n    text = f.read()\nwith open(formatted_file, 'r') as f:\n    result = f.read()\nreturn text, result\n",
        "CUT_1": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_2": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_3": "\"\"\"\n            Produce HTML for a class tree as given by inspect.getclasstree().\n            \"\"\"\nresult = ''\nfor entry in tree:\n    if type(entry) is type(()):\n        c, bases = entry\n        result = result + '<dt>'\n        result = result + self.classlink(c, modname)\n        if bases and bases != (parent,):\n            parents = []\n            for base in bases:\n                parents.append(self.classlink(base, modname))\n            result = result + '(' + ', '.join(parents) + ')'\n        result = result + '\\n</dt>'\n    elif type(entry) is type([]):\n        result = result + '<dd>\\n%s</dd>\\n' % self.formattree(entry, modname, c\n            )\nreturn \"\"\"<dl><dt></dt>\n%s<dd></dd></dl>\n\"\"\" % result\n",
        "CUT_4": "\"\"\"\n            Produce HTML for a class tree as given by inspect.getclasstree().\n            \"\"\"\nresult = ''\nfor entry in tree:\n    if type(entry) is type(()):\n        c, bases = entry\n        result = result + '<dt>'\n        result = result + self.classlink(c, modname)\n        if bases and bases != (parent,):\n            parents = []\n            for base in bases:\n                parents.append(self.classlink(base, modname))\n            result = result + '(' + ', '.join(parents) + ')'\n        result = result + '\\n</dt>'\n    elif type(entry) is type([]):\n        result = result + '<dd>\\n%s</dd>\\n' % self.formattree(entry, modname, c\n            )\nreturn \"\"\"<dl><dt></dt>\n%s<dd></dd></dl>\n\"\"\" % result\n",
        "CUT_5": "\"\"\"Format a list of items into a multi-column list.\"\"\"\nresult = ''\nrows = (len(list) + cols - 1) // cols\nfor col in range(cols):\n    result = result + '<td style=\"width:%d%%;vertical-align:text-top\">' % (\n        100 // cols)\n    for i in range(rows * col, rows * col + rows):\n        if i < len(list):\n            result = result + format(list[i]) + '<br>\\n'\n    result = result + '</td>'\nreturn '<table style=\"width:100%%\"><tr>%s</tr></table>' % result\n"
    },
    {
        "functionName": "test_document_formatting",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_formatting.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Validate text autoformatting via autopep8, yapf or black.\"\"\"\ncode_editor, manager = lsp_codeeditor\ntext, expected = get_formatter_values(formatter)\nCONF.set('lsp-server', 'formatting', formatter)\nqtbot.wait(2000)\nmanager.update_configuration()\ncode_editor.set_text(text)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.format_document()\nqtbot.wait(2000)\nassert code_editor.toPlainText() == expected\npytest.mark.slowpytest.mark.firstpytest.mark.parametrize('formatter', ['autopep8', 'yapf', 'black'])",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "super().__init__(code_editor)\nself._editor = code_editor\nself._left_padding = 6\nself._right_padding = 3\n"
    },
    {
        "functionName": "test_document_range_formatting",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_formatting.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Validate text range autoformatting.\"\"\"\ncode_editor, manager = lsp_codeeditor\ntext, expected = get_formatter_values(formatter, range_fmt=True)\nCONF.set('lsp-server', 'formatting', formatter)\nqtbot.wait(2000)\nmanager.update_configuration()\ncode_editor.set_text(text)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\ncode_editor.go_to_line(12)\ncursor = code_editor.textCursor()\nstart = code_editor.get_position_line_number(11, -1)\nend = code_editor.get_position_line_number(27, 0)\ncursor.setPosition(start)\ncursor.setPosition(end, QTextCursor.KeepAnchor)\ncursor.movePosition(QTextCursor.EndOfBlock, QTextCursor.KeepAnchor)\ncode_editor.setTextCursor(cursor)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.format_document_range()\nqtbot.wait(2000)\nassert code_editor.toPlainText() == expected\npytest.mark.slowpytest.mark.firstpytest.mark.parametrize('formatter', ['autopep8', 'yapf', 'black'])",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_folding",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_folding.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "code_editor, _ = lsp_codeeditor\ncode_editor.toggle_code_folding(True)\ncode_editor.insert_text(text)\nfolding_panel = code_editor.panels.get('FoldingPanel')\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nwhile folding_panel.folding_regions == {}:\n    with qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n        code_editor.request_folding()\nfolding_regions = folding_panel.folding_regions\nfolding_levels = folding_panel.folding_levels\nexpected_regions = {(2): 6, (3): 4, (8): 36, (22): 23, (24): 26, (27): 28,\n    (30): 31, (32): 33, (34): 35}\nexpected_levels = {(2): 0, (3): 1, (8): 0, (22): 1, (24): 1, (27): 1, (30):\n    1, (32): 1, (34): 1}\nassert folding_regions == expected_regions\nassert expected_levels == folding_levels\ncode_editor.toggle_code_folding(False)\npytest.mark.slowpytest.mark.second",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_unfold_when_searching",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_folding.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "editor, finder = search_codeeditor\neditor.toggle_code_folding(True)\nfolding_panel = editor.panels.get('FoldingPanel')\neditor.insert_text(text)\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_change()\nwhile folding_panel.folding_regions == {}:\n    with qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n        editor.request_folding()\nline_search = editor.document().findBlockByLineNumber(3)\nblock = editor.document().findBlockByLineNumber(2)\nfolding_panel.toggle_fold_trigger(block)\nassert not line_search.isVisible()\nfinder.show()\nqtbot.keyClicks(finder.search_text, 'print')\nqtbot.keyPress(finder.search_text, Qt.Key_Return)\nassert line_search.isVisible()\neditor.toggle_code_folding(False)\npytest.mark.slowpytest.mark.secondpytest.mark.skipif(os.name == 'nt', reason='Hangs on Windows')",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"CodeEditor instance with LSP services activated.\"\"\"\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.sig_perform_completion_request.connect(lsp_plugin.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\nlsp_plugin.register_file('python', 'test.py', editor)\ncapabilities = lsp_plugin.main.editor.completion_capabilities['python']\neditor.start_completion_services()\neditor.register_completion_capabilities(capabilities)\nwith qtbot_module.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_open()\ndef teardown():\n    editor.completion_widget.hide()\n    editor.tooltip_widget.hide()\n    editor.hide()\n    sys_stream = capsys.readouterr()\n    sys_err = sys_stream.err\n    if PY2:\n        sys_err = to_text_string(sys_err).encode('utf-8')\n    assert sys_err == ''\nrequest.addfinalizer(teardown)\nlsp_plugin = lsp_plugin.get_client('lsp')\neditor.show()\nreturn editor, lsp_plugin\npytest.fixture",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_unfold_goto",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_folding.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "editor, finder = search_codeeditor\neditor.toggle_code_folding(True)\neditor.insert_text(text)\nfolding_panel = editor.panels.get('FoldingPanel')\nwith qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_change()\nwhile folding_panel.folding_regions == {}:\n    with qtbot.waitSignal(editor.lsp_response_signal, timeout=30000):\n        editor.request_folding()\nline_goto = editor.document().findBlockByLineNumber(5)\nblock = editor.document().findBlockByLineNumber(2)\nfolding_panel.toggle_fold_trigger(block)\nassert not line_goto.isVisible()\neditor.go_to_line(6)\nassert line_goto.isVisible()\neditor.toggle_code_folding(False)\npytest.mark.slowpytest.mark.secondpytest.mark.skipif(os.name == 'nt', reason='Hangs on Windows')",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"CodeEditor instance with LSP services activated.\"\"\"\neditor = codeeditor_factory()\nqtbot_module.addWidget(editor)\neditor.sig_perform_completion_request.connect(lsp_plugin.send_request)\neditor.filename = 'test.py'\neditor.language = 'Python'\nlsp_plugin.register_file('python', 'test.py', editor)\ncapabilities = lsp_plugin.main.editor.completion_capabilities['python']\neditor.start_completion_services()\neditor.register_completion_capabilities(capabilities)\nwith qtbot_module.waitSignal(editor.lsp_response_signal, timeout=30000):\n    editor.document_did_open()\ndef teardown():\n    editor.completion_widget.hide()\n    editor.tooltip_widget.hide()\n    editor.hide()\n    sys_stream = capsys.readouterr()\n    sys_err = sys_stream.err\n    if PY2:\n        sys_err = to_text_string(sys_err).encode('utf-8')\n    assert sys_err == ''\nrequest.addfinalizer(teardown)\nlsp_plugin = lsp_plugin.get_client('lsp')\neditor.show()\nreturn editor, lsp_plugin\npytest.fixture",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "toggle_comment",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_comments.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Toggle comment and return code.\"\"\"\neditor.go_to_line(start_line)\nif single_line:\n    editor.toggle_comment()\nelse:\n    editor.moveCursor(QTextCursor.End, mode=QTextCursor.KeepAnchor)\n    editor.toggle_comment()\ntext = editor.toPlainText()\nreturn to_text_string(text)\n",
        "CUT_1": "\"\"\"Comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.toggle_comment()\nSlot()",
        "CUT_2": "\"\"\"Comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.toggle_comment()\nSlot()",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Return associated editor source code\"\"\"\nreturn to_text_string(self.editor.toPlainText())\n"
    },
    {
        "functionName": "code_editor_bot",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_comments.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Setup CodeEditor with some text useful for folding related tests.\n    \"\"\"\neditor = CodeEditor(parent=None)\nindent_chars = ' ' * 4\ntab_stop_width_spaces = 4\nlanguage = 'Python'\neditor.setup_editor(language=language, indent_chars=indent_chars,\n    tab_stop_width_spaces=tab_stop_width_spaces)\nreturn editor, qtbot\npytest.fixture",
        "CUT_1": "self.indent_chars = indent_chars\n",
        "CUT_2": "self.indent_chars = indent_chars\n",
        "CUT_3": "self.tab_stop_width_spaces = tab_stop_width_spaces\nif self.data:\n    for finfo in self.data:\n        finfo.editor.tab_stop_width_spaces = tab_stop_width_spaces\n        finfo.editor.update_tab_stop_width_spaces()\n",
        "CUT_4": "self.tab_stop_width_spaces = tab_stop_width_spaces\nif self.data:\n    for finfo in self.data:\n        finfo.editor.tab_stop_width_spaces = tab_stop_width_spaces\n        finfo.editor.update_tab_stop_width_spaces()\n",
        "CUT_5": "indent_chars = indent_chars[1:-1]\nself.indent_chars = indent_chars\nif self.data:\n    for finfo in self.data:\n        finfo.editor.set_indent_chars(indent_chars)\n"
    },
    {
        "functionName": "test_single_line_comment",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_comments.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test toggle comment in a single line.\"\"\"\neditor, qtbot = code_editor_bot\ntext = \"\"\"#class a():\n#    self.b = 1\n #   print(self.b)\n#    \n\"\"\"\neditor.set_text(text)\ntext = toggle_comment(editor)\nassert text == \"\"\"class a():\n#    self.b = 1\n #   print(self.b)\n#    \n\"\"\"\ntext = toggle_comment(editor)\nassert text == \"\"\"# class a():\n#    self.b = 1\n #   print(self.b)\n#    \n\"\"\"\ntext = toggle_comment(editor)\nassert text == \"\"\"class a():\n#    self.b = 1\n #   print(self.b)\n#    \n\"\"\"\ntext = toggle_comment(editor, start_line=2)\nassert text == \"\"\"class a():\n    self.b = 1\n #   print(self.b)\n#    \n\"\"\"\ntext = toggle_comment(editor, start_line=2)\nassert text == \"\"\"class a():\n    # self.b = 1\n #   print(self.b)\n#    \n\"\"\"\ntext = toggle_comment(editor, start_line=2)\nassert text == \"\"\"class a():\n    self.b = 1\n #   print(self.b)\n#    \n\"\"\"\ntext = toggle_comment(editor, start_line=3)\nassert text == \"\"\"class a():\n    self.b = 1\n    print(self.b)\n#    \n\"\"\"\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"Comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.toggle_comment()\nSlot()",
        "CUT_4": "\"\"\"Comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.toggle_comment()\nSlot()",
        "CUT_5": "\"\"\"Line edit's text has changed\"\"\"\ntext = to_text_string(text)\nif text:\n    self.lineno = int(text)\nelse:\n    self.lineno = None\n"
    },
    {
        "functionName": "test_selection_comment",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_comments.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test toggle comments with selection of more tha one line.\"\"\"\neditor, qtbot = code_editor_bot\ntext = \"\"\"#class a():\n#    self.b = 1\n #   print(self.b)\n#    \n\"\"\"\neditor.set_text(text)\ntext = toggle_comment(editor, single_line=False)\nassert text == \"\"\"class a():\n    self.b = 1\n    print(self.b)\n    \n\"\"\"\ntext = toggle_comment(editor, single_line=False)\nassert text == \"\"\"# class a():\n#     self.b = 1\n#     print(self.b)\n    \n\"\"\"\ntext = toggle_comment(editor, single_line=False)\nassert text == \"\"\"class a():\n    self.b = 1\n    print(self.b)\n    \n\"\"\"\ntext = \"\"\"#class a():\n#    self.b = 1\n#    print(self.b)\n#    \n\"\"\"\neditor.set_text(text)\ntext = toggle_comment(editor, single_line=False)\nassert text == \"\"\"class a():\n    self.b = 1\n    print(self.b)\n    \n\"\"\"\n",
        "CUT_1": "return self.text\n",
        "CUT_2": "return self.text\n",
        "CUT_3": "\"\"\"Comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.toggle_comment()\nSlot()",
        "CUT_4": "\"\"\"Comment current line or selection\"\"\"\neditor = self.get_current_editor()\nif editor is not None:\n    editor.toggle_comment()\nSlot()",
        "CUT_5": "\"\"\"Line edit's text has changed\"\"\"\ntext = to_text_string(text)\nif text:\n    self.lineno = int(text)\nelse:\n    self.lineno = None\n"
    },
    {
        "functionName": "test_autosave_error_message_box",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_autosaveerror.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that AutosaveErrorDialog exec's at first, but that after the\n    'do not show anymore' checkbox is clicked, it does not exec anymore.\"\"\"\nmock_exec = mocker.patch.object(AutosaveErrorDialog, 'exec_')\nbox = AutosaveErrorDialog('action', 'error')\nbox.exec_if_enabled()\nassert mock_exec.call_count == 1\nbox.dismiss_box.click()\nok_button = box.findChild(QPushButton)\nok_button.click()\nbox2 = AutosaveErrorDialog('action', 'error')\nbox2.exec_if_enabled()\nassert mock_exec.call_count == 1\n",
        "CUT_1": "\"\"\"\n        Create a textbox field.\n        \"\"\"\nif default is not None and len(default) > 30:\n    box = QtWidgets.QTextEdit(parent=self)\n    box.setText = box.setPlainText\n    box.text = box.toPlainText\nelse:\n    box = QtWidgets.QLineEdit(parent=self)\nbox.setting = setting\nif default is not None:\n    box.setText(default)\n    box.textChanged.connect(lambda x=None: self.render())\nbox.get_value = lambda : box.text()\nbox.set_value = lambda text: box.setText(text)\nreturn box\n",
        "CUT_2": "\"\"\"\n        Create a textbox field.\n        \"\"\"\nif default is not None and len(default) > 30:\n    box = QtWidgets.QTextEdit(parent=self)\n    box.setText = box.setPlainText\n    box.text = box.toPlainText\nelse:\n    box = QtWidgets.QLineEdit(parent=self)\nbox.setting = setting\nif default is not None:\n    box.setText(default)\n    box.textChanged.connect(lambda x=None: self.render())\nbox.get_value = lambda : box.text()\nbox.set_value = lambda text: box.setText(text)\nreturn box\n",
        "CUT_3": "\"\"\"\n        Execute dialog box unless disabled by the user.\n\n        The dialog box is disabled once the user clicks the 'Hide all future\n        errors' check box on one dialog box.\n        \"\"\"\nif AutosaveErrorDialog.show_errors:\n    return self.exec_()\n",
        "CUT_4": "\"\"\"\n        Execute dialog box unless disabled by the user.\n\n        The dialog box is disabled once the user clicks the 'Hide all future\n        errors' check box on one dialog box.\n        \"\"\"\nif AutosaveErrorDialog.show_errors:\n    return self.exec_()\n",
        "CUT_5": "\"\"\"\n        Update `show_errors` and hide dialog box.\n\n        Overrides method of `QDialogBox`.\n        \"\"\"\nAutosaveErrorDialog.show_errors = not self.dismiss_box.isChecked()\nreturn QDialog.accept(self)\n"
    },
    {
        "functionName": "recovery_env",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create a dir with various autosave files and cleans up afterwards.\"\"\"\nyield make_temporary_files(str(tmpdir))\nshutil.rmtree(str(tmpdir))\npytest.fixture",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_3": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_4": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_5": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture"
    },
    {
        "functionName": "test_recoverydialog_has_cancel_button",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that RecoveryDialog has a Cancel button.\n\n    Test that a RecoveryDialog has a button in a dialog button box and that\n    this button cancels the dialog window.\n    \"\"\"\ndialog = RecoveryDialog([])\nqtbot.addWidget(dialog)\nbutton = dialog.findChild(QDialogButtonBox).findChild(QPushButton)\nwith qtbot.waitSignal(dialog.rejected):\n    button.click()\n",
        "CUT_1": "\"\"\"Create a QToolButton\"\"\"\nbutton = QToolButton(parent)\nif text is not None:\n    button.setText(text)\nif icon is not None:\n    if is_text_string(icon):\n        icon = get_icon(icon)\n    button.setIcon(icon)\nif text is not None or tip is not None:\n    button.setToolTip(text if tip is None else tip)\nif text_beside_icon:\n    button.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)\nbutton.setAutoRaise(autoraise)\nif triggered is not None:\n    button.clicked.connect(triggered)\nif toggled is not None:\n    button.toggled.connect(toggled)\n    button.setCheckable(True)\nif shortcut is not None:\n    button.setShortcut(shortcut)\nreturn button\n",
        "CUT_2": "\"\"\"Create a QToolButton\"\"\"\nbutton = QToolButton(parent)\nif text is not None:\n    button.setText(text)\nif icon is not None:\n    if is_text_string(icon):\n        icon = get_icon(icon)\n    button.setIcon(icon)\nif text is not None or tip is not None:\n    button.setToolTip(text if tip is None else tip)\nif text_beside_icon:\n    button.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)\nbutton.setAutoRaise(autoraise)\nif triggered is not None:\n    button.clicked.connect(triggered)\nif toggled is not None:\n    button.toggled.connect(toggled)\n    button.setCheckable(True)\nif shortcut is not None:\n    button.setShortcut(shortcut)\nreturn button\n",
        "CUT_3": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_4": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_5": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()"
    },
    {
        "functionName": "test_recoverydialog_table_labels",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that table in RecoveryDialog has the correct labels.\"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\ndef text(i, j):\n    return table.cellWidget(i, j).text()\nassert osp.join(orig_dir, 'ham.py') in text(0, 0)\nassert osp.join(autosave_dir, 'ham.py') in text(0, 1)\nassert osp.join(orig_dir, 'spam.py') in text(1, 0)\nassert 'no longer exists' in text(1, 0)\nassert osp.join(autosave_dir, 'spam.py') in text(1, 1)\nassert 'not recorded' in text(2, 0)\nassert osp.join(autosave_dir, 'cheese.py') in text(2, 1)\nassert table.rowCount() == 3\n",
        "CUT_1": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_2": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_3": "return self.text\n",
        "CUT_4": "return self.text\n",
        "CUT_5": "\"\"\"\n        Add current text to combo box history (convenient method).\n        If path ends in os separator (\"\" windows, \"/\" unix) remove it.\n        \"\"\"\ntext = self.currentText()\nif osp.isdir(text) and text:\n    if text[-1] == os.sep:\n        text = text[:-1]\nself.add_text(text)\n"
    },
    {
        "functionName": "text",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return table.cellWidget(i, j).text()\n",
        "CUT_1": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n",
        "CUT_2": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntable = ShortcutsTable()\ntable = load_shortcuts(table)\ntable.show()\napp.exec_()\ntable.check_shortcuts()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntable = ShortcutsTable()\ntable = load_shortcuts(table)\ntable.show()\napp.exec_()\ntable.check_shortcuts()\n",
        "CUT_5": "return self.text\n"
    },
    {
        "functionName": "test_recoverydialog_exec_if_nonempty_when_empty",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that exec_if_nonempty does nothing if autosave files do not exist.\n\n    Specifically, test that it does not `exec_()` the dialog.\n    \"\"\"\ndialog = RecoveryDialog([('ham', 'spam')])\nmocker.patch.object(dialog, 'exec_')\nassert dialog.exec_if_nonempty() == dialog.Accepted\ndialog.exec_.assert_not_called()\n",
        "CUT_1": "\"\"\"Test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ndialog = ImportWizard(None, text)\nif dialog.exec_():\n    print(dialog.get_data())\n",
        "CUT_2": "\"\"\"Test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ndialog = ImportWizard(None, text)\nif dialog.exec_():\n    print(dialog.get_data())\n",
        "CUT_3": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_4": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_5": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()"
    },
    {
        "functionName": "test_recoverydialog_exec_if_nonempty_when_nonempty",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that exec_if_nonempty executes dialog if autosave dir not empty.\"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\ndialog = RecoveryDialog(autosave_mapping)\nmocker.patch.object(dialog, 'exec_', return_value='eggs')\nassert dialog.exec_if_nonempty() == 'eggs'\nassert dialog.exec_.called\n",
        "CUT_1": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_3": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_4": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_5": "\"\"\"\n        Set maximum amount of results to add to the result browser.\n\n        Parameters\n        ----------\n        value: int, optional\n            Number of results. If None an input dialog will be used.\n            Default is None.\n        \"\"\"\nif value is None:\n    dialog = QInputDialog(self)\n    dialog.setModal(False)\n    dialog.setWindowTitle(self.get_name())\n    dialog.setLabelText(_('Set maximum number of results: '))\n    dialog.setInputMode(QInputDialog.IntInput)\n    dialog.setIntRange(1, 10000)\n    dialog.setIntStep(1)\n    dialog.setIntValue(self.get_option('max_results'))\n    dialog.intValueSelected.connect(lambda value: self.set_option(\n        'max_results', value))\n    dialog.show()\nelse:\n    self.set_option('max_results', value)\n"
    },
    {
        "functionName": "test_recoverydialog_exec_if_nonempty_when_no_autosave_dir",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that exec_if_nonempty does nothing if autosave dir does not exist.\n\n    Specifically, test that it does not `exec_()` the dialog.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\nshutil.rmtree(autosave_dir)\ndialog = RecoveryDialog(autosave_mapping)\nmocker.patch.object(dialog, 'exec_')\nassert dialog.exec_if_nonempty() == dialog.Accepted\ndialog.exec_.assert_not_called()\n",
        "CUT_1": "\"\"\"Test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ndialog = ImportWizard(None, text)\nif dialog.exec_():\n    print(dialog.get_data())\n",
        "CUT_2": "\"\"\"Test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ndialog = ImportWizard(None, text)\nif dialog.exec_():\n    print(dialog.get_data())\n",
        "CUT_3": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_4": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_5": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()"
    },
    {
        "functionName": "test_recoverydialog_restore_button",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the `Restore` button in `RecoveryDialog`.\n\n    Test that after pressing the 'Restore' button, the original file is\n    replaced by the autosave file, the latter is removed, and the row in the\n    grid is deactivated.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\nbutton = table.cellWidget(0, 2).findChildren(QPushButton)[0]\nbutton.click()\nwith open(osp.join(orig_dir, 'ham.py')) as f:\n    assert f.read() == 'ham = \"autosave\"\\n'\nassert not osp.isfile(osp.join(autosave_dir, 'ham.py'))\nfor col in range(table.columnCount()):\n    assert not table.cellWidget(0, col).isEnabled()\n",
        "CUT_1": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_2": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_3": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_4": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_5": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n"
    },
    {
        "functionName": "test_recoverydialog_restore_when_original_does_not_exist",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the `Restore` button when the original file does not exist.\n\n    Test that after pressing the 'Restore' button, the autosave file is moved\n    to the location of the original file and the row in the grid is\n    deactivated.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\nbutton = table.cellWidget(1, 2).findChildren(QPushButton)[0]\nbutton.click()\nwith open(osp.join(orig_dir, 'spam.py')) as f:\n    assert f.read() == 'spam = \"autosave\"\\n'\nassert not osp.isfile(osp.join(autosave_dir, 'spam.py'))\nfor col in range(table.columnCount()):\n    assert not table.cellWidget(1, col).isEnabled()\n",
        "CUT_1": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_2": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_3": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_4": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_5": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n"
    },
    {
        "functionName": "test_recoverydialog_restore_when_original_not_recorded",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the `Restore` button when the original file name is not known.\n\n    Test that after pressing the 'Restore' button, the autosave file is moved\n    to a location specified by the user and the row in the grid is deactivated.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\nnew_name = osp.join(orig_dir, 'monty.py')\nmocker.patch('spyder.plugins.editor.widgets.recover.getsavefilename',\n    return_value=(new_name, 'ignored'))\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\nbutton = table.cellWidget(2, 2).findChildren(QPushButton)[0]\nbutton.click()\nwith open(new_name) as f:\n    assert f.read() == 'cheese = \"autosave\"\\n'\nassert not osp.isfile(osp.join(autosave_dir, 'cheese.py'))\nfor col in range(table.columnCount()):\n    assert not table.cellWidget(2, col).isEnabled()\n",
        "CUT_1": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_2": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_3": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_4": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_5": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n"
    },
    {
        "functionName": "test_recoverydialog_restore_fallback",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test fallback for when os.replace() fails when recovering a file.\n\n    Test that after pressing the 'Restore' button, if os.replace() fails,\n    the fallback to copy and delete kicks in and the restore succeeds.\n    Regression test for spyder-ide/spyder#8631.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\nif not PY2:\n    mocker.patch('spyder.plugins.editor.widgets.recover.os.replace',\n        side_effect=OSError)\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\nbutton = table.cellWidget(0, 2).findChildren(QPushButton)[0]\nbutton.click()\nwith open(osp.join(orig_dir, 'ham.py')) as f:\n    assert f.read() == 'ham = \"autosave\"\\n'\nassert not osp.isfile(osp.join(autosave_dir, 'ham.py'))\nfor col in range(table.columnCount()):\n    assert not table.cellWidget(0, col).isEnabled()\n",
        "CUT_1": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_2": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_3": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_4": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_5": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n"
    },
    {
        "functionName": "test_recoverydialog_restore_when_error",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that errors during a restore action are handled gracefully.\n\n    Test that if an error arises when restoring a file, both the original and\n    the autosave files are kept unchanged, a dialog is displayed, and the row\n    in the grid is not deactivated.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\nif not PY2:\n    mocker.patch('spyder.plugins.editor.widgets.recover.os.replace',\n        side_effect=OSError)\nmocker.patch('spyder.plugins.editor.widgets.recover.shutil.copy2',\n    side_effect=IOError)\nmock_QMessageBox = mocker.patch(\n    'spyder.plugins.editor.widgets.recover.QMessageBox')\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\nbutton = table.cellWidget(0, 2).findChildren(QPushButton)[0]\nbutton.click()\nwith open(osp.join(orig_dir, 'ham.py')) as f:\n    assert f.read() == 'ham = \"original\"\\n'\nwith open(osp.join(autosave_dir, 'ham.py')) as f:\n    assert f.read() == 'ham = \"autosave\"\\n'\nassert mock_QMessageBox.called\nfor col in range(table.columnCount()):\n    assert table.cellWidget(0, col).isEnabled()\n",
        "CUT_1": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_2": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_3": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_4": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_5": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n"
    },
    {
        "functionName": "test_recoverydialog_accepted_after_all_restored",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the recovery dialog is accepted after all files are restored.\n\n    Click all `Restore` buttons and test that the dialog is accepted\n    afterwards, but not before.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\nnew_name = osp.join(orig_dir, 'monty.py')\nmocker.patch('spyder.plugins.editor.widgets.recover.getsavefilename',\n    return_value=(new_name, 'ignored'))\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\nwith qtbot.assertNotEmitted(dialog.accepted):\n    for row in range(table.rowCount() - 1):\n        table.cellWidget(row, 2).findChildren(QPushButton)[0].click()\nwith qtbot.waitSignal(dialog.accepted):\n    row = table.rowCount() - 1\n    table.cellWidget(row, 2).findChildren(QPushButton)[0].click()\n",
        "CUT_1": "if not dialog:\n    dialog = KernelConnectionDialog(parent)\nresult = dialog.exec_()\nis_remote = bool(dialog.rm_group.isChecked())\naccepted = result == QDialog.Accepted\nif is_remote:\n\n    def falsy_to_none(arg):\n        return arg if arg else None\n    if dialog.hn.text() and dialog.un.text():\n        port = dialog.pn.text() if dialog.pn.text() else '22'\n        hostname = '{0}@{1}:{2}'.format(dialog.un.text(), dialog.hn.text(),\n            port)\n    else:\n        hostname = None\n    if dialog.pw_radio.isChecked():\n        password = falsy_to_none(dialog.pw.text())\n        keyfile = None\n    elif dialog.kf_radio.isChecked():\n        keyfile = falsy_to_none(dialog.kf.text())\n        password = falsy_to_none(dialog.kfp.text())\n    else:\n        keyfile = None\n        password = None\n    return dialog.cf.text(), hostname, keyfile, password, accepted\nelse:\n    path = dialog.cf.text()\n    _dir, filename = osp.dirname(path), osp.basename(path)\n    if _dir == '' and not filename.endswith('.json'):\n        path = osp.join(jupyter_runtime_dir(), 'kernel-' + path + '.json')\n    return path, None, None, None, accepted\nstaticmethod",
        "CUT_2": "if not dialog:\n    dialog = KernelConnectionDialog(parent)\nresult = dialog.exec_()\nis_remote = bool(dialog.rm_group.isChecked())\naccepted = result == QDialog.Accepted\nif is_remote:\n\n    def falsy_to_none(arg):\n        return arg if arg else None\n    if dialog.hn.text() and dialog.un.text():\n        port = dialog.pn.text() if dialog.pn.text() else '22'\n        hostname = '{0}@{1}:{2}'.format(dialog.un.text(), dialog.hn.text(),\n            port)\n    else:\n        hostname = None\n    if dialog.pw_radio.isChecked():\n        password = falsy_to_none(dialog.pw.text())\n        keyfile = None\n    elif dialog.kf_radio.isChecked():\n        keyfile = falsy_to_none(dialog.kf.text())\n        password = falsy_to_none(dialog.kfp.text())\n    else:\n        keyfile = None\n        password = None\n    return dialog.cf.text(), hostname, keyfile, password, accepted\nelse:\n    path = dialog.cf.text()\n    _dir, filename = osp.dirname(path), osp.basename(path)\n    if _dir == '' and not filename.endswith('.json'):\n        path = osp.join(jupyter_runtime_dir(), 'kernel-' + path + '.json')\n    return path, None, None, None, accepted\nstaticmethod",
        "CUT_3": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_4": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntable = ShortcutsTable()\ntable = load_shortcuts(table)\ntable.show()\napp.exec_()\ntable.check_shortcuts()\n"
    },
    {
        "functionName": "test_recoverydialog_discard_button",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the `Discard` button in the recovery dialog.\n\n    Test that after pressing the 'Discard' button, the autosave file is\n    deleted, the original file unchanged, and the row in the grid is\n    deactivated.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\nbutton = table.cellWidget(0, 2).findChildren(QPushButton)[1]\nbutton.click()\nassert not osp.isfile(osp.join(autosave_dir, 'ham.py'))\nwith open(osp.join(orig_dir, 'ham.py')) as f:\n    assert f.read() == 'ham = \"original\"\\n'\nfor col in range(table.columnCount()):\n    assert not table.cellWidget(0, col).isEnabled()\n",
        "CUT_1": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_2": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_3": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_4": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_5": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n"
    },
    {
        "functionName": "test_recoverydialog_discard_when_error",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that errors during a discard action are handled gracefully.\n\n    Test that if an error arises when discarding a file, both the original and\n    the autosave files are kept unchanged, a dialog is displayed, and the row\n    in the grid is not deactivated.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\nmocker.patch('spyder.plugins.editor.widgets.recover.os.remove', side_effect\n    =OSError)\nmock_QMessageBox = mocker.patch(\n    'spyder.plugins.editor.widgets.recover.QMessageBox')\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\nbutton = table.cellWidget(0, 2).findChildren(QPushButton)[1]\nbutton.click()\nwith open(osp.join(orig_dir, 'ham.py')) as f:\n    assert f.read() == 'ham = \"original\"\\n'\nwith open(osp.join(autosave_dir, 'ham.py')) as f:\n    assert f.read() == 'ham = \"autosave\"\\n'\nassert mock_QMessageBox.called\nfor col in range(table.columnCount()):\n    assert table.cellWidget(0, col).isEnabled()\n",
        "CUT_1": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_2": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_3": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_4": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_5": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n"
    },
    {
        "functionName": "test_recoverydialog_open_button",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the `Open` button in the recovery dialog.\n\n    Test that after pressing the 'Open' button, `files_to_open` contains\n    the autosave and the original file, and the row in the grid is\n    deactivated.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\nbutton = table.cellWidget(0, 2).findChildren(QPushButton)[2]\nbutton.click()\nassert dialog.files_to_open == [osp.join(orig_dir, 'ham.py'), osp.join(\n    autosave_dir, 'ham.py')]\nfor col in range(table.columnCount()):\n    assert not table.cellWidget(0, col).isEnabled()\n",
        "CUT_1": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_2": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_3": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_4": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n",
        "CUT_5": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n"
    },
    {
        "functionName": "test_recoverydialog_open_when_no_original",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_recover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the `Open` button when the original file is not known.\n\n    Test that when the user requests to open an autosave file for which the\n    original file is not known, `files_to_open` contains only the autosave\n    file.\n    \"\"\"\norig_dir, autosave_dir, autosave_mapping = recovery_env\ndialog = RecoveryDialog(autosave_mapping)\ntable = dialog.findChild(QTableWidget)\nbutton = table.cellWidget(2, 2).findChildren(QPushButton)[2]\nbutton.click()\nassert dialog.files_to_open == [osp.join(autosave_dir, 'cheese.py')]\nfor col in range(table.columnCount()):\n    assert not table.cellWidget(2, col).isEnabled()\n",
        "CUT_1": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_2": "\"\"\"Add table with info about files to be recovered.\"\"\"\ntable = QTableWidget(len(self.data), 3, self)\nself.table = table\nlabels = [_('Original file'), _('Autosave file'), _('Actions')]\ntable.setHorizontalHeaderLabels(labels)\ntable.verticalHeader().hide()\ntable.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\ntable.setSelectionMode(QTableWidget.NoSelection)\ntable.setShowGrid(False)\ntable.setStyleSheet('::item { border-bottom: 1px solid gray }')\nfor idx, (original, autosave) in enumerate(self.data):\n    self.add_label_to_table(idx, 0, file_data_to_str(original))\n    self.add_label_to_table(idx, 1, file_data_to_str(autosave))\n    widget = QWidget()\n    layout = QHBoxLayout()\n    tooltip = _(\n        'Recover the autosave file to its original location, replacing the original if it exists.'\n        )\n    button = QPushButton(_('Restore'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.restore(my_idx))\n    layout.addWidget(button)\n    tooltip = _('Delete the autosave file.')\n    button = QPushButton(_('Discard'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.discard(my_idx))\n    layout.addWidget(button)\n    tooltip = _(\n        \"Display the autosave file (and the original, if it exists) in Spyder's Editor. You will have to move or delete it manually.\"\n        )\n    button = QPushButton(_('Open'))\n    button.setToolTip(tooltip)\n    button.clicked.connect(lambda checked, my_idx=idx: self.open_files(my_idx))\n    layout.addWidget(button)\n    widget.setLayout(layout)\n    self.table.setCellWidget(idx, 2, widget)\ntable.resizeRowsToContents()\ntable.resizeColumnsToContents()\nself.layout.addWidget(table)\n",
        "CUT_3": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n",
        "CUT_4": "for col in range(self.table.columnCount()):\n    self.table.cellWidget(idx, col).setEnabled(False)\nself.num_enabled -= 1\nif self.num_enabled == 0:\n    self.accept()\n",
        "CUT_5": "\"\"\"\n    Make temporary files to simulate a recovery use case.\n\n    Create a directory under tempdir containing some original files and another\n    directory with autosave files. Return a tuple with the name of the\n    directory with the original files, the name of the directory with the\n    autosave files, and the autosave mapping.\n    \"\"\"\norig_dir = osp.join(tempdir, 'orig')\nos.mkdir(orig_dir)\nautosave_dir = osp.join(tempdir, 'autosave')\nos.mkdir(autosave_dir)\nautosave_mapping = {}\norig_file = osp.join(orig_dir, 'ham.py')\nwith open(orig_file, 'w') as f:\n    f.write('ham = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'ham.py')\nwith open(autosave_file, 'w') as f:\n    f.write('ham = \"autosave\"\\n')\nautosave_mapping = [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'spam.py')\nautosave_file = osp.join(autosave_dir, 'spam.py')\nwith open(autosave_file, 'w') as f:\n    f.write('spam = \"autosave\"\\n')\nautosave_mapping += [(orig_file, autosave_file)]\norig_file = osp.join(orig_dir, 'eggs.py')\nwith open(orig_file, 'w') as f:\n    f.write('eggs = \"original\"\\n')\nautosave_file = osp.join(autosave_dir, 'eggs.py')\nautosave_mapping += [(orig_file, autosave_file)]\nautosave_file = osp.join(autosave_dir, 'cheese.py')\nwith open(autosave_file, 'w') as f:\n    f.write('cheese = \"autosave\"\\n')\nautosave_mapping += [(None, autosave_file)]\nreturn orig_dir, autosave_dir, autosave_mapping\n"
    },
    {
        "functionName": "test_automatic_completions_hide_complete",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_completions_hide.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test on-the-fly completion closing when already complete.\n\n    Regression test for issue #11600 and pull requests #11824, #12140\n    and #12710.\n    \"\"\"\ncode_editor, _ = lsp_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_code_snippets(False)\ncode_editor.set_text(\"\"\"some = 0\nsomething = 1\n\"\"\")\ncursor = code_editor.textCursor()\ncode_editor.moveCursor(cursor.End)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, 'some')\nassert 'some' in [x['label'] for x in sig.args[0]]\nassert 'something' in [x['label'] for x in sig.args[0]]\nqtbot.keyClicks(code_editor, 'thing')\nqtbot.wait(500)\nassert completion.isHidden()\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyClicks(code_editor, 'print(something')\nqtbot.wait(500)\nassert completion.isHidden()\nqtbot.keyClicks(code_editor, ')')\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nqtbot.keyClicks(code_editor, 'a = {something')\nqtbot.wait(500)\nassert completion.isHidden()\ncode_editor.moveCursor(cursor.End)\nqtbot.keyPress(code_editor, Qt.Key_Enter)\nqtbot.keyClicks(code_editor, 'some')\nqtbot.keyPress(code_editor, Qt.Key_Enter)\nqtbot.keyClicks(code_editor, '  None')\ncode_editor.moveCursor(cursor.End - 6)\nqtbot.keyPress(code_editor, Qt.Key_Backspace)\nqtbot.wait(2000)\nassert completion.isHidden()\nqtbot.keyPress(code_editor, Qt.Key_Backspace)\nqtbot.wait(2000)\nassert completion.isHidden()\ncode_editor.moveCursor(cursor.End)\nqtbot.keyPress(code_editor, Qt.Key_Enter)\nqtbot.keyClicks(code_editor, 'some +  some ')\nqtbot.keyPress(code_editor, Qt.Key_Left)\nqtbot.keyPress(code_editor, Qt.Key_Left)\nqtbot.keyPress(code_editor, Qt.Key_Left)\nqtbot.keyPress(code_editor, Qt.Key_Left)\nqtbot.keyPress(code_editor, Qt.Key_Left)\nqtbot.keyPress(code_editor, Qt.Key_Backspace)\nqtbot.wait(2000)\nassert completion.isHidden()\ncode_editor.toggle_code_snippets(True)\npytest.mark.slowpytest.mark.first",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "test_automatic_completions_widget_visible",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_completions_hide.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test on-the-fly completions when the widget is visible and the Backspace\n    key is pressed.\n\n    Regression test for PR #12710\n    \"\"\"\ncode_editor, _ = lsp_codeeditor\ncompletion = code_editor.completion_widget\ncode_editor.toggle_code_snippets(False)\ncode_editor.set_text('import math')\ncursor = code_editor.textCursor()\ncode_editor.moveCursor(cursor.End)\nqtbot.keyPress(code_editor, Qt.Key_Enter, delay=300)\nwith qtbot.waitSignal(completion.sig_show_completions, timeout=10000) as sig:\n    qtbot.keyClicks(code_editor, 'math.aco')\nassert completion.isVisible()\nqtbot.keyPress(code_editor, Qt.Key_Backspace, delay=300)\nassert completion.isVisible()\nqtbot.keyPress(code_editor, Qt.Key_Backspace, delay=300)\nassert completion.isVisible()\npytest.mark.slowpytest.mark.first",
        "CUT_1": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_2": "\"\"\"Init QMenu.\"\"\"\nsuper(QMenuOnlyForEnter, self).__init__(code_editor)\nself.code_editor = code_editor\n",
        "CUT_3": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_4": "\"\"\"Initialize and Add code_editor to the variable.\"\"\"\nself.code_editor = code_editor\nself.quote3 = '\"\"\"'\nself.quote3_other = \"'''\"\nself.line_number_cursor = None\n",
        "CUT_5": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n"
    },
    {
        "functionName": "construct_editor",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_decorations.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Construct editor for testing decorations.\"\"\"\neditor = CodeEditor(parent=None)\neditor.setup_editor(language='Python', color_scheme='spyder/dark', font=\n    QFont('Monospace', 10))\neditor.resize(640, 480)\neditor.show()\nqtbot.addWidget(editor)\nreturn editor\npytest.fixture",
        "CUT_1": "editor = CodeEditor(parent=None)\neditor.setup_editor(language='Python', tab_mode=False, markers=True,\n    close_quotes=True, close_parentheses=True, color_scheme='spyder/dark',\n    font=QFont('Monospace', 10), automatic_completions=True,\n    automatic_completions_after_chars=1, automatic_completions_after_ms=200,\n    folding=False)\neditor.resize(640, 480)\nreturn editor\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "QSplitter.__init__(self, parent)\nself.editor = CodeEditor(self)\nself.editor.setup_editor(linenumbers=True, markers=True, tab_mode=False,\n    font=QFont('Courier New', 10), show_blanks=True, color_scheme='Zenburn')\nself.addWidget(self.editor)\nself.setWindowIcon(ima.icon('spyder'))\n",
        "CUT_5": "QSplitter.__init__(self, parent)\nself.editor = CodeEditor(self)\nself.editor.setup_editor(linenumbers=True, markers=True, tab_mode=False,\n    font=QFont('Courier New', 10), show_blanks=True, color_scheme='Zenburn')\nself.addWidget(self.editor)\nself.setWindowIcon(ima.icon('spyder'))\n"
    },
    {
        "functionName": "test_decorations",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_decorations.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test decorations.\"\"\"\neditor = construct_editor\neditor.resize(640, random.randint(200, 500))\nbase_function = \"\"\"def some_function():\n    some_variable = 1\n    some_variable += 2\n    return some_variable\n\n\"\"\"\ntext = ''\nfor __ in range(100):\n    base_text = base_function * random.randint(2, 8) + '# %%\\n'\n    text = text + base_text\neditor.set_text(text)\neditor.go_to_line(2)\ncursor = editor.textCursor()\ncursor.movePosition(QTextCursor.Right, n=5)\neditor.setTextCursor(cursor)\nqtbot.wait(3000)\ndecorations = editor.decorations._decorations\nassert len(decorations) == 2 + text.count('some_variable')\nassert decorations[0].kind == 'current_cell'\nassert decorations[1].kind == 'current_line'\nassert all([(d.kind == 'occurrences') for d in decorations[2:5]])\nselected_texts = [d.cursor.selectedText() for d in decorations]\nassert set(selected_texts[2:]) == set(['some_variable'])\nfirst, last = editor.get_buffer_block_numbers()\nmax_decorations = last - first\nassert len(editor.extraSelections()) < max_decorations\neditor.decorations.clear()\neditor.decorations._update()\nassert editor.decorations._decorations == []\nline_number = random.randint(100, editor.blockCount())\neditor.go_to_line(line_number)\nqtbot.wait(UPDATE_DECORATIONS_TIMEOUT + 100)\ndecorations = editor.decorations._decorations\nassert decorations[0].kind == 'current_cell'\n",
        "CUT_1": "\"\"\"\n        Add text decorations on a CodeEditor instance.\n\n        Don't add duplicated decorations, and order decorations according\n        draw_order and the size of the selection.\n\n        Args:\n            decorations (sourcecode.api.TextDecoration) (could be a list)\n        Returns:\n            int: Amount of decorations added.\n        \"\"\"\nadded = 0\nif isinstance(decorations, list):\n    not_repeated = set(decorations) - set(self._decorations)\n    self._decorations.extend(list(not_repeated))\n    added = len(not_repeated)\nelif decorations not in self._decorations:\n    self._decorations.append(decorations)\n    added = 1\nif added > 0:\n    self._order_decorations()\n    self.update()\nreturn added\n",
        "CUT_2": "\"\"\"\n        Add text decorations on a CodeEditor instance.\n\n        Don't add duplicated decorations, and order decorations according\n        draw_order and the size of the selection.\n\n        Args:\n            decorations (sourcecode.api.TextDecoration) (could be a list)\n        Returns:\n            int: Amount of decorations added.\n        \"\"\"\nadded = 0\nif isinstance(decorations, list):\n    not_repeated = set(decorations) - set(self._decorations)\n    self._decorations.extend(list(not_repeated))\n    added = len(not_repeated)\nelif decorations not in self._decorations:\n    self._decorations.append(decorations)\n    added = 1\nif added > 0:\n    self._order_decorations()\n    self.update()\nreturn added\n",
        "CUT_3": "\"\"\"Clear scope decorations (on the editor)\"\"\"\nfor deco in self._scope_decos:\n    self.editor.decorations.remove(deco)\nself._scope_decos[:] = []\n",
        "CUT_4": "\"\"\"Clear scope decorations (on the editor)\"\"\"\nfor deco in self._scope_decos:\n    self.editor.decorations.remove(deco)\nself._scope_decos[:] = []\n",
        "CUT_5": "\"\"\"Clear the folded block decorations.\"\"\"\nfor deco in self._block_decos:\n    self.editor.decorations.remove(deco)\nself._block_decos[:] = []\n"
    },
    {
        "functionName": "test_update_decorations_when_scrolling",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_decorations.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test how many calls we're doing to update decorations when\n    scrolling.\n    \"\"\"\npatched_object = (\n    'spyder.plugins.editor.utils.decoration.TextDecorationsManager._update')\nwith patch(patched_object) as _update:\n    editor = CodeEditor(parent=None)\n    editor.setup_editor(language='Python', color_scheme='spyder/dark', font\n        =QFont('Monospace', 10))\n    editor.resize(640, 480)\n    editor.show()\n    qtbot.addWidget(editor)\n    assert _update.call_count == 0\n    with open(osp.join(PARENT, 'codeeditor.py'), 'r') as f:\n        text = f.read()\n    editor.set_text(text)\n    assert _update.call_count == 0\n    scrollbar = editor.verticalScrollBar()\n    for i in range(6):\n        scrollbar.setValue(i * 70)\n        qtbot.wait(100)\n    assert _update.call_count == 1\n    qtbot.wait(UPDATE_DECORATIONS_TIMEOUT + 100)\n    assert _update.call_count == 2\n    scrollbar = editor.verticalScrollBar()\n    value = scrollbar.value()\n    for __ in range(400):\n        scrollbar.setValue(value + 1)\n        value = scrollbar.value()\n    assert _update.call_count == 2\n    qtbot.wait(UPDATE_DECORATIONS_TIMEOUT + 100)\n    assert _update.call_count == 3\n    _, last = editor.get_visible_block_numbers()\n    editor.go_to_line(last)\n    for __ in range(200):\n        qtbot.keyPress(editor, Qt.Key_Down)\n        if sys.platform.startswith('linux'):\n            qtbot.wait(5)\n    qtbot.wait(UPDATE_DECORATIONS_TIMEOUT + 100)\n    assert _update.call_count == 4\n    for __ in range(200):\n        qtbot.keyPress(editor, Qt.Key_Up)\n        if sys.platform.startswith('linux'):\n            qtbot.wait(5)\n    qtbot.wait(UPDATE_DECORATIONS_TIMEOUT + 100)\n    assert _update.call_count == 5\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Refreshes the editor panels (resize and update margins).\"\"\"\nself.resize()\nself._update(self.editor.contentsRect(), 0, force_update_margins=True)\n",
        "CUT_3": "\"\"\"Refreshes the editor panels (resize and update margins).\"\"\"\nself.resize()\nself._update(self.editor.contentsRect(), 0, force_update_margins=True)\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_class_func_selector",
        "className": null,
        "fileName": "/spyder/plugins/editor/widgets/tests/test_classfunc_selector.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "code_editor, _ = lsp_codeeditor\npanel = code_editor.classfuncdropdown\npanel.setVisible(True)\ncode_editor.toggle_automatic_completions(False)\ncode_editor.set_text(text)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.document_did_change()\nqtbot.wait(2000)\nwith qtbot.waitSignal(code_editor.lsp_response_signal, timeout=30000):\n    code_editor.request_symbols()\nqtbot.wait(2000)\nclass_names = [item['name'] for item in panel.classes]\nfunc_names = [item['name'] for item in panel.funcs]\nassert len(panel.classes) == 2\nassert len(panel.funcs) == 6\nassert 'SomeObject' in class_names\nassert 'SomeOtherObject' in class_names\nassert '__init__' in func_names\nassert 'nested_func' in func_names\nfor _ in range(7):\n    qtbot.keyPress(code_editor, Qt.Key_Down)\nassert panel.class_cb.currentText() == 'SomeObject'\nassert panel.method_cb.currentText() == 'SomeObject.__init__'\nfor _ in range(18):\n    qtbot.keyPress(code_editor, Qt.Key_Down)\nassert panel.class_cb.currentText() == 'SomeOtherObject'\nassert panel.method_cb.currentText() == 'SomeOtherObject.hello_3.nested_func'\nqtbot.mouseClick(panel.class_cb, Qt.LeftButton, pos=QPoint(5, 5))\nlistview = panel.class_cb.findChild(QListView)\nqtbot.keyPress(listview, Qt.Key_Up)\nqtbot.keyPress(listview, Qt.Key_Return)\nqtbot.wait(1000)\ncursor = code_editor.textCursor()\nassert cursor.blockNumber() == 4\nassert panel.method_cb.currentIndex() == 0\npanel.method_cb.setFocus()\nqtbot.mouseClick(panel.method_cb, Qt.LeftButton, pos=QPoint(5, 5))\nlistview = panel.method_cb.findChild(QListView)\nqtbot.keyPress(listview, Qt.Key_Down)\nqtbot.keyPress(listview, Qt.Key_Down)\nqtbot.keyPress(listview, Qt.Key_Return)\nqtbot.wait(1000)\ncursor = code_editor.textCursor()\nassert cursor.blockNumber() == 9\nassert panel.class_cb.currentIndex() == 1\npanel.setVisible(False)\ncode_editor.toggle_automatic_completions(True)\npytest.mark.slowpytest.mark.second",
        "CUT_1": "\"\"\"\n        Installs a panel on the editor.\n\n        :param panel: Panel to install\n        :param position: Position where the panel must be installed.\n        :return: The installed panel\n        \"\"\"\nassert panel is not None\npos_to_string = {Panel.Position.BOTTOM: 'bottom', Panel.Position.LEFT:\n    'left', Panel.Position.RIGHT: 'right', Panel.Position.TOP: 'top', Panel\n    .Position.FLOATING: 'floating'}\nlogger.debug('adding panel %s at %s' % (panel.name, pos_to_string[position]))\npanel.order_in_zone = len(self._panels[position])\nself._panels[position][panel.name] = panel\npanel.position = position\npanel.on_install(self.editor)\nlogger.debug('panel %s installed' % panel.name)\nreturn panel\n",
        "CUT_2": "\"\"\"\n        Installs a panel on the editor.\n\n        :param panel: Panel to install\n        :param position: Position where the panel must be installed.\n        :return: The installed panel\n        \"\"\"\nassert panel is not None\npos_to_string = {Panel.Position.BOTTOM: 'bottom', Panel.Position.LEFT:\n    'left', Panel.Position.RIGHT: 'right', Panel.Position.TOP: 'top', Panel\n    .Position.FLOATING: 'floating'}\nlogger.debug('adding panel %s at %s' % (panel.name, pos_to_string[position]))\npanel.order_in_zone = len(self._panels[position])\nself._panels[position][panel.name] = panel\npanel.position = position\npanel.on_install(self.editor)\nlogger.debug('panel %s installed' % panel.name)\nreturn panel\n",
        "CUT_3": "\"\"\"\n        Removes the specified panel.\n\n        :param name_or_klass: Name or class of the panel to remove.\n        :return: The removed panel\n        \"\"\"\nlogger.debug('removing panel %s' % name_or_klass)\npanel = self.get(name_or_klass)\npanel.on_uninstall()\npanel.hide()\npanel.setParent(None)\nreturn self._panels[panel.position].pop(panel.name, None)\n",
        "CUT_4": "\"\"\"\n        Removes the specified panel.\n\n        :param name_or_klass: Name or class of the panel to remove.\n        :return: The removed panel\n        \"\"\"\nlogger.debug('removing panel %s' % name_or_klass)\npanel = self.get(name_or_klass)\npanel.on_uninstall()\npanel.hide()\npanel.setParent(None)\nreturn self._panels[panel.position].pop(panel.name, None)\n",
        "CUT_5": "\"\"\"Update viewport margins.\"\"\"\ntop = 0\nleft = 0\nright = 0\nbottom = 0\nfor panel in self.panels_for_zone(Panel.Position.LEFT):\n    if panel.isVisible():\n        width = panel.sizeHint().width()\n        left += width\nfor panel in self.panels_for_zone(Panel.Position.RIGHT):\n    if panel.isVisible():\n        width = panel.sizeHint().width()\n        right += width\nfor panel in self.panels_for_zone(Panel.Position.TOP):\n    if panel.isVisible():\n        height = panel.sizeHint().height()\n        top += height\nfor panel in self.panels_for_zone(Panel.Position.BOTTOM):\n    if panel.isVisible():\n        height = panel.sizeHint().height()\n        bottom += height\nself._margin_sizes = top, left, right, bottom\nself.editor.setViewportMargins(left, top, right, bottom)\n"
    },
    {
        "functionName": "create_outlineexplorer",
        "className": null,
        "fileName": "/spyder/plugins/outlineexplorer/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "def _create_outlineexplorer(case, follow_cursor=False):\n    case_info = CASES[case]\n    filename = case_info['file']\n    with open(case_info['file'], 'r') as f:\n        text = f.read()\n    symbol_info = json.load(open(case_info['data'], 'r'))\n    expected_tree = json.load(open(case_info['tree'], 'r'))\n    code_editor = CodeEditor(None)\n    code_editor.set_language('py', filename)\n    code_editor.set_text(text)\n    editor = OutlineExplorerProxyEditor(code_editor, filename)\n    outlineexplorer = OutlineExplorerWidget(follow_cursor=follow_cursor,\n        display_variables=True, group_cells=True, show_comments=True)\n    outlineexplorer.register_editor(editor)\n    outlineexplorer.set_current_editor(editor, False, False)\n    outlineexplorer.show()\n    outlineexplorer.setFixedSize(400, 350)\n    editor.update_outline_info(symbol_info)\n    qtbot.addWidget(outlineexplorer)\n    return outlineexplorer, expected_tree\nreturn _create_outlineexplorer\npytest.fixture",
        "CUT_1": "self.outlineexplorer = outlineexplorer\n",
        "CUT_2": "self.outlineexplorer = outlineexplorer\n",
        "CUT_3": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n",
        "CUT_4": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n",
        "CUT_5": "self.outlineexplorer = outlineexplorer\nfor editorstack in self.editorstacks:\n    editorstack.set_outlineexplorer(self.outlineexplorer.explorer)\nself.outlineexplorer.explorer.edit_goto.connect(lambda filenames, goto,\n    word: self.load(filenames=filenames, goto=goto, word=word, editorwindow\n    =self))\nself.outlineexplorer.explorer.edit.connect(lambda filenames: self.load(\n    filenames=filenames, editorwindow=self))\n"
    },
    {
        "functionName": "_create_outlineexplorer",
        "className": null,
        "fileName": "/spyder/plugins/outlineexplorer/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "case_info = CASES[case]\nfilename = case_info['file']\nwith open(case_info['file'], 'r') as f:\n    text = f.read()\nsymbol_info = json.load(open(case_info['data'], 'r'))\nexpected_tree = json.load(open(case_info['tree'], 'r'))\ncode_editor = CodeEditor(None)\ncode_editor.set_language('py', filename)\ncode_editor.set_text(text)\neditor = OutlineExplorerProxyEditor(code_editor, filename)\noutlineexplorer = OutlineExplorerWidget(follow_cursor=follow_cursor,\n    display_variables=True, group_cells=True, show_comments=True)\noutlineexplorer.register_editor(editor)\noutlineexplorer.set_current_editor(editor, False, False)\noutlineexplorer.show()\noutlineexplorer.setFixedSize(400, 350)\neditor.update_outline_info(symbol_info)\nqtbot.addWidget(outlineexplorer)\nreturn outlineexplorer, expected_tree\n",
        "CUT_1": "self.outlineexplorer = outlineexplorer\n",
        "CUT_2": "self.outlineexplorer = outlineexplorer\n",
        "CUT_3": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n",
        "CUT_4": "\"\"\"Handles the change of the cursor inside the current editor.\"\"\"\ncode_editor = self.get_current_editor()\nfilename = code_editor.filename\nposition = code_editor.get_position('cursor')\nline, column = code_editor.get_cursor_line_column()\nself.add_cursor_position_to_history(to_text_string(filename), position,\n    line, column, fc=True)\n",
        "CUT_5": "self.outlineexplorer = outlineexplorer\nfor editorstack in self.editorstacks:\n    editorstack.set_outlineexplorer(self.outlineexplorer.explorer)\nself.outlineexplorer.explorer.edit_goto.connect(lambda filenames, goto,\n    word: self.load(filenames=filenames, goto=goto, word=word, editorwindow\n    =self))\nself.outlineexplorer.explorer.edit.connect(lambda filenames: self.load(\n    filenames=filenames, editorwindow=self))\n"
    },
    {
        "functionName": "test_outline_explorer",
        "className": null,
        "fileName": "/spyder/plugins/outlineexplorer/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test to assert the outline explorer is initializing correctly and\n    is showing the expected number of items, the expected type of items, and\n    the expected text for each item.\n    \"\"\"\noutlineexplorer, expected_tree = create_outlineexplorer(case)\nassert outlineexplorer\noutlineexplorer.treewidget.expandAll()\ntree_widget = outlineexplorer.treewidget\neditor = tree_widget.current_editor\nroot_item = tree_widget.get_top_level_items()[0]\nroot_ref = root_item.ref\nfilename = osp.basename(root_ref.name)\nroot_tree = {filename: []}\nstack = [(root_tree[filename], node) for node in root_ref.children]\nwhile len(stack) > 0:\n    parent_tree, node = stack.pop(0)\n    this_tree = {node.name: []}\n    parent_tree.append(this_tree)\n    this_stack = [(this_tree[node.name], child) for child in node.children]\n    stack = this_stack + stack\nassert root_tree == expected_tree\npytest.mark.parametrize('case', AVAILABLE_CASES)",
        "CUT_1": "self.id = node.id\nself.index = node.index\nself.path = node.path\nself.children = node.children\nself.status = node.status\nself.node = node.node\nself.parent = node.parent\nself.node.update_info(self.name, self.kind, self.position[0] + 1)\nself.node.ref = self\nfor child in self.children:\n    child.parent = self\nif self.parent is not None:\n    self.parent.replace_node(self.index, self)\n",
        "CUT_2": "self.id = node.id\nself.index = node.index\nself.path = node.path\nself.children = node.children\nself.status = node.status\nself.node = node.node\nself.parent = node.parent\nself.node.update_info(self.name, self.kind, self.position[0] + 1)\nself.node.ref = self\nfor child in self.children:\n    child.parent = self\nif self.parent is not None:\n    self.parent.replace_node(self.index, self)\n",
        "CUT_3": "from_keyword = False\nif isinstance(node, tree_nodes.Keyword):\n    from_keyword = True\n    if node.value in {'if', 'elif', 'with', 'while'}:\n        node, end_line = __handle_skip(stack, 2)\n    elif node.value in {'except'}:\n        first_node = stack[0]\n        if isinstance(first_node, tree_nodes.Operator):\n            node, end_line = __handle_skip(stack, 1)\n        else:\n            node, end_line = __handle_skip(stack, 2)\n    elif node.value in {'for'}:\n        node, end_line = __handle_skip(stack, 4)\n    elif node.value in {'else'}:\n        node, end_line = __handle_skip(stack, 1)\nreturn end_line, from_keyword, node, stack\n",
        "CUT_4": "self.children[index] = node\n",
        "CUT_5": "self.children[index] = node\n"
    },
    {
        "functionName": "test_go_to_cursor_position",
        "className": null,
        "fileName": "/spyder/plugins/outlineexplorer/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that clicking on the 'Go to cursor position' button located in the\n    toolbar of the outline explorer is working as expected.\n\n    Regression test for spyder-ide/spyder#7729.\n    \"\"\"\noutlineexplorer, _ = create_outlineexplorer('text')\neditor = outlineexplorer.treewidget.current_editor\neditor._editor.go_to_line(15)\nassert editor._editor.get_text_line(15) == '        return 2'\nassert outlineexplorer.treewidget.currentItem() is None\nqtbot.mouseClick(outlineexplorer.fromcursor_btn, Qt.LeftButton)\nassert outlineexplorer.treewidget.currentItem().text(0) == 'inner'\n",
        "CUT_1": "self.outlineexplorer = outlineexplorer\n",
        "CUT_2": "self.outlineexplorer = outlineexplorer\n",
        "CUT_3": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_4": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_5": "self.outlineexplorer = outlineexplorer\nfor editorstack in self.editorstacks:\n    editorstack.set_outlineexplorer(self.outlineexplorer.explorer)\nself.outlineexplorer.explorer.edit_goto.connect(lambda filenames, goto,\n    word: self.load(filenames=filenames, goto=goto, word=word, editorwindow\n    =self))\nself.outlineexplorer.explorer.edit.connect(lambda filenames: self.load(\n    filenames=filenames, editorwindow=self))\n"
    },
    {
        "functionName": "test_follow_cursor",
        "className": null,
        "fileName": "/spyder/plugins/outlineexplorer/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the cursor is followed.\n    \"\"\"\noutlineexplorer, _ = create_outlineexplorer('text', follow_cursor=True)\neditor = outlineexplorer.treewidget.current_editor\neditor._editor.go_to_line(45)\nassert editor._editor.get_text_line(45) == '        self.x = 2'\nassert outlineexplorer.treewidget.currentItem().text(0) == '__init__'\nqtbot.mouseClick(outlineexplorer.fromcursor_btn, Qt.LeftButton)\neditor._editor.go_to_line(1)\ntext = outlineexplorer.treewidget.currentItem().text(0)\nassert text == CASES['text']['file']\neditor._editor.go_to_line(37)\nassert outlineexplorer.treewidget.currentItem().text(0) == 'b'\n",
        "CUT_1": "self.outlineexplorer = outlineexplorer\n",
        "CUT_2": "self.outlineexplorer = outlineexplorer\n",
        "CUT_3": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_4": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_5": "if self._editor:\n    return self._editor()\nreturn None\nproperty"
    },
    {
        "functionName": "test_go_to_cursor_position_with_new_file",
        "className": null,
        "fileName": "/spyder/plugins/outlineexplorer/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that clicking on the 'Go to cursor position' button located in the\n    toolbar of the outline explorer is working as expected for newly created\n    files.\n\n    Regression test for spyder-ide/spyder#8510.\n    \"\"\"\noutlineexplorer, _ = create_outlineexplorer('text')\nfilename = CASES['text']['file']\nassert outlineexplorer.treewidget.currentItem() is None\nqtbot.mouseClick(outlineexplorer.fromcursor_btn, Qt.LeftButton)\nassert outlineexplorer.treewidget.currentItem().text(0) == filename\n",
        "CUT_1": "self.outlineexplorer = outlineexplorer\n",
        "CUT_2": "self.outlineexplorer = outlineexplorer\n",
        "CUT_3": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_4": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_5": "self.outlineexplorer = outlineexplorer\nfor editorstack in self.editorstacks:\n    editorstack.set_outlineexplorer(self.outlineexplorer.explorer)\nself.outlineexplorer.explorer.edit_goto.connect(lambda filenames, goto,\n    word: self.load(filenames=filenames, goto=goto, word=word, editorwindow\n    =self))\nself.outlineexplorer.explorer.edit.connect(lambda filenames: self.load(\n    filenames=filenames, editorwindow=self))\n"
    },
    {
        "functionName": "test_go_to_last_item",
        "className": null,
        "fileName": "/spyder/plugins/outlineexplorer/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that clicking on the 'Go to cursor position' button located in the\n    toolbar of the outline explorer is working as expected when the cursor\n    is located in the editor under the last item of the outline tree widget.\n\n    Regression test for spyder-ide/spyder#7744.\n    \"\"\"\noutlineexplorer, _ = create_outlineexplorer('text')\neditor = outlineexplorer.treewidget.current_editor\nline_count = editor._editor.document().blockCount() - 2\neditor._editor.go_to_line(line_count)\nassert editor._editor.get_text_line(line_count) == '        pass'\nassert outlineexplorer.treewidget.currentItem() is None\nqtbot.mouseClick(outlineexplorer.fromcursor_btn, Qt.LeftButton)\nassert outlineexplorer.treewidget.currentItem().text(0) == 'method1'\n",
        "CUT_1": "self.outlineexplorer = outlineexplorer\n",
        "CUT_2": "self.outlineexplorer = outlineexplorer\n",
        "CUT_3": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_4": "\"\"\"\n        Order the root file items of the outline explorer as in the tabbar\n        of the current EditorStack.\n        \"\"\"\nif self.outlineexplorer is not None:\n    self.outlineexplorer.treewidget.set_editor_ids_order([finfo.editor.\n        get_document_id() for finfo in self.data])\n",
        "CUT_5": "\"\"\"\n        Returns the line count of the specified editor.\n\n        :return: number of lines in the document.\n        \"\"\"\nreturn self._editor.document().blockCount()\n"
    },
    {
        "functionName": "test_code_cell_grouping",
        "className": null,
        "fileName": "/spyder/plugins/outlineexplorer/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test to assert the outline explorer is initializing correctly and\n    is showing the expected number of items, the expected type of items, and\n    the expected text for each item. In addition this tests ancestry, code\n    cells comments, code cell grouping and disabling this feature.\n    \"\"\"\noutlineexplorer = create_outlineexplorer(dedent(CODE), 'test_file.py')\nassert outlineexplorer\nexpected_results = [('test_file.py', FileRootItem), ('function0',\n    FunctionItem, 'test_file.py', 'test_file.py', False), ('Top level 1',\n    CellItem, 'test_file.py', 'test_file.py'), ('function1', FunctionItem,\n    'Top level 1', 'test_file.py', False), ('Cell Level 1-1', CellItem,\n    'Top level 1', 'test_file.py'), ('Cell Level 1-2', CellItem,\n    'Top level 1', 'test_file.py'), ('function2', FunctionItem,\n    'Cell Level 1-2', 'test_file.py', False), ('inside', FunctionItem,\n    'function2', 'function2', False), ('Cell Level 2', CellItem,\n    'Cell Level 1-2', 'test_file.py'), ('Class2', ClassItem, 'Cell Level 2',\n    'test_file.py'), ('__init__', FunctionItem, 'Class2', 'Class2', True),\n    ('medthod1', FunctionItem, 'Class2', 'Class2', True), ('Cell level 4',\n    CellItem, 'Cell Level 2', 'test_file.py'), ('function4', FunctionItem,\n    'Cell level 4', 'test_file.py', False), ('Cell Level 3', CellItem,\n    'Cell Level 1-2', 'test_file.py'), ('function5', FunctionItem,\n    'Cell Level 3', 'test_file.py', False), ('Cell Level 6', CellItem,\n    'Cell Level 3', 'test_file.py'), ('Class3', ClassItem, 'Cell Level 6',\n    'test_file.py'), ('__init__', FunctionItem, 'Class3', 'Class3', True),\n    ('medthod1', FunctionItem, 'Class3', 'Class3', True), ('Top level 2',\n    CellItem, 'test_file.py', 'test_file.py'), ('Class4', ClassItem,\n    'Top level 2', 'test_file.py'), ('__init__', FunctionItem, 'Class4',\n    'Class4', True), ('medthod1', FunctionItem, 'Class4', 'Class4', True),\n    ('MGroup3', CellItem, 'test_file.py', 'test_file.py'), ('function6',\n    FunctionItem, 'MGroup3', 'MGroup3', False), ('MGroup4', CellItem,\n    'MGroup3', 'test_file.py'), ('Unnamed Cell, #2', CellItem,\n    'test_file.py', 'test_file.py'), ('Unnamed Cell, #3', CellItem,\n    'Unnamed Cell, #2', 'test_file.py'), ('Unnamed Cell, #4', CellItem,\n    'test_file.py', 'test_file.py'), ('Unnamed Cell, #1, #1', CellItem,\n    'test_file.py', 'test_file.py'), ('Unnamed Cell, #1, #2', CellItem,\n    'Unnamed Cell, #1, #1', 'test_file.py'), ('Unnamed Cell, #5', CellItem,\n    'test_file.py', 'test_file.py'), ('a, #1', CellItem, 'test_file.py',\n    'test_file.py'), ('a', FunctionItem, 'a, #1', 'test_file.py', False), (\n    'a, #2', CellItem, 'test_file.py', 'test_file.py'), ('b', CellItem,\n    'test_file.py', 'test_file.py'), ('b', FunctionItem, 'b',\n    'test_file.py', False)]\noutlineexplorer.treewidget.expandAll()\ntree_widget = outlineexplorer.treewidget\ncell_items = tree_widget.get_top_level_items() + tree_widget.get_items()\nassert len(cell_items) == len(expected_results)\nfor item, expected_result in zip(cell_items, expected_results):\n    assert item.text(0) == expected_result[0]\n    assert type(item) == expected_result[1]\n    if type(item) != FileRootItem:\n        assert item.parent().text(0) == expected_result[2]\n    if type(item) == FunctionItem:\n        assert item.is_method() == expected_result[4]\ntree_widget.toggle_group_cells(False)\ntree_widget.expandAll()\nflat_items = tree_widget.get_top_level_items() + tree_widget.get_items()\nassert len(flat_items) == len(expected_results)\nfor item, expected_result in zip(flat_items, expected_results):\n    assert item.text(0) == expected_result[0]\n    assert type(item) == expected_result[1]\n    if type(item) != FileRootItem:\n        assert item.parent().text(0) == expected_result[3]\n    if type(item) == FunctionItem:\n        assert item.is_method() == expected_result[4]\ntree_widget.toggle_group_cells(True)\ntree_widget.expandAll()\ncell_items2 = tree_widget.get_top_level_items() + tree_widget.get_items()\nassert len(cell_items2) == len(expected_results)\nfor item, expected_result in zip(cell_items2, expected_results):\n    assert item.text(0) == expected_result[0]\n    assert type(item) == expected_result[1]\n    if type(item) != FileRootItem:\n        assert item.parent().text(0) == expected_result[2]\n    if type(item) == FunctionItem:\n        assert item.is_method() == expected_result[4]\npytest.mark.skip(reason='Cell support is disabled temporarily')",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Get cell code for a given cell.\n\n        If the cell doesn't exist, raises an exception\n        \"\"\"\nselected_block = None\nif is_string(cell):\n    for oedata in self.cell_list():\n        if oedata.def_name == cell:\n            selected_block = oedata.block\n            break\nelif cell == 0:\n    selected_block = self.document().firstBlock()\nelse:\n    cell_list = list(self.cell_list())\n    if cell <= len(cell_list):\n        selected_block = cell_list[cell - 1].block\nif not selected_block:\n    raise RuntimeError('Cell {} not found.'.format(repr(cell)))\ncursor = QTextCursor(selected_block)\ncell_code, _ = self.get_cell_as_executable_code(cursor)\nreturn cell_code\n",
        "CUT_3": "\"\"\"\n        Get cell code for a given cell.\n\n        If the cell doesn't exist, raises an exception\n        \"\"\"\nselected_block = None\nif is_string(cell):\n    for oedata in self.cell_list():\n        if oedata.def_name == cell:\n            selected_block = oedata.block\n            break\nelif cell == 0:\n    selected_block = self.document().firstBlock()\nelse:\n    cell_list = list(self.cell_list())\n    if cell <= len(cell_list):\n        selected_block = cell_list[cell - 1].block\nif not selected_block:\n    raise RuntimeError('Cell {} not found.'.format(repr(cell)))\ncursor = QTextCursor(selected_block)\ncell_code, _ = self.get_cell_as_executable_code(cursor)\nreturn cell_code\n",
        "CUT_4": "\"\"\"Guess filename\"\"\"\nif osp.isfile(filename):\n    return filename\nif not filename.endswith('.py'):\n    filename += '.py'\nfor path in ([getcwd_or_home()] + sys.path):\n    fname = osp.join(path, filename)\n    if osp.isfile(fname):\n        return fname\n    elif osp.isfile(fname + '.py'):\n        return fname + '.py'\n    elif osp.isfile(fname + '.pyw'):\n        return fname + '.pyw'\nreturn filename\n",
        "CUT_5": "\"\"\"Guess filename\"\"\"\nif osp.isfile(filename):\n    return filename\nif not filename.endswith('.py'):\n    filename += '.py'\nfor path in ([getcwd_or_home()] + sys.path):\n    fname = osp.join(path, filename)\n    if osp.isfile(fname):\n        return fname\n    elif osp.isfile(fname + '.py'):\n        return fname + '.py'\n    elif osp.isfile(fname + '.pyw'):\n        return fname + '.pyw'\nreturn filename\n"
    },
    {
        "functionName": "help_plugin",
        "className": null,
        "fileName": "/spyder/plugins/help/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Help plugin fixture\"\"\"\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr == 'ipyconsole' or attr == 'editor':\n            return None\n        else:\n            return Mock()\nwindow = MainMock()\nhelp_plugin = Help(parent=window)\nwindow.setCentralWidget(help_plugin)\nwebview = help_plugin.rich_text.webview._webview\nif WEBENGINE:\n    help_plugin._webpage = webview.page()\nelse:\n    help_plugin._webpage = webview.page().mainFrame()\nqtbot.addWidget(window)\nwindow.show()\nreturn help_plugin\npytest.fixture",
        "CUT_1": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture",
        "CUT_2": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_3": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_4": "oe_options = self.outlineexplorer.explorer.get_options()\nwindow = EditorMainWindow(self, self.stack_menu_actions, self.toolbar_list,\n    self.menu_list, outline_explorer_options=oe_options)\nwindow.add_toolbars_to_menu('&View', window.get_toolbars())\nwindow.load_toolbars()\nwindow.resize(self.size())\nwindow.show()\nwindow.editorwidget.editorsplitter.editorstack.new_window = True\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\nreturn window\n",
        "CUT_5": "oe_options = self.outlineexplorer.explorer.get_options()\nwindow = EditorMainWindow(self, self.stack_menu_actions, self.toolbar_list,\n    self.menu_list, outline_explorer_options=oe_options)\nwindow.add_toolbars_to_menu('&View', window.get_toolbars())\nwindow.load_toolbars()\nwindow.resize(self.size())\nwindow.show()\nwindow.editorwidget.editorsplitter.editorstack.new_window = True\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\nreturn window\n"
    },
    {
        "functionName": "__getattr__",
        "className": "MainMock",
        "fileName": "/spyder/plugins/help/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if attr == 'ipyconsole' or attr == 'editor':\n    return None\nelse:\n    return Mock()\n",
        "CUT_1": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_2": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_3": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n",
        "CUT_4": "self[attr] = value\n",
        "CUT_5": "self[attr] = value\n"
    },
    {
        "functionName": "check_text",
        "className": null,
        "fileName": "/spyder/plugins/help/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Check if some text is present in a widget.\"\"\"\nif WEBENGINE:\n\n    def callback(data):\n        global html\n        html = data\n    widget.toHtml(callback)\n    try:\n        return text in html\n    except NameError:\n        return False\nelse:\n    return text in widget.toHtml()\n",
        "CUT_1": "\"\"\"Return the widget tooltip text.\"\"\"\nreturn ''\n",
        "CUT_2": "\"\"\"Return the widget tooltip text.\"\"\"\nreturn ''\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "return self.text\n"
    },
    {
        "functionName": "callback",
        "className": null,
        "fileName": "/spyder/plugins/help/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "global html\nhtml = data\n",
        "CUT_1": "\"\"\"Format an HTML page.\"\"\"\nreturn \"\"\"<!doctype html>\n<html><head><title>Python: %s</title>\n<meta charset=\"UTF-8\">\n</head><body>\n%s\n</body></html>\"\"\" % (\n    title, contents)\n",
        "CUT_2": "\"\"\"Format an HTML page.\"\"\"\nreturn \"\"\"<!doctype html>\n<html><head><title>Python: %s</title>\n<meta charset=\"UTF-8\">\n</head><body>\n%s\n</body></html>\"\"\" % (\n    title, contents)\n",
        "CUT_3": "return '<a href=\"%s.html\">%s</a>' % (name, name)\n",
        "CUT_4": "return '<a href=\"%s.html\">%s</a>' % (name, name)\n",
        "CUT_5": "\"\"\"Pydoc url handler for use with the pydoc server.\n\n    If the content_type is 'text/css', the _pydoc.css style\n    sheet is read and returned if it exits.\n\n    If the content_type is 'text/html', then the result of\n    get_html_page(url) is returned.\n\n    See https://github.com/python/cpython/blob/master/Lib/pydoc.py\n    \"\"\"\nclass _HTMLDoc(CustomHTMLDoc):\n\n    def page(self, title, contents):\n        \"\"\"Format an HTML page.\"\"\"\n        rich_text_font = get_font(option='rich_font').family()\n        plain_text_font = get_font(option='font').family()\n        if is_dark_interface():\n            css_path = 'static/css/dark_pydoc.css'\n        else:\n            css_path = 'static/css/light_pydoc.css'\n        css_link = ('<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\">' %\n            css_path)\n        code_style = ('<style>code {font-family: \"%s\"}</style>' %\n            plain_text_font)\n        html_page = (\n            \"\"\"<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Pydoc: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n%s%s</head><body style=\"clear:both;font-family:'%s'\">\n%s<div style=\"clear:both;padding-top:.7em;\">%s</div>\n</body></html>\"\"\"\n             % (title, css_link, code_style, rich_text_font, html_navbar(),\n            contents))\n        return html_page\n\n    def filelink(self, url, path):\n        return '<a href=\"getfile?key=%s\">%s</a>' % (url, path)\nhtml = _HTMLDoc()\ndef html_navbar():\n    version = html.escape('%s [%s, %s]' % (platform.python_version(),\n        platform.python_build()[0], platform.python_compiler()))\n    return (\n        \"\"\"\n            <div style='float:left'>\n                Python %s<br>%s\n            </div>\n            <div style='float:right'>\n                <div style='text-align:right; padding-bottom:.7em;'>\n                  <a href=\"index.html\">Module Index</a>\n                  : <a href=\"topics.html\">Topics</a>\n                  : <a href=\"keywords.html\">Keywords</a>\n                </div>\n                <div style='text-align:right;'>\n                    <form action=\"search\" style='display:inline;'>\n                      <input class=\"input-search\" type=text name=key size=\"22\">\n                      <input class=\"submit-search\" type=submit value=\"Search\">\n                    </form>\n                </div>\n            </div>\n            \"\"\"\n         % (version, html.escape(platform.platform(terse=True))))\ndef html_index():\n    \"\"\"Index page.\"\"\"\n\n    def bltinlink(name):\n        return '<a href=\"%s.html\">%s</a>' % (name, name)\n    heading = html.heading('<span>Index of Modules</span>')\n    names = [name for name in sys.builtin_module_names if name != '__main__']\n    contents = html.multicolumn(names, bltinlink)\n    contents = [heading, '<p>' + html.bigsection('Built-in Modules',\n        contents, css_class='builtin_modules')]\n    seen = {}\n    for dir in sys.path:\n        contents.append(html.index(dir, seen))\n    contents.append(\n        '<p class=\"ka_ping_yee\"><strong>pydoc</strong> by Ka-Ping Yee&lt;ping@lfw.org&gt;</p>'\n        )\n    return 'Index of Modules', ''.join(contents)\ndef html_search(key):\n    \"\"\"Search results page.\"\"\"\n    search_result = []\n\n    def callback(path, modname, desc):\n        if modname[-9:] == '.__init__':\n            modname = modname[:-9] + ' (package)'\n        search_result.append((modname, desc and '- ' + desc))\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore')\n        ModuleScanner().run(callback, key)\n\n    def bltinlink(name):\n        return '<a href=\"%s.html\">%s</a>' % (name, name)\n    results = []\n    heading = html.heading('Search Results')\n    for name, desc in search_result:\n        results.append(bltinlink(name) + desc)\n    contents = heading + html.bigsection('key = {}'.format(key), '<br>'.\n        join(results), css_class='search')\n    return 'Search Results', contents\ndef html_getfile(path):\n    \"\"\"Get and display a source file listing safely.\"\"\"\n    path = path.replace('%20', ' ')\n    with tokenize.open(path) as fp:\n        lines = html.escape(fp.read())\n    body = '<pre>%s</pre>' % lines\n    heading = html.heading('File Listing')\n    contents = heading + html.bigsection('File: {}'.format(path), body,\n        css_class='getfile')\n    return 'getfile %s' % path, contents\ndef html_topics():\n    \"\"\"Index of topic texts available.\"\"\"\n\n    def bltinlink(name):\n        return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n    heading = html.heading('Index of Topics') + '<br>'\n    names = sorted(Helper.topics.keys())\n    contents = html.multicolumn(names, bltinlink)\n    contents = heading + html.bigsection('Topics', contents, css_class='topics'\n        )\n    return 'Topics', contents\ndef html_keywords():\n    \"\"\"Index of keywords.\"\"\"\n    heading = html.heading('Index of Keywords')\n    names = sorted(Helper.keywords.keys())\n\n    def bltinlink(name):\n        return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n    contents = html.multicolumn(names, bltinlink)\n    contents = heading + '<br>' + html.bigsection('Keywords', contents,\n        css_class='keywords')\n    return 'Keywords', contents\ndef html_topicpage(topic):\n    \"\"\"Topic or keyword help page.\"\"\"\n    buf = io.StringIO()\n    htmlhelp = Helper(buf, buf)\n    contents, xrefs = htmlhelp._gettopic(topic)\n    if topic in htmlhelp.keywords:\n        title = 'Keyword'\n    else:\n        title = 'Topic'\n    heading = html.heading(title)\n    contents = '<pre>%s</pre>' % html.markup(contents)\n    contents = html.bigsection(topic, contents, css_class='topics')\n    if xrefs:\n        xrefs = sorted(xrefs.split())\n\n        def bltinlink(name):\n            return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n        xrefs = html.multicolumn(xrefs, bltinlink)\n        xrefs = html.html_section('Related help topics: ', xrefs, css_class\n            ='topics')\n    return '%s %s' % (title, topic), ''.join((heading, contents, xrefs))\ndef html_getobj(url):\n    obj = locate(url, forceload=1)\n    if obj is None and url != 'None':\n        raise ValueError(_(\n            'There was an error while retrieving documentation for the object you requested: Object could not be found'\n            ))\n    title = describe(obj)\n    content = html.document(obj, url)\n    return title, content\ndef html_error(url, exc):\n    heading = html.heading('Error')\n    if DEV:\n        contents = '<br>'.join(html.escape(line) for line in\n            format_exception_only(type(exc), exc))\n    else:\n        contents = '%s' % to_text_string(exc)\n    contents = heading + html.bigsection(url, contents, css_class='error')\n    return 'Error - %s' % url, contents\ndef get_html_page(url):\n    \"\"\"Generate an HTML page for url.\"\"\"\n    complete_url = url\n    if url.endswith('.html'):\n        url = url[:-5]\n    try:\n        if url in ('', 'index'):\n            title, content = html_index()\n        elif url == 'topics':\n            title, content = html_topics()\n        elif url == 'keywords':\n            title, content = html_keywords()\n        elif '=' in url:\n            op, _, url = url.partition('=')\n            if op == 'search?key':\n                title, content = html_search(url)\n            elif op == 'getfile?key':\n                title, content = html_getfile(url)\n            elif op == 'topic?key':\n                try:\n                    title, content = html_topicpage(url)\n                except ValueError:\n                    title, content = html_getobj(url)\n            elif op == 'get?key':\n                if url in ('', 'index'):\n                    title, content = html_index()\n                else:\n                    try:\n                        title, content = html_getobj(url)\n                    except ValueError:\n                        title, content = html_topicpage(url)\n            else:\n                raise ValueError(_(\n                    'There was an error while retrieving documentation for the object you requested: Bad URL %s'\n                    ) % url)\n        else:\n            title, content = html_getobj(url)\n    except Exception as exc:\n        title, content = html_error(complete_url, exc)\n    return html.page(title, content)\nif url.startswith('/'):\n    url = url[1:]\nif content_type == 'text/css':\n    path_here = os.path.dirname(os.path.realpath(__file__))\n    css_path = os.path.join(path_here, url)\n    with open(css_path) as fp:\n        return ''.join(fp.readlines())\nelif content_type == 'text/html':\n    return get_html_page(url)\nraise TypeError(_(\n    'There was an error while retrieving documentation for the object you requested: unknown content type %r for url %s'\n    ) % (content_type, url))\n"
    },
    {
        "functionName": "test_no_docs_message",
        "className": null,
        "fileName": "/spyder/plugins/help/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that no docs message is shown when instrospection plugins\n    can't get any info.\n    \"\"\"\nhelp_plugin.render_sphinx_doc(default_info_response())\nqtbot.waitUntil(lambda : check_text(help_plugin._webpage,\n    'No documentation available'), timeout=4000)\npytest.mark.skipif(PYQT_VERSION > '5.10', reason='Segfaults in PyQt 5.10+')",
        "CUT_1": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_2": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_3": "docs = pyfunction.get_doc()\ndocs = self._trim_docstring(docs, indents=0)\nreturn docs\n",
        "CUT_4": "docs = pyfunction.get_doc()\ndocs = self._trim_docstring(docs, indents=0)\nreturn docs\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_no_further_docs_message",
        "className": null,
        "fileName": "/spyder/plugins/help/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that no further docs message is shown when instrospection\n    plugins can get partial info.\n    \"\"\"\ninfo = default_info_response()\ninfo['name'] = 'foo'\ninfo['argspec'] = '(x, y)'\nhelp_plugin.render_sphinx_doc(info)\nqtbot.waitUntil(lambda : check_text(help_plugin._webpage,\n    'No further documentation available'), timeout=3000)\npytest.mark.skipif(PYQT_VERSION > '5.10', reason='Segfaults in PyQt 5.10+')",
        "CUT_1": "self.sig_outline_explorer_data_changed.emit(info)\nself.info = info\n",
        "CUT_2": "self.sig_outline_explorer_data_changed.emit(info)\nself.info = info\n",
        "CUT_3": "\"\"\"Get a formatted calltip and docstring from Fallback\"\"\"\nif info['docstring']:\n    if info['filename']:\n        filename = os.path.basename(info['filename'])\n        filename = os.path.splitext(filename)[0]\n    else:\n        filename = '<module>'\n    resp = dict(docstring=info['docstring'], name=filename, note='',\n        argspec='', calltip=None)\n    return resp\nelse:\n    return default_info_response()\n",
        "CUT_4": "\"\"\"Get a formatted calltip and docstring from Fallback\"\"\"\nif info['docstring']:\n    if info['filename']:\n        filename = os.path.basename(info['filename'])\n        filename = os.path.splitext(filename)[0]\n    else:\n        filename = '<module>'\n    resp = dict(docstring=info['docstring'], name=filename, note='',\n        argspec='', calltip=None)\n    return resp\nelse:\n    return default_info_response()\n",
        "CUT_5": "\"\"\"Return support status dict if path is under VCS root\"\"\"\nfor info in SUPPORTED:\n    vcs_path = osp.join(path, info['rootdir'])\n    if osp.isdir(vcs_path):\n        return info\n"
    },
    {
        "functionName": "test_help_opens_when_show_tutorial_unit",
        "className": null,
        "fileName": "/spyder/plugins/help/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    'Show tutorial' opens the help plugin if closed.\n\n    Test fix for spyder-ide/spyder#6317.\n    \"\"\"\nMockDockwidget = MagicMock()\nMockDockwidget.return_value.isVisible.return_value = False\nmockDockwidget_instance = MockDockwidget()\nmock_show_rich_text = Mock()\nhelp_plugin.dockwidget = mockDockwidget_instance\nhelp_plugin.show_rich_text = mock_show_rich_text\nhelp_plugin.show_tutorial()\nqtbot.wait(100)\nassert mock_show_rich_text.call_count == 1\nMockDockwidget.return_value.isVisible.return_value = True\nmockDockwidget_instance = MockDockwidget()\nhelp_plugin.dockwidget = mockDockwidget_instance\nhelp_plugin.show_tutorial()\nqtbot.wait(100)\nassert mock_show_rich_text.call_count == 2\npytest.mark.skipif(PYQT_VERSION > '5.10', reason='Segfaults in PyQt 5.10+')",
        "CUT_1": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_2": "\"\"\"\n        Bind help instance to this console.\n        \"\"\"\nself.shell.help = help_plugin\n",
        "CUT_3": "\"\"\"Show the Spyder tutorial.\"\"\"\nself.switch_to_plugin()\nself.get_widget().show_tutorial()\n",
        "CUT_4": "\"\"\"Show the Spyder tutorial.\"\"\"\nself.switch_to_plugin()\nself.get_widget().show_tutorial()\n",
        "CUT_5": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "richtext",
        "className": null,
        "fileName": "/spyder/plugins/help/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up richtext widget.\"\"\"\nwidget = RichText(None)\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "plaintext",
        "className": null,
        "fileName": "/spyder/plugins/help/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up plaintext widget.\"\"\"\nwidget = PlainText(None)\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_richtext",
        "className": null,
        "fileName": "/spyder/plugins/help/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run RichText.\"\"\"\nassert richtext\n",
        "CUT_1": "return _('Run')\n",
        "CUT_2": "return _('Run')\n",
        "CUT_3": "return self.create_icon('run')\n",
        "CUT_4": "return self.create_icon('run')\n",
        "CUT_5": "CONF.set('run', 'breakpoints', {})\n"
    },
    {
        "functionName": "test_plaintext",
        "className": null,
        "fileName": "/spyder/plugins/help/tests/test_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run PlainText.\"\"\"\nassert plaintext\n",
        "CUT_1": "return _('Run')\n",
        "CUT_2": "return _('Run')\n",
        "CUT_3": "return self.create_icon('run')\n",
        "CUT_4": "return self.create_icon('run')\n",
        "CUT_5": "CONF.set('run', 'breakpoints', {})\n"
    },
    {
        "functionName": "figbrowser",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"An empty figure browser widget fixture.\"\"\"\nfigbrowser = FigureBrowser()\nfigbrowser.set_shellwidget(Mock())\noptions = {'mute_inline_plotting': True, 'show_plot_outline': False,\n    'auto_fit_plotting': False}\nfigbrowser.setup(options)\nqtbot.addWidget(figbrowser)\nfigbrowser.show()\nfigbrowser.setMinimumSize(700, 500)\nreturn figbrowser\npytest.fixture",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Setup the figure browser with provided options.\"\"\"\nself.splitter.setContentsMargins(0, 0, 0, 0)\nfor option, value in options.items():\n    if option == 'auto_fit_plotting':\n        self.change_auto_fit_plotting(value)\n    elif option == 'mute_inline_plotting':\n        self.mute_inline_plotting = value\n    elif option == 'show_plot_outline':\n        self.show_fig_outline_in_viewer(value)\n    elif option == 'save_dir':\n        self.thumbnails_sb.save_dir = value\n",
        "CUT_3": "\"\"\"Setup the figure browser with provided options.\"\"\"\nself.splitter.setContentsMargins(0, 0, 0, 0)\nfor option, value in options.items():\n    if option == 'auto_fit_plotting':\n        self.change_auto_fit_plotting(value)\n    elif option == 'mute_inline_plotting':\n        self.mute_inline_plotting = value\n    elif option == 'show_plot_outline':\n        self.show_fig_outline_in_viewer(value)\n    elif option == 'save_dir':\n        self.thumbnails_sb.save_dir = value\n",
        "CUT_4": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_5": "return Document(DOC_URI, workspace, DOC)\npytest.fixture"
    },
    {
        "functionName": "create_figure",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create a matplotlib figure, save it to disk and return its data.\"\"\"\nfig = Figure()\ncanvas = FigureCanvasAgg(fig)\nax = fig.add_axes([0.15, 0.15, 0.7, 0.7])\nfig.set_size_inches(6, 4)\nax.plot(np.random.rand(10), '.', color='red')\nfig.savefig(figname)\nwith open(figname, 'rb') as img:\n    fig = img.read()\nreturn fig\n",
        "CUT_1": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n",
        "CUT_2": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n",
        "CUT_3": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_4": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_5": "\"\"\"Save the currently selected figure.\"\"\"\nself.save_figure_as(thumbnail.canvas.fig, thumbnail.canvas.fmt)\n"
    },
    {
        "functionName": "add_figures_to_browser",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Create and add bitmap figures to the figure browser. Also return a list\n    of the created figures data.\n    \"\"\"\nfext = '.svg' if fmt == 'image/svg+xml' else '.png'\nfigs = []\nfor i in range(nfig):\n    figname = osp.join(str(tmpdir), 'mplfig' + str(i) + fext)\n    figs.append(create_figure(figname))\n    figbrowser._handle_new_figure(figs[-1], fmt)\nassert len(figbrowser.thumbnails_sb._thumbnails) == nfig\nassert figbrowser.thumbnails_sb.get_current_index() == nfig - 1\nassert figbrowser.thumbnails_sb.current_thumbnail.canvas.fig == figs[-1]\nassert figbrowser.figviewer.figcanvas.fig == figs[-1]\nreturn figs\n",
        "CUT_1": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_2": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_3": "\"\"\"Save the figure to a file.\"\"\"\nfext, ffilt = {'image/png': ('.png', 'PNG (*.png)'), 'image/jpeg': ('.jpg',\n    'JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)'), 'image/svg+xml': ('.svg',\n    'SVG (*.svg);;PNG (*.png)')}[fmt]\nfigname = get_unique_figname(self.save_dir, 'Figure ' + datetime.datetime.\n    now().strftime('%Y-%m-%d %H%M%S'), fext)\nself.sig_redirect_stdio_requested.emit(False)\nfname, fext = getsavefilename(parent=self.parent(), caption='Save Figure',\n    basedir=figname, filters=ffilt, selectedfilter='', options=None)\nself.sig_redirect_stdio_requested.emit(True)\nif fname:\n    self.sig_save_dir_changed.emit(osp.dirname(fname))\n    save_figure_tofile(fig, fmt, fname)\n",
        "CUT_4": "\"\"\"Save the figure to a file.\"\"\"\nfext, ffilt = {'image/png': ('.png', 'PNG (*.png)'), 'image/jpeg': ('.jpg',\n    'JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)'), 'image/svg+xml': ('.svg',\n    'SVG (*.svg);;PNG (*.png)')}[fmt]\nfigname = get_unique_figname(self.save_dir, 'Figure ' + datetime.datetime.\n    now().strftime('%Y-%m-%d %H%M%S'), fext)\nself.sig_redirect_stdio_requested.emit(False)\nfname, fext = getsavefilename(parent=self.parent(), caption='Save Figure',\n    basedir=figname, filters=ffilt, selectedfilter='', options=None)\nself.sig_redirect_stdio_requested.emit(True)\nif fname:\n    self.sig_save_dir_changed.emit(osp.dirname(fname))\n    save_figure_tofile(fig, fmt, fname)\n",
        "CUT_5": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n"
    },
    {
        "functionName": "png_to_qimage",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Return a QImage from the raw data of a png image.\"\"\"\nqpix = QPixmap()\nqpix.loadFromData(png, 'image/png'.upper())\nreturn qpix.toImage()\n",
        "CUT_1": "\"\"\"Copy figure to clipboard.\"\"\"\nif self.fmt in ['image/png', 'image/jpeg']:\n    qpixmap = QPixmap()\n    qpixmap.loadFromData(self.fig, self.fmt.upper())\n    QApplication.clipboard().setImage(qpixmap.toImage())\nelif self.fmt == 'image/svg+xml':\n    svg_to_clipboard(self.fig)\nelse:\n    return\nself.blink_figure()\nSlot()",
        "CUT_2": "\"\"\"Copy figure to clipboard.\"\"\"\nif self.fmt in ['image/png', 'image/jpeg']:\n    qpixmap = QPixmap()\n    qpixmap.loadFromData(self.fig, self.fmt.upper())\n    QApplication.clipboard().setImage(qpixmap.toImage())\nelif self.fmt == 'image/svg+xml':\n    svg_to_clipboard(self.fig)\nelse:\n    return\nself.blink_figure()\nSlot()",
        "CUT_3": "\"\"\"Save the figure to a file.\"\"\"\nfext, ffilt = {'image/png': ('.png', 'PNG (*.png)'), 'image/jpeg': ('.jpg',\n    'JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)'), 'image/svg+xml': ('.svg',\n    'SVG (*.svg);;PNG (*.png)')}[fmt]\nfigname = get_unique_figname(self.save_dir, 'Figure ' + datetime.datetime.\n    now().strftime('%Y-%m-%d %H%M%S'), fext)\nself.sig_redirect_stdio_requested.emit(False)\nfname, fext = getsavefilename(parent=self.parent(), caption='Save Figure',\n    basedir=figname, filters=ffilt, selectedfilter='', options=None)\nself.sig_redirect_stdio_requested.emit(True)\nif fname:\n    self.sig_save_dir_changed.emit(osp.dirname(fname))\n    save_figure_tofile(fig, fmt, fname)\n",
        "CUT_4": "\"\"\"Save the figure to a file.\"\"\"\nfext, ffilt = {'image/png': ('.png', 'PNG (*.png)'), 'image/jpeg': ('.jpg',\n    'JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)'), 'image/svg+xml': ('.svg',\n    'SVG (*.svg);;PNG (*.png)')}[fmt]\nfigname = get_unique_figname(self.save_dir, 'Figure ' + datetime.datetime.\n    now().strftime('%Y-%m-%d %H%M%S'), fext)\nself.sig_redirect_stdio_requested.emit(False)\nfname, fext = getsavefilename(parent=self.parent(), caption='Save Figure',\n    basedir=figname, filters=ffilt, selectedfilter='', options=None)\nself.sig_redirect_stdio_requested.emit(True)\nif fname:\n    self.sig_save_dir_changed.emit(osp.dirname(fname))\n    save_figure_tofile(fig, fmt, fname)\n",
        "CUT_5": "\"\"\"Return True if variable is a PIL.Image image\"\"\"\ntry:\n    from PIL import Image\n    return isinstance(var, Image.Image)\nexcept:\n    return False\n"
    },
    {
        "functionName": "test_handle_new_figures",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the figure browser widget display correctly new figures in\n    its viewer and thumbnails scrollbar.\n    \"\"\"\nassert len(figbrowser.thumbnails_sb._thumbnails) == 0\nassert figbrowser.thumbnails_sb.current_thumbnail is None\nassert figbrowser.figviewer.figcanvas.fig is None\nfor i in range(3):\n    figname = osp.join(str(tmpdir), 'mplfig' + str(i) + fext)\n    fig = create_figure(figname)\n    figbrowser._handle_new_figure(fig, fmt)\n    assert len(figbrowser.thumbnails_sb._thumbnails) == i + 1\n    assert figbrowser.thumbnails_sb.get_current_index() == i\n    assert figbrowser.thumbnails_sb.current_thumbnail.canvas.fig == fig\n    assert figbrowser.figviewer.figcanvas.fig == fig\npytest.mark.firstpytest.mark.parametrize('fmt, fext', [('image/png', '.png'), (\n    'image/svg+xml', '.svg')])",
        "CUT_1": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n",
        "CUT_2": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n",
        "CUT_3": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_4": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "test_save_figure_to_file",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test saving png and svg figures to file with the figure browser.\n    \"\"\"\nfig = add_figures_to_browser(figbrowser, 1, tmpdir, fmt)[0]\nexpected_qpix = QPixmap()\nexpected_qpix.loadFromData(fig, fmt.upper())\nsaved_figname = osp.join(str(tmpdir), 'spyfig' + fext)\nmocker.patch('spyder.plugins.plots.widgets.figurebrowser.getsavefilename',\n    return_value=(saved_figname, fext))\nfigbrowser.save_figure()\nsaved_qpix = QPixmap()\nsaved_qpix.load(saved_figname)\nassert osp.exists(saved_figname)\nassert expected_qpix.toImage() == saved_qpix.toImage()\npytest.mark.parametrize('fmt, fext', [('image/png', '.png'), (\n    'image/svg+xml', '.svg'), ('image/svg+xml', '.png')])",
        "CUT_1": "\"\"\"Save the figure to a file.\"\"\"\nfext, ffilt = {'image/png': ('.png', 'PNG (*.png)'), 'image/jpeg': ('.jpg',\n    'JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)'), 'image/svg+xml': ('.svg',\n    'SVG (*.svg);;PNG (*.png)')}[fmt]\nfigname = get_unique_figname(self.save_dir, 'Figure ' + datetime.datetime.\n    now().strftime('%Y-%m-%d %H%M%S'), fext)\nself.sig_redirect_stdio_requested.emit(False)\nfname, fext = getsavefilename(parent=self.parent(), caption='Save Figure',\n    basedir=figname, filters=ffilt, selectedfilter='', options=None)\nself.sig_redirect_stdio_requested.emit(True)\nif fname:\n    self.sig_save_dir_changed.emit(osp.dirname(fname))\n    save_figure_tofile(fig, fmt, fname)\n",
        "CUT_2": "\"\"\"Save the figure to a file.\"\"\"\nfext, ffilt = {'image/png': ('.png', 'PNG (*.png)'), 'image/jpeg': ('.jpg',\n    'JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)'), 'image/svg+xml': ('.svg',\n    'SVG (*.svg);;PNG (*.png)')}[fmt]\nfigname = get_unique_figname(self.save_dir, 'Figure ' + datetime.datetime.\n    now().strftime('%Y-%m-%d %H%M%S'), fext)\nself.sig_redirect_stdio_requested.emit(False)\nfname, fext = getsavefilename(parent=self.parent(), caption='Save Figure',\n    basedir=figname, filters=ffilt, selectedfilter='', options=None)\nself.sig_redirect_stdio_requested.emit(True)\nif fname:\n    self.sig_save_dir_changed.emit(osp.dirname(fname))\n    save_figure_tofile(fig, fmt, fname)\n",
        "CUT_3": "\"\"\"Copy figure to clipboard.\"\"\"\nif self.fmt in ['image/png', 'image/jpeg']:\n    qpixmap = QPixmap()\n    qpixmap.loadFromData(self.fig, self.fmt.upper())\n    QApplication.clipboard().setImage(qpixmap.toImage())\nelif self.fmt == 'image/svg+xml':\n    svg_to_clipboard(self.fig)\nelse:\n    return\nself.blink_figure()\nSlot()",
        "CUT_4": "\"\"\"Copy figure to clipboard.\"\"\"\nif self.fmt in ['image/png', 'image/jpeg']:\n    qpixmap = QPixmap()\n    qpixmap.loadFromData(self.fig, self.fmt.upper())\n    QApplication.clipboard().setImage(qpixmap.toImage())\nelif self.fmt == 'image/svg+xml':\n    svg_to_clipboard(self.fig)\nelse:\n    return\nself.blink_figure()\nSlot()",
        "CUT_5": "\"\"\"\n        Load the figure from a png, jpg, or svg image, convert it in\n        a QPixmap, and force a repaint of the widget.\n        \"\"\"\nself.fig = fig\nself.fmt = fmt\nif fmt in ['image/png', 'image/jpeg']:\n    self._qpix_orig = QPixmap()\n    self._qpix_orig.loadFromData(fig, fmt.upper())\nelif fmt == 'image/svg+xml':\n    self._qpix_orig = QPixmap(svg_to_image(fig))\nself._qpix_scaled = self._qpix_orig\nself.fwidth = self._qpix_orig.width()\nself.fheight = self._qpix_orig.height()\n"
    },
    {
        "functionName": "test_save_all_figures",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test saving all figures contained in the thumbnail scrollbar in batch\n    into a single directory.\n    \"\"\"\nfigs = add_figures_to_browser(figbrowser, 3, tmpdir, fmt)\nmocker.patch('spyder.plugins.plots.widgets.figurebrowser.getexistingdirectory',\n    return_value=None)\nfignames = figbrowser.save_all_figures()\nassert fignames is None\nmocker.patch('spyder.plugins.plots.widgets.figurebrowser.getexistingdirectory',\n    return_value=str(tmpdir.mkdir('all_saved_figures')))\nfignames = figbrowser.save_all_figures()\nassert len(fignames) == len(figs)\nfor fig, figname in zip(figs, fignames):\n    expected_qpix = QPixmap()\n    expected_qpix.loadFromData(fig, fmt.upper())\n    saved_qpix = QPixmap()\n    saved_qpix.load(figname)\n    assert osp.exists(figname)\n    assert expected_qpix.toImage() == saved_qpix.toImage()\npytest.mark.parametrize('fmt', ['image/png', 'image/svg+xml'])",
        "CUT_1": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_2": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_3": "\"\"\"Copy figure to clipboard.\"\"\"\nif self.fmt in ['image/png', 'image/jpeg']:\n    qpixmap = QPixmap()\n    qpixmap.loadFromData(self.fig, self.fmt.upper())\n    QApplication.clipboard().setImage(qpixmap.toImage())\nelif self.fmt == 'image/svg+xml':\n    svg_to_clipboard(self.fig)\nelse:\n    return\nself.blink_figure()\nSlot()",
        "CUT_4": "\"\"\"Copy figure to clipboard.\"\"\"\nif self.fmt in ['image/png', 'image/jpeg']:\n    qpixmap = QPixmap()\n    qpixmap.loadFromData(self.fig, self.fmt.upper())\n    QApplication.clipboard().setImage(qpixmap.toImage())\nelif self.fmt == 'image/svg+xml':\n    svg_to_clipboard(self.fig)\nelse:\n    return\nself.blink_figure()\nSlot()",
        "CUT_5": "\"\"\"\n        Load the figure from a png, jpg, or svg image, convert it in\n        a QPixmap, and force a repaint of the widget.\n        \"\"\"\nself.fig = fig\nself.fmt = fmt\nif fmt in ['image/png', 'image/jpeg']:\n    self._qpix_orig = QPixmap()\n    self._qpix_orig.loadFromData(fig, fmt.upper())\nelif fmt == 'image/svg+xml':\n    self._qpix_orig = QPixmap(svg_to_image(fig))\nself._qpix_scaled = self._qpix_orig\nself.fwidth = self._qpix_orig.width()\nself.fheight = self._qpix_orig.height()\n"
    },
    {
        "functionName": "test_get_unique_figname",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the unique fig names work when saving only one and when\n    saving multiple figures.\n    \"\"\"\nfext = '.png'\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfigname = get_unique_figname(tmpdir, figname_root, fext)\nexpected = osp.join(tmpdir, '{}{}'.format(figname_root, fext))\nassert figname == expected\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor i in range(5):\n    figname = get_unique_figname(tmpdir, figname_root, fext, start_at_zero=True\n        )\n    with open(figname, 'w') as _:\n        pass\n    expected = osp.join(tmpdir, '{} ({}){}'.format(figname_root, i, fext))\n    assert figname == expected\n",
        "CUT_1": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_2": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_3": "\"\"\"Save the figure to a file.\"\"\"\nfext, ffilt = {'image/png': ('.png', 'PNG (*.png)'), 'image/jpeg': ('.jpg',\n    'JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)'), 'image/svg+xml': ('.svg',\n    'SVG (*.svg);;PNG (*.png)')}[fmt]\nfigname = get_unique_figname(self.save_dir, 'Figure ' + datetime.datetime.\n    now().strftime('%Y-%m-%d %H%M%S'), fext)\nself.sig_redirect_stdio_requested.emit(False)\nfname, fext = getsavefilename(parent=self.parent(), caption='Save Figure',\n    basedir=figname, filters=ffilt, selectedfilter='', options=None)\nself.sig_redirect_stdio_requested.emit(True)\nif fname:\n    self.sig_save_dir_changed.emit(osp.dirname(fname))\n    save_figure_tofile(fig, fmt, fname)\n",
        "CUT_4": "\"\"\"Save the figure to a file.\"\"\"\nfext, ffilt = {'image/png': ('.png', 'PNG (*.png)'), 'image/jpeg': ('.jpg',\n    'JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)'), 'image/svg+xml': ('.svg',\n    'SVG (*.svg);;PNG (*.png)')}[fmt]\nfigname = get_unique_figname(self.save_dir, 'Figure ' + datetime.datetime.\n    now().strftime('%Y-%m-%d %H%M%S'), fext)\nself.sig_redirect_stdio_requested.emit(False)\nfname, fext = getsavefilename(parent=self.parent(), caption='Save Figure',\n    basedir=figname, filters=ffilt, selectedfilter='', options=None)\nself.sig_redirect_stdio_requested.emit(True)\nif fname:\n    self.sig_save_dir_changed.emit(osp.dirname(fname))\n    save_figure_tofile(fig, fmt, fname)\n",
        "CUT_5": "\"\"\"\n    Append a number to \"root\" to form a filename that does not already exist\n    in \"dirname\".\n    \"\"\"\ni = 1\nfigname = '{}{}'.format(root, ext)\nif start_at_zero:\n    i = 0\n    figname = '{} ({}){}'.format(root, i, ext)\nwhile True:\n    if osp.exists(osp.join(dirname, figname)):\n        figname = '{} ({}){}'.format(root, i, ext)\n        i += 1\n    else:\n        return osp.join(dirname, figname)\n"
    },
    {
        "functionName": "test_close_current_figure",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that clearing the current figure works as expected.\n    \"\"\"\nfigs = add_figures_to_browser(figbrowser, 2, tmpdir, fmt)\nfigbrowser.close_figure()\nassert len(figbrowser.thumbnails_sb._thumbnails) == 1\nassert figbrowser.thumbnails_sb.get_current_index() == 0\nassert figbrowser.thumbnails_sb.current_thumbnail.canvas.fig == figs[0]\nassert figbrowser.figviewer.figcanvas.fig == figs[0]\nfigbrowser.close_figure()\nassert len(figbrowser.thumbnails_sb._thumbnails) == 0\nassert figbrowser.thumbnails_sb.get_current_index() == -1\nassert figbrowser.thumbnails_sb.current_thumbnail is None\nassert figbrowser.figviewer.figcanvas.fig is None\npytest.mark.parametrize('fmt', ['image/png', 'image/svg+xml'])",
        "CUT_1": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_2": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_3": "\"\"\"\n        Handle when a new figure is sent to the IPython console by the\n        kernel.\n        \"\"\"\nself.thumbnails_sb.add_thumbnail(fig, fmt)\n",
        "CUT_4": "\"\"\"\n        Handle when a new figure is sent to the IPython console by the\n        kernel.\n        \"\"\"\nself.thumbnails_sb.add_thumbnail(fig, fmt)\n",
        "CUT_5": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n"
    },
    {
        "functionName": "test_close_all_figures",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that clearing all figures displayed in the thumbnails scrollbar\n    works as expected.\n    \"\"\"\nadd_figures_to_browser(figbrowser, 3, tmpdir, fmt)\nfigbrowser.close_all_figures()\nassert len(figbrowser.thumbnails_sb._thumbnails) == 0\nassert figbrowser.thumbnails_sb.get_current_index() == -1\nassert figbrowser.thumbnails_sb.current_thumbnail is None\nassert figbrowser.figviewer.figcanvas.fig is None\nassert len(figbrowser.thumbnails_sb.findChildren(FigureThumbnail)) == 0\npytest.mark.parametrize('fmt', ['image/png', 'image/svg+xml'])",
        "CUT_1": "\"\"\"Close all the figures in the thumbnail scrollbar.\"\"\"\nself.thumbnails_sb.remove_all_thumbnails()\n",
        "CUT_2": "\"\"\"Close all the figures in the thumbnail scrollbar.\"\"\"\nself.thumbnails_sb.remove_all_thumbnails()\n",
        "CUT_3": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "\"\"\"Save all the figures in a selected directory.\"\"\"\nreturn self.thumbnails_sb.save_all_figures_as()\n"
    },
    {
        "functionName": "test_close_one_thumbnail",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the thumbnail is removed from the GUI.\n    \"\"\"\nadd_figures_to_browser(figbrowser, 2, tmpdir, fmt)\nassert len(figbrowser.thumbnails_sb.findChildren(FigureThumbnail)) == 2\nfigures = figbrowser.thumbnails_sb.findChildren(FigureThumbnail)\nfigbrowser.thumbnails_sb.remove_thumbnail(figures[0])\nqtbot.wait(200)\nassert len(figbrowser.thumbnails_sb.findChildren(FigureThumbnail)) == 1\npytest.mark.parametrize('fmt', ['image/png', 'image/svg+xml'])",
        "CUT_1": "\"\"\"Close all the figures in the thumbnail scrollbar.\"\"\"\nself.thumbnails_sb.remove_all_thumbnails()\n",
        "CUT_2": "\"\"\"Close all the figures in the thumbnail scrollbar.\"\"\"\nself.thumbnails_sb.remove_all_thumbnails()\n",
        "CUT_3": "\"\"\"Save all the figures in a selected directory.\"\"\"\nreturn self.thumbnails_sb.save_all_figures_as()\n",
        "CUT_4": "\"\"\"Save all the figures in a selected directory.\"\"\"\nreturn self.thumbnails_sb.save_all_figures_as()\n",
        "CUT_5": "\"\"\"\n        Reimplemented to handle communications between the figure explorer\n        and the kernel.\n        \"\"\"\nimg = None\ndata = msg['content']['data']\nif 'image/svg+xml' in data:\n    fmt = 'image/svg+xml'\n    img = data['image/svg+xml']\nelif 'image/png' in data:\n    fmt = 'image/png'\n    img = decodebytes(data['image/png'].encode('ascii'))\nelif 'image/jpeg' in data and self._jpg_supported:\n    fmt = 'image/jpeg'\n    img = decodebytes(data['image/jpeg'].encode('ascii'))\nif img is not None:\n    self.sig_new_inline_figure.emit(img, fmt)\n    if (self.figurebrowser is not None and self.figurebrowser.\n        mute_inline_plotting):\n        if not self.sended_render_message:\n            self._append_html(_(\n                \"\"\"<br><hr>\nFigures now render in the Plots pane by default. To make them also appear inline in the Console, uncheck \"Mute Inline Plotting\" under the Plots pane options menu. \n<hr><br>\"\"\"\n                ), before_prompt=True)\n            self.sended_render_message = True\n        return\nreturn super(FigureBrowserWidget, self)._handle_display_data(msg)\n"
    },
    {
        "functionName": "test_go_prev_next_thumbnail",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test go to previous and next thumbnail actions.\n    \"\"\"\nfigs = add_figures_to_browser(figbrowser, 3, tmpdir, fmt)\nfigbrowser.go_next_thumbnail()\nassert figbrowser.thumbnails_sb.get_current_index() == 0\nassert figbrowser.thumbnails_sb.current_thumbnail.canvas.fig == figs[0]\nassert figbrowser.figviewer.figcanvas.fig == figs[0]\nfigbrowser.go_previous_thumbnail()\nassert figbrowser.thumbnails_sb.get_current_index() == 2\nassert figbrowser.thumbnails_sb.current_thumbnail.canvas.fig == figs[2]\nassert figbrowser.figviewer.figcanvas.fig == figs[2]\nfigbrowser.go_previous_thumbnail()\nassert figbrowser.thumbnails_sb.get_current_index() == 1\nassert figbrowser.thumbnails_sb.current_thumbnail.canvas.fig == figs[1]\nassert figbrowser.figviewer.figcanvas.fig == figs[1]\npytest.mark.parametrize('fmt', ['image/png', 'image/svg+xml'])",
        "CUT_1": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_2": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_3": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n",
        "CUT_4": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n",
        "CUT_5": "\"\"\"Save the currently selected figure.\"\"\"\nif self.current_thumbnail is not None:\n    self.save_figure_as(self.current_thumbnail.canvas.fig, self.\n        current_thumbnail.canvas.fmt)\n"
    },
    {
        "functionName": "test_scroll_to_item",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test scroll to the item of ThumbnailScrollBar.\"\"\"\nnfig = 10\nadd_figures_to_browser(figbrowser, nfig, tmpdir, 'image/png')\nfigbrowser.setFixedSize(500, 500)\nfor __ in range(nfig // 2):\n    figbrowser.go_next_thumbnail()\n    qtbot.wait(500)\nscene = figbrowser.thumbnails_sb.scene\nspacing = scene.verticalSpacing()\nheight = scene.itemAt(0).sizeHint().height()\nheight_view = figbrowser.thumbnails_sb.scrollarea.viewport().height()\nexpected = spacing * (nfig // 2) + height * (nfig // 2 - 1) - (height_view -\n    height) // 2\nvsb = figbrowser.thumbnails_sb.scrollarea.verticalScrollBar()\nassert vsb.value() == expected\n",
        "CUT_1": "\"\"\"Scroll to the selected item of ThumbnailScrollBar.\"\"\"\nspacing_between_items = self.scene.verticalSpacing()\nheight_view = self.scrollarea.viewport().height()\nheight_item = self.scene.itemAt(index).sizeHint().height()\nheight_view_excluding_item = max(0, height_view - height_item)\nheight_of_top_items = spacing_between_items\nfor i in range(index):\n    item = self.scene.itemAt(i)\n    height_of_top_items += item.sizeHint().height()\n    height_of_top_items += spacing_between_items\npos_scroll = height_of_top_items - height_view_excluding_item // 2\nvsb = self.scrollarea.verticalScrollBar()\nvsb.setValue(pos_scroll)\n",
        "CUT_2": "\"\"\"Scroll to the selected item of ThumbnailScrollBar.\"\"\"\nspacing_between_items = self.scene.verticalSpacing()\nheight_view = self.scrollarea.viewport().height()\nheight_item = self.scene.itemAt(index).sizeHint().height()\nheight_view_excluding_item = max(0, height_view - height_item)\nheight_of_top_items = spacing_between_items\nfor i in range(index):\n    item = self.scene.itemAt(i)\n    height_of_top_items += item.sizeHint().height()\n    height_of_top_items += spacing_between_items\npos_scroll = height_of_top_items - height_view_excluding_item // 2\nvsb = self.scrollarea.verticalScrollBar()\nvsb.setValue(pos_scroll)\n",
        "CUT_3": "\"\"\"Setup the scrollarea that will contain the FigureThumbnails.\"\"\"\nself.view = QWidget()\nself.scene = QGridLayout(self.view)\nself.scene.setContentsMargins(0, 0, 0, 0)\nself.scene.setSpacing(5)\nself.scrollarea = QScrollArea()\nself.scrollarea.setWidget(self.view)\nself.scrollarea.setWidgetResizable(True)\nself.scrollarea.setFrameStyle(0)\nself.scrollarea.setViewportMargins(2, 2, 2, 2)\nself.scrollarea.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\nself.scrollarea.setMinimumWidth(self._min_scrollbar_width)\nself.scrollarea.setVerticalScrollBar(QScrollBar())\nself.scrollarea.installEventFilter(self)\nself.layout().setContentsMargins(0, 0, 0, 0)\nself.layout().setSpacing(0)\nreturn self.scrollarea\n",
        "CUT_4": "\"\"\"Setup the scrollarea that will contain the FigureThumbnails.\"\"\"\nself.view = QWidget()\nself.scene = QGridLayout(self.view)\nself.scene.setContentsMargins(0, 0, 0, 0)\nself.scene.setSpacing(5)\nself.scrollarea = QScrollArea()\nself.scrollarea.setWidget(self.view)\nself.scrollarea.setWidgetResizable(True)\nself.scrollarea.setFrameStyle(0)\nself.scrollarea.setViewportMargins(2, 2, 2, 2)\nself.scrollarea.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\nself.scrollarea.setMinimumWidth(self._min_scrollbar_width)\nself.scrollarea.setVerticalScrollBar(QScrollBar())\nself.scrollarea.installEventFilter(self)\nself.layout().setContentsMargins(0, 0, 0, 0)\nself.layout().setSpacing(0)\nreturn self.scrollarea\n",
        "CUT_5": "\"\"\"Scroll the scrollbar of the scrollarea up by a single step.\"\"\"\nvsb = self.scrollarea.verticalScrollBar()\nvsb.setValue(int(vsb.value() - vsb.singleStep()))\n"
    },
    {
        "functionName": "test_scroll_down_to_newest_plot",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the ThumbnailScrollBar is scrolled to the newest plot after\n    it is added to it.\n\n    Test that covers spyder-ide/spyder#10914.\n    \"\"\"\nfigbrowser.setFixedSize(500, 500)\nnfig = 8\nfor i in range(8):\n    newfig = create_figure(osp.join(str(tmpdir), 'new_mplfig{}.png'.format(i)))\n    figbrowser._handle_new_figure(newfig, 'image/png')\n    qtbot.wait(500)\nheight_view = figbrowser.thumbnails_sb.scrollarea.viewport().height()\nscene = figbrowser.thumbnails_sb.scene\nspacing = scene.verticalSpacing()\nheight = scene.itemAt(0).sizeHint().height()\nexpected = spacing * (nfig - 1) + height * nfig - height_view\nvsb = figbrowser.thumbnails_sb.scrollarea.verticalScrollBar()\nassert vsb.value() == expected\n",
        "CUT_1": "\"\"\"Scroll to the selected item of ThumbnailScrollBar.\"\"\"\nspacing_between_items = self.scene.verticalSpacing()\nheight_view = self.scrollarea.viewport().height()\nheight_item = self.scene.itemAt(index).sizeHint().height()\nheight_view_excluding_item = max(0, height_view - height_item)\nheight_of_top_items = spacing_between_items\nfor i in range(index):\n    item = self.scene.itemAt(i)\n    height_of_top_items += item.sizeHint().height()\n    height_of_top_items += spacing_between_items\npos_scroll = height_of_top_items - height_view_excluding_item // 2\nvsb = self.scrollarea.verticalScrollBar()\nvsb.setValue(pos_scroll)\n",
        "CUT_2": "\"\"\"Scroll to the selected item of ThumbnailScrollBar.\"\"\"\nspacing_between_items = self.scene.verticalSpacing()\nheight_view = self.scrollarea.viewport().height()\nheight_item = self.scene.itemAt(index).sizeHint().height()\nheight_view_excluding_item = max(0, height_view - height_item)\nheight_of_top_items = spacing_between_items\nfor i in range(index):\n    item = self.scene.itemAt(i)\n    height_of_top_items += item.sizeHint().height()\n    height_of_top_items += spacing_between_items\npos_scroll = height_of_top_items - height_view_excluding_item // 2\nvsb = self.scrollarea.verticalScrollBar()\nvsb.setValue(pos_scroll)\n",
        "CUT_3": "\"\"\"Setup the scrollarea that will contain the FigureThumbnails.\"\"\"\nself.view = QWidget()\nself.scene = QGridLayout(self.view)\nself.scene.setContentsMargins(0, 0, 0, 0)\nself.scene.setSpacing(5)\nself.scrollarea = QScrollArea()\nself.scrollarea.setWidget(self.view)\nself.scrollarea.setWidgetResizable(True)\nself.scrollarea.setFrameStyle(0)\nself.scrollarea.setViewportMargins(2, 2, 2, 2)\nself.scrollarea.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\nself.scrollarea.setMinimumWidth(self._min_scrollbar_width)\nself.scrollarea.setVerticalScrollBar(QScrollBar())\nself.scrollarea.installEventFilter(self)\nself.layout().setContentsMargins(0, 0, 0, 0)\nself.layout().setSpacing(0)\nreturn self.scrollarea\n",
        "CUT_4": "\"\"\"Setup the scrollarea that will contain the FigureThumbnails.\"\"\"\nself.view = QWidget()\nself.scene = QGridLayout(self.view)\nself.scene.setContentsMargins(0, 0, 0, 0)\nself.scene.setSpacing(5)\nself.scrollarea = QScrollArea()\nself.scrollarea.setWidget(self.view)\nself.scrollarea.setWidgetResizable(True)\nself.scrollarea.setFrameStyle(0)\nself.scrollarea.setViewportMargins(2, 2, 2, 2)\nself.scrollarea.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\nself.scrollarea.setMinimumWidth(self._min_scrollbar_width)\nself.scrollarea.setVerticalScrollBar(QScrollBar())\nself.scrollarea.installEventFilter(self)\nself.layout().setContentsMargins(0, 0, 0, 0)\nself.layout().setSpacing(0)\nreturn self.scrollarea\n",
        "CUT_5": "\"\"\"Scroll the scrollbar of the scrollarea up by a single step.\"\"\"\nvsb = self.scrollarea.verticalScrollBar()\nvsb.setValue(int(vsb.value() - vsb.singleStep()))\n"
    },
    {
        "functionName": "test_mouse_clicking_thumbnails",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test mouse clicking on thumbnails.\n    \"\"\"\nfigs = add_figures_to_browser(figbrowser, 3, tmpdir, fmt)\nfor i in [1, 0, 2]:\n    qtbot.mouseClick(figbrowser.thumbnails_sb._thumbnails[i].canvas, Qt.\n        LeftButton)\n    assert figbrowser.thumbnails_sb.get_current_index() == i\n    assert figbrowser.thumbnails_sb.current_thumbnail.canvas.fig == figs[i]\n    assert figbrowser.figviewer.figcanvas.fig == figs[i]\npytest.mark.parametrize('fmt', ['image/png', 'image/svg+xml'])",
        "CUT_1": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n",
        "CUT_2": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n",
        "CUT_3": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_4": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_5": "\"\"\"Save the currently selected figure.\"\"\"\nif self.current_thumbnail is not None:\n    self.save_figure_as(self.current_thumbnail.canvas.fig, self.\n        current_thumbnail.canvas.fmt)\n"
    },
    {
        "functionName": "test_save_thumbnails",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test saving figures by clicking on the thumbnail icon.\n    \"\"\"\nfigs = add_figures_to_browser(figbrowser, 3, tmpdir, fmt)\nfext = '.svg' if fmt == 'image/svg+xml' else '.png'\nfigname = osp.join(str(tmpdir), 'figname' + fext)\nmocker.patch('spyder.plugins.plots.widgets.figurebrowser.getsavefilename',\n    return_value=(figname, fext))\nfigbrowser.thumbnails_sb.set_current_index(1)\nfigbrowser.save_figure()\nexpected_qpix = QPixmap()\nexpected_qpix.loadFromData(figs[1], fmt.upper())\nsaved_qpix = QPixmap()\nsaved_qpix.load(figname)\nassert osp.exists(figname)\nassert expected_qpix.toImage() == saved_qpix.toImage()\npytest.mark.parametrize('fmt', ['image/png', 'image/svg+xml'])",
        "CUT_1": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_2": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_3": "\"\"\"Save the figure to a file.\"\"\"\nfext, ffilt = {'image/png': ('.png', 'PNG (*.png)'), 'image/jpeg': ('.jpg',\n    'JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)'), 'image/svg+xml': ('.svg',\n    'SVG (*.svg);;PNG (*.png)')}[fmt]\nfigname = get_unique_figname(self.save_dir, 'Figure ' + datetime.datetime.\n    now().strftime('%Y-%m-%d %H%M%S'), fext)\nself.sig_redirect_stdio_requested.emit(False)\nfname, fext = getsavefilename(parent=self.parent(), caption='Save Figure',\n    basedir=figname, filters=ffilt, selectedfilter='', options=None)\nself.sig_redirect_stdio_requested.emit(True)\nif fname:\n    self.sig_save_dir_changed.emit(osp.dirname(fname))\n    save_figure_tofile(fig, fmt, fname)\n",
        "CUT_4": "\"\"\"Save the figure to a file.\"\"\"\nfext, ffilt = {'image/png': ('.png', 'PNG (*.png)'), 'image/jpeg': ('.jpg',\n    'JPEG (*.jpg;*.jpeg;*.jpe;*.jfif)'), 'image/svg+xml': ('.svg',\n    'SVG (*.svg);;PNG (*.png)')}[fmt]\nfigname = get_unique_figname(self.save_dir, 'Figure ' + datetime.datetime.\n    now().strftime('%Y-%m-%d %H%M%S'), fext)\nself.sig_redirect_stdio_requested.emit(False)\nfname, fext = getsavefilename(parent=self.parent(), caption='Save Figure',\n    basedir=figname, filters=ffilt, selectedfilter='', options=None)\nself.sig_redirect_stdio_requested.emit(True)\nif fname:\n    self.sig_save_dir_changed.emit(osp.dirname(fname))\n    save_figure_tofile(fig, fmt, fname)\n",
        "CUT_5": "\"\"\"Copy figure to clipboard.\"\"\"\nif self.fmt in ['image/png', 'image/jpeg']:\n    qpixmap = QPixmap()\n    qpixmap.loadFromData(self.fig, self.fmt.upper())\n    QApplication.clipboard().setImage(qpixmap.toImage())\nelif self.fmt == 'image/svg+xml':\n    svg_to_clipboard(self.fig)\nelse:\n    return\nself.blink_figure()\nSlot()"
    },
    {
        "functionName": "test_close_thumbnails",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test closing figures by clicking on the thumbnail icon.\n    \"\"\"\nfigs = add_figures_to_browser(figbrowser, 3, tmpdir, fmt)\nfigbrowser.thumbnails_sb.set_current_index(1)\nfigbrowser.close_figure()\ndel figs[1]\nassert len(figbrowser.thumbnails_sb._thumbnails) == len(figs)\nassert figbrowser.thumbnails_sb._thumbnails[0].canvas.fig == figs[0]\nassert figbrowser.thumbnails_sb._thumbnails[1].canvas.fig == figs[1]\npytest.mark.parametrize('fmt', ['image/png', 'image/svg+xml'])",
        "CUT_1": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_2": "\"\"\"Save all figure in dirname.\"\"\"\nfignames = []\nfigname_root = 'Figure ' + datetime.datetime.now().strftime('%Y-%m-%d %H%M%S')\nfor thumbnail in self._thumbnails:\n    fig = thumbnail.canvas.fig\n    fmt = thumbnail.canvas.fmt\n    fext = {'image/png': '.png', 'image/jpeg': '.jpg', 'image/svg+xml': '.svg'\n        }[fmt]\n    figname = get_unique_figname(dirname, figname_root, fext, start_at_zero\n        =True)\n    save_figure_tofile(fig, fmt, figname)\n    fignames.append(figname)\nreturn fignames\n",
        "CUT_3": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n",
        "CUT_4": "\"\"\"Save fig to fname in the format specified by fmt.\"\"\"\nroot, ext = osp.splitext(fname)\nif ext == '.png' and fmt == 'image/svg+xml':\n    qimg = svg_to_image(fig)\n    qimg.save(fname)\nelse:\n    if fmt == 'image/svg+xml' and isinstance(fig, str):\n        fig = fig.encode('utf-8')\n    with open(fname, 'wb') as f:\n        f.write(fig)\n",
        "CUT_5": "\"\"\"Save the currently selected figure.\"\"\"\nself.save_figure_as(thumbnail.canvas.fig, thumbnail.canvas.fmt)\n"
    },
    {
        "functionName": "test_copy_png_to_clipboard",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test copying png figures to the clipboard.\n    \"\"\"\nfigs = add_figures_to_browser(figbrowser, 3, tmpdir, 'image/png')\nclipboard = QApplication.clipboard()\nfigbrowser.copy_figure()\nassert clipboard.image() == png_to_qimage(figs[-1])\nfigbrowser.go_next_thumbnail()\nfigbrowser.copy_figure()\nassert clipboard.image() == png_to_qimage(figs[0])\n",
        "CUT_1": "\"\"\"Import text/data/code from clipboard\"\"\"\nclipboard = QApplication.clipboard()\ncliptext = ''\nif clipboard.mimeData().hasText():\n    cliptext = to_text_string(clipboard.text())\nif cliptext.strip():\n    self.import_from_string(cliptext, title=_('Import from clipboard'))\nelse:\n    QMessageBox.warning(self, _('Empty clipboard'), _(\n        'Nothing to be imported from clipboard.'))\nSlot()",
        "CUT_2": "\"\"\"Import text/data/code from clipboard\"\"\"\nclipboard = QApplication.clipboard()\ncliptext = ''\nif clipboard.mimeData().hasText():\n    cliptext = to_text_string(clipboard.text())\nif cliptext.strip():\n    self.import_from_string(cliptext, title=_('Import from clipboard'))\nelse:\n    QMessageBox.warning(self, _('Empty clipboard'), _(\n        'Nothing to be imported from clipboard.'))\nSlot()",
        "CUT_3": "\"\"\"Copy text to clipboard\"\"\"\ncliptxt = self._sel_to_text(self.selectedIndexes())\nclipboard = QApplication.clipboard()\nclipboard.setText(cliptxt)\nSlot()",
        "CUT_4": "\"\"\"Copy text to clipboard\"\"\"\ncliptxt = self._sel_to_text(self.selectedIndexes())\nclipboard = QApplication.clipboard()\nclipboard.setText(cliptxt)\nSlot()",
        "CUT_5": "\"\"\"\n        Reimplement Qt method\n        Copy text to clipboard with correct EOL chars\n        \"\"\"\nif self.get_selected_text():\n    QApplication.clipboard().setText(self.get_selected_text())\nSlot()"
    },
    {
        "functionName": "test_copy_svg_to_clipboard",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test copying svg figures to the clipboard.\n    \"\"\"\nfigs = add_figures_to_browser(figbrowser, 3, tmpdir, 'image/svg+xml')\nclipboard = QApplication.clipboard()\nfigbrowser.copy_figure()\nassert clipboard.mimeData().data('image/svg+xml') == figs[-1]\nfigbrowser.go_next_thumbnail()\nfigbrowser.copy_figure()\nassert clipboard.mimeData().data('image/svg+xml') == figs[0]\n",
        "CUT_1": "\"\"\"Import text/data/code from clipboard\"\"\"\nclipboard = QApplication.clipboard()\ncliptext = ''\nif clipboard.mimeData().hasText():\n    cliptext = to_text_string(clipboard.text())\nif cliptext.strip():\n    self.import_from_string(cliptext, title=_('Import from clipboard'))\nelse:\n    QMessageBox.warning(self, _('Empty clipboard'), _(\n        'Nothing to be imported from clipboard.'))\nSlot()",
        "CUT_2": "\"\"\"Import text/data/code from clipboard\"\"\"\nclipboard = QApplication.clipboard()\ncliptext = ''\nif clipboard.mimeData().hasText():\n    cliptext = to_text_string(clipboard.text())\nif cliptext.strip():\n    self.import_from_string(cliptext, title=_('Import from clipboard'))\nelse:\n    QMessageBox.warning(self, _('Empty clipboard'), _(\n        'Nothing to be imported from clipboard.'))\nSlot()",
        "CUT_3": "\"\"\"Copy text to clipboard\"\"\"\ncliptxt = self._sel_to_text(self.selectedIndexes())\nclipboard = QApplication.clipboard()\nclipboard.setText(cliptxt)\nSlot()",
        "CUT_4": "\"\"\"Copy text to clipboard\"\"\"\ncliptxt = self._sel_to_text(self.selectedIndexes())\nclipboard = QApplication.clipboard()\nclipboard.setText(cliptxt)\nSlot()",
        "CUT_5": "\"\"\"Copy figure to clipboard.\"\"\"\nif self.fmt in ['image/png', 'image/jpeg']:\n    qpixmap = QPixmap()\n    qpixmap.loadFromData(self.fig, self.fmt.upper())\n    QApplication.clipboard().setImage(qpixmap.toImage())\nelif self.fmt == 'image/svg+xml':\n    svg_to_clipboard(self.fig)\nelse:\n    return\nself.blink_figure()\nSlot()"
    },
    {
        "functionName": "test_zoom_figure_viewer",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test zooming in and out the figure diplayed in the figure viewer.\n    \"\"\"\nfig = add_figures_to_browser(figbrowser, 1, tmpdir, fmt)[0]\nfigcanvas = figbrowser.figviewer.figcanvas\nfigbrowser.change_auto_fit_plotting(False)\nqpix = QPixmap()\nqpix.loadFromData(fig, fmt.upper())\nfwidth, fheight = qpix.width(), qpix.height()\nassert figbrowser.zoom_disp_value == 100\nassert figcanvas.width() == fwidth\nassert figcanvas.height() == fheight\nscaling_factor = 0\nscaling_step = figbrowser.figviewer._scalestep\nfor zoom_step in [1, 1, -1, -1, -1]:\n    if zoom_step == 1:\n        figbrowser.zoom_in()\n    elif zoom_step == -1:\n        figbrowser.zoom_out()\n    scaling_factor += zoom_step\n    scale = scaling_step ** scaling_factor\n    assert figbrowser.zoom_disp_value == np.round(int(fwidth * scale) /\n        fwidth * 100)\n    assert figcanvas.width() == int(fwidth * scale)\n    assert figcanvas.height() == int(fheight * scale)\npytest.mark.parametrize('fmt', ['image/png', 'image/svg+xml'])",
        "CUT_1": "\"\"\"Scale the image size.\"\"\"\nfwidth = self.figcanvas.fwidth\nfheight = self.figcanvas.fheight\nif not self.auto_fit_plotting:\n    new_width = int(fwidth * self._scalestep ** self._scalefactor)\n    new_height = int(fheight * self._scalestep ** self._scalefactor)\nelse:\n    size = self.size()\n    style = self.style()\n    width = size.width() - style.pixelMetric(QStyle.PM_LayoutLeftMargin\n        ) - style.pixelMetric(QStyle.PM_LayoutRightMargin)\n    height = size.height() - style.pixelMetric(QStyle.PM_LayoutTopMargin\n        ) - style.pixelMetric(QStyle.PM_LayoutBottomMargin)\n    self.figcanvas.setToolTip('')\n    try:\n        if fwidth / fheight > width / height:\n            new_width = int(width)\n            new_height = int(width / fwidth * fheight)\n        else:\n            new_height = int(height)\n            new_width = int(height / fheight * fwidth)\n    except ZeroDivisionError:\n        icon = self.create_icon('broken_image')\n        self.figcanvas._qpix_orig = icon.pixmap(fwidth, fheight)\n        self.figcanvas.setToolTip(_(\n            'The image is broken, please try to generate it again'))\n        new_width = fwidth\n        new_height = fheight\nif self.figcanvas.size() != QSize(new_width, new_height):\n    self.figcanvas.setFixedSize(new_width, new_height)\n    self.sig_zoom_changed.emit(self.get_scaling())\n",
        "CUT_2": "\"\"\"Scale the image size.\"\"\"\nfwidth = self.figcanvas.fwidth\nfheight = self.figcanvas.fheight\nif not self.auto_fit_plotting:\n    new_width = int(fwidth * self._scalestep ** self._scalefactor)\n    new_height = int(fheight * self._scalestep ** self._scalefactor)\nelse:\n    size = self.size()\n    style = self.style()\n    width = size.width() - style.pixelMetric(QStyle.PM_LayoutLeftMargin\n        ) - style.pixelMetric(QStyle.PM_LayoutRightMargin)\n    height = size.height() - style.pixelMetric(QStyle.PM_LayoutTopMargin\n        ) - style.pixelMetric(QStyle.PM_LayoutBottomMargin)\n    self.figcanvas.setToolTip('')\n    try:\n        if fwidth / fheight > width / height:\n            new_width = int(width)\n            new_height = int(width / fwidth * fheight)\n        else:\n            new_height = int(height)\n            new_width = int(height / fheight * fwidth)\n    except ZeroDivisionError:\n        icon = self.create_icon('broken_image')\n        self.figcanvas._qpix_orig = icon.pixmap(fwidth, fheight)\n        self.figcanvas.setToolTip(_(\n            'The image is broken, please try to generate it again'))\n        new_width = fwidth\n        new_height = fheight\nif self.figcanvas.size() != QSize(new_width, new_height):\n    self.figcanvas.setFixedSize(new_width, new_height)\n    self.sig_zoom_changed.emit(self.get_scaling())\n",
        "CUT_3": "\"\"\"Get the current scaling of the figure in percent.\"\"\"\nreturn round(self.figcanvas.width() / self.figcanvas.fwidth * 100)\n",
        "CUT_4": "\"\"\"Get the current scaling of the figure in percent.\"\"\"\nreturn round(self.figcanvas.width() / self.figcanvas.fwidth * 100)\n",
        "CUT_5": "\"\"\"Set a new figure in the figure canvas.\"\"\"\nself.figcanvas.load_figure(fig, fmt)\nself.sig_figure_loaded.emit()\nself.scale_image()\nself.figcanvas.repaint()\n"
    },
    {
        "functionName": "test_autofit_figure_viewer",
        "className": null,
        "fileName": "/spyder/plugins/plots/widgets/tests/test_plots_widgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test figure diplayed when `Fit plots to window` is True.\n    \"\"\"\nfig = add_figures_to_browser(figbrowser, 1, tmpdir, fmt)[0]\nfigviewer = figbrowser.figviewer\nfigcanvas = figviewer.figcanvas\nqpix = QPixmap()\nqpix.loadFromData(fig, fmt.upper())\nfwidth, fheight = qpix.width(), qpix.height()\nfigbrowser.change_auto_fit_plotting(True)\nsize = figviewer.size()\nstyle = figviewer.style()\nwidth = size.width() - style.pixelMetric(QStyle.PM_LayoutLeftMargin\n    ) - style.pixelMetric(QStyle.PM_LayoutRightMargin)\nheight = size.height() - style.pixelMetric(QStyle.PM_LayoutTopMargin\n    ) - style.pixelMetric(QStyle.PM_LayoutBottomMargin)\nif fwidth / fheight > width / height:\n    new_width = int(width)\n    new_height = int(width / fwidth * fheight)\nelse:\n    new_height = int(height)\n    new_width = int(height / fheight * fwidth)\nassert figcanvas.width() == new_width\nassert figcanvas.height() == new_height\nassert figbrowser.zoom_disp_value == round(figcanvas.width() / fwidth * 100)\npytest.mark.parametrize('fmt', ['image/png', 'image/svg+xml'])",
        "CUT_1": "\"\"\"Scale the image size.\"\"\"\nfwidth = self.figcanvas.fwidth\nfheight = self.figcanvas.fheight\nif not self.auto_fit_plotting:\n    new_width = int(fwidth * self._scalestep ** self._scalefactor)\n    new_height = int(fheight * self._scalestep ** self._scalefactor)\nelse:\n    size = self.size()\n    style = self.style()\n    width = size.width() - style.pixelMetric(QStyle.PM_LayoutLeftMargin\n        ) - style.pixelMetric(QStyle.PM_LayoutRightMargin)\n    height = size.height() - style.pixelMetric(QStyle.PM_LayoutTopMargin\n        ) - style.pixelMetric(QStyle.PM_LayoutBottomMargin)\n    self.figcanvas.setToolTip('')\n    try:\n        if fwidth / fheight > width / height:\n            new_width = int(width)\n            new_height = int(width / fwidth * fheight)\n        else:\n            new_height = int(height)\n            new_width = int(height / fheight * fwidth)\n    except ZeroDivisionError:\n        icon = self.create_icon('broken_image')\n        self.figcanvas._qpix_orig = icon.pixmap(fwidth, fheight)\n        self.figcanvas.setToolTip(_(\n            'The image is broken, please try to generate it again'))\n        new_width = fwidth\n        new_height = fheight\nif self.figcanvas.size() != QSize(new_width, new_height):\n    self.figcanvas.setFixedSize(new_width, new_height)\n    self.sig_zoom_changed.emit(self.get_scaling())\n",
        "CUT_2": "\"\"\"Scale the image size.\"\"\"\nfwidth = self.figcanvas.fwidth\nfheight = self.figcanvas.fheight\nif not self.auto_fit_plotting:\n    new_width = int(fwidth * self._scalestep ** self._scalefactor)\n    new_height = int(fheight * self._scalestep ** self._scalefactor)\nelse:\n    size = self.size()\n    style = self.style()\n    width = size.width() - style.pixelMetric(QStyle.PM_LayoutLeftMargin\n        ) - style.pixelMetric(QStyle.PM_LayoutRightMargin)\n    height = size.height() - style.pixelMetric(QStyle.PM_LayoutTopMargin\n        ) - style.pixelMetric(QStyle.PM_LayoutBottomMargin)\n    self.figcanvas.setToolTip('')\n    try:\n        if fwidth / fheight > width / height:\n            new_width = int(width)\n            new_height = int(width / fwidth * fheight)\n        else:\n            new_height = int(height)\n            new_width = int(height / fheight * fwidth)\n    except ZeroDivisionError:\n        icon = self.create_icon('broken_image')\n        self.figcanvas._qpix_orig = icon.pixmap(fwidth, fheight)\n        self.figcanvas.setToolTip(_(\n            'The image is broken, please try to generate it again'))\n        new_width = fwidth\n        new_height = fheight\nif self.figcanvas.size() != QSize(new_width, new_height):\n    self.figcanvas.setFixedSize(new_width, new_height)\n    self.sig_zoom_changed.emit(self.get_scaling())\n",
        "CUT_3": "\"\"\"Copy figure from figviewer to clipboard.\"\"\"\nif self.figviewer and self.figviewer.figcanvas.fig:\n    self.figviewer.figcanvas.copy_figure()\n",
        "CUT_4": "\"\"\"Copy figure from figviewer to clipboard.\"\"\"\nif self.figviewer and self.figviewer.figcanvas.fig:\n    self.figviewer.figcanvas.copy_figure()\n",
        "CUT_5": "\"\"\"Get the current scaling of the figure in percent.\"\"\"\nreturn round(self.figcanvas.width() / self.figcanvas.fwidth * 100)\n"
    },
    {
        "functionName": "console_plugin",
        "className": null,
        "fileName": "/spyder/plugins/console/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Console plugin fixture.\"\"\"\nclass MainWindowMock(QMainWindow):\n\n    def __init__(self):\n        super().__init__()\n        self._INTERNAL_PLUGINS = {'internal_console': Console}\n\n    def __getattr__(self, attr):\n        if attr != '_INTERNAL_PLUGINS':\n            return Mock()\n        else:\n            return self.__dict__[attr]\nwindow = MainWindowMock()\nconsole_plugin = Console(parent=window, configuration=CONF)\nconsole_plugin.start_interpreter({})\nwindow.setCentralWidget(console_plugin.get_widget())\nqtbot.addWidget(window)\nwindow.resize(640, 480)\nwindow.show()\nreturn console_plugin\npytest.fixture",
        "CUT_1": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture",
        "CUT_2": "oe_options = self.outlineexplorer.explorer.get_options()\nwindow = EditorMainWindow(self, self.stack_menu_actions, self.toolbar_list,\n    self.menu_list, outline_explorer_options=oe_options)\nwindow.add_toolbars_to_menu('&View', window.get_toolbars())\nwindow.load_toolbars()\nwindow.resize(self.size())\nwindow.show()\nwindow.editorwidget.editorsplitter.editorstack.new_window = True\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\nreturn window\n",
        "CUT_3": "oe_options = self.outlineexplorer.explorer.get_options()\nwindow = EditorMainWindow(self, self.stack_menu_actions, self.toolbar_list,\n    self.menu_list, outline_explorer_options=oe_options)\nwindow.add_toolbars_to_menu('&View', window.get_toolbars())\nwindow.load_toolbars()\nwindow.resize(self.size())\nwindow.show()\nwindow.editorwidget.editorsplitter.editorstack.new_window = True\nself.register_editorwindow(window)\nwindow.destroyed.connect(lambda : self.unregister_editorwindow(window))\nreturn window\n",
        "CUT_4": "\"\"\"Create a QMainWindow instance containing this plugin.\"\"\"\nself._undocked_window = window = PluginWindow(self)\nwindow.setAttribute(Qt.WA_DeleteOnClose)\nicon = self.get_plugin_icon()\nif is_text_string(icon):\n    icon = self.get_icon(icon)\nwindow.setWindowIcon(icon)\nwindow.setWindowTitle(self.get_plugin_title())\nwindow.setCentralWidget(self)\nwindow.resize(self.size())\nself.refresh_plugin()\nself.set_ancestor(window)\nself.dockwidget.setFloating(False)\nself.dockwidget.setVisible(False)\nwindow.show()\nSlot()",
        "CUT_5": "\"\"\"Create a QMainWindow instance containing this plugin.\"\"\"\nself._undocked_window = window = PluginWindow(self)\nwindow.setAttribute(Qt.WA_DeleteOnClose)\nicon = self.get_plugin_icon()\nif is_text_string(icon):\n    icon = self.get_icon(icon)\nwindow.setWindowIcon(icon)\nwindow.setWindowTitle(self.get_plugin_title())\nwindow.setCentralWidget(self)\nwindow.resize(self.size())\nself.refresh_plugin()\nself.set_ancestor(window)\nself.dockwidget.setFloating(False)\nself.dockwidget.setVisible(False)\nwindow.show()\nSlot()"
    },
    {
        "functionName": "__init__",
        "className": "MainWindowMock",
        "fileName": "/spyder/plugins/console/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "super().__init__()\nself._INTERNAL_PLUGINS = {'internal_console': Console}\n",
        "CUT_1": "\"\"\"\n        Set the internal console shell.\n\n        Parameters\n        ----------\n        console: :py:class:spyder.plugins.console.plugin.Console\n            Console plugin.\n        \"\"\"\nself.internal_console = console\nself.internal_shell = console.get_widget().shell\n",
        "CUT_2": "\"\"\"\n        Set the internal console shell.\n\n        Parameters\n        ----------\n        console: :py:class:spyder.plugins.console.plugin.Console\n            Console plugin.\n        \"\"\"\nself.internal_console = console\nself.internal_shell = console.get_widget().shell\n",
        "CUT_3": "super().__init__(parent)\n",
        "CUT_4": "super().__init__(parent)\n",
        "CUT_5": "super(QObject, self).__init__(parent)\nsuper(FileSystemEventHandler, self).__init__()\n"
    },
    {
        "functionName": "__getattr__",
        "className": "MainWindowMock",
        "fileName": "/spyder/plugins/console/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if attr != '_INTERNAL_PLUGINS':\n    return Mock()\nelse:\n    return self.__dict__[attr]\n",
        "CUT_1": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_2": "if attr == 'editor':\n    return self.editor\nelif attr == 'projects':\n    return self.projects\nelse:\n    return Mock()\n",
        "CUT_3": "self[attr] = value\n",
        "CUT_4": "self[attr] = value\n",
        "CUT_5": "if attr.endswith('actions'):\n    return []\nelif attr == 'projects':\n    projects = Mock()\n    projects.get_active_project.return_value = None\n    return projects\nelif attr == 'ipyconsole':\n    ipyconsole = Mock()\n    ipyconsole.get_pdb_state.return_value = False\n    return ipyconsole\nelse:\n    return Mock()\n"
    },
    {
        "functionName": "test_run_code",
        "className": null,
        "fileName": "/spyder/plugins/console/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the console runs code.\"\"\"\nshell = console_plugin.get_widget().shell\nshell.insert_text('2+2', at_end=True)\nshell._key_enter()\nsys_stream = capsys.readouterr()\nassert sys_stream.out == '4\\n'\n",
        "CUT_1": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_2": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_3": "return self.shell\n",
        "CUT_4": "return self.shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_completions",
        "className": null,
        "fileName": "/spyder/plugins/console/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that completions work as expected.\"\"\"\nshell = console_plugin.get_widget().shell\nqtbot.keyClicks(shell, 'impor')\nqtbot.keyClick(shell, Qt.Key_Tab)\nqtbot.keyClick(shell.completion_widget, Qt.Key_Enter)\nassert 'import' in shell.toPlainText()\n",
        "CUT_1": "return self.shell\n",
        "CUT_2": "return self.shell\n",
        "CUT_3": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_4": "\"\"\"\n        Bind to shell.\n\n        Parameters\n        ----------\n        shell: object\n            internal shell or ipython console shell\n        \"\"\"\nself.shell = shell\n",
        "CUT_5": "\"\"\"\n        Return shell which is currently bound to Help.\n        \"\"\"\nif self.shell is None:\n    self.shell = self.internal_shell\nreturn self.shell\n"
    },
    {
        "functionName": "test_handle_exception",
        "className": null,
        "fileName": "/spyder/plugins/console/tests/test_plugin.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that error dialog is called.\"\"\"\nwidget = console_plugin.get_widget()\nshell = widget.shell\nmocker.patch('spyder.widgets.reporterror.SpyderErrorDialog.show',\n    return_value=None)\nerror = \"\"\"\nTraceback (most recent call last):\n  File \"/home/foo/miniconda3/envs/py37/lib/python3.7/code.py\", line 90, in runcode\n    exec(code, self.locals)\n  File \"<console>\", line 2, in <module>\nZeroDivisionError: division by zero\n\"\"\"\nshell.append_text_to_shell(error, error=True, prompt=False)\nassert widget.error_dlg is not None\nwidget.error_dlg.details_btn.clicked.emit()\nassert 'foo' in widget.error_dlg.details.toPlainText()\nassert 'code.py' in widget.error_dlg.details.toPlainText()\nwidget.error_dlg = None\nconsole_plugin.handle_exception(dict(text=error, is_traceback=True, title=\n    'Internal Python Language Server error'))\nassert widget.error_dlg is not None\nassert widget.error_dlg.title.text() == 'Internal Python Language Server error'\nwidget.error_dlg = None\nconsole_plugin.set_conf_option('previous_crash', error, section='main')\nconsole_plugin.register()\nassert widget.error_dlg is not None\nassert widget.error_dlg.title.text() == 'Segmentation fault crash'\nconsole_plugin.set_conf_option('previous_crash', '', section='main')\n",
        "CUT_1": "\"\"\"\n        Remove error dialog.\n        \"\"\"\nself.error_dlg = None\n",
        "CUT_2": "\"\"\"\n        Remove error dialog.\n        \"\"\"\nself.error_dlg = None\n",
        "CUT_3": "\"\"\"\n        Close error dialog.\n        \"\"\"\nif self.error_dlg.dismiss_box.isChecked():\n    self.dismiss_error = True\nself.error_dlg.reject()\n",
        "CUT_4": "\"\"\"\n        Close error dialog.\n        \"\"\"\nif self.error_dlg.dismiss_box.isChecked():\n    self.dismiss_error = True\nself.error_dlg.reject()\n",
        "CUT_5": "\"\"\"\n        Exception ocurred in the internal console.\n\n        Show a QDialog or the internal console to warn the user.\n\n        Handle any exception that occurs during Spyder usage.\n\n        Parameters\n        ----------\n        error_data: dict\n            The dictionary containing error data. The expected keys are:\n            >>> error_data= {\n                \"text\": str,\n                \"is_traceback\": bool,\n                \"repo\": str,\n                \"title\": str,\n                \"label\": str,\n                \"steps\": str,\n            }\n        sender: spyder.api.plugins.SpyderPluginV2, optional\n            The sender plugin. Default is None.\n\n        Notes\n        -----\n        The `is_traceback` key indicates if `text` contains plain text or a\n        Python error traceback.\n\n        The `title` and `repo` keys indicate how the error data should\n        customize the report dialog and Github error submission.\n\n        The `label` and `steps` keys allow customizing the content of the\n        error dialog.\n        \"\"\"\ntext = error_data.get('text', None)\nis_traceback = error_data.get('is_traceback', False)\ntitle = error_data.get('title', '')\nlabel = error_data.get('label', '')\nsteps = error_data.get('steps', '')\nif not text and not is_traceback and self.error_dlg is None or self.dismiss_error:\n    return\nif internal_plugins is None:\n    internal_plugins = find_internal_plugins()\nif internal_plugins:\n    internal_plugin_names = []\n    for __, val in internal_plugins.items():\n        name = getattr(val, 'NAME', getattr(val, 'CONF_SECTION'))\n        internal_plugin_names.append(name)\n    sender_name = getattr(val, 'NAME', getattr(val, 'CONF_SECTION'))\n    is_internal_plugin = sender_name in internal_plugin_names\nelse:\n    is_internal_plugin = False\nrepo = 'spyder-ide/spyder'\nif sender is not None and not is_internal_plugin:\n    repo = error_data.get('repo', None)\n    try:\n        plugin_name = sender.NAME\n    except Exception:\n        plugin_name = sender.CONF_SECTION\n    if repo is None:\n        raise Exception(\n            'External plugin \"{}\" does not define \"repo\" key in the \"error_data\" dictionary!'\n            .format(plugin_name))\nif self.get_option('show_internal_errors'):\n    if self.error_dlg is None:\n        self.error_dlg = SpyderErrorDialog(self)\n        self.error_dlg.set_color_scheme(self.get_option('color_theme'))\n        self.error_dlg.close_btn.clicked.connect(self.close_error_dlg)\n        self.error_dlg.rejected.connect(self.remove_error_dlg)\n        self.error_dlg.details.go_to_error.connect(self.go_to_error)\n    self.error_dlg.set_github_repo_org(repo)\n    if title:\n        self.error_dlg.set_title(title)\n        self.error_dlg.title.setEnabled(False)\n    if label:\n        self.error_dlg.main_label.setText(label)\n        self.error_dlg.submit_btn.setEnabled(True)\n    if steps:\n        self.error_dlg.steps_text.setText(steps)\n        self.error_dlg.set_require_minimum_length(False)\n    self.error_dlg.append_traceback(text)\n    self.error_dlg.show()\nelif DEV or get_debug_level():\n    self.change_visibility(True, True)\nSlot(dict)"
    },
    {
        "functionName": "test_dont_use_isinstance_str",
        "className": null,
        "fileName": "/spyder/tests/tests_py3compat_usage.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "found = False\nfor dir_name, _, file_list in os.walk(root_path):\n    for fname in file_list:\n        if fname.endswith('.py') and fname != 'py3compat.py':\n            file = os.path.join(dir_name, fname)\n            for i, line in enumerate(open(file)):\n                for match in re.finditer(pattern, line):\n                    print('{}\\nline:{}, {}'.format(file, i + 1, line))\n                    found = True\nassert found == False, \"Don't use builtin isinstance() function,use spyder.py3compat.is_text_string() instead\"\n",
        "CUT_1": "fname = osp.abspath(encoding.to_unicode_from_fs(fname))\nif os.name == 'nt' and len(fname) >= 2 and fname[1] == ':':\n    fname = fname[0].upper() + fname[1:]\nreturn fname\n",
        "CUT_2": "fname = osp.abspath(encoding.to_unicode_from_fs(fname))\nif os.name == 'nt' and len(fname) >= 2 and fname[1] == ':':\n    fname = fname[0].upper() + fname[1:]\nreturn fname\n",
        "CUT_3": "\"\"\"Select the right file uri scheme according to the operating system\"\"\"\nif os.name == 'nt':\n    if re.search('^[a-zA-Z]:', fname):\n        return 'file:///' + fname\n    else:\n        return 'file://' + fname\nelse:\n    return 'file://' + fname\n",
        "CUT_4": "\"\"\"Select the right file uri scheme according to the operating system\"\"\"\nif os.name == 'nt':\n    if re.search('^[a-zA-Z]:', fname):\n        return 'file:///' + fname\n    else:\n        return 'file://' + fname\nelse:\n    return 'file://' + fname\n",
        "CUT_5": "\"\"\"Format uri to conform to absolute or relative file paths.\"\"\"\nfname = uri.replace('file://', '')\nif fname[-1] == '/':\n    fname = fname[:-1]\nif fname.startswith('^/'):\n    if self.current_project_path is not None:\n        fname = osp.join(self.current_project_path, fname[2:])\n    else:\n        fname = fname.replace('^/', '~/')\nif fname.startswith('~/'):\n    fname = osp.expanduser(fname)\ndirname = osp.dirname(osp.abspath(self.filename))\nif osp.isdir(dirname):\n    if not osp.isfile(fname):\n        fname = osp.join(dirname, fname)\nself.sig_file_uri_preprocessed.emit(fname)\nreturn fname\n"
    },
    {
        "functionName": "parse_requirements",
        "className": null,
        "fileName": "/spyder/tests/test_dependencies_in_sync.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Parse a requirements file and return a dict of deps and versions.\n    \"\"\"\nwith open(fpath, 'r') as fh:\n    data = fh.read()\nlines = data.split('\\n')\nlines = [line.strip() for line in lines if line and line[0] != '#']\ndeps = {}\nfor line in lines:\n    parts = line.split(' ')\n    if len(parts) > 1:\n        ver = parts[-1]\n        if ver[0] == '=':\n            ver = '=' + ver\n        deps[parts[0].lower()] = ver\n    else:\n        deps[parts[0].lower()] = None\nreturn deps\n",
        "CUT_1": "\"\"\"Return module version or None if version can't be retrieved.\"\"\"\nmod = __import__(module_name)\nver = getattr(mod, '__version__', getattr(mod, 'VERSION', None))\nif not ver:\n    ver = get_package_version(module_name)\nreturn ver\n",
        "CUT_2": "\"\"\"Return module version or None if version can't be retrieved.\"\"\"\nmod = __import__(module_name)\nver = getattr(mod, '__version__', getattr(mod, 'VERSION', None))\nif not ver:\n    ver = get_package_version(module_name)\nreturn ver\n",
        "CUT_3": "\"\"\"Count the number of leading empty cells.\"\"\"\nif PY2:\n    lines = cell.splitlines(True)\nelse:\n    lines = cell.splitlines(keepends=True)\nif not lines:\n    return 0\nfor i, line in enumerate(lines):\n    if line and not line.isspace():\n        return i\nreturn len(lines)\n",
        "CUT_4": "\"\"\"\n        Load history from a text file in the Spyder configuration directory.\n        \"\"\"\nif osp.isfile(self.LOG_PATH):\n    with open(self.LOG_PATH, 'r') as fh:\n        lines = fh.read().split('\\n')\n    history = [line.replace('\\n', '') for line in lines]\nelse:\n    history = []\nreturn history\n",
        "CUT_5": "\"\"\"\n        Load history from a text file in the Spyder configuration directory.\n        \"\"\"\nif osp.isfile(self.LOG_PATH):\n    with open(self.LOG_PATH, 'r') as fh:\n        lines = fh.read().split('\\n')\n    history = [line.replace('\\n', '') for line in lines]\nelse:\n    history = []\nreturn history\n"
    },
    {
        "functionName": "parse_environment_yaml",
        "className": null,
        "fileName": "/spyder/tests/test_dependencies_in_sync.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Parse an environment yaml file and return a dict of deps and versions.\n    \"\"\"\nwith open(fpath, 'r') as fh:\n    data = yaml.load(fh, Loader=yaml.FullLoader)\ndeps = {}\nyaml_deps = data.get('dependencies')\nfor dep in yaml_deps:\n    if isinstance(dep, dict):\n        continue\n    elif dep == 'websockify':\n        continue\n    else:\n        parts = dep.split(' ')\n        if len(parts) > 1:\n            ver = parts[-1]\n            if ver[0] == '=':\n                ver = '=' + ver\n            deps[parts[0]] = ver\n        else:\n            deps[parts[0]] = None\nreturn deps\n",
        "CUT_1": "for dep in DESCRIPTIONS:\n    if dep.get('display', True):\n        add(dep['modname'], dep['package_name'], dep['features'], dep[\n            'required_version'], kind=dep.get('kind', MANDATORY))\n",
        "CUT_2": "for dep in DESCRIPTIONS:\n    if dep.get('display', True):\n        add(dep['modname'], dep['package_name'], dep['features'], dep[\n            'required_version'], kind=dep.get('kind', MANDATORY))\n",
        "CUT_3": "\"\"\"Return module version or None if version can't be retrieved.\"\"\"\nmod = __import__(module_name)\nver = getattr(mod, '__version__', getattr(mod, 'VERSION', None))\nif not ver:\n    ver = get_package_version(module_name)\nreturn ver\n",
        "CUT_4": "\"\"\"Return module version or None if version can't be retrieved.\"\"\"\nmod = __import__(module_name)\nver = getattr(mod, '__version__', getattr(mod, 'VERSION', None))\nif not ver:\n    ver = get_package_version(module_name)\nreturn ver\n",
        "CUT_5": "hor, ver = position\nself.horizontalScrollBar().setValue(hor)\nself.verticalScrollBar().setValue(ver)\n"
    },
    {
        "functionName": "parse_spyder_dependencies",
        "className": null,
        "fileName": "/spyder/tests/test_dependencies_in_sync.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Parse Spyder dependencies and return a dict of deps and versions.\n    \"\"\"\ndeps = {}\nfor dep in DESCRIPTIONS:\n    if dep.get('kind', None) == OPTIONAL:\n        continue\n    ver = dep['required_version']\n    if ver:\n        if ';' in ver:\n            ver = ver.replace(';', ',')\n        elif ver[0] == '=':\n            ver = '=' + ver\n    deps[dep['package_name'].lower()] = ver\nreturn deps\n",
        "CUT_1": "\"\"\"Return module version or None if version can't be retrieved.\"\"\"\nmod = __import__(module_name)\nver = getattr(mod, '__version__', getattr(mod, 'VERSION', None))\nif not ver:\n    ver = get_package_version(module_name)\nreturn ver\n",
        "CUT_2": "\"\"\"Return module version or None if version can't be retrieved.\"\"\"\nmod = __import__(module_name)\nver = getattr(mod, '__version__', getattr(mod, 'VERSION', None))\nif not ver:\n    ver = get_package_version(module_name)\nreturn ver\n",
        "CUT_3": "hor, ver = position\nself.horizontalScrollBar().setValue(hor)\nself.verticalScrollBar().setValue(ver)\n",
        "CUT_4": "hor, ver = position\nself.horizontalScrollBar().setValue(hor)\nself.verticalScrollBar().setValue(ver)\n",
        "CUT_5": "\"\"\"Return package version or None if version can't be retrieved.\"\"\"\ntry:\n    ver = pkg_resources.get_distribution(package_name).version\n    return ver\nexcept DistributionNotFound:\n    return None\n"
    },
    {
        "functionName": "parse_setup_install_requires",
        "className": null,
        "fileName": "/spyder/tests/test_dependencies_in_sync.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Parse Spyder setup.py and return a dict of deps and versions.\n    \"\"\"\ndeps = {}\nwith open(fpath, 'r') as fh:\n    data = fh.read()\nlines = data.split('\\n')\nstart = None\nend = None\nfor idx, line in enumerate(lines):\n    if line.startswith('install_requires = '):\n        start = idx + 1\n    if start is not None and line.startswith(']'):\n        end = idx\n        break\ndep_list = literal_eval('[' + '\\n'.join(lines[start:end + 1]))\ndep_list = [item for item in dep_list if item[0] != '#']\nfor dep in dep_list:\n    dep = dep.split(';')[0]\n    name, ver = None, None\n    for sep in ['>=', '==', '<=', '<', '>']:\n        if sep in dep:\n            idx = dep.index(sep)\n            name = dep[:idx]\n            ver = dep[idx:]\n            break\n    if name is not None:\n        name = name.split('[')[0]\n    else:\n        name = dep.split('[')[0]\n    if name == 'pyqt5':\n        name = 'pyqt'\n    deps[name] = ver\nreturn deps\n",
        "CUT_1": "for dep in DESCRIPTIONS:\n    if dep.get('display', True):\n        add(dep['modname'], dep['package_name'], dep['features'], dep[\n            'required_version'], kind=dep.get('kind', MANDATORY))\n",
        "CUT_2": "for dep in DESCRIPTIONS:\n    if dep.get('display', True):\n        add(dep['modname'], dep['package_name'], dep['features'], dep[\n            'required_version'], kind=dep.get('kind', MANDATORY))\n",
        "CUT_3": "\"\"\"Return a status of dependencies.\"\"\"\nmaxwidth = 0\ndata = []\nfor dep in deps:\n    title = dep.modname\n    if dep.required_version is not None:\n        title += ' ' + dep.required_version\n    maxwidth = max([maxwidth, len(title)])\n    dep_order = {MANDATORY: '0', OPTIONAL: '1', PLUGIN: '2'}\n    order_dep = {'0': MANDATORY, '1': OPTIONAL, '2': PLUGIN}\n    data.append([dep_order[dep.kind], title, dep.get_installed_version()])\nmaxwidth += 1\ntext = ''\nprev_order = '-1'\nfor order, title, version in sorted(data, key=lambda x: x[0] + x[1].lower()):\n    if order != prev_order:\n        text += '{sep}# {name}:{sep}'.format(sep=linesep, name=order_dep[\n            order].capitalize())\n        prev_order = order\n    text += '{title}:  {version}{linesep}'.format(title=title.ljust(\n        maxwidth), version=version, linesep=linesep)\nif not linesep == '<br>':\n    text = text[:-1]\nreturn text\n",
        "CUT_4": "\"\"\"Return a status of dependencies.\"\"\"\nmaxwidth = 0\ndata = []\nfor dep in deps:\n    title = dep.modname\n    if dep.required_version is not None:\n        title += ' ' + dep.required_version\n    maxwidth = max([maxwidth, len(title)])\n    dep_order = {MANDATORY: '0', OPTIONAL: '1', PLUGIN: '2'}\n    order_dep = {'0': MANDATORY, '1': OPTIONAL, '2': PLUGIN}\n    data.append([dep_order[dep.kind], title, dep.get_installed_version()])\nmaxwidth += 1\ntext = ''\nprev_order = '-1'\nfor order, title, version in sorted(data, key=lambda x: x[0] + x[1].lower()):\n    if order != prev_order:\n        text += '{sep}# {name}:{sep}'.format(sep=linesep, name=order_dep[\n            order].capitalize())\n        prev_order = order\n    text += '{title}:  {version}{linesep}'.format(title=title.ljust(\n        maxwidth), version=version, linesep=linesep)\nif not linesep == '<br>':\n    text = text[:-1]\nreturn text\n",
        "CUT_5": "\"\"\"Dependencies are expressed as a dictionary whose keys are items\nand whose values are a set of dependent items. Output is a list of\nsets in topological order. The first set consists of items with no\ndependences, each subsequent set consists of items that depend upon\nitems in the preceeding sets.\n\"\"\"\nif len(data) == 0:\n    return\ndata = data.copy()\nfor k, v in data.items():\n    v.discard(k)\nextra_items_in_deps = _reduce(set.union, data.values()) - set(data.keys())\ndata.update({item: set() for item in extra_items_in_deps})\nwhile True:\n    ordered = set(item for item, dep in data.items() if len(dep) == 0)\n    if not ordered:\n        break\n    yield ordered\n    data = {item: (dep - ordered) for item, dep in data.items() if item not in\n        ordered}\nif len(data) != 0:\n    raise CircularDependencyError(data)\n"
    },
    {
        "functionName": "parse_setup_extra_requires",
        "className": null,
        "fileName": "/spyder/tests/test_dependencies_in_sync.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Parse Spyder setup.py and return a dict of deps and versions.\n    \"\"\"\ndeps = {}\nwith open(fpath, 'r') as fh:\n    data = fh.read()\nlines = data.split('\\n')\nstart = None\nend = None\nfor idx, line in enumerate(lines):\n    if line.startswith('extras_require = '):\n        start = idx + 1\n    if start is not None and line.startswith('}'):\n        end = idx\n        break\ndep_dict = literal_eval('{' + '\\n'.join(lines[start:end + 1]))\ndep_list = dep_dict.get('test')\ndep_list = [item for item in dep_list if item[0] != '#']\nfor dep in dep_list:\n    dep = dep.split(';')[0]\n    name, ver = None, None\n    for sep in ['>=', '==', '<=', '<', '>']:\n        if sep in dep:\n            idx = dep.index(sep)\n            name = dep[:idx]\n            ver = dep[idx:]\n            break\n    if name is not None:\n        name = name.split('[')[0]\n    else:\n        name = dep.split('[')[0]\n    if name == 'pyqt5':\n        name = 'pyqt'\n    deps[name] = ver\nprint(deps)\nreturn deps\n",
        "CUT_1": "for dep in DESCRIPTIONS:\n    if dep.get('display', True):\n        add(dep['modname'], dep['package_name'], dep['features'], dep[\n            'required_version'], kind=dep.get('kind', MANDATORY))\n",
        "CUT_2": "for dep in DESCRIPTIONS:\n    if dep.get('display', True):\n        add(dep['modname'], dep['package_name'], dep['features'], dep[\n            'required_version'], kind=dep.get('kind', MANDATORY))\n",
        "CUT_3": "\"\"\"Return a status of dependencies.\"\"\"\nmaxwidth = 0\ndata = []\nfor dep in deps:\n    title = dep.modname\n    if dep.required_version is not None:\n        title += ' ' + dep.required_version\n    maxwidth = max([maxwidth, len(title)])\n    dep_order = {MANDATORY: '0', OPTIONAL: '1', PLUGIN: '2'}\n    order_dep = {'0': MANDATORY, '1': OPTIONAL, '2': PLUGIN}\n    data.append([dep_order[dep.kind], title, dep.get_installed_version()])\nmaxwidth += 1\ntext = ''\nprev_order = '-1'\nfor order, title, version in sorted(data, key=lambda x: x[0] + x[1].lower()):\n    if order != prev_order:\n        text += '{sep}# {name}:{sep}'.format(sep=linesep, name=order_dep[\n            order].capitalize())\n        prev_order = order\n    text += '{title}:  {version}{linesep}'.format(title=title.ljust(\n        maxwidth), version=version, linesep=linesep)\nif not linesep == '<br>':\n    text = text[:-1]\nreturn text\n",
        "CUT_4": "\"\"\"Return a status of dependencies.\"\"\"\nmaxwidth = 0\ndata = []\nfor dep in deps:\n    title = dep.modname\n    if dep.required_version is not None:\n        title += ' ' + dep.required_version\n    maxwidth = max([maxwidth, len(title)])\n    dep_order = {MANDATORY: '0', OPTIONAL: '1', PLUGIN: '2'}\n    order_dep = {'0': MANDATORY, '1': OPTIONAL, '2': PLUGIN}\n    data.append([dep_order[dep.kind], title, dep.get_installed_version()])\nmaxwidth += 1\ntext = ''\nprev_order = '-1'\nfor order, title, version in sorted(data, key=lambda x: x[0] + x[1].lower()):\n    if order != prev_order:\n        text += '{sep}# {name}:{sep}'.format(sep=linesep, name=order_dep[\n            order].capitalize())\n        prev_order = order\n    text += '{title}:  {version}{linesep}'.format(title=title.ljust(\n        maxwidth), version=version, linesep=linesep)\nif not linesep == '<br>':\n    text = text[:-1]\nreturn text\n",
        "CUT_5": "\"\"\"Dependencies are expressed as a dictionary whose keys are items\nand whose values are a set of dependent items. Output is a list of\nsets in topological order. The first set consists of items with no\ndependences, each subsequent set consists of items that depend upon\nitems in the preceeding sets.\n\"\"\"\nif len(data) == 0:\n    return\ndata = data.copy()\nfor k, v in data.items():\n    v.discard(k)\nextra_items_in_deps = _reduce(set.union, data.values()) - set(data.keys())\ndata.update({item: set() for item in extra_items_in_deps})\nwhile True:\n    ordered = set(item for item, dep in data.items() if len(dep) == 0)\n    if not ordered:\n        break\n    yield ordered\n    data = {item: (dep - ordered) for item, dep in data.items() if item not in\n        ordered}\nif len(data) != 0:\n    raise CircularDependencyError(data)\n"
    },
    {
        "functionName": "test_dependencies_for_binder_in_sync",
        "className": null,
        "fileName": "/spyder/tests/test_dependencies_in_sync.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Binder environment yaml should be the sum of conda.txt and tests.txt\n    requirements.\n    \"\"\"\nspyder_env = parse_environment_yaml(ENV_FPATH)\nspyder_reqs = parse_requirements(REQ_FPATH)\ntest_reqs = parse_requirements(REQ_TEST_FPATH)\nif 'pytest-xvfb' in spyder_env:\n    spyder_env.pop('pytest-xvfb')\nfor req in [spyder_env, spyder_reqs]:\n    req.pop('python-language-server')\nfull_reqs = {}\nfull_reqs.update(test_reqs)\nfull_reqs.update(spyder_reqs)\nassert spyder_env == full_reqs\n",
        "CUT_1": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.snippets_actor.sig_mailbox.emit(request)\n",
        "CUT_2": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.snippets_actor.sig_mailbox.emit(request)\n",
        "CUT_3": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.fallback_actor.sig_mailbox.emit(request)\n",
        "CUT_4": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.fallback_actor.sig_mailbox.emit(request)\n",
        "CUT_5": "\"\"\"Call function req and then emit its results to the completion server.\"\"\"\nif req is None:\n    return functools.partial(request, method=method, requires_response=\n        requires_response)\n@functools.wraps(req)\ndef wrapper(self, *args, **kwargs):\n    params = req(self, *args, **kwargs)\n    if params is not None and self.completions_available:\n        self.emit_request(method, params, requires_response)\nreturn wrapper\n"
    },
    {
        "functionName": "test_dependencies_for_spyder_dialog_in_sync",
        "className": null,
        "fileName": "/spyder/tests/test_dependencies_in_sync.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Spyder dependencies dialog should share deps with conda.txt.\n    \"\"\"\nspyder_deps = parse_spyder_dependencies()\nspyder_reqs = parse_requirements(REQ_FPATH)\nfor req in [spyder_deps, spyder_reqs]:\n    req.pop('spyder-kernels')\n    req.pop('python-language-server')\nif 'pyqt' in spyder_reqs:\n    spyder_reqs.pop('pyqt')\nif PY2:\n    if 'ipython' in spyder_reqs:\n        spyder_reqs.pop('ipython')\n    if 'ipython' in spyder_deps:\n        spyder_deps.pop('ipython')\nassert spyder_deps == spyder_reqs\n",
        "CUT_1": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.snippets_actor.sig_mailbox.emit(request)\n",
        "CUT_2": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.snippets_actor.sig_mailbox.emit(request)\n",
        "CUT_3": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.fallback_actor.sig_mailbox.emit(request)\n",
        "CUT_4": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.fallback_actor.sig_mailbox.emit(request)\n",
        "CUT_5": "\"\"\"Return widget title\"\"\"\nreturn _('IPython console')\n"
    },
    {
        "functionName": "test_dependencies_for_spyder_setup_install_requires_in_sync",
        "className": null,
        "fileName": "/spyder/tests/test_dependencies_in_sync.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Spyder setup.py should share deps with conda.txt.\n    \"\"\"\nspyder_setup = parse_setup_install_requires(SETUP_FPATH)\nspyder_reqs = parse_requirements(REQ_FPATH)\nfor req in [spyder_reqs, spyder_setup]:\n    req.pop('spyder-kernels')\n    req.pop('python-language-server')\nif 'rtree' in spyder_reqs:\n    spyder_reqs.pop('rtree')\nif 'pyqtwebengine' in spyder_setup:\n    spyder_setup.pop('pyqtwebengine')\nassert spyder_setup == spyder_reqs\n",
        "CUT_1": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.snippets_actor.sig_mailbox.emit(request)\n",
        "CUT_2": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.snippets_actor.sig_mailbox.emit(request)\n",
        "CUT_3": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.fallback_actor.sig_mailbox.emit(request)\n",
        "CUT_4": "if not self.enabled:\n    return\nrequest = {'type': req_type, 'file': req['file'], 'id': req_id, 'msg': req}\nreq['language'] = language\nself.fallback_actor.sig_mailbox.emit(request)\n",
        "CUT_5": "\"\"\"Call function req and then emit its results to the completion server.\"\"\"\nif req is None:\n    return functools.partial(request, method=method, requires_response=\n        requires_response)\n@functools.wraps(req)\ndef wrapper(self, *args, **kwargs):\n    params = req(self, *args, **kwargs)\n    if params is not None and self.completions_available:\n        self.emit_request(method, params, requires_response)\nreturn wrapper\n"
    },
    {
        "functionName": "test_dependencies_for_spyder_setup_extras_requires_in_sync",
        "className": null,
        "fileName": "/spyder/tests/test_dependencies_in_sync.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Spyder setup.py extra_requires should share deps with tests.txt.\n    \"\"\"\nspyder_extras_setup = parse_setup_extra_requires(SETUP_FPATH)\nspyder_test_reqs = parse_requirements(REQ_TEST_FPATH)\nassert spyder_extras_setup == spyder_test_reqs\n",
        "CUT_1": "\"\"\"Replaces the selected text by its lower version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.lower())\n",
        "CUT_2": "\"\"\"Replaces the selected text by its lower version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.lower())\n",
        "CUT_3": "\"\"\"Replaces the selected text by its upper version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.upper())\n",
        "CUT_4": "\"\"\"Replaces the selected text by its upper version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.upper())\n",
        "CUT_5": "\"\"\"Add option to run slow tests.\"\"\"\nparser.addoption('--run-slow', action='store_true', default=False, help=\n    'Run slow tests')\n"
    },
    {
        "functionName": "test_dont_use",
        "className": null,
        "fileName": "/spyder/tests/test_dont_use.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    This test is used for discouraged using of some expresions that could\n    introduce errors, and encourage use spyder function instead.\n\n    If you want to skip some line from this test just use:\n        # spyder: test-skip\n    \"\"\"\npattern = re.compile(pattern + '((?!# spyder: test-skip)\\\\s)*$')\nfound = 0\nfor dir_name, _, file_list in os.walk(root_path):\n    for fname in file_list:\n        exclude = any([re.search(ex, fname) for ex in exclude_patterns])\n        exclude = exclude or any([re.search(ex, dir_name) for ex in\n            exclude_patterns])\n        if fname.endswith('.py') and not exclude:\n            file = os.path.join(dir_name, fname)\n            with codecs.open(file, encoding='utf-8') as f:\n                for i, line in enumerate(f):\n                    for match in re.finditer(pattern, line):\n                        print('{}\\nline:{}, {}'.format(file, i + 1, line))\n                        found += 1\nassert found == 0, \"\"\"{}\n{} errors found\"\"\".format(message, found)\npytest.mark.parametrize('pattern,exclude_patterns,message', [(\n    'isinstance\\\\(.*,.*str\\\\)', ['py3compat.py', 'example_latin1.py'],\n    \"Don't use builtin isinstance() function,use spyder.py3compat.is_text_string() instead\"\n    ), ('^[\\\\s\\\\#]*\\\\bprint\\\\(((?!file=).)*\\\\)', ['.*test.*', 'example.py',\n    'example_latin1.py', 'binaryornot'], (\n    \"Don't use the print() function; \",\n    'for debugging, use logging module instead')), (\n    '^[\\\\s\\\\#]*\\\\bprint\\\\s+(?!>>)((?!#).)*', ['.*test.*',\n    'example_latin1.py'], (\"Don't use print statements; \",\n    'for debugging, use the logging module instead.'))])",
        "CUT_1": "\"\"\"Get the number of matches for the searched text.\"\"\"\npattern = to_text_string(pattern)\nif not pattern:\n    return 0\nif not regexp:\n    pattern = re.escape(pattern)\nif not source_text:\n    source_text = to_text_string(self.toPlainText())\nif word:\n    pattern = '\\\\b{pattern}\\\\b'.format(pattern=pattern)\ntry:\n    re_flags = re.MULTILINE if case else re.IGNORECASE | re.MULTILINE\n    regobj = re.compile(pattern, flags=re_flags)\nexcept sre_constants.error:\n    return None\nnumber_matches = 0\nfor match in regobj.finditer(source_text):\n    number_matches += 1\nreturn number_matches\n",
        "CUT_2": "\"\"\"Get the number of matches for the searched text.\"\"\"\npattern = to_text_string(pattern)\nif not pattern:\n    return 0\nif not regexp:\n    pattern = re.escape(pattern)\nif not source_text:\n    source_text = to_text_string(self.toPlainText())\nif word:\n    pattern = '\\\\b{pattern}\\\\b'.format(pattern=pattern)\ntry:\n    re_flags = re.MULTILINE if case else re.IGNORECASE | re.MULTILINE\n    regobj = re.compile(pattern, flags=re_flags)\nexcept sre_constants.error:\n    return None\nnumber_matches = 0\nfor match in regobj.finditer(source_text):\n    number_matches += 1\nreturn number_matches\n",
        "CUT_3": "patterns = [pattern.format(token, '[^0-9a-zA-Z.[]') for pattern in patterns]\npattern = re.compile('|^'.join(patterns))\nlines = [(line.strip() + ' ') for line in source.splitlines()]\nif start_line == -1:\n    start_line = len(lines)\nmatches = []\nfor index, line in enumerate(lines):\n    if re.match(pattern, line):\n        matches.append(index + 1)\nreturn matches\n",
        "CUT_4": "patterns = [pattern.format(token, '[^0-9a-zA-Z.[]') for pattern in patterns]\npattern = re.compile('|^'.join(patterns))\nlines = [(line.strip() + ' ') for line in source.splitlines()]\nif start_line == -1:\n    start_line = len(lines)\nmatches = []\nfor index, line in enumerate(lines):\n    if re.match(pattern, line):\n        matches.append(index + 1)\nreturn matches\n",
        "CUT_5": "\"\"\"Get the number of matches for the searched text.\"\"\"\npattern = to_text_string(pattern)\nif not pattern:\n    return 0\nif not regexp:\n    pattern = re.escape(pattern)\nif not source_text:\n    if WEBENGINE:\n        self.page().toPlainText(self.set_source_text)\n        source_text = to_text_string(self.source_text)\n    else:\n        source_text = to_text_string(self.page().mainFrame().toPlainText())\nif word:\n    pattern = '\\\\b{pattern}\\\\b'.format(pattern=pattern)\ntry:\n    if case:\n        regobj = re.compile(pattern, re.MULTILINE)\n    else:\n        regobj = re.compile(pattern, re.MULTILINE | re.IGNORECASE)\nexcept sre_constants.error:\n    return\nnumber_matches = 0\nfor match in regobj.finditer(source_text):\n    number_matches += 1\nreturn number_matches\n"
    },
    {
        "functionName": "test_check_charaters_translation",
        "className": null,
        "fileName": "/spyder/tests/test_dont_use.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    This test is used to prevent the addition of unwanted unicode characters\n    in the translations like \uff05 instead of %.\n\n    \"\"\"\nfound = 0\nfor dir_name, _, file_list in os.walk(os.path.join(root_path, 'locale')):\n    for fname in file_list:\n        if fname.endswith('.po'):\n            file = os.path.join(dir_name, fname)\n            with codecs.open(file, encoding='utf-8') as f:\n                for i, line in enumerate(f):\n                    for match in re.finditer(pattern, line):\n                        print('{}\\nline:{}, {}'.format(file, i + 1, line))\n                        found += 1\nassert found == 0, \"\"\"{}\n{} characters found\"\"\".format(\n    'Strange characters found in translations', found)\npytest.mark.parametrize('pattern', ['\uff05'])",
        "CUT_1": "self.error_flag = False\nself.sig_current_file.emit(fname)\ntry:\n    for lineno, line in enumerate(open(fname, 'rb')):\n        for text, enc in self.texts:\n            with QMutexLocker(self.mutex):\n                if self.stopped:\n                    return False\n            line_search = line\n            if not self.case_sensitive:\n                line_search = line_search.lower()\n            if self.text_re:\n                found = re.search(text, line_search)\n                if found is not None:\n                    break\n            else:\n                found = line_search.find(text)\n                if found > -1:\n                    break\n        try:\n            line_dec = line.decode(enc)\n        except UnicodeDecodeError:\n            line_dec = line\n        if not self.case_sensitive:\n            line = line.lower()\n        if self.text_re:\n            for match in re.finditer(text, line):\n                with QMutexLocker(self.mutex):\n                    if self.stopped:\n                        return False\n                self.total_matches += 1\n                self.partial_results.append((osp.abspath(fname), lineno + 1,\n                    match.start(), match.end(), line_dec))\n                if len(self.partial_results) > 2 ** self.power:\n                    self.process_results()\n                    if self.power < self.max_power:\n                        self.power += 1\n        else:\n            found = line.find(text)\n            while found > -1:\n                with QMutexLocker(self.mutex):\n                    if self.stopped:\n                        return False\n                self.total_matches += 1\n                self.partial_results.append((osp.abspath(fname), lineno + 1,\n                    found, found + len(text), line_dec))\n                if len(self.partial_results) > 2 ** self.power:\n                    self.process_results()\n                    if self.power < self.max_power:\n                        self.power += 1\n                for text, enc in self.texts:\n                    found = line.find(text, found + 1)\n                    if found > -1:\n                        break\nexcept IOError as xxx_todo_changeme:\n    _errno, _strerror = xxx_todo_changeme.args\n    self.error_flag = _('permission denied errors were encountered')\nself.completed = True\n",
        "CUT_2": "self.error_flag = False\nself.sig_current_file.emit(fname)\ntry:\n    for lineno, line in enumerate(open(fname, 'rb')):\n        for text, enc in self.texts:\n            with QMutexLocker(self.mutex):\n                if self.stopped:\n                    return False\n            line_search = line\n            if not self.case_sensitive:\n                line_search = line_search.lower()\n            if self.text_re:\n                found = re.search(text, line_search)\n                if found is not None:\n                    break\n            else:\n                found = line_search.find(text)\n                if found > -1:\n                    break\n        try:\n            line_dec = line.decode(enc)\n        except UnicodeDecodeError:\n            line_dec = line\n        if not self.case_sensitive:\n            line = line.lower()\n        if self.text_re:\n            for match in re.finditer(text, line):\n                with QMutexLocker(self.mutex):\n                    if self.stopped:\n                        return False\n                self.total_matches += 1\n                self.partial_results.append((osp.abspath(fname), lineno + 1,\n                    match.start(), match.end(), line_dec))\n                if len(self.partial_results) > 2 ** self.power:\n                    self.process_results()\n                    if self.power < self.max_power:\n                        self.power += 1\n        else:\n            found = line.find(text)\n            while found > -1:\n                with QMutexLocker(self.mutex):\n                    if self.stopped:\n                        return False\n                self.total_matches += 1\n                self.partial_results.append((osp.abspath(fname), lineno + 1,\n                    found, found + len(text), line_dec))\n                if len(self.partial_results) > 2 ** self.power:\n                    self.process_results()\n                    if self.power < self.max_power:\n                        self.power += 1\n                for text, enc in self.texts:\n                    found = line.find(text, found + 1)\n                    if found > -1:\n                        break\nexcept IOError as xxx_todo_changeme:\n    _errno, _strerror = xxx_todo_changeme.args\n    self.error_flag = _('permission denied errors were encountered')\nself.completed = True\n",
        "CUT_3": "\"\"\"Return the last configuration file used if found.\"\"\"\nreturn self.get_config_fpath()\n",
        "CUT_4": "\"\"\"Return the last configuration file used if found.\"\"\"\nreturn self.get_config_fpath()\n",
        "CUT_5": "\"\"\"Select the right file uri scheme according to the operating system\"\"\"\nif os.name == 'nt':\n    if re.search('^[a-zA-Z]:', fname):\n        return 'file:///' + fname\n    else:\n        return 'file://' + fname\nelse:\n    return 'file://' + fname\n"
    },
    {
        "functionName": "test_get_common_path",
        "className": null,
        "fileName": "/spyder/utils/tests/test_misc.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test getting the common path.\"\"\"\nif os.name == 'nt':\n    assert get_common_path(['D:\\\\Python\\\\spyder-v21\\\\spyder\\\\widgets',\n        'D:\\\\Python\\\\spyder\\\\spyder\\\\utils',\n        'D:\\\\Python\\\\spyder\\\\spyder\\\\widgets',\n        'D:\\\\Python\\\\spyder-v21\\\\spyder\\\\utils']) == 'D:\\\\Python'\nelse:\n    assert get_common_path(['/Python/spyder-v21/spyder.widgets',\n        '/Python/spyder/spyder.utils', '/Python/spyder/spyder.widgets',\n        '/Python/spyder-v21/spyder.utils']) == '/Python'\n",
        "CUT_1": "return _('Internal console running Spyder.')\n",
        "CUT_2": "return _('Internal console running Spyder.')\n",
        "CUT_3": "\"\"\"Check spyder-kernel requirement.\"\"\"\ntry:\n    import spyder_kernels\n    required_ver = '1.0.0'\n    actual_ver = spyder_kernels.__version__\n    if LooseVersion(actual_ver) < LooseVersion(required_ver):\n        show_warning(\n            \"\"\"Please check Spyder installation requirements:\nspyder-kernels >= 1.0 is required (found %s).\"\"\"\n             % actual_ver)\nexcept ImportError:\n    show_warning(\n        \"\"\"Failed to import spyder-kernels.\nPlease check Spyder installation requirements:\n\nspyder-kernels >= 1.0 is required\"\"\"\n        )\n",
        "CUT_4": "\"\"\"Check spyder-kernel requirement.\"\"\"\ntry:\n    import spyder_kernels\n    required_ver = '1.0.0'\n    actual_ver = spyder_kernels.__version__\n    if LooseVersion(actual_ver) < LooseVersion(required_ver):\n        show_warning(\n            \"\"\"Please check Spyder installation requirements:\nspyder-kernels >= 1.0 is required (found %s).\"\"\"\n             % actual_ver)\nexcept ImportError:\n    show_warning(\n        \"\"\"Failed to import spyder-kernels.\nPlease check Spyder installation requirements:\n\nspyder-kernels >= 1.0 is required\"\"\"\n        )\n",
        "CUT_5": "\"\"\"\n        Return the Spyder main window..\n        \"\"\"\nreturn self._main\n"
    },
    {
        "functionName": "test_add_pathlist_to_PYTHONPATH",
        "className": null,
        "fileName": "/spyder/utils/tests/test_misc.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test for add_pathlist_to_PYTHONPATH.\"\"\"\npathlist = ['test123', 'test456']\nif drop_env:\n    env = []\n    expected = ['PYTHONPATH=' + pathlist[0] + os.pathsep + pathlist[1]]\nelse:\n    env = ['PYTHONPATH=test0']\n    expected = ['PYTHONPATH=' + pathlist[0] + os.pathsep + pathlist[1] + os\n        .pathsep + 'test0']\nadd_pathlist_to_PYTHONPATH(env, pathlist, drop_env=drop_env)\nassert env == expected\npytest.mark.parametrize('drop_env', [True, False])",
        "CUT_1": "\"\"\"\n    Add a PYTHONPATH entry to a list of enviroment variables.\n\n    This allows to extend the environment of an external process\n    created with QProcess with our additions to PYTHONPATH.\n\n    Parameters\n    ----------\n    env: list\n        List of environment variables in the format of\n        QProcessEnvironment.\n    pathlist: list\n        List of paths to add to PYTHONPATH\n    drop_env: bool\n        Whether to drop PYTHONPATH previously found in the environment.\n    \"\"\"\nassert isinstance(env, list)\nassert all([is_text_string(path) for path in env])\npypath = 'PYTHONPATH'\npathstr = os.pathsep.join(pathlist)\nif not drop_env:\n    for index, var in enumerate(env[:]):\n        if var.startswith(pypath + '='):\n            env[index] = var.replace(pypath + '=', pypath + '=' + pathstr +\n                os.pathsep)\nelse:\n    env.append(pypath + '=' + pathstr)\n",
        "CUT_2": "\"\"\"\n    Add a PYTHONPATH entry to a list of enviroment variables.\n\n    This allows to extend the environment of an external process\n    created with QProcess with our additions to PYTHONPATH.\n\n    Parameters\n    ----------\n    env: list\n        List of environment variables in the format of\n        QProcessEnvironment.\n    pathlist: list\n        List of paths to add to PYTHONPATH\n    drop_env: bool\n        Whether to drop PYTHONPATH previously found in the environment.\n    \"\"\"\nassert isinstance(env, list)\nassert all([is_text_string(path) for path in env])\npypath = 'PYTHONPATH'\npathstr = os.pathsep.join(pathlist)\nif not drop_env:\n    for index, var in enumerate(env[:]):\n        if var.startswith(pypath + '='):\n            env[index] = var.replace(pypath + '=', pypath + '=' + pathstr +\n                os.pathsep)\nelse:\n    env.append(pypath + '=' + pathstr)\n",
        "CUT_3": "pypath = os.environ.get('SPY_PYTHONPATH')\nif pypath:\n    pathlist = pypath.split(os.pathsep)\n    sys.path.extend(pathlist)\n",
        "CUT_4": "\"\"\"\n    Extract url list from MIME data\n    extlist: for example ('.py', '.pyw')\n    \"\"\"\npathlist = []\nif source.hasUrls():\n    for url in source.urls():\n        path = _process_mime_path(unquote(to_text_string(url.toString())),\n            extlist)\n        if path is not None:\n            pathlist.append(path)\nelif source.hasText():\n    for rawpath in to_text_string(source.text()).splitlines():\n        path = _process_mime_path(rawpath, extlist)\n        if path is not None:\n            pathlist.append(path)\nif pathlist:\n    return pathlist\n",
        "CUT_5": "\"\"\"\n    Extract url list from MIME data\n    extlist: for example ('.py', '.pyw')\n    \"\"\"\npathlist = []\nif source.hasUrls():\n    for url in source.urls():\n        path = _process_mime_path(unquote(to_text_string(url.toString())),\n            extlist)\n        if path is not None:\n            pathlist.append(path)\nelif source.hasText():\n    for rawpath in to_text_string(source.text()).splitlines():\n        path = _process_mime_path(rawpath, extlist)\n        if path is not None:\n            pathlist.append(path)\nif pathlist:\n    return pathlist\n"
    },
    {
        "functionName": "test_bsdsockets",
        "className": null,
        "fileName": "/spyder/utils/tests/test_bsdsocket.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test write-read packet methods.\"\"\"\naddress = '127.0.0.1', 9999\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.setblocking(0)\nserver.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nserver.bind(address)\nserver.listen(2)\nclient = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient.connect(address)\nclient.send('data to be catched'.encode('utf-8'))\naccsock, addr = server.accept()\nassert accsock.recv(4096) == b'data to be catched'\nwrite_packet(client, 'a tiny piece of data')\nread = read_packet(accsock)\nassert read == 'a tiny piece of data'\nclient.close()\nserver.close()\npytest.mark.skipif(os.name == 'nt', reason=\n    'A non-blocking socket operation cannot be completed in Windows immediately'\n    )",
        "CUT_1": "\"\"\"Find and return a non used port\"\"\"\nimport socket\nwhile True:\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.\n            IPPROTO_TCP)\n        sock.bind(('127.0.0.1', default_port))\n    except socket.error as _msg:\n        default_port += 1\n    else:\n        break\n    finally:\n        sock.close()\n        sock = None\nreturn default_port\n",
        "CUT_2": "\"\"\"Find and return a non used port\"\"\"\nimport socket\nwhile True:\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.\n            IPPROTO_TCP)\n        sock.bind(('127.0.0.1', default_port))\n    except socket.error as _msg:\n        default_port += 1\n    else:\n        break\n    finally:\n        sock.close()\n        sock = None\nreturn default_port\n",
        "CUT_3": "\"\"\"\n    Simple socket client used to send the args passed to the Spyder\n    executable to an already running instance.\n\n    Args can be Python scripts or files with these extensions: .spydata, .mat,\n    .npy, or .h5, which can be imported by the Variable Explorer.\n    \"\"\"\nfrom spyder.config.manager import CONF\nport = CONF.get('main', 'open_files_port')\nfor _x in range(200):\n    try:\n        for arg in args:\n            client = socket.socket(socket.AF_INET, socket.SOCK_STREAM,\n                socket.IPPROTO_TCP)\n            client.connect(('127.0.0.1', port))\n            if is_unicode(arg):\n                arg = arg.encode('utf-8')\n            client.send(osp.abspath(arg))\n            client.close()\n    except socket.error:\n        time.sleep(0.25)\n        continue\n    break\n",
        "CUT_4": "\"\"\"\n    Simple socket client used to send the args passed to the Spyder\n    executable to an already running instance.\n\n    Args can be Python scripts or files with these extensions: .spydata, .mat,\n    .npy, or .h5, which can be imported by the Variable Explorer.\n    \"\"\"\nfrom spyder.config.manager import CONF\nport = CONF.get('main', 'open_files_port')\nfor _x in range(200):\n    try:\n        for arg in args:\n            client = socket.socket(socket.AF_INET, socket.SOCK_STREAM,\n                socket.IPPROTO_TCP)\n            client.connect(('127.0.0.1', port))\n            if is_unicode(arg):\n                arg = arg.encode('utf-8')\n            client.send(osp.abspath(arg))\n            client.close()\n    except socket.error:\n        time.sleep(0.25)\n        continue\n    break\n",
        "CUT_5": "connected = False\ninitial_time = time.time()\nconnection_error = None\nwhile not connected:\n    try:\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.socket.connect((self.host, int(self.port)))\n        connected = True\n    except Exception as e:\n        connection_error = e\n    if time.time() - initial_time > self.MAX_TIMEOUT_TIME:\n        break\nreturn connected, connection_error, None\n"
    },
    {
        "functionName": "test_symlinks",
        "className": null,
        "fileName": "/spyder/utils/tests/test_encoding.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Check that modifing symlinks files changes source file and keeps symlinks.\n    \"\"\"\nbase_dir = tmpdir.mkdir('symlinks')\nbase_file = base_dir.join('symlinks_text.txt')\nbase_file_path = to_text_string(base_file)\nwrite('Some text for symlink', base_file_path)\nsymlink_file = pathlib.Path(base_dir.join('link-to-symlinks_text.txt'))\nsymlink_file.symlink_to(base_file_path)\nsymlink_file_path = to_text_string(symlink_file)\nassert os.path.islink(symlink_file_path)\nencoding = write('New text for symlink', symlink_file_path)\nassert os.path.islink(symlink_file_path)\nassert base_file.read_text(encoding) == symlink_file.read_text(encoding)\nassert symlink_file.read_text(encoding) == 'New text for symlink'\npytest.mark.firstpytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on Win!')",
        "CUT_1": "os.remove(os.path.join(filename, 'symlink'))\nos.rmdir(filename)\n",
        "CUT_2": "os.remove(os.path.join(filename, 'symlink'))\nos.rmdir(filename)\n",
        "CUT_3": "\"\"\"\n    Write 'lines' to file ('filename') assuming 'encoding'\n    Return (eventually new) encoding\n    \"\"\"\nreturn write(os.linesep.join(lines), filename, encoding, mode)\n",
        "CUT_4": "\"\"\"\n    Write 'lines' to file ('filename') assuming 'encoding'\n    Return (eventually new) encoding\n    \"\"\"\nreturn write(os.linesep.join(lines), filename, encoding, mode)\n",
        "CUT_5": "\"\"\"\n    Read lines from file ('filename')\n    Return lines and encoding\n    \"\"\"\ntext, encoding = read(filename, encoding)\nreturn text.split(os.linesep), encoding\n"
    },
    {
        "functionName": "test_permissions",
        "className": null,
        "fileName": "/spyder/utils/tests/test_encoding.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Check that file permissions are preserved.\"\"\"\np_file = tmpdir.mkdir('permissions').join('permissions_text.txt')\np_file = to_text_string(p_file)\nwrite('Some text', p_file)\nst = os.stat(p_file)\nmode = st.st_mode | stat.S_IEXEC\nos.chmod(p_file, mode)\nold_mode = os.stat(p_file).st_mode\nwrite('Some text and more', p_file)\nnew_mode = os.stat(p_file).st_mode\nassert old_mode == new_mode\n",
        "CUT_1": "\"\"\"\n    Write 'text' to file ('filename') assuming 'encoding' in an atomic way\n    Return (eventually new) encoding\n    \"\"\"\ntext, encoding = encode(text, encoding)\nif os.name == 'nt':\n    try:\n        absolute_path_filename = pathlib.Path(filename).resolve()\n        if absolute_path_filename.exists():\n            absolute_filename = to_text_string(absolute_path_filename)\n        else:\n            absolute_filename = osp.realpath(filename)\n    except (OSError, RuntimeError):\n        absolute_filename = osp.realpath(filename)\nelse:\n    absolute_filename = osp.realpath(filename)\nif 'a' in mode:\n    with open(absolute_filename, mode) as textfile:\n        textfile.write(text)\nelse:\n    try:\n        file_stat = os.stat(absolute_filename)\n        original_mode = file_stat.st_mode\n        creation = file_stat.st_atime\n    except OSError:\n        umask = os.umask(0)\n        os.umask(umask)\n        original_mode = 511 & ~umask\n        creation = time.time()\n    try:\n        tempfolder = None\n        if 'dropbox' in absolute_filename.lower():\n            tempfolder = tempfile.gettempdir()\n        with atomic_write(absolute_filename, overwrite=True, mode=mode, dir\n            =tempfolder) as textfile:\n            textfile.write(text)\n    except OSError as error:\n        if error.errno != errno.EINVAL:\n            with open(absolute_filename, mode) as textfile:\n                textfile.write(text)\n    try:\n        os.chmod(absolute_filename, original_mode)\n        file_stat = os.stat(absolute_filename)\n        os.utime(absolute_filename, (creation, file_stat.st_mtime))\n    except OSError:\n        pass\nreturn encoding\n",
        "CUT_2": "\"\"\"\n    Write 'text' to file ('filename') assuming 'encoding' in an atomic way\n    Return (eventually new) encoding\n    \"\"\"\ntext, encoding = encode(text, encoding)\nif os.name == 'nt':\n    try:\n        absolute_path_filename = pathlib.Path(filename).resolve()\n        if absolute_path_filename.exists():\n            absolute_filename = to_text_string(absolute_path_filename)\n        else:\n            absolute_filename = osp.realpath(filename)\n    except (OSError, RuntimeError):\n        absolute_filename = osp.realpath(filename)\nelse:\n    absolute_filename = osp.realpath(filename)\nif 'a' in mode:\n    with open(absolute_filename, mode) as textfile:\n        textfile.write(text)\nelse:\n    try:\n        file_stat = os.stat(absolute_filename)\n        original_mode = file_stat.st_mode\n        creation = file_stat.st_atime\n    except OSError:\n        umask = os.umask(0)\n        os.umask(umask)\n        original_mode = 511 & ~umask\n        creation = time.time()\n    try:\n        tempfolder = None\n        if 'dropbox' in absolute_filename.lower():\n            tempfolder = tempfile.gettempdir()\n        with atomic_write(absolute_filename, overwrite=True, mode=mode, dir\n            =tempfolder) as textfile:\n            textfile.write(text)\n    except OSError as error:\n        if error.errno != errno.EINVAL:\n            with open(absolute_filename, mode) as textfile:\n                textfile.write(text)\n    try:\n        os.chmod(absolute_filename, original_mode)\n        file_stat = os.stat(absolute_filename)\n        os.utime(absolute_filename, (creation, file_stat.st_mtime))\n    except OSError:\n        pass\nreturn encoding\n",
        "CUT_3": "os.remove(os.path.join(filename, 'symlink'))\nos.rmdir(filename)\n",
        "CUT_4": "os.remove(os.path.join(filename, 'symlink'))\nos.rmdir(filename)\n",
        "CUT_5": "\"\"\"Error handler for `shutil.rmtree`.\n\n    If the error is due to an access error (read-only file), it\n    attempts to add write permission and then retries.\n    If the error is for another reason, it re-raises the error.\n\n    Usage: `shutil.rmtree(path, onerror=onerror)\"\"\"\nif not os.access(path, os.W_OK):\n    os.chmod(path, stat.S_IWUSR)\n    function(path)\nelse:\n    raise\n"
    },
    {
        "functionName": "test_timestamp",
        "className": null,
        "fileName": "/spyder/utils/tests/test_encoding.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Check that the modification timestamp is preserved.\"\"\"\ntmp_file = tmpdir.mkdir('timestamp').join('test_file.txt')\ntmp_file = to_text_string(tmp_file)\nwrite('Test text', tmp_file)\nst = os.stat(tmp_file)\nactual_creation_time = st.st_atime\nwrite('New text', tmp_file)\ncreation_time = os.stat(tmp_file).st_atime\nassert actual_creation_time == creation_time\n",
        "CUT_1": "\"\"\"\n    Write 'lines' to file ('filename') assuming 'encoding'\n    Return (eventually new) encoding\n    \"\"\"\nreturn write(os.linesep.join(lines), filename, encoding, mode)\n",
        "CUT_2": "\"\"\"\n    Write 'lines' to file ('filename') assuming 'encoding'\n    Return (eventually new) encoding\n    \"\"\"\nreturn write(os.linesep.join(lines), filename, encoding, mode)\n",
        "CUT_3": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_4": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_5": "\"\"\"Simulate stderr\"\"\"\nself.flush()\nself.write(text, flush=True, error=True)\nif get_debug_level():\n    STDERR.write(text)\n"
    },
    {
        "functionName": "test_is_text_file",
        "className": null,
        "fileName": "/spyder/utils/tests/test_encoding.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "p = tmpdir.mkdir('sub').join('random_text.txt')\np.write('Some random text')\nassert is_text_file(str(p)) == True\n",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_3": "\"\"\"Return a workspace with a root_path other than tmpdir.\"\"\"\nws_path = str(tmpdir.mkdir('test123').mkdir('test456'))\nws = Workspace(uris.from_fs_path(ws_path), Mock())\nws._config = Config(ws.root_uri, {}, 0, {})\nreturn ws\npytest.fixture",
        "CUT_4": "text = BACKSLASH_REPLACE_REGEX.sub('\\\\2', self.value)\nif self.name == 'left_curly_name':\n    text = text[1:]\nreturn text\n",
        "CUT_5": "text = BACKSLASH_REPLACE_REGEX.sub('\\\\2', self.value)\nif self.name == 'left_curly_name':\n    text = text[1:]\nreturn text\n"
    },
    {
        "functionName": "test_files_encodings",
        "className": null,
        "fileName": "/spyder/utils/tests/test_encoding.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "with open(os.path.join(__location__, text_file), 'rb') as f:\n    text = f.read()\n    assert get_coding(text).lower() == expected_encoding.lower()\npytest.mark.parametrize('expected_encoding, text_file', [('utf-8',\n    'utf-8.txt'), ('windows-1252', 'windows-1252.txt'), ('ascii',\n    'ascii.txt'), ('Big5', 'Big5.txt'), ('KOI8-R', 'KOI8-R.txt')])",
        "CUT_1": "\"\"\"Replaces the selected text by its lower version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.lower())\n",
        "CUT_2": "\"\"\"Replaces the selected text by its lower version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.lower())\n",
        "CUT_3": "\"\"\"Replaces the selected text by its upper version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.upper())\n",
        "CUT_4": "\"\"\"Replaces the selected text by its upper version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.upper())\n",
        "CUT_5": "\"\"\"Return the last valid object name in string\"\"\"\ntxt_end = ''\nfor startchar, endchar in ['[]', '()']:\n    if txt.endswith(endchar):\n        pos = txt.rfind(startchar)\n        if pos:\n            txt_end = txt[pos:]\n            txt = txt[:pos]\ntokens = re.split(SYMBOLS, txt)\ntoken = None\ntry:\n    while token is None or re.match(SYMBOLS, token):\n        token = tokens.pop()\n    if token.endswith('.'):\n        token = token[:-1]\n    if token.startswith('.'):\n        return None\n    if last:\n        token += txt[txt.rfind(token) + len(token)]\n    token += txt_end\n    if token:\n        return token\nexcept IndexError:\n    return None\n"
    },
    {
        "functionName": "compare_formats",
        "className": null,
        "fileName": "/spyder/utils/tests/test_syntaxhighlighters.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert len(actualFormats) == len(expectedFormats)\nfor actual, expected in zip(actualFormats, expectedFormats):\n    assert actual.start == expected[0]\n    assert actual.length == expected[1]\n    assert actual.format.foreground().color().name() == sh.formats[expected[2]\n        ].foreground().color().name()\n",
        "CUT_1": "\"\"\"Return color name assigned to a given format\"\"\"\nreturn self.formats[fmt].foreground().color().name()\n",
        "CUT_2": "\"\"\"Return color name assigned to a given format\"\"\"\nreturn self.formats[fmt].foreground().color().name()\n",
        "CUT_3": "\"\"\"Return foreground ('normal' text) color\"\"\"\nreturn self.formats['normal'].foreground().color()\n",
        "CUT_4": "\"\"\"Return foreground ('normal' text) color\"\"\"\nreturn self.formats['normal'].foreground().color()\n",
        "CUT_5": "\"\"\" Return color for the comments \"\"\"\nreturn self.formats['comment'].foreground().color()\n"
    },
    {
        "functionName": "test_HtmlSH_basic",
        "className": null,
        "fileName": "/spyder/utils/tests/test_syntaxhighlighters.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "txt = '<p style=\"color:red;\">Foo <!--comment--> bar.</p>'\ndoc = QTextDocument(txt)\nsh = HtmlSH(doc, color_scheme='Spyder')\nsh.rehighlightBlock(doc.firstBlock())\nres = [(0, 2, 'builtin'), (2, 6, 'keyword'), (8, 1, 'normal'), (9, 12,\n    'string'), (21, 1, 'builtin'), (22, 4, 'normal'), (26, 14, 'comment'),\n    (40, 5, 'normal'), (45, 4, 'builtin')]\ncompare_formats(doc.firstBlock().layout().additionalFormats(), res, sh)\n",
        "CUT_1": "self._tokmap = {Text: 'normal', Generic: 'normal', Other: 'normal', Keyword:\n    'keyword', Token.Operator: 'normal', Name.Builtin: 'builtin', Name:\n    'normal', Comment: 'comment', String: 'string', Number: 'number'}\nif self._lang_name is not None:\n    self._lexer = get_lexer_by_name(self._lang_name)\nBaseSH.__init__(self, parent, font, color_scheme)\nself._worker_manager = WorkerManager()\nself._charlist = []\nself._allow_highlight = True\n",
        "CUT_2": "self._tokmap = {Text: 'normal', Generic: 'normal', Other: 'normal', Keyword:\n    'keyword', Token.Operator: 'normal', Name.Builtin: 'builtin', Name:\n    'normal', Comment: 'comment', String: 'string', Number: 'number'}\nif self._lang_name is not None:\n    self._lexer = get_lexer_by_name(self._lang_name)\nBaseSH.__init__(self, parent, font, color_scheme)\nself._worker_manager = WorkerManager()\nself._charlist = []\nself._allow_highlight = True\n",
        "CUT_3": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n"
    },
    {
        "functionName": "test_HtmlSH_unclosed_commend",
        "className": null,
        "fileName": "/spyder/utils/tests/test_syntaxhighlighters.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "txt = '-->'\ndoc = QTextDocument(txt)\nsh = HtmlSH(doc, color_scheme='Spyder')\nsh.rehighlightBlock(doc.firstBlock())\nres = [(0, 3, 'normal')]\ncompare_formats(doc.firstBlock().layout().additionalFormats(), res, sh)\n",
        "CUT_1": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_2": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_3": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n",
        "CUT_4": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setDocumentMargin(self._margin)\ndoc.setHtml(options.text)\nreturn options, doc\n"
    },
    {
        "functionName": "test_python_string_prefix",
        "className": null,
        "fileName": "/spyder/utils/tests/test_syntaxhighlighters.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if PY3:\n    prefixes = ('r', 'u', 'R', 'U', 'f', 'F', 'fr', 'Fr', 'fR', 'FR', 'rf',\n        'rF', 'Rf', 'RF', 'b', 'B', 'br', 'Br', 'bR', 'BR', 'rb', 'rB',\n        'Rb', 'RB')\nelse:\n    prefixes = ('r', 'u', 'ur', 'R', 'U', 'UR', 'Ur', 'uR', 'b', 'B', 'br',\n        'Br', 'bR', 'BR')\nfor prefix in prefixes:\n    txt = \"[%s'test', %s'''test''']\" % (prefix, prefix)\n    doc = QTextDocument(txt)\n    sh = PythonSH(doc, color_scheme='Spyder')\n    sh.rehighlightBlock(doc.firstBlock())\n    offset = len(prefix)\n    res = [(0, 1, 'normal'), (1, 6 + offset, 'string'), (7 + offset, 2,\n        'normal'), (9 + offset, 10 + offset, 'string'), (19 + 2 * offset, 1,\n        'normal')]\n    compare_formats(doc.firstBlock().layout().additionalFormats(), res, sh)\n",
        "CUT_1": "\"\"\"Strongly inspired from idlelib.ColorDelegator.make_pat\"\"\"\nkwlist = keyword.kwlist + additional_keywords\nbuiltinlist = [str(name) for name in dir(builtins) if not name.startswith('_')\n    ] + additional_builtins\nrepeated = set(kwlist) & set(builtinlist)\nfor repeated_element in repeated:\n    kwlist.remove(repeated_element)\nkw = '\\\\b' + any('keyword', kwlist) + '\\\\b'\nbuiltin = '([^.\\'\\\\\"\\\\\\\\#]\\\\b|^)' + any('builtin', builtinlist) + '\\\\b'\ncomment = any('comment', ['#[^\\\\n]*'])\ninstance = any('instance', ['\\\\bself\\\\b', '\\\\bcls\\\\b',\n    '^\\\\s*@([a-zA-Z_][a-zA-Z0-9_]*)(\\\\.[a-zA-Z_][a-zA-Z0-9_]*)*'])\nnumber_regex = ['\\\\b[+-]?[0-9]+[lLjJ]?\\\\b',\n    '\\\\b[+-]?0[xX][0-9A-Fa-f]+[lL]?\\\\b', '\\\\b[+-]?0[oO][0-7]+[lL]?\\\\b',\n    '\\\\b[+-]?0[bB][01]+[lL]?\\\\b',\n    '\\\\b[+-]?[0-9]+(?:\\\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?[jJ]?\\\\b']\nif PY3:\n    prefix = 'r|u|R|U|f|F|fr|Fr|fR|FR|rf|rF|Rf|RF|b|B|br|Br|bR|BR|rb|rB|Rb|RB'\nelse:\n    prefix = 'r|u|ur|R|U|UR|Ur|uR|b|B|br|Br|bR|BR'\nsqstring = \"(\\\\b(%s))?'[^'\\\\\\\\\\\\n]*(\\\\\\\\.[^'\\\\\\\\\\\\n]*)*'?\" % prefix\ndqstring = '(\\\\b(%s))?\"[^\"\\\\\\\\\\\\n]*(\\\\\\\\.[^\"\\\\\\\\\\\\n]*)*\"?' % prefix\nuf_sqstring = (\"(\\\\b(%s))?'[^'\\\\\\\\\\\\n]*(\\\\\\\\.[^'\\\\\\\\\\\\n]*)*(\\\\\\\\)$(?!')$\" %\n    prefix)\nuf_dqstring = ('(\\\\b(%s))?\"[^\"\\\\\\\\\\\\n]*(\\\\\\\\.[^\"\\\\\\\\\\\\n]*)*(\\\\\\\\)$(?!\")$' %\n    prefix)\nufe_sqstring = (\n    \"(\\\\b(%s))?'[^'\\\\\\\\\\\\n]*(\\\\\\\\.[^'\\\\\\\\\\\\n]*)*(?!\\\\\\\\)$(?!')$\" % prefix)\nufe_dqstring = (\n    '(\\\\b(%s))?\"[^\"\\\\\\\\\\\\n]*(\\\\\\\\.[^\"\\\\\\\\\\\\n]*)*(?!\\\\\\\\)$(?!\")$' % prefix)\nsq3string = \"(\\\\b(%s))?'''[^'\\\\\\\\]*((\\\\\\\\.|'(?!''))[^'\\\\\\\\]*)*(''')?\" % prefix\ndq3string = '(\\\\b(%s))?\"\"\"[^\"\\\\\\\\]*((\\\\\\\\.|\"(?!\"\"))[^\"\\\\\\\\]*)*(\"\"\")?' % prefix\nuf_sq3string = (\n    \"(\\\\b(%s))?'''[^'\\\\\\\\]*((\\\\\\\\.|'(?!''))[^'\\\\\\\\]*)*(\\\\\\\\)?(?!''')$\" % prefix\n    )\nuf_dq3string = (\n    '(\\\\b(%s))?\"\"\"[^\"\\\\\\\\]*((\\\\\\\\.|\"(?!\"\"))[^\"\\\\\\\\]*)*(\\\\\\\\)?(?!\"\"\")$' % prefix\n    )\nif PY36_OR_MORE:\n    number_regex = ['\\\\b[+-]?0[xX](?:_?[0-9A-Fa-f])+[lL]?\\\\b',\n        '\\\\b[+-]?0[bB](?:_?[01])+[lL]?\\\\b',\n        '\\\\b[+-]?0[oO](?:_?[0-7])+[lL]?\\\\b',\n        '\\\\b[+-]?(?:0(?:_?0)*|[1-9](?:_?[0-9])*)[lL]?\\\\b',\n        \"\\\\b((\\\\.[0-9](?:_?[0-9])*')|\\\\.[0-9](?:_?[0-9])*)([eE][+-]?[0-9](?:_?[0-9])*)?[jJ]?\\x08\"\n        , '\\\\b[0-9](?:_?[0-9])*([eE][+-]?[0-9](?:_?[0-9])*)?[jJ]?\\\\b',\n        '\\\\b[0-9](?:_?[0-9])*[jJ]\\\\b']\nnumber = any('number', number_regex)\nstring = any('string', [sq3string, dq3string, sqstring, dqstring])\nufstring1 = any('uf_sqstring', [uf_sqstring])\nufstring2 = any('uf_dqstring', [uf_dqstring])\nufstring3 = any('uf_sq3string', [uf_sq3string])\nufstring4 = any('uf_dq3string', [uf_dq3string])\nufstring5 = any('ufe_sqstring', [ufe_sqstring])\nufstring6 = any('ufe_dqstring', [ufe_dqstring])\nreturn '|'.join([instance, kw, builtin, comment, ufstring1, ufstring2,\n    ufstring3, ufstring4, ufstring5, ufstring6, string, number, any('SYNC',\n    ['\\\\n'])])\n",
        "CUT_2": "\"\"\"Strongly inspired from idlelib.ColorDelegator.make_pat\"\"\"\nkwlist = keyword.kwlist + additional_keywords\nbuiltinlist = [str(name) for name in dir(builtins) if not name.startswith('_')\n    ] + additional_builtins\nrepeated = set(kwlist) & set(builtinlist)\nfor repeated_element in repeated:\n    kwlist.remove(repeated_element)\nkw = '\\\\b' + any('keyword', kwlist) + '\\\\b'\nbuiltin = '([^.\\'\\\\\"\\\\\\\\#]\\\\b|^)' + any('builtin', builtinlist) + '\\\\b'\ncomment = any('comment', ['#[^\\\\n]*'])\ninstance = any('instance', ['\\\\bself\\\\b', '\\\\bcls\\\\b',\n    '^\\\\s*@([a-zA-Z_][a-zA-Z0-9_]*)(\\\\.[a-zA-Z_][a-zA-Z0-9_]*)*'])\nnumber_regex = ['\\\\b[+-]?[0-9]+[lLjJ]?\\\\b',\n    '\\\\b[+-]?0[xX][0-9A-Fa-f]+[lL]?\\\\b', '\\\\b[+-]?0[oO][0-7]+[lL]?\\\\b',\n    '\\\\b[+-]?0[bB][01]+[lL]?\\\\b',\n    '\\\\b[+-]?[0-9]+(?:\\\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?[jJ]?\\\\b']\nif PY3:\n    prefix = 'r|u|R|U|f|F|fr|Fr|fR|FR|rf|rF|Rf|RF|b|B|br|Br|bR|BR|rb|rB|Rb|RB'\nelse:\n    prefix = 'r|u|ur|R|U|UR|Ur|uR|b|B|br|Br|bR|BR'\nsqstring = \"(\\\\b(%s))?'[^'\\\\\\\\\\\\n]*(\\\\\\\\.[^'\\\\\\\\\\\\n]*)*'?\" % prefix\ndqstring = '(\\\\b(%s))?\"[^\"\\\\\\\\\\\\n]*(\\\\\\\\.[^\"\\\\\\\\\\\\n]*)*\"?' % prefix\nuf_sqstring = (\"(\\\\b(%s))?'[^'\\\\\\\\\\\\n]*(\\\\\\\\.[^'\\\\\\\\\\\\n]*)*(\\\\\\\\)$(?!')$\" %\n    prefix)\nuf_dqstring = ('(\\\\b(%s))?\"[^\"\\\\\\\\\\\\n]*(\\\\\\\\.[^\"\\\\\\\\\\\\n]*)*(\\\\\\\\)$(?!\")$' %\n    prefix)\nufe_sqstring = (\n    \"(\\\\b(%s))?'[^'\\\\\\\\\\\\n]*(\\\\\\\\.[^'\\\\\\\\\\\\n]*)*(?!\\\\\\\\)$(?!')$\" % prefix)\nufe_dqstring = (\n    '(\\\\b(%s))?\"[^\"\\\\\\\\\\\\n]*(\\\\\\\\.[^\"\\\\\\\\\\\\n]*)*(?!\\\\\\\\)$(?!\")$' % prefix)\nsq3string = \"(\\\\b(%s))?'''[^'\\\\\\\\]*((\\\\\\\\.|'(?!''))[^'\\\\\\\\]*)*(''')?\" % prefix\ndq3string = '(\\\\b(%s))?\"\"\"[^\"\\\\\\\\]*((\\\\\\\\.|\"(?!\"\"))[^\"\\\\\\\\]*)*(\"\"\")?' % prefix\nuf_sq3string = (\n    \"(\\\\b(%s))?'''[^'\\\\\\\\]*((\\\\\\\\.|'(?!''))[^'\\\\\\\\]*)*(\\\\\\\\)?(?!''')$\" % prefix\n    )\nuf_dq3string = (\n    '(\\\\b(%s))?\"\"\"[^\"\\\\\\\\]*((\\\\\\\\.|\"(?!\"\"))[^\"\\\\\\\\]*)*(\\\\\\\\)?(?!\"\"\")$' % prefix\n    )\nif PY36_OR_MORE:\n    number_regex = ['\\\\b[+-]?0[xX](?:_?[0-9A-Fa-f])+[lL]?\\\\b',\n        '\\\\b[+-]?0[bB](?:_?[01])+[lL]?\\\\b',\n        '\\\\b[+-]?0[oO](?:_?[0-7])+[lL]?\\\\b',\n        '\\\\b[+-]?(?:0(?:_?0)*|[1-9](?:_?[0-9])*)[lL]?\\\\b',\n        \"\\\\b((\\\\.[0-9](?:_?[0-9])*')|\\\\.[0-9](?:_?[0-9])*)([eE][+-]?[0-9](?:_?[0-9])*)?[jJ]?\\x08\"\n        , '\\\\b[0-9](?:_?[0-9])*([eE][+-]?[0-9](?:_?[0-9])*)?[jJ]?\\\\b',\n        '\\\\b[0-9](?:_?[0-9])*[jJ]\\\\b']\nnumber = any('number', number_regex)\nstring = any('string', [sq3string, dq3string, sqstring, dqstring])\nufstring1 = any('uf_sqstring', [uf_sqstring])\nufstring2 = any('uf_dqstring', [uf_dqstring])\nufstring3 = any('uf_sq3string', [uf_sq3string])\nufstring4 = any('uf_dq3string', [uf_dq3string])\nufstring5 = any('ufe_sqstring', [ufe_sqstring])\nufstring6 = any('ufe_dqstring', [ufe_dqstring])\nreturn '|'.join([instance, kw, builtin, comment, ufstring1, ufstring2,\n    ufstring3, ufstring4, ufstring5, ufstring6, string, number, any('SYNC',\n    ['\\\\n'])])\n",
        "CUT_3": "\"\"\"Help on Spyder console\"\"\"\nQMessageBox.about(self, _('Help'), \n    \"\"\"<b>%s</b>\n                          <p><i>%s</i><br>    edit foobar.py\n                          <p><i>%s</i><br>    xedit foobar.py\n                          <p><i>%s</i><br>    run foobar.py\n                          <p><i>%s</i><br>    clear x, y\n                          <p><i>%s</i><br>    !ls\n                          <p><i>%s</i><br>    object?\n                          <p><i>%s</i><br>    result = oedit(object)\n                          \"\"\"\n     % (_('Shell special commands:'), _('Internal editor:'), _(\n    'External editor:'), _('Run script:'), _('Remove references:'), _(\n    'System commands:'), _('Python help:'), _('GUI-based editor:')))\nSlot()",
        "CUT_4": "\"\"\"Help on Spyder console\"\"\"\nQMessageBox.about(self, _('Help'), \n    \"\"\"<b>%s</b>\n                          <p><i>%s</i><br>    edit foobar.py\n                          <p><i>%s</i><br>    xedit foobar.py\n                          <p><i>%s</i><br>    run foobar.py\n                          <p><i>%s</i><br>    clear x, y\n                          <p><i>%s</i><br>    !ls\n                          <p><i>%s</i><br>    object?\n                          <p><i>%s</i><br>    result = oedit(object)\n                          \"\"\"\n     % (_('Shell special commands:'), _('Internal editor:'), _(\n    'External editor:'), _('Run script:'), _('Remove references:'), _(\n    'System commands:'), _('Python help:'), _('GUI-based editor:')))\nSlot()",
        "CUT_5": "\"\"\"\n        Show a warning when trying to modify the PyLS advanced\n        settings.\n        \"\"\"\nif self.get_option('advanced/enabled'):\n    return\nif state:\n    QMessageBox.warning(self, _('Warning'), _(\n        \"<b>Modifying these options can break code completion!!</b><br><br>If that's the case, please reset your Spyder preferences by going to the menu<br><br><tt>Tools > Reset Spyder to factory defaults</tt><br><br>instead of reporting a bug.\"\n        ))\nSlot(bool)"
    },
    {
        "functionName": "test_Markdown_basic",
        "className": null,
        "fileName": "/spyder/utils/tests/test_syntaxhighlighters.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "txt = 'Some __random__ **text** with ~~different~~ [styles](link_url)'\ndoc = QTextDocument(txt)\nsh = MarkdownSH(doc, color_scheme='Spyder')\nsh.rehighlightBlock(doc.firstBlock())\nres = [(0, 5, 'normal'), (5, 10, 'italic'), (15, 1, 'normal'), (16, 8,\n    'strong'), (24, 6, 'normal'), (30, 13, 'italic'), (43, 1, 'normal'), (\n    44, 8, 'string'), (52, 1, 'normal'), (53, 8, 'string'), (61, 1, 'normal')]\ncompare_formats(doc.firstBlock().layout().additionalFormats(), res, sh)\n",
        "CUT_1": "if is_italic:\n    return 'italic'\nelse:\n    return 'normal'\n",
        "CUT_2": "if is_italic:\n    return 'italic'\nelse:\n    return 'normal'\n",
        "CUT_3": "self._tokmap = {Text: 'normal', Generic: 'normal', Other: 'normal', Keyword:\n    'keyword', Token.Operator: 'normal', Name.Builtin: 'builtin', Name:\n    'normal', Comment: 'comment', String: 'string', Number: 'number'}\nif self._lang_name is not None:\n    self._lexer = get_lexer_by_name(self._lang_name)\nBaseSH.__init__(self, parent, font, color_scheme)\nself._worker_manager = WorkerManager()\nself._charlist = []\nself._allow_highlight = True\n",
        "CUT_4": "self._tokmap = {Text: 'normal', Generic: 'normal', Other: 'normal', Keyword:\n    'keyword', Token.Operator: 'normal', Name.Builtin: 'builtin', Name:\n    'normal', Comment: 'comment', String: 'string', Number: 'number'}\nif self._lang_name is not None:\n    self._lexer = get_lexer_by_name(self._lang_name)\nBaseSH.__init__(self, parent, font, color_scheme)\nself._worker_manager = WorkerManager()\nself._charlist = []\nself._allow_highlight = True\n",
        "CUT_5": "\"\"\"Return foreground ('normal' text) color\"\"\"\nreturn self.formats['normal'].foreground().color()\n"
    },
    {
        "functionName": "test_python_outline_explorer_comment",
        "className": null,
        "fileName": "/spyder/utils/tests/test_syntaxhighlighters.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert PythonSH.OECOMMENT.match(line)\npytest.mark.parametrize('line', ['# --- First variant',\n    '#------ 2nd variant', '### 3rd variant'])",
        "CUT_1": "\"\"\"\n        Hook method executed just before the command line is\n        interpreted, but after the input prompt is generated and issued.\n\n        Here we switch ! and non !\n        \"\"\"\nif not self.pdb_use_exclamation_mark:\n    return line\nif not line:\n    return line\nif line[0] == '!':\n    line = line[1:]\nelse:\n    line = '!' + line\nreturn line\n",
        "CUT_2": "return self.highlighter_class is sh.PythonSH\n",
        "CUT_3": "return self.highlighter_class is sh.PythonSH\n",
        "CUT_4": "self.setToolTip(0, _('Line %s') % str(self.line))\n",
        "CUT_5": "self.setToolTip(0, _('Line %s') % str(self.line))\n"
    },
    {
        "functionName": "test_python_not_an_outline_explorer_comment",
        "className": null,
        "fileName": "/spyder/utils/tests/test_syntaxhighlighters.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert not PythonSH.OECOMMENT.match(line)\npytest.mark.parametrize('line', ['#---', '#--------', '#---   ', '# -------'])",
        "CUT_1": "\"\"\"\n        Hook method executed just before the command line is\n        interpreted, but after the input prompt is generated and issued.\n\n        Here we switch ! and non !\n        \"\"\"\nif not self.pdb_use_exclamation_mark:\n    return line\nif not line:\n    return line\nif line[0] == '!':\n    line = line[1:]\nelse:\n    line = '!' + line\nreturn line\n",
        "CUT_2": "return self.highlighter_class is sh.PythonSH\n",
        "CUT_3": "return self.highlighter_class is sh.PythonSH\n",
        "CUT_4": "self.setToolTip(0, _('Line %s') % str(self.line))\n",
        "CUT_5": "self.setToolTip(0, _('Line %s') % str(self.line))\n"
    },
    {
        "functionName": "test_system",
        "className": null,
        "fileName": "/spyder/utils/tests/test_system.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test system physical memory usage.\"\"\"\nif os.name == 'nt':\n    assert windows_memory_usage() > 0\nelse:\n    assert memory_usage() > 0\n",
        "CUT_1": "\"\"\"Return memory usage.\"\"\"\nfrom spyder.utils.system import memory_usage\ntext = '%d%%' % memory_usage()\nreturn 'Mem ' + text.rjust(3)\n",
        "CUT_2": "\"\"\"Return memory usage.\"\"\"\nfrom spyder.utils.system import memory_usage\ntext = '%d%%' % memory_usage()\nreturn 'Mem ' + text.rjust(3)\n",
        "CUT_3": "\"\"\"Return the widget tooltip text.\"\"\"\nreturn _('Memory usage')\n",
        "CUT_4": "\"\"\"Return the widget tooltip text.\"\"\"\nreturn _('Memory usage')\n",
        "CUT_5": "\"\"\"Raise ImportError if feature is not supported.\"\"\"\nfrom spyder.utils.system import memory_usage\n"
    },
    {
        "functionName": "test_normalize_eols",
        "className": null,
        "fileName": "/spyder/utils/tests/test_sourcecode.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "text = 'a\\nb\\r\\nc\\rd'\nassert sourcecode.normalize_eols(text) == 'a\\nb\\nc\\nd'\n",
        "CUT_1": "\"\"\"Removes all ouput in the ipynb format (Json only)\"\"\"\ntry:\n    nb = nbformat.reads(self.toPlainText(), as_version=4)\n    if nb.cells:\n        for cell in nb.cells:\n            if 'outputs' in cell:\n                cell['outputs'] = []\n            if 'prompt_number' in cell:\n                cell['prompt_number'] = None\n    self.selectAll()\n    self.skip_rstrip = True\n    self.insertPlainText(nbformat.writes(nb))\n    self.skip_rstrip = False\nexcept Exception as e:\n    QMessageBox.critical(self, _('Removal error'), _(\n        \"\"\"It was not possible to remove outputs from this notebook. The error is:\n\n\"\"\"\n        ) + to_text_string(e))\n    return\nSlot()",
        "CUT_2": "\"\"\"Removes all ouput in the ipynb format (Json only)\"\"\"\ntry:\n    nb = nbformat.reads(self.toPlainText(), as_version=4)\n    if nb.cells:\n        for cell in nb.cells:\n            if 'outputs' in cell:\n                cell['outputs'] = []\n            if 'prompt_number' in cell:\n                cell['prompt_number'] = None\n    self.selectAll()\n    self.skip_rstrip = True\n    self.insertPlainText(nbformat.writes(nb))\n    self.skip_rstrip = False\nexcept Exception as e:\n    QMessageBox.critical(self, _('Removal error'), _(\n        \"\"\"It was not possible to remove outputs from this notebook. The error is:\n\n\"\"\"\n        ) + to_text_string(e))\n    return\nSlot()",
        "CUT_3": "\"\"\"Convert an IPython notebook to a Python script in editor\"\"\"\ntry:\n    nb = nbformat.reads(self.toPlainText(), as_version=4)\n    script = nbexporter().from_notebook_node(nb)[0]\nexcept Exception as e:\n    QMessageBox.critical(self, _('Conversion error'), _(\n        \"\"\"It was not possible to convert this notebook. The error is:\n\n\"\"\"\n        ) + to_text_string(e))\n    return\nself.sig_new_file.emit(script)\nSlot()",
        "CUT_4": "\"\"\"Convert an IPython notebook to a Python script in editor\"\"\"\ntry:\n    nb = nbformat.reads(self.toPlainText(), as_version=4)\n    script = nbexporter().from_notebook_node(nb)[0]\nexcept Exception as e:\n    QMessageBox.critical(self, _('Conversion error'), _(\n        \"\"\"It was not possible to convert this notebook. The error is:\n\n\"\"\"\n        ) + to_text_string(e))\n    return\nself.sig_new_file.emit(script)\nSlot()",
        "CUT_5": "return self.text\n"
    },
    {
        "functionName": "test_get_primary_at",
        "className": null,
        "fileName": "/spyder/utils/tests/test_sourcecode.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "code = \"\"\"import functools\nfunctools.partial\"\"\"\nassert sourcecode.get_primary_at(code, len(code)) == 'functools.partial'\n",
        "CUT_1": "assert isinstance(code, int)\nif code == 0:\n    self.reset()\nelif code == 1:\n    self.intensity = 1\nelif code == 3:\n    self.italic = True\nelif code == 4:\n    self.underline = True\nelif code == 22:\n    self.intensity = 0\n    self.bold = False\nelif code == 23:\n    self.italic = False\nelif code == 24:\n    self.underline = False\nelif code >= 30 and code <= 37:\n    self.foreground_color = code\nelif code == 39:\n    self.foreground_color = self.default_foreground_color\nelif code >= 40 and code <= 47:\n    self.background_color = code\nelif code == 49:\n    self.background_color = self.default_background_color\nself.set_style()\n",
        "CUT_2": "assert isinstance(code, int)\nif code == 0:\n    self.reset()\nelif code == 1:\n    self.intensity = 1\nelif code == 3:\n    self.italic = True\nelif code == 4:\n    self.underline = True\nelif code == 22:\n    self.intensity = 0\n    self.bold = False\nelif code == 23:\n    self.italic = False\nelif code == 24:\n    self.underline = False\nelif code >= 30 and code <= 37:\n    self.foreground_color = code\nelif code == 39:\n    self.foreground_color = self.default_foreground_color\nelif code >= 40 and code <= 47:\n    self.background_color = code\nelif code == 49:\n    self.background_color = self.default_background_color\nself.set_style()\n",
        "CUT_3": "\"\"\"Transform ipython code to python code.\"\"\"\nnumber_empty_lines = count_leading_empty_lines(code)\nif indent_only:\n    if LooseVersion(ipy_version) < LooseVersion('7.0.0'):\n        return code\n    if not code.endswith('\\n'):\n        code += '\\n'\n    lines = code.splitlines(keepends=True)\n    lines = leading_indent(leading_empty_lines(lines))\n    code = ''.join(lines)\nelif LooseVersion(ipy_version) < LooseVersion('7.0.0'):\n    tm = IPythonInputSplitter()\n    return tm.transform_cell(code)\nelse:\n    tm = TransformerManager()\n    code = tm.transform_cell(code)\nreturn '\\n' * number_empty_lines + code\n",
        "CUT_4": "code = text[:4]\nif self._ignore_code(code):\n    return\nif code in self.expected:\n    return\nerr_range = {'start': {'line': line_number - 1, 'character': offset}, 'end':\n    {'line': line_number - 1, 'character': 100 if line_number > len(self.\n    lines) else len(self.lines[line_number - 1])}}\nself.diagnostics.append({'source': 'pycodestyle', 'range': err_range,\n    'message': text, 'code': code, 'severity': _get_severity(code)})\n",
        "CUT_5": "with self._lock:\n    return method(self, *args, **kwargs)\nfunctools.wraps(method)"
    },
    {
        "functionName": "test_get_identifiers",
        "className": null,
        "fileName": "/spyder/utils/tests/test_sourcecode.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "code = \"\"\"import functools\nfunctools.partial\"\"\"\nassert set(sourcecode.get_identifiers(code)) == set(['import', 'functools',\n    'functools.partial'])\n",
        "CUT_1": "with self._lock:\n    return method(self, *args, **kwargs)\nfunctools.wraps(method)",
        "CUT_2": "\"\"\"Send message as a proper JSON-RPC request.\"\"\"\nif req is None:\n    return functools.partial(send_request, method=method)\nreturn send_message(req, method, kind=MessageKind.REQUEST)\n",
        "CUT_3": "\"\"\"Send message as a proper JSON-RPC request.\"\"\"\nif req is None:\n    return functools.partial(send_request, method=method)\nreturn send_message(req, method, kind=MessageKind.REQUEST)\n",
        "CUT_4": "\"\"\"Call function req and then emit its results to the completion server.\"\"\"\nif req is None:\n    return functools.partial(request, method=method, requires_response=\n        requires_response)\n@functools.wraps(req)\ndef wrapper(self, *args, **kwargs):\n    params = req(self, *args, **kwargs)\n    if params is not None and self.completions_available:\n        self.emit_request(method, params, requires_response)\nreturn wrapper\n",
        "CUT_5": "\"\"\"Call function req and then emit its results to the completion server.\"\"\"\nif req is None:\n    return functools.partial(request, method=method, requires_response=\n        requires_response)\n@functools.wraps(req)\ndef wrapper(self, *args, **kwargs):\n    params = req(self, *args, **kwargs)\n    if params is not None and self.completions_available:\n        self.emit_request(method, params, requires_response)\nreturn wrapper\n"
    },
    {
        "functionName": "test_split_source",
        "className": null,
        "fileName": "/spyder/utils/tests/test_sourcecode.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "code = \"\"\"import functools\nfunctools.partial\"\"\"\nassert sourcecode.split_source(code) == ['import functools',\n    'functools.partial']\ncode = code.replace('\\n', '\\r\\n')\nassert sourcecode.split_source(code) == ['import functools',\n    'functools.partial']\n",
        "CUT_1": "assert isinstance(code, int)\nif code == 0:\n    self.reset()\nelif code == 1:\n    self.intensity = 1\nelif code == 3:\n    self.italic = True\nelif code == 4:\n    self.underline = True\nelif code == 22:\n    self.intensity = 0\n    self.bold = False\nelif code == 23:\n    self.italic = False\nelif code == 24:\n    self.underline = False\nelif code >= 30 and code <= 37:\n    self.foreground_color = code\nelif code == 39:\n    self.foreground_color = self.default_foreground_color\nelif code >= 40 and code <= 47:\n    self.background_color = code\nelif code == 49:\n    self.background_color = self.default_background_color\nself.set_style()\n",
        "CUT_2": "assert isinstance(code, int)\nif code == 0:\n    self.reset()\nelif code == 1:\n    self.intensity = 1\nelif code == 3:\n    self.italic = True\nelif code == 4:\n    self.underline = True\nelif code == 22:\n    self.intensity = 0\n    self.bold = False\nelif code == 23:\n    self.italic = False\nelif code == 24:\n    self.underline = False\nelif code >= 30 and code <= 37:\n    self.foreground_color = code\nelif code == 39:\n    self.foreground_color = self.default_foreground_color\nelif code >= 40 and code <= 47:\n    self.background_color = code\nelif code == 49:\n    self.background_color = self.default_background_color\nself.set_style()\n",
        "CUT_3": "\"\"\"Transform ipython code to python code.\"\"\"\nnumber_empty_lines = count_leading_empty_lines(code)\nif indent_only:\n    if LooseVersion(ipy_version) < LooseVersion('7.0.0'):\n        return code\n    if not code.endswith('\\n'):\n        code += '\\n'\n    lines = code.splitlines(keepends=True)\n    lines = leading_indent(leading_empty_lines(lines))\n    code = ''.join(lines)\nelif LooseVersion(ipy_version) < LooseVersion('7.0.0'):\n    tm = IPythonInputSplitter()\n    return tm.transform_cell(code)\nelse:\n    tm = TransformerManager()\n    code = tm.transform_cell(code)\nreturn '\\n' * number_empty_lines + code\n",
        "CUT_4": "with self._lock:\n    return method(self, *args, **kwargs)\nfunctools.wraps(method)",
        "CUT_5": "code = text[:4]\nif self._ignore_code(code):\n    return\nif code in self.expected:\n    return\nerr_range = {'start': {'line': line_number - 1, 'character': offset}, 'end':\n    {'line': line_number - 1, 'character': 100 if line_number > len(self.\n    lines) else len(self.lines[line_number - 1])}}\nself.diagnostics.append({'source': 'pycodestyle', 'range': err_range,\n    'message': text, 'code': code, 'severity': _get_severity(code)})\n"
    },
    {
        "functionName": "test_path_components",
        "className": null,
        "fileName": "/spyder/utils/tests/test_sourcecode.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if not os.name == 'nt':\n    path_components0 = ['', '', 'documents', 'test', 'test.py']\nelse:\n    path_components0 = ['c:', '', 'documents', 'test', 'test.py']\npath0 = os.path.join(*path_components0)\nassert sourcecode.path_components(path0) == path_components0\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\nfrom spyder.config.base import get_module_path\nspyder_dir = get_module_path('spyder')\napp = qapplication(test_time=8)\ntest = EditorPluginExample()\ntest.resize(900, 700)\ntest.show()\nimport time\nt0 = time.time()\ntest.load(osp.join(spyder_dir, 'widgets', 'collectionseditor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'editor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'explorer', 'widgets', 'explorer.py')\n    )\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'codeeditor.py')\n    )\nprint('Elapsed time: %.3f s' % (time.time() - t0))\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_differentiate_prefix",
        "className": null,
        "fileName": "/spyder/utils/tests/test_sourcecode.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if not os.name == 'nt':\n    path_components0 = ['', '', 'documents', 'test', 'test.py']\n    path_components1 = ['', '', 'documents', 'projects', 'test', 'test.py']\nelse:\n    path_components0 = ['c:', '', 'documents', 'test', 'test.py']\n    path_components1 = ['c:', '', 'documents', 'projects', 'test', 'test.py']\ndiff_path0 = os.path.join(*['test'])\ndiff_path1 = os.path.join(*['projects', 'test'])\nassert sourcecode.differentiate_prefix(path_components0, path_components1\n    ) == diff_path0\nassert sourcecode.differentiate_prefix(path_components1, path_components0\n    ) == diff_path1\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\nfrom spyder.config.base import get_module_path\nspyder_dir = get_module_path('spyder')\napp = qapplication(test_time=8)\ntest = EditorPluginExample()\ntest.resize(900, 700)\ntest.show()\nimport time\nt0 = time.time()\ntest.load(osp.join(spyder_dir, 'widgets', 'collectionseditor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'editor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'explorer', 'widgets', 'explorer.py')\n    )\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'codeeditor.py')\n    )\nprint('Elapsed time: %.3f s' % (time.time() - t0))\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_get_same_name_files",
        "className": null,
        "fileName": "/spyder/utils/tests/test_sourcecode.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "files_path_list = []\nif not os.name == 'nt':\n    fname0 = os.path.join(*['', '', 'documents', 'test', 'test.py'])\n    files_path_list.append(fname0)\n    fname1 = os.path.join(*['', '', 'documents', 'projects', 'test', 'test.py']\n        )\n    files_path_list.append(fname1)\n    same_name_files = [['', '', 'documents', 'test', 'test.py'], ['', '',\n        'documents', 'projects', 'test', 'test.py']]\nelse:\n    fname0 = os.path.join(*['c:', '', 'documents', 'test', 'test.py'])\n    files_path_list.append(fname0)\n    fname1 = os.path.join(*['c:', '', 'documents', 'projects', 'test',\n        'test.py'])\n    files_path_list.append(fname1)\n    same_name_files = [['c:', '', 'documents', 'test', 'test.py'], ['c:',\n        '', 'documents', 'projects', 'test', 'test.py']]\n    assert sourcecode.get_same_name_files(files_path_list, 'test.py'\n        ) == same_name_files\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\nfrom spyder.config.base import get_module_path\nspyder_dir = get_module_path('spyder')\napp = qapplication(test_time=8)\ntest = EditorPluginExample()\ntest.resize(900, 700)\ntest.show()\nimport time\nt0 = time.time()\ntest.load(osp.join(spyder_dir, 'widgets', 'collectionseditor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'editor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'explorer', 'widgets', 'explorer.py')\n    )\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'codeeditor.py')\n    )\nprint('Elapsed time: %.3f s' % (time.time() - t0))\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_shortest_path",
        "className": null,
        "fileName": "/spyder/utils/tests/test_sourcecode.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if not os.name == 'nt':\n    files_path_list = [['', '', 'documents', 'test', 'test.py'], ['', '',\n        'documents', 'projects', 'test', 'test.py']]\n    shortest_path = os.path.join(*['', '', 'documents', 'test', 'test.py'])\nelse:\n    files_path_list = [['c:', '', 'documents', 'test', 'test.py'], ['c:',\n        '', 'documents', 'projects', 'test', 'test.py']]\n    shortest_path = os.path.join(*['c:', '', 'documents', 'test', 'test.py'])\nassert sourcecode.shortest_path(files_path_list) == shortest_path\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\nfrom spyder.config.base import get_module_path\nspyder_dir = get_module_path('spyder')\napp = qapplication(test_time=8)\ntest = EditorPluginExample()\ntest.resize(900, 700)\ntest.show()\nimport time\nt0 = time.time()\ntest.load(osp.join(spyder_dir, 'widgets', 'collectionseditor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'editor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'explorer', 'widgets', 'explorer.py')\n    )\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'codeeditor.py')\n    )\nprint('Elapsed time: %.3f s' % (time.time() - t0))\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_disambiguate_fname",
        "className": null,
        "fileName": "/spyder/utils/tests/test_sourcecode.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "files_path_list = []\nif not os.name == 'nt':\n    fname0 = os.path.join(*['', '', 'documents', 'test', 'test.py'])\n    files_path_list.append(fname0)\n    fname1 = os.path.join(*['', '', 'documents', 'projects', 'test', 'test.py']\n        )\n    files_path_list.append(fname1)\nelse:\n    fname0 = os.path.join(*['c:', '', 'documents', 'test', 'test.py'])\n    files_path_list.append(fname0)\n    fname1 = os.path.join(*['c:', '', 'documents', 'projects', 'test',\n        'test.py'])\n    files_path_list.append(fname1)\ntitle0 = 'test.py - ' + os.path.join(*['test'])\ntitle1 = 'test.py - ' + os.path.join(*['projects', 'test'])\nassert sourcecode.disambiguate_fname(files_path_list, fname0) == title0\nassert sourcecode.disambiguate_fname(files_path_list, fname1) == title1\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\nfrom spyder.config.base import get_module_path\nspyder_dir = get_module_path('spyder')\napp = qapplication(test_time=8)\ntest = EditorPluginExample()\ntest.resize(900, 700)\ntest.show()\nimport time\nt0 = time.time()\ntest.load(osp.join(spyder_dir, 'widgets', 'collectionseditor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'editor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'explorer', 'widgets', 'explorer.py')\n    )\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'codeeditor.py')\n    )\nprint('Elapsed time: %.3f s' % (time.time() - t0))\nsys.exit(app.exec_())\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\nfrom spyder.config.base import get_module_path\nspyder_dir = get_module_path('spyder')\napp = qapplication(test_time=8)\ntest = EditorPluginExample()\ntest.resize(900, 700)\ntest.show()\nimport time\nt0 = time.time()\ntest.load(osp.join(spyder_dir, 'widgets', 'collectionseditor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'editor.py'))\ntest.load(osp.join(spyder_dir, 'plugins', 'explorer', 'widgets', 'explorer.py')\n    )\ntest.load(osp.join(spyder_dir, 'plugins', 'editor', 'widgets', 'codeeditor.py')\n    )\nprint('Elapsed time: %.3f s' % (time.time() - t0))\nsys.exit(app.exec_())\n",
        "CUT_5": "\"\"\"Generate a file name without ambiguation.\"\"\"\nfiles_path_list = [filename for filename in self.filenames if filename]\nreturn sourcecode.disambiguate_fname(files_path_list, fname)\n"
    },
    {
        "functionName": "test_stringmatching_full",
        "className": null,
        "fileName": "/spyder/utils/tests/test_stringmatching.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test stringmatching full results.\"\"\"\ntemplate = '<b>{0}</b>'\nnames = ['close pane', 'debug continue', 'debug exit', 'debug step into',\n    'debug step over', 'debug step return', 'fullscreen mode',\n    'layout preferences', 'lock unlock panes', 'maximize pane',\n    'preferences', 'quit', 'restart', 'save current layout',\n    'switch to breakpoints', 'switch to console', 'switch to editor',\n    'switch to explorer', 'switch to find_in_files', 'switch to historylog',\n    'switch to help', 'switch to ipython_console', 'switch to onlinehelp',\n    'switch to outline_explorer', 'switch to project_explorer',\n    'switch to variable_explorer', 'use next layout', 'use previous layout',\n    'clear line', 'clear shell', 'inspect current object', 'blockcomment',\n    'breakpoint', 'close all', 'code completion', 'conditional breakpoint',\n    'configure', 'copy', 'copy line', 'cut', 'debug', 'debug with winpdb',\n    'delete', 'delete line', 'duplicate line', 'end of document',\n    'end of line', 'file list management', 'find next', 'find previous',\n    'find text', 'go to definition', 'go to line', 'go to next file',\n    'go to previous file', 'inspect current object', 'kill next word',\n    'kill previous word', 'kill to line end', 'kill to line start',\n    'last edit location', 'move line down', 'move line up', 'new file',\n    'next char', 'next cursor position', 'next line', 'next word',\n    'open file', 'paste', 'previous char', 'previous cursor position',\n    'previous line', 'previous word', 'print', 're-run last script', 'redo',\n    'replace text', 'rotate kill ring', 'run', 'run selection', 'save all',\n    'save as', 'save file', 'select all', 'show/hide outline',\n    'show/hide project explorer', 'start of document', 'start of line',\n    'toggle comment', 'unblockcomment', 'undo', 'yank', 'run profiler',\n    'run analysis']\nfull_results = get_search_scores('lay', names, template=template)\nassert full_results == [('close pane', 'close pane', -1), ('debug continue',\n    'debug continue', -1), ('debug exit', 'debug exit', -1), (\n    'debug step into', 'debug step into', -1), ('debug step over',\n    'debug step over', -1), ('debug step return', 'debug step return', -1),\n    ('fullscreen mode', 'fullscreen mode', -1), ('layout preferences',\n    '<b>lay</b>out preferences', 400100), ('lock unlock panes',\n    'lock unlock panes', -1), ('maximize pane', 'maximize pane', -1), (\n    'preferences', 'preferences', -1), ('quit', 'quit', -1), ('restart',\n    'restart', -1), ('save current layout', 'save current <b>lay</b>out', \n    400113), ('switch to breakpoints', 'switch to breakpoints', -1), (\n    'switch to console', 'switch to console', -1), ('switch to editor',\n    'switch to editor', -1), ('switch to explorer', 'switch to explorer', -\n    1), ('switch to find_in_files', 'switch to find_in_files', -1), (\n    'switch to historylog', 'switch to historylog', -1), ('switch to help',\n    'switch to help', -1), ('switch to ipython_console',\n    'switch to ipython_console', -1), ('switch to onlinehelp',\n    'switch to onlinehelp', -1), ('switch to outline_explorer',\n    'switch to outline_explorer', -1), ('switch to project_explorer',\n    'switch to project_explorer', -1), ('switch to variable_explorer',\n    'switch to variable_explorer', -1), ('use next layout',\n    'use next <b>lay</b>out', 400109), ('use previous layout',\n    'use previous <b>lay</b>out', 400113), ('clear line', 'clear line', -1),\n    ('clear shell', 'clear shell', -1), ('inspect current object',\n    'inspect current object', -1), ('blockcomment', 'blockcomment', -1), (\n    'breakpoint', 'breakpoint', -1), ('close all', 'close all', -1), (\n    'code completion', 'code completion', -1), ('conditional breakpoint',\n    'conditional breakpoint', -1), ('configure', 'configure', -1), ('copy',\n    'copy', -1), ('copy line', 'copy line', -1), ('cut', 'cut', -1), (\n    'debug', 'debug', -1), ('debug with winpdb', 'debug with winpdb', -1),\n    ('delete', 'delete', -1), ('delete line', 'delete line', -1), (\n    'duplicate line', 'duplicate line', -1), ('end of document',\n    'end of document', -1), ('end of line', 'end of line', -1), (\n    'file list management', 'file list management', -1), ('find next',\n    'find next', -1), ('find previous', 'find previous', -1), ('find text',\n    'find text', -1), ('go to definition', 'go to definition', -1), (\n    'go to line', 'go to line', -1), ('go to next file', 'go to next file',\n    -1), ('go to previous file', 'go to previous file', -1), (\n    'inspect current object', 'inspect current object', -1), (\n    'kill next word', 'kill next word', -1), ('kill previous word',\n    'kill previous word', -1), ('kill to line end', 'kill to line end', -1),\n    ('kill to line start', 'kill to line start', -1), ('last edit location',\n    'last edit location', -1), ('move line down', 'move line down', -1), (\n    'move line up', 'move line up', -1), ('new file', 'new file', -1), (\n    'next char', 'next char', -1), ('next cursor position',\n    'next cursor position', -1), ('next line', 'next line', -1), (\n    'next word', 'next word', -1), ('open file', 'open file', -1), ('paste',\n    'paste', -1), ('previous char', 'previous char', -1), (\n    'previous cursor position', 'previous cursor position', -1), (\n    'previous line', 'previous line', -1), ('previous word',\n    'previous word', -1), ('print', 'print', -1), ('re-run last script',\n    're-run last script', -1), ('redo', 'redo', -1), ('replace text',\n    'replace text', -1), ('rotate kill ring', 'rotate kill ring', -1), (\n    'run', 'run', -1), ('run selection', 'run selection', -1), ('save all',\n    'save all', -1), ('save as', 'save as', -1), ('save file', 'save file',\n    -1), ('select all', 'select all', -1), ('show/hide outline',\n    'show/hide outline', -1), ('show/hide project explorer',\n    'show/hide project explorer', -1), ('start of document',\n    'start of document', -1), ('start of line', 'start of line', -1), (\n    'toggle comment', 'toggle comment', -1), ('unblockcomment',\n    'unblockcomment', -1), ('undo', 'undo', -1), ('yank', 'yank', -1), (\n    'run profiler', 'run profiler', -1), ('run analysis', 'run analysis', -1)]\n",
        "CUT_1": "template = '<b>{0}</b>'\nnames = ['close pane', 'debug continue', 'debug exit', 'debug step into',\n    'debug step over', 'debug step return', 'fullscreen mode',\n    'layout preferences', 'lock unlock panes', 'maximize pane',\n    'preferences', 'quit', 'restart', 'save current layout',\n    'switch to breakpoints', 'switch to console', 'switch to editor',\n    'switch to explorer', 'switch to find_in_files', 'switch to historylog',\n    'switch to help', 'switch to ipython_console', 'switch to onlinehelp',\n    'switch to outline_explorer', 'switch to project_explorer',\n    'switch to variable_explorer', 'use next layout', 'use previous layout',\n    'clear line', 'clear shell', 'inspect current object', 'blockcomment',\n    'breakpoint', 'close all', 'code completion', 'conditional breakpoint',\n    'configure', 'copy', 'copy line', 'cut', 'debug', 'debug with winpdb',\n    'delete', 'delete line', 'duplicate line', 'end of document',\n    'end of line', 'file list management', 'find next', 'find previous',\n    'find text', 'go to definition', 'go to line', 'go to next file',\n    'go to previous file', 'inspect current object', 'kill next word',\n    'kill previous word', 'kill to line end', 'kill to line start',\n    'last edit location', 'move line down', 'move line up', 'new file',\n    'next char', 'next cursor position', 'next line', 'next word',\n    'open file', 'paste', 'previous char', 'previous cursor position',\n    'previous line', 'previous word', 'print', 're-run last script', 'redo',\n    'replace text', 'rotate kill ring', 'run', 'run selection', 'save all',\n    'save as', 'save file', 'select all', 'show/hide outline',\n    'show/hide project explorer', 'start of document', 'start of line',\n    'toggle comment', 'unblockcomment', 'undo', 'yank', 'run profiler',\n    'run analysis']\na = get_search_scores('lay', names, template=template)\nb = get_search_scores('lay', names, template=template, valid_only=True,\n    sort=True)\nfor r in a:\n    print(r)\nprint('\\n')\nfor r in b:\n    print(r)\n",
        "CUT_2": "template = '<b>{0}</b>'\nnames = ['close pane', 'debug continue', 'debug exit', 'debug step into',\n    'debug step over', 'debug step return', 'fullscreen mode',\n    'layout preferences', 'lock unlock panes', 'maximize pane',\n    'preferences', 'quit', 'restart', 'save current layout',\n    'switch to breakpoints', 'switch to console', 'switch to editor',\n    'switch to explorer', 'switch to find_in_files', 'switch to historylog',\n    'switch to help', 'switch to ipython_console', 'switch to onlinehelp',\n    'switch to outline_explorer', 'switch to project_explorer',\n    'switch to variable_explorer', 'use next layout', 'use previous layout',\n    'clear line', 'clear shell', 'inspect current object', 'blockcomment',\n    'breakpoint', 'close all', 'code completion', 'conditional breakpoint',\n    'configure', 'copy', 'copy line', 'cut', 'debug', 'debug with winpdb',\n    'delete', 'delete line', 'duplicate line', 'end of document',\n    'end of line', 'file list management', 'find next', 'find previous',\n    'find text', 'go to definition', 'go to line', 'go to next file',\n    'go to previous file', 'inspect current object', 'kill next word',\n    'kill previous word', 'kill to line end', 'kill to line start',\n    'last edit location', 'move line down', 'move line up', 'new file',\n    'next char', 'next cursor position', 'next line', 'next word',\n    'open file', 'paste', 'previous char', 'previous cursor position',\n    'previous line', 'previous word', 'print', 're-run last script', 'redo',\n    'replace text', 'rotate kill ring', 'run', 'run selection', 'save all',\n    'save as', 'save file', 'select all', 'show/hide outline',\n    'show/hide project explorer', 'start of document', 'start of line',\n    'toggle comment', 'unblockcomment', 'undo', 'yank', 'run profiler',\n    'run analysis']\na = get_search_scores('lay', names, template=template)\nb = get_search_scores('lay', names, template=template, valid_only=True,\n    sort=True)\nfor r in a:\n    print(r)\nprint('\\n')\nfor r in b:\n    print(r)\n",
        "CUT_3": "\"\"\"\n        Hook method executed just before the command line is\n        interpreted, but after the input prompt is generated and issued.\n\n        Here we switch ! and non !\n        \"\"\"\nif not self.pdb_use_exclamation_mark:\n    return line\nif not line:\n    return line\nif line[0] == '!':\n    line = line[1:]\nelse:\n    line = '!' + line\nreturn line\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_stringmatching_order_filter",
        "className": null,
        "fileName": "/spyder/utils/tests/test_stringmatching.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test stringmatching ordered and filtered.\"\"\"\ntemplate = '<b>{0}</b>'\nnames = ['close pane', 'debug continue', 'debug exit', 'debug step into',\n    'debug step over', 'debug step return', 'fullscreen mode',\n    'layout preferences', 'lock unlock panes', 'maximize pane',\n    'preferences', 'quit', 'restart', 'save current layout',\n    'switch to breakpoints', 'switch to console', 'switch to editor',\n    'switch to explorer', 'switch to find_in_files', 'switch to historylog',\n    'switch to help', 'switch to ipython_console', 'switch to onlinehelp',\n    'switch to outline_explorer', 'switch to project_explorer',\n    'switch to variable_explorer', 'use next layout', 'use previous layout',\n    'clear line', 'clear shell', 'inspect current object', 'blockcomment',\n    'breakpoint', 'close all', 'code completion', 'conditional breakpoint',\n    'configure', 'copy', 'copy line', 'cut', 'debug', 'debug with winpdb',\n    'delete', 'delete line', 'duplicate line', 'end of document',\n    'end of line', 'file list management', 'find next', 'find previous',\n    'find text', 'go to definition', 'go to line', 'go to next file',\n    'go to previous file', 'inspect current object', 'kill next word',\n    'kill previous word', 'kill to line end', 'kill to line start',\n    'last edit location', 'move line down', 'move line up', 'new file',\n    'next char', 'next cursor position', 'next line', 'next word',\n    'open file', 'paste', 'previous char', 'previous cursor position',\n    'previous line', 'previous word', 'print', 're-run last script', 'redo',\n    'replace text', 'rotate kill ring', 'run', 'run selection', 'save all',\n    'save as', 'save file', 'select all', 'show/hide outline',\n    'show/hide project explorer', 'start of document', 'start of line',\n    'toggle comment', 'unblockcomment', 'undo', 'yank', 'run profiler',\n    'run analysis']\norder_filter_results = get_search_scores('lay', names, template=template,\n    valid_only=True, sort=True)\nassert order_filter_results == [('layout preferences',\n    '<b>lay</b>out preferences', 400100), ('use next layout',\n    'use next <b>lay</b>out', 400109), ('save current layout',\n    'save current <b>lay</b>out', 400113), ('use previous layout',\n    'use previous <b>lay</b>out', 400113)]\n",
        "CUT_1": "template = '<b>{0}</b>'\nnames = ['close pane', 'debug continue', 'debug exit', 'debug step into',\n    'debug step over', 'debug step return', 'fullscreen mode',\n    'layout preferences', 'lock unlock panes', 'maximize pane',\n    'preferences', 'quit', 'restart', 'save current layout',\n    'switch to breakpoints', 'switch to console', 'switch to editor',\n    'switch to explorer', 'switch to find_in_files', 'switch to historylog',\n    'switch to help', 'switch to ipython_console', 'switch to onlinehelp',\n    'switch to outline_explorer', 'switch to project_explorer',\n    'switch to variable_explorer', 'use next layout', 'use previous layout',\n    'clear line', 'clear shell', 'inspect current object', 'blockcomment',\n    'breakpoint', 'close all', 'code completion', 'conditional breakpoint',\n    'configure', 'copy', 'copy line', 'cut', 'debug', 'debug with winpdb',\n    'delete', 'delete line', 'duplicate line', 'end of document',\n    'end of line', 'file list management', 'find next', 'find previous',\n    'find text', 'go to definition', 'go to line', 'go to next file',\n    'go to previous file', 'inspect current object', 'kill next word',\n    'kill previous word', 'kill to line end', 'kill to line start',\n    'last edit location', 'move line down', 'move line up', 'new file',\n    'next char', 'next cursor position', 'next line', 'next word',\n    'open file', 'paste', 'previous char', 'previous cursor position',\n    'previous line', 'previous word', 'print', 're-run last script', 'redo',\n    'replace text', 'rotate kill ring', 'run', 'run selection', 'save all',\n    'save as', 'save file', 'select all', 'show/hide outline',\n    'show/hide project explorer', 'start of document', 'start of line',\n    'toggle comment', 'unblockcomment', 'undo', 'yank', 'run profiler',\n    'run analysis']\na = get_search_scores('lay', names, template=template)\nb = get_search_scores('lay', names, template=template, valid_only=True,\n    sort=True)\nfor r in a:\n    print(r)\nprint('\\n')\nfor r in b:\n    print(r)\n",
        "CUT_2": "template = '<b>{0}</b>'\nnames = ['close pane', 'debug continue', 'debug exit', 'debug step into',\n    'debug step over', 'debug step return', 'fullscreen mode',\n    'layout preferences', 'lock unlock panes', 'maximize pane',\n    'preferences', 'quit', 'restart', 'save current layout',\n    'switch to breakpoints', 'switch to console', 'switch to editor',\n    'switch to explorer', 'switch to find_in_files', 'switch to historylog',\n    'switch to help', 'switch to ipython_console', 'switch to onlinehelp',\n    'switch to outline_explorer', 'switch to project_explorer',\n    'switch to variable_explorer', 'use next layout', 'use previous layout',\n    'clear line', 'clear shell', 'inspect current object', 'blockcomment',\n    'breakpoint', 'close all', 'code completion', 'conditional breakpoint',\n    'configure', 'copy', 'copy line', 'cut', 'debug', 'debug with winpdb',\n    'delete', 'delete line', 'duplicate line', 'end of document',\n    'end of line', 'file list management', 'find next', 'find previous',\n    'find text', 'go to definition', 'go to line', 'go to next file',\n    'go to previous file', 'inspect current object', 'kill next word',\n    'kill previous word', 'kill to line end', 'kill to line start',\n    'last edit location', 'move line down', 'move line up', 'new file',\n    'next char', 'next cursor position', 'next line', 'next word',\n    'open file', 'paste', 'previous char', 'previous cursor position',\n    'previous line', 'previous word', 'print', 're-run last script', 'redo',\n    'replace text', 'rotate kill ring', 'run', 'run selection', 'save all',\n    'save as', 'save file', 'select all', 'show/hide outline',\n    'show/hide project explorer', 'start of document', 'start of line',\n    'toggle comment', 'unblockcomment', 'undo', 'yank', 'run profiler',\n    'run analysis']\na = get_search_scores('lay', names, template=template)\nb = get_search_scores('lay', names, template=template, valid_only=True,\n    sort=True)\nfor r in a:\n    print(r)\nprint('\\n')\nfor r in b:\n    print(r)\n",
        "CUT_3": "\"\"\"Switch to previous file tab on the current editor stack.\"\"\"\neditorstack = self.get_current_editorstack()\neditorstack.tabs.tab_navigate(-1)\nSlot()",
        "CUT_4": "\"\"\"Switch to previous file tab on the current editor stack.\"\"\"\neditorstack = self.get_current_editorstack()\neditorstack.tabs.tab_navigate(-1)\nSlot()",
        "CUT_5": "\"\"\"\n        Hook method executed just before the command line is\n        interpreted, but after the input prompt is generated and issued.\n\n        Here we switch ! and non !\n        \"\"\"\nif not self.pdb_use_exclamation_mark:\n    return line\nif not line:\n    return line\nif line[0] == '!':\n    line = line[1:]\nelse:\n    line = '!' + line\nreturn line\n"
    },
    {
        "functionName": "test_add_quotes",
        "className": null,
        "fileName": "/spyder/utils/tests/test_conda.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "output = add_quotes('/some path/with spaces')\nassert output == '\"/some path/with spaces\"'\noutput = add_quotes('/some-path/with-no-spaces')\nassert output == '/some-path/with-no-spaces'\n",
        "CUT_1": "\"\"\"Get the number of spaces from a group of spaces in a line.\"\"\"\nspaces = re.findall('\\\\s+', line_text)\nif len(spaces) - 1 >= group:\n    return len(spaces[group])\n",
        "CUT_2": "\"\"\"Get the number of spaces from a group of spaces in a line.\"\"\"\nspaces = re.findall('\\\\s+', line_text)\nif len(spaces) - 1 >= group:\n    return len(spaces[group])\n",
        "CUT_3": "\"\"\"\n        Get if there is a correct indentation from a group of spaces of a line.\n        \"\"\"\nspaces = re.findall('\\\\s+', line_text)\nif len(spaces) - 1 >= group:\n    return len(spaces[group]) % len(self.indent_chars) == 0\n",
        "CUT_4": "\"\"\"\n        Get if there is a correct indentation from a group of spaces of a line.\n        \"\"\"\nspaces = re.findall('\\\\s+', line_text)\nif len(spaces) - 1 >= group:\n    return len(spaces[group]) % len(self.indent_chars) == 0\n",
        "CUT_5": "\"\"\"Show process output log.\"\"\"\nif self.output:\n    output_dialog = TextEditor(self.output, title=_('Profiler output'),\n        readonly=True, parent=self)\n    output_dialog.resize(700, 500)\n    output_dialog.exec_()\n"
    },
    {
        "functionName": "test_get_conda_activation_script",
        "className": null,
        "fileName": "/spyder/utils/tests/test_conda.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "output = get_conda_activation_script(TEST_PYEXEC)\nif os.name == 'nt':\n    assert output == 'c:/miniconda/Scripts/activate'\nelse:\n    assert output == '/miniconda/bin/activate'\n",
        "CUT_1": "\"\"\"\n    Return full path to conda activation script.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nif os.name == 'nt':\n    activate = 'Scripts/activate'\nelse:\n    activate = 'bin/activate'\nscript_path = os.path.join(get_conda_root_prefix(pyexec, quote=False), activate\n    ).replace('\\\\', '/')\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_2": "\"\"\"\n    Return full path to conda activation script.\n\n    If `quote` is True, then quotes are added if spaces are found in the path.\n    \"\"\"\nif os.name == 'nt':\n    activate = 'Scripts/activate'\nelse:\n    activate = 'bin/activate'\nscript_path = os.path.join(get_conda_root_prefix(pyexec, quote=False), activate\n    ).replace('\\\\', '/')\nif quote:\n    script_path = add_quotes(script_path)\nreturn script_path\n",
        "CUT_3": "\"\"\"Show process output log.\"\"\"\nif self.output:\n    output_dialog = TextEditor(self.output, title=_('Profiler output'),\n        readonly=True, parent=self)\n    output_dialog.resize(700, 500)\n    output_dialog.exec_()\n",
        "CUT_4": "\"\"\"Show process output log.\"\"\"\nif self.output:\n    output_dialog = TextEditor(self.output, title=_('Profiler output'),\n        readonly=True, parent=self)\n    output_dialog.resize(700, 500)\n    output_dialog.exec_()\n",
        "CUT_5": "\"\"\"Print worker output for tests.\"\"\"\nprint(worker, output, error)\n"
    },
    {
        "functionName": "test_get_conda_env_path",
        "className": null,
        "fileName": "/spyder/utils/tests/test_conda.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "output = get_conda_env_path(TEST_PYEXEC)\nif os.name == 'nt':\n    assert output == 'c:/miniconda/envs/foobar'\nelse:\n    assert output == '/miniconda/envs/foobar'\n",
        "CUT_1": "\"\"\"Show process output log.\"\"\"\nif self.output:\n    output_dialog = TextEditor(self.output, title=_('Profiler output'),\n        readonly=True, parent=self)\n    output_dialog.resize(700, 500)\n    output_dialog.exec_()\n",
        "CUT_2": "\"\"\"Show process output log.\"\"\"\nif self.output:\n    output_dialog = TextEditor(self.output, title=_('Profiler output'),\n        readonly=True, parent=self)\n    output_dialog.resize(700, 500)\n    output_dialog.exec_()\n",
        "CUT_3": "\"\"\"Print worker output for tests.\"\"\"\nprint(worker, output, error)\n",
        "CUT_4": "\"\"\"Print worker output for tests.\"\"\"\nprint(worker, output, error)\n",
        "CUT_5": "if self.output:\n    output_dialog = TextEditor(self.output, title=_('Pylint output'),\n        parent=self, readonly=True)\n    output_dialog.resize(700, 500)\n    output_dialog.exec_()\nSlot()"
    },
    {
        "functionName": "test_get_conda_root_prefix",
        "className": null,
        "fileName": "/spyder/utils/tests/test_conda.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "output = get_conda_root_prefix(TEST_PYEXEC)\nif os.name == 'nt':\n    assert output == 'c:/miniconda'\nelse:\n    assert output == '/miniconda'\nassert 'envs' not in get_conda_root_prefix(sys.executable)\n",
        "CUT_1": "\"\"\"Show process output log.\"\"\"\nif self.output:\n    output_dialog = TextEditor(self.output, title=_('Profiler output'),\n        readonly=True, parent=self)\n    output_dialog.resize(700, 500)\n    output_dialog.exec_()\n",
        "CUT_2": "\"\"\"Show process output log.\"\"\"\nif self.output:\n    output_dialog = TextEditor(self.output, title=_('Profiler output'),\n        readonly=True, parent=self)\n    output_dialog.resize(700, 500)\n    output_dialog.exec_()\n",
        "CUT_3": "\"\"\"Print worker output for tests.\"\"\"\nprint(worker, output, error)\n",
        "CUT_4": "\"\"\"Print worker output for tests.\"\"\"\nprint(worker, output, error)\n",
        "CUT_5": "\"\"\"Copy text to clipboard\"\"\"\nclipboard = QApplication.clipboard()\nclipl = []\nfor idx in self.selectedIndexes():\n    if not idx.isValid():\n        continue\n    obj = self.delegate.get_value(idx)\n    if isinstance(obj, (ndarray, MaskedArray)) and ndarray is not FakeObject:\n        if PY3:\n            output = io.BytesIO()\n        else:\n            output = io.StringIO()\n        try:\n            np_savetxt(output, obj, delimiter='\\t')\n        except:\n            QMessageBox.warning(self, _('Warning'), _(\n                'It was not possible to copy this array'))\n            return\n        obj = output.getvalue().decode('utf-8')\n        output.close()\n    elif isinstance(obj, (DataFrame, Series)) and DataFrame is not FakeObject:\n        output = io.StringIO()\n        try:\n            obj.to_csv(output, sep='\\t', index=True, header=True)\n        except Exception:\n            QMessageBox.warning(self, _('Warning'), _(\n                'It was not possible to copy this dataframe'))\n            return\n        if PY3:\n            obj = output.getvalue()\n        else:\n            obj = output.getvalue().decode('utf-8')\n        output.close()\n    elif is_binary_string(obj):\n        obj = to_text_string(obj, 'utf8')\n    else:\n        obj = to_text_string(obj)\n    clipl.append(obj)\nclipboard.setText('\\n'.join(clipl))\nSlot()"
    },
    {
        "functionName": "test_icon_mapping",
        "className": null,
        "fileName": "/spyder/utils/tests/test_icons.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that all the entries on the icon dict for QtAwesome are valid.\"\"\"\nqapp = qapplication()\nicons_dict = ima._qtaargs\nfor key in icons_dict:\n    try:\n        assert isinstance(ima.icon(key), QIcon)\n    except Exception as e:\n        print('Invalid icon name:', key)\n        raise e\n",
        "CUT_1": "if self.fullscreen_flag:\n    icon = ima.icon('window_nofullscreen')\nelse:\n    icon = ima.icon('window_fullscreen')\nif is_text_string(icon):\n    icon = get_icon(icon)\nself.fullscreen_action.setIcon(icon)\n",
        "CUT_2": "if self.fullscreen_flag:\n    icon = ima.icon('window_nofullscreen')\nelse:\n    icon = ima.icon('window_fullscreen')\nif is_text_string(icon):\n    icon = get_icon(icon)\nself.fullscreen_action.setIcon(icon)\n",
        "CUT_3": "\"\"\"Return widget icon.\"\"\"\nreturn ima.icon('edit')\n",
        "CUT_4": "\"\"\"Return widget icon.\"\"\"\nreturn ima.icon('edit')\n",
        "CUT_5": "\"\"\"Return widget icon\"\"\"\nreturn ima.icon('ipython_console')\n"
    },
    {
        "functionName": "environ_dialog",
        "className": null,
        "fileName": "/spyder/utils/tests/test_environ.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Setup the Environment variables Dialog taking into account the os.\"\"\"\nQTimer.singleShot(1000, lambda : close_message_box(qtbot))\nif os.name == 'nt':\n    from spyder.utils.environ import WinUserEnvDialog\n    dialog = WinUserEnvDialog()\nelse:\n    from spyder.utils.environ import EnvDialog\n    dialog = EnvDialog()\nqtbot.addWidget(dialog)\nreturn dialog\npytest.fixture",
        "CUT_1": "\"\"\"Run Windows environment variable editor\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nif os.name == 'nt':\n    dialog = WinUserEnvDialog()\nelse:\n    dialog = EnvDialog()\ndialog.show()\napp.exec_()\n",
        "CUT_2": "\"\"\"Run Windows environment variable editor\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nif os.name == 'nt':\n    dialog = WinUserEnvDialog()\nelse:\n    dialog = EnvDialog()\ndialog.show()\napp.exec_()\n",
        "CUT_3": "\"\"\"Test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ndialog = ImportWizard(None, text)\nif dialog.exec_():\n    print(dialog.get_data())\n",
        "CUT_4": "\"\"\"Test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_app = qapplication()\ndialog = ImportWizard(None, text)\nif dialog.exec_():\n    print(dialog.get_data())\n",
        "CUT_5": "\"\"\"Test Collections editor.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\ndialog = CollectionsEditor()\ndialog.setup(get_test_data())\ndialog.show()\napp.exec_()\n"
    },
    {
        "functionName": "test_environ",
        "className": null,
        "fileName": "/spyder/utils/tests/test_environ.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the environment variables dialog.\"\"\"\nenviron_dialog.show()\nassert environ_dialog\n",
        "CUT_1": "\"\"\"\n        Show environment variables.\n        \"\"\"\nself.dialog_manager.show(EnvDialog(parent=self))\nSlot()",
        "CUT_2": "\"\"\"\n        Show environment variables.\n        \"\"\"\nself.dialog_manager.show(EnvDialog(parent=self))\nSlot()",
        "CUT_3": "\"\"\"Get environment variables.\"\"\"\nreturn os.environ.copy()\n",
        "CUT_4": "\"\"\"Show Windows current user environment variables.\"\"\"\nself.dialog_manager.show(WinUserEnvDialog(self))\nSlot()",
        "CUT_5": "\"\"\"Show Windows current user environment variables.\"\"\"\nself.dialog_manager.show(WinUserEnvDialog(self))\nSlot()"
    },
    {
        "functionName": "test_clean_env",
        "className": null,
        "fileName": "/spyder/utils/tests/test_environ.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "env = {'foo': '/foo/bar/\u6e2c\u8a66', 'bar': '/spam', 'PYTHONPATH': '\u6e2c\u8a66'}\nnew_env = clean_env(env)\nassert new_env['foo'] == '/foo/bar/\u00e6\u00b8\u00ac\u00e8\u00a9\u00a6'\nassert new_env['PYTHONPATH'] == '\u00e6\u00b8\u00ac\u00e8\u00a9\u00a6'\npytest.mark.skipif(PY3 or os.name == 'nt', reason=\n    'This tests only applies to Python 2.')",
        "CUT_1": "\"\"\"\n    Add a PYTHONPATH entry to a list of enviroment variables.\n\n    This allows to extend the environment of an external process\n    created with QProcess with our additions to PYTHONPATH.\n\n    Parameters\n    ----------\n    env: list\n        List of environment variables in the format of\n        QProcessEnvironment.\n    pathlist: list\n        List of paths to add to PYTHONPATH\n    drop_env: bool\n        Whether to drop PYTHONPATH previously found in the environment.\n    \"\"\"\nassert isinstance(env, list)\nassert all([is_text_string(path) for path in env])\npypath = 'PYTHONPATH'\npathstr = os.pathsep.join(pathlist)\nif not drop_env:\n    for index, var in enumerate(env[:]):\n        if var.startswith(pypath + '='):\n            env[index] = var.replace(pypath + '=', pypath + '=' + pathstr +\n                os.pathsep)\nelse:\n    env.append(pypath + '=' + pathstr)\n",
        "CUT_2": "\"\"\"\n    Add a PYTHONPATH entry to a list of enviroment variables.\n\n    This allows to extend the environment of an external process\n    created with QProcess with our additions to PYTHONPATH.\n\n    Parameters\n    ----------\n    env: list\n        List of environment variables in the format of\n        QProcessEnvironment.\n    pathlist: list\n        List of paths to add to PYTHONPATH\n    drop_env: bool\n        Whether to drop PYTHONPATH previously found in the environment.\n    \"\"\"\nassert isinstance(env, list)\nassert all([is_text_string(path) for path in env])\npypath = 'PYTHONPATH'\npathstr = os.pathsep.join(pathlist)\nif not drop_env:\n    for index, var in enumerate(env[:]):\n        if var.startswith(pypath + '='):\n            env[index] = var.replace(pypath + '=', pypath + '=' + pathstr +\n                os.pathsep)\nelse:\n    env.append(pypath + '=' + pathstr)\n",
        "CUT_3": "\"\"\"\n    Try to get the formatted argspec of a callable from the first block of its\n    docstring\n    \n    This will return something like\n    '(foo, bar, k=1)'\n    \"\"\"\nblocks = text.split('\\n\\n')\nfirst_block = blocks[0].strip()\nreturn getsignaturefromtext(first_block, '')\n",
        "CUT_4": "\"\"\"Process conda environment information.\"\"\"\nout, err = self._get_interpreter_env_info()\nout = out or err\nout = out.split('\\n')[0]\nparts = out.split()\nif len(parts) >= 2:\n    out = ' '.join(parts[:2])\nif is_conda_env(pyexec=self._interpreter):\n    envs_folder = os.path.sep + 'envs' + os.path.sep\n    if envs_folder in self._interpreter:\n        if os.name == 'nt':\n            env = os.path.dirname(self._interpreter)\n        else:\n            env = os.path.dirname(os.path.dirname(self._interpreter))\n        env = os.path.basename(env)\n    else:\n        env = 'base'\n    env = 'conda: ' + env\nelif running_in_mac_app(self._interpreter):\n    env = 'internal'\nelse:\n    env = 'venv'\ntext = '{env} ({version})'.format(env=env, version=out)\nreturn text\n",
        "CUT_5": "\"\"\"Process conda environment information.\"\"\"\nout, err = self._get_interpreter_env_info()\nout = out or err\nout = out.split('\\n')[0]\nparts = out.split()\nif len(parts) >= 2:\n    out = ' '.join(parts[:2])\nif is_conda_env(pyexec=self._interpreter):\n    envs_folder = os.path.sep + 'envs' + os.path.sep\n    if envs_folder in self._interpreter:\n        if os.name == 'nt':\n            env = os.path.dirname(self._interpreter)\n        else:\n            env = os.path.dirname(os.path.dirname(self._interpreter))\n        env = os.path.basename(env)\n    else:\n        env = 'base'\n    env = 'conda: ' + env\nelif running_in_mac_app(self._interpreter):\n    env = 'internal'\nelse:\n    env = 'venv'\ntext = '{env} ({version})'.format(env=env, version=out)\nreturn text\n"
    },
    {
        "functionName": "scriptpath",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Save a basic Python script in a file.\"\"\"\nscript = \"\"\"with open('out.txt', 'w') as f:\n    f.write('done')\n\"\"\"\nscriptpath = tmpdir.join('write-done.py')\nscriptpath.write(script)\nreturn scriptpath\npytest.fixture",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Convert an IPython notebook to a Python script in editor\"\"\"\ntry:\n    script = nbexporter().from_filename(fname)[0]\nexcept Exception as e:\n    QMessageBox.critical(self, _('Conversion error'), _(\n        \"\"\"It was not possible to convert this notebook. The error is:\n\n\"\"\"\n        ) + to_text_string(e))\n    return\nself.sig_new_file.emit(script)\n",
        "CUT_3": "\"\"\"Convert an IPython notebook to a Python script in editor\"\"\"\ntry:\n    script = nbexporter().from_filename(fname)[0]\nexcept Exception as e:\n    QMessageBox.critical(self, _('Conversion error'), _(\n        \"\"\"It was not possible to convert this notebook. The error is:\n\n\"\"\"\n        ) + to_text_string(e))\n    return\nself.sig_new_file.emit(script)\n",
        "CUT_4": "\"\"\"Save language setting to language config file\"\"\"\ntry:\n    with open(LANG_FILE, 'w') as f:\n        f.write(value)\nexcept EnvironmentError:\n    pass\n",
        "CUT_5": "\"\"\"Save language setting to language config file\"\"\"\ntry:\n    with open(LANG_FILE, 'w') as f:\n        f.write(value)\nexcept EnvironmentError:\n    pass\n"
    },
    {
        "functionName": "scriptpath_with_blanks",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Save a basic Python script in a file.\"\"\"\nname_dir = 'test dir'\nif not osp.exists(name_dir):\n    os.mkdir(name_dir)\nos.chdir(name_dir)\ntmpdir.join(name_dir)\nscript = \"\"\"with open('out.txt', 'w') as f:\n    f.write('done')\n\"\"\"\nscriptpath = tmpdir.join('write-done.py')\nscriptpath.write(script)\nreturn scriptpath\npytest.fixture",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_3": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_4": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_5": "\"\"\"A project directory with dirs and files for testing.\"\"\"\nproject_dir = to_text_string(tmpdir.mkdir('project'))\ndestination_dir = to_text_string(tmpdir.mkdir('destination'))\ntop_folder = osp.join(project_dir, 'top_folder_in_proj')\nif not osp.exists(top_folder):\n    os.mkdir(top_folder)\nlist_paths = []\nfor item in request.param:\n    if osp.splitext(item)[1]:\n        if osp.split(item)[0]:\n            dirs, fname = osp.split(item)\n            dirpath = osp.join(top_folder, dirs)\n            if not osp.exists(dirpath):\n                os.makedirs(dirpath)\n                item_path = osp.join(dirpath, fname)\n        else:\n            item_path = osp.join(top_folder, item)\n    else:\n        dirpath = osp.join(top_folder, item)\n        if not osp.exists(dirpath):\n            os.makedirs(dirpath)\n            item_path = dirpath\n    if not osp.isdir(item_path):\n        with open(item_path, 'w') as fh:\n            fh.write('File Path:\\n' + str(item_path).replace(os.sep, '/'))\n    list_paths.append(item_path)\nreturn list_paths, project_dir, destination_dir, top_folder\npytest.fixture(params=[['script.py', 'dir1/dir2/dir3/dir4'], ['script.py',\n    'script1.py', 'testdir/dir1/script2.py'], [\n    'subdir/innerdir/dir3/text.txt', 'dir1/dir2/dir3',\n    'dir1/dir2/dir3/file.txt', 'dir1/dir2/dir3/dir4/python.py']])"
    },
    {
        "functionName": "test_is_valid_w_interpreter",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert is_python_interpreter(VALID_W_INTERPRETER)\npytest.mark.skipif(sys.platform.startswith('linux') or os.environ.get('CI',\n    None) is None, reason=\n    'It only runs in CI services and Linux does not have pythonw executables.')",
        "CUT_1": "\"\"\" \"\"\"\nplatform = sys.platform.lower()\nif 'linux' in platform:\n    pass\nelif 'win' in platform:\n    for widget in widgets:\n        widget.setModal(value)\n        widget.hide()\n        widget.show()\nelif 'darwin' in platform:\n    pass\nelse:\n    pass\n",
        "CUT_2": "\"\"\" \"\"\"\nplatform = sys.platform.lower()\nif 'linux' in platform:\n    pass\nelif 'win' in platform:\n    for widget in widgets:\n        widget.setModal(value)\n        widget.hide()\n        widget.show()\nelif 'darwin' in platform:\n    pass\nelse:\n    pass\n",
        "CUT_3": "\"\"\"\n        Check if optional dependencies are available for special consoles.\n        \"\"\"\ntry:\n    if os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True':\n        import matplotlib\n    elif os.environ.get('SPY_SYMPY_O') == 'True':\n        import sympy\n    elif os.environ.get('SPY_RUN_CYTHON') == 'True':\n        import cython\nexcept Exception:\n    if os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True':\n        return 'matplotlib'\n    elif os.environ.get('SPY_SYMPY_O') == 'True':\n        return 'sympy'\n    elif os.environ.get('SPY_RUN_CYTHON') == 'True':\n        return 'cython'\nreturn None\n",
        "CUT_4": "\"\"\"Detect if we are running in a KDE desktop\"\"\"\nif sys.platform.startswith('linux'):\n    xdg_desktop = os.environ.get('XDG_CURRENT_DESKTOP', '')\n    if xdg_desktop:\n        if 'KDE' in xdg_desktop:\n            return True\n        else:\n            return False\n    else:\n        return False\nelse:\n    return False\n",
        "CUT_5": "\"\"\"Detect if we are running in a KDE desktop\"\"\"\nif sys.platform.startswith('linux'):\n    xdg_desktop = os.environ.get('XDG_CURRENT_DESKTOP', '')\n    if xdg_desktop:\n        if 'KDE' in xdg_desktop:\n            return True\n        else:\n            return False\n    else:\n        return False\nelse:\n    return False\n"
    },
    {
        "functionName": "test_run_python_script_in_terminal",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test running a Python script in an external terminal when specifying\n    explicitely the working directory.\n    \"\"\"\noutfilepath = osp.join(scriptpath.dirname, 'out.txt')\nrun_python_script_in_terminal(scriptpath.strpath, scriptpath.dirname, '',\n    False, False, '')\nqtbot.waitUntil(lambda : osp.exists(outfilepath), timeout=10000)\nwith open(outfilepath, 'r') as txtfile:\n    res = txtfile.read()\nassert res == 'done'\npytest.mark.skipif(bool(os.environ.get('CI', None)), reason='Only on CI!')",
        "CUT_1": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_2": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_3": "\"\"\"Set shell current working directory.\"\"\"\nif os.name == 'nt':\n    dirname = osp.normpath(dirname)\nif self.ipyclient.hostname is None:\n    self.call_kernel(interrupt=self.is_debugging()).set_cwd(dirname)\n    self._cwd = dirname\n",
        "CUT_4": "\"\"\"Set shell current working directory.\"\"\"\nif os.name == 'nt':\n    dirname = osp.normpath(dirname)\nif self.ipyclient.hostname is None:\n    self.call_kernel(interrupt=self.is_debugging()).set_cwd(dirname)\n    self._cwd = dirname\n",
        "CUT_5": "\"\"\"Set current working directory.\"\"\"\nos.chdir(dirname)\n"
    },
    {
        "functionName": "test_run_python_script_in_terminal_blank_wdir",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test running a Python script in an external terminal when specifying\n    explicitely the working directory.\n    \"\"\"\noutfilepath = osp.join(scriptpath_with_blanks.dirname, 'out.txt')\nrun_python_script_in_terminal(scriptpath_with_blanks.strpath,\n    scriptpath_with_blanks.dirname, '', False, False, '')\nqtbot.waitUntil(lambda : osp.exists(outfilepath), timeout=10000)\nwith open(outfilepath, 'r') as txtfile:\n    res = txtfile.read()\nassert res == 'done'\npytest.mark.firstpytest.mark.skipif(os.environ.get('CI', None) is None or os.name == 'nt',\n    reason='Only on CI and not on windows!')",
        "CUT_1": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_2": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_3": "\"\"\"Set shell current working directory.\"\"\"\nif os.name == 'nt':\n    dirname = osp.normpath(dirname)\nif self.ipyclient.hostname is None:\n    self.call_kernel(interrupt=self.is_debugging()).set_cwd(dirname)\n    self._cwd = dirname\n",
        "CUT_4": "\"\"\"Set shell current working directory.\"\"\"\nif os.name == 'nt':\n    dirname = osp.normpath(dirname)\nif self.ipyclient.hostname is None:\n    self.call_kernel(interrupt=self.is_debugging()).set_cwd(dirname)\n    self._cwd = dirname\n",
        "CUT_5": "\"\"\"Set current working directory.\"\"\"\nos.chdir(dirname)\n"
    },
    {
        "functionName": "test_run_python_script_in_terminal_with_wdir_empty",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test running a Python script in an external terminal without specifying\n    the working directory.\n    \"\"\"\nif sys.platform == 'darwin':\n    outfilepath = osp.join(osp.expanduser('~'), 'out.txt')\nelse:\n    outfilepath = osp.join(os.getcwd(), 'out.txt')\nrun_python_script_in_terminal(scriptpath.strpath, '', '', False, False, '')\nqtbot.waitUntil(lambda : osp.exists(outfilepath), timeout=10000)\nwith open(outfilepath, 'r') as txtfile:\n    res = txtfile.read()\nassert res == 'done'\npytest.mark.firstpytest.mark.skipif(os.environ.get('CI', None) is None or os.name == 'nt',\n    reason='Only on CI and not on windows!')",
        "CUT_1": "\"\"\"Get current working directory.\"\"\"\nreturn os.getcwd()\n",
        "CUT_2": "\"\"\"\n    Generates a Sphinx configuration in `directory`.\n\n    Parameters\n    ----------\n    directory : str\n        Base directory to use\n    \"\"\"\nconf = osp.join(get_module_source_path('spyder.plugins.help.utils'), 'conf.py')\nlayout = osp.join(osp.join(CONFDIR_PATH, 'templates'), 'layout.html')\nos.makedirs(osp.join(directory, 'templates'))\nos.makedirs(osp.join(directory, 'static'))\nshutil.copy(conf, directory)\nshutil.copy(layout, osp.join(directory, 'templates'))\nopen(osp.join(directory, '__init__.py'), 'w').write('')\nopen(osp.join(directory, 'static', 'empty'), 'w').write('')\n",
        "CUT_3": "\"\"\"\n    Generates a Sphinx configuration in `directory`.\n\n    Parameters\n    ----------\n    directory : str\n        Base directory to use\n    \"\"\"\nconf = osp.join(get_module_source_path('spyder.plugins.help.utils'), 'conf.py')\nlayout = osp.join(osp.join(CONFDIR_PATH, 'templates'), 'layout.html')\nos.makedirs(osp.join(directory, 'templates'))\nos.makedirs(osp.join(directory, 'static'))\nshutil.copy(conf, directory)\nshutil.copy(layout, osp.join(directory, 'templates'))\nopen(osp.join(directory, '__init__.py'), 'w').write('')\nopen(osp.join(directory, 'static', 'empty'), 'w').write('')\n",
        "CUT_4": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_5": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n"
    },
    {
        "functionName": "test_is_valid_interpreter",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert is_python_interpreter(VALID_INTERPRETER)\npytest.mark.firstpytest.mark.skipif(os.environ.get('CI', None) is None, reason='Only on CI!')",
        "CUT_1": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n",
        "CUT_2": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n",
        "CUT_3": "\"\"\"Mark an AST node for deletion.\"\"\"\nself.to_delete = True\n",
        "CUT_4": "\"\"\"Mark an AST node for deletion.\"\"\"\nself.to_delete = True\n",
        "CUT_5": "\"\"\"\n        Check if optional dependencies are available for special consoles.\n        \"\"\"\ntry:\n    if os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True':\n        import matplotlib\n    elif os.environ.get('SPY_SYMPY_O') == 'True':\n        import sympy\n    elif os.environ.get('SPY_RUN_CYTHON') == 'True':\n        import cython\nexcept Exception:\n    if os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True':\n        return 'matplotlib'\n    elif os.environ.get('SPY_SYMPY_O') == 'True':\n        return 'sympy'\n    elif os.environ.get('SPY_RUN_CYTHON') == 'True':\n        return 'cython'\nreturn None\n"
    },
    {
        "functionName": "test_is_invalid_interpreter",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert not is_python_interpreter(INVALID_INTERPRETER)\npytest.mark.firstpytest.mark.skipif(os.environ.get('CI', None) is None, reason='Only on CI!')",
        "CUT_1": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n",
        "CUT_2": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n",
        "CUT_3": "\"\"\"Mark an AST node for deletion.\"\"\"\nself.to_delete = True\n",
        "CUT_4": "\"\"\"Mark an AST node for deletion.\"\"\"\nself.to_delete = True\n",
        "CUT_5": "\"\"\"\n        Check if optional dependencies are available for special consoles.\n        \"\"\"\ntry:\n    if os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True':\n        import matplotlib\n    elif os.environ.get('SPY_SYMPY_O') == 'True':\n        import sympy\n    elif os.environ.get('SPY_RUN_CYTHON') == 'True':\n        import cython\nexcept Exception:\n    if os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True':\n        return 'matplotlib'\n    elif os.environ.get('SPY_SYMPY_O') == 'True':\n        return 'sympy'\n    elif os.environ.get('SPY_RUN_CYTHON') == 'True':\n        return 'cython'\nreturn None\n"
    },
    {
        "functionName": "test_is_valid_interpreter_name",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "names = ['python', 'pythonw', 'python2.7', 'python3.5', 'python.exe',\n    'pythonw.exe']\nassert all([is_python_interpreter_valid_name(n) for n in names])\npytest.mark.firstpytest.mark.skipif(os.environ.get('CI', None) is None, reason='Only on CI!')",
        "CUT_1": "\"\"\"Return path to Python executable\"\"\"\nexecutable = sys.executable.replace('pythonw.exe', 'python.exe')\nif executable.endswith('spyder.exe'):\n    executable = 'python.exe'\nreturn executable\n",
        "CUT_2": "\"\"\"Return path to Python executable\"\"\"\nexecutable = sys.executable.replace('pythonw.exe', 'python.exe')\nif executable.endswith('spyder.exe'):\n    executable = 'python.exe'\nreturn executable\n",
        "CUT_3": "\"\"\"Check that the python interpreter has 'pythonw'.\"\"\"\npattern = '.*python(\\\\d\\\\.?\\\\d*)?w(.exe)?$'\nif re.match(pattern, filename, flags=re.I) is None:\n    return False\nelse:\n    return True\n",
        "CUT_4": "\"\"\"Check that the python interpreter has 'pythonw'.\"\"\"\npattern = '.*python(\\\\d\\\\.?\\\\d*)?w(.exe)?$'\nif re.match(pattern, filename, flags=re.I) is None:\n    return False\nelse:\n    return True\n",
        "CUT_5": "\"\"\"Set syntax color scheme\"\"\"\nsection = 'appearance'\nnames = CONF.get('appearance', 'names', [])\nfor key in sh.COLOR_SCHEME_KEYS:\n    option = '%s/%s' % (name, key)\n    value = CONF.get(section, option, default=None)\n    if value is None or replace or name not in names:\n        CONF.set(section, option, color_scheme[key])\nnames.append(to_text_string(name))\nCONF.set(section, 'names', sorted(list(set(names))))\n"
    },
    {
        "functionName": "test_find_program",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test if can find the program.\"\"\"\nassert find_program('git')\n",
        "CUT_1": "return _('Find')\n",
        "CUT_2": "return _('Find')\n",
        "CUT_3": "return _('Find')\n",
        "CUT_4": "return _('Find')\n",
        "CUT_5": "\"\"\"\n    Run program in a separate process.\n\n    NOTE: returns the process object created by\n    `subprocess.Popen()`. This can be used with\n    `proc.communicate()` for example.\n\n    If 'shell' appears in the kwargs, it must be False,\n    otherwise ProgramError will be raised.\n\n    If only the program name is given and not the full path,\n    a lookup will be performed to find the program. If the\n    lookup fails, ProgramError will be raised.\n\n    Note that stdin, stdout and stderr will be set by default\n    to PIPE unless specified in subprocess_kwargs.\n\n    :str program: The name of the program to run.\n    :list args: The program arguments.\n    :subprocess_kwargs: These will be passed to subprocess.Popen.\n    \"\"\"\nif 'shell' in subprocess_kwargs and subprocess_kwargs['shell']:\n    raise ProgramError(\n        'This function is only for non-shell programs, use run_shell_command() instead.'\n        )\nfullcmd = find_program(program)\nif not fullcmd:\n    raise ProgramError('Program %s was not found' % program)\nfullcmd = get_full_command_for_program(fullcmd) + (args or [])\nfor stream in ['stdin', 'stdout', 'stderr']:\n    subprocess_kwargs.setdefault(stream, subprocess.PIPE)\nsubprocess_kwargs = alter_subprocess_kwargs_by_platform(**subprocess_kwargs)\nreturn subprocess.Popen(fullcmd, **subprocess_kwargs)\n"
    },
    {
        "functionName": "test_shell_split",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test if the text can be split using shell-like sintax.\"\"\"\nassert shell_split('-q -o -a') == ['-q', '-o', '-a']\nassert shell_split('-q \"d:\\\\Python de xxxx\\\\t.txt\" -o -a') == ['-q',\n    'd:\\\\Python de xxxx\\\\t.txt', '-o', '-a']\n",
        "CUT_1": "\"\"\"Replaces the selected text by its lower version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.lower())\n",
        "CUT_2": "\"\"\"Replaces the selected text by its lower version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.lower())\n",
        "CUT_3": "\"\"\"Replaces the selected text by its upper version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.upper())\n",
        "CUT_4": "\"\"\"Replaces the selected text by its upper version.\"\"\"\ntxt = self.selected_text()\nself.insert_text(txt.upper())\n",
        "CUT_5": "\"\"\"Return the last valid object name in string\"\"\"\ntxt_end = ''\nfor startchar, endchar in ['[]', '()']:\n    if txt.endswith(endchar):\n        pos = txt.rfind(startchar)\n        if pos:\n            txt_end = txt[pos:]\n            txt = txt[:pos]\ntokens = re.split(SYMBOLS, txt)\ntoken = None\ntry:\n    while token is None or re.match(SYMBOLS, token):\n        token = tokens.pop()\n    if token.endswith('.'):\n        token = token[:-1]\n    if token.startswith('.'):\n        return None\n    if last:\n        token += txt[txt.rfind(token) + len(token)]\n    token += txt_end\n    if token:\n        return token\nexcept IndexError:\n    return None\n"
    },
    {
        "functionName": "test_check_version",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the compare function for versions.\"\"\"\nassert check_version('0.9.4-1', '0.9.4', '>=')\nassert check_version('3.0.0rc1', '3.0.0', '<')\nassert check_version('1.0', '1.0b2', '>')\n",
        "CUT_1": "\"\"\"Create internal shell banner\"\"\"\nif message is None:\n    versions = get_versions()\n    return 'Python %s %dbits [%s]' % (versions['python'], versions[\n        'bitness'], versions['system'])\nelse:\n    return message\n",
        "CUT_2": "\"\"\"Create internal shell banner\"\"\"\nif message is None:\n    versions = get_versions()\n    return 'Python %s %dbits [%s]' % (versions['python'], versions[\n        'bitness'], versions['system'])\nelse:\n    return message\n",
        "CUT_3": "\"\"\"Compare previous saved run with last run.\"\"\"\nfilename, _selfilter = getopenfilename(self, _('Select script to compare'),\n    getcwd_or_home(), _('Profiler result') + ' (*.Result)')\nif filename:\n    self.datatree.compare(filename)\n    self.show_data()\n    self.clear_action.setEnabled(True)\n",
        "CUT_4": "\"\"\"Compare previous saved run with last run.\"\"\"\nfilename, _selfilter = getopenfilename(self, _('Select script to compare'),\n    getcwd_or_home(), _('Profiler result') + ' (*.Result)')\nif filename:\n    self.datatree.compare(filename)\n    self.show_data()\n    self.clear_action.setEnabled(True)\n",
        "CUT_5": "versions = get_versions()\nQApplication.clipboard().setText(\n    \"\"\"* Spyder version: {spyder_ver} {revision}\n* Python version: {python_ver} {bitness}-bit\n* Qt version: {qt_ver}\n* {qt_api} version: {qt_api_ver}\n* Operating System: {os_name} {os_ver}\"\"\"\n    .format(spyder_ver=versions['spyder'], revision=versions['revision'],\n    python_ver=versions['python'], bitness=versions['bitness'], qt_ver=\n    versions['qt'], qt_api=versions['qt_api'], qt_api_ver=versions[\n    'qt_api_ver'], os_name=versions['system'], os_ver=versions['release']))\n"
    },
    {
        "functionName": "test_is_module_installed",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test if a module with the proper version is installed\"\"\"\nassert is_module_installed('qtconsole', '>=4.5')\nassert not is_module_installed('IPython', '>=1.0;<3.0')\nassert is_module_installed('jedi', '>=0.7.0')\n",
        "CUT_1": "from spyder.utils.programs import is_module_installed\nreturn is_module_installed('cProfile') and is_module_installed('pstats')\n",
        "CUT_2": "from spyder.utils.programs import is_module_installed\nreturn is_module_installed('cProfile') and is_module_installed('pstats')\n",
        "CUT_3": "\"\"\"Check if dependency is installed\"\"\"\nif self.required_version:\n    return programs.is_module_installed(self.modname, self.required_version)\nelse:\n    return True\n",
        "CUT_4": "\"\"\"Check if dependency is installed\"\"\"\nif self.required_version:\n    return programs.is_module_installed(self.modname, self.required_version)\nelse:\n    return True\n",
        "CUT_5": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n"
    },
    {
        "functionName": "test_is_module_installed_with_custom_interpreter",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test if a module with the proper version is installed\"\"\"\ncurrent = sys.executable\nassert is_module_installed('qtconsole', '>=4.5', interpreter=current)\nassert not is_module_installed('IPython', '>=1.0;<3.0', interpreter=current)\nassert is_module_installed('jedi', '>=0.7.0', interpreter=current)\n",
        "CUT_1": "from spyder.utils.programs import is_module_installed\nreturn is_module_installed('cProfile') and is_module_installed('pstats')\n",
        "CUT_2": "from spyder.utils.programs import is_module_installed\nreturn is_module_installed('cProfile') and is_module_installed('pstats')\n",
        "CUT_3": "\"\"\"Exit interpreter\"\"\"\nself.interpreter.exit_flag = True\nif self.multithreaded:\n    self.interpreter.stdin_write.write(to_binary_string('\\n'))\nself.interpreter.restore_stds()\n",
        "CUT_4": "\"\"\"Exit interpreter\"\"\"\nself.interpreter.exit_flag = True\nif self.multithreaded:\n    self.interpreter.stdin_write.write(to_binary_string('\\n'))\nself.interpreter.restore_stds()\n",
        "CUT_5": "\"\"\"Start Python interpreter.\"\"\"\nself.clear()\nif self.interpreter is not None:\n    self.interpreter.closing()\nself.interpreter = Interpreter(namespace, self.exitfunc, SysOutput,\n    WidgetProxy, get_debug_level())\nself.interpreter.stdout_write.data_avail.connect(self.stdout_avail)\nself.interpreter.stderr_write.data_avail.connect(self.stderr_avail)\nself.interpreter.widget_proxy.sig_set_readonly.connect(self.setReadOnly)\nself.interpreter.widget_proxy.sig_new_prompt.connect(self.new_prompt)\nself.interpreter.widget_proxy.sig_edit.connect(self.edit_script)\nself.interpreter.widget_proxy.sig_wait_input.connect(self.wait_input)\nif self.multithreaded:\n    self.interpreter.start()\nbanner = create_banner(self.message)\nself.write(banner, prompt=True)\nfor cmd in self.commands:\n    self.run_command(cmd, history=False, new_prompt=False)\nself.new_prompt(self.interpreter.p1)\nself.sig_refreshed.emit()\nreturn self.interpreter\n"
    },
    {
        "functionName": "test_get_temp_dir_ensure_dir_exists",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the call to get_temp_dir creates the dir when it doesn't exists\n    \"\"\"\ntemp_dir = get_temp_dir(suffix='test')\nassert os.path.exists(temp_dir)\nos.rmdir(temp_dir)\nanother_call = get_temp_dir(suffix='test')\nassert os.path.exists(another_call)\nassert another_call == temp_dir\n",
        "CUT_1": "\"\"\"Download the installer or installation script.\"\"\"\ntemp_dir = gettempdir()\npath = osp.join(temp_dir, self._installer_name)\nif sys.platform.startswith('linux'):\n    self._change_installation_status(status=DOWNLOADING_SCRIPT)\nelse:\n    self._change_installation_status(status=DOWNLOADING_INSTALLER)\nreturn urlretrieve(self._download_url, path, reporthook=self._progress_reporter\n    )\n",
        "CUT_2": "\"\"\"Download the installer or installation script.\"\"\"\ntemp_dir = gettempdir()\npath = osp.join(temp_dir, self._installer_name)\nif sys.platform.startswith('linux'):\n    self._change_installation_status(status=DOWNLOADING_SCRIPT)\nelse:\n    self._change_installation_status(status=DOWNLOADING_INSTALLER)\nreturn urlretrieve(self._download_url, path, reporthook=self._progress_reporter\n    )\n",
        "CUT_3": "os.remove(os.path.join(filename, 'symlink'))\nos.rmdir(filename)\n",
        "CUT_4": "os.remove(os.path.join(filename, 'symlink'))\nos.rmdir(filename)\n",
        "CUT_5": "\"\"\"Get the project root directory.\n\n    We require that all commands are run from the project root, i.e. the\n    directory that contains setup.py, setup.cfg, and versioneer.py .\n    \"\"\"\nroot = os.path.realpath(os.path.abspath(os.getcwd()))\nsetup_py = os.path.join(root, 'setup.py')\nversioneer_py = os.path.join(root, 'versioneer.py')\nif not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n    root = os.path.dirname(os.path.realpath(os.path.abspath(sys.argv[0])))\n    setup_py = os.path.join(root, 'setup.py')\n    versioneer_py = os.path.join(root, 'versioneer.py')\nif not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n    err = (\n        \"Versioneer was unable to run the project root directory. Versioneer requires setup.py to be executed from its immediate directory (like 'python setup.py COMMAND'), or in a way that lets it use sys.argv[0] to find the root (like 'python path/to/setup.py COMMAND').\"\n        )\n    raise VersioneerBadRootError(err)\ntry:\n    me = os.path.realpath(os.path.abspath(__file__))\n    me_dir = os.path.normcase(os.path.splitext(me)[0])\n    vsr_dir = os.path.normcase(os.path.splitext(versioneer_py)[0])\n    if me_dir != vsr_dir:\n        print('Warning: build in %s is using versioneer.py from %s' % (os.\n            path.dirname(me), versioneer_py))\nexcept NameError:\n    pass\nreturn root\n"
    },
    {
        "functionName": "test_clean_win_application_path",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "data = ('\"c:\\\\some thing\\\\foo.exe\"', 'c:/some thing/foo.exe'), (\n    \"c:\\\\some' thing\\\\foo.exe\", \"c:/some' thing/foo.exe\")\nfor path, expected_output in data:\n    assert _clean_win_application_path(path) == expected_output\n",
        "CUT_1": "\"\"\"Return path to Python executable\"\"\"\nexecutable = sys.executable.replace('pythonw.exe', 'python.exe')\nif executable.endswith('spyder.exe'):\n    executable = 'python.exe'\nreturn executable\n",
        "CUT_2": "\"\"\"Return path to Python executable\"\"\"\nexecutable = sys.executable.replace('pythonw.exe', 'python.exe')\nif executable.endswith('spyder.exe'):\n    executable = 'python.exe'\nreturn executable\n",
        "CUT_3": "\"\"\"Returns True if some text is selected.\"\"\"\nreturn bool(to_text_string(self.textCursor().selectedText()))\n",
        "CUT_4": "\"\"\"Returns True if some text is selected.\"\"\"\nreturn bool(to_text_string(self.textCursor().selectedText()))\n",
        "CUT_5": "\"\"\"\n        Return Spyder PYTHONPATH.\n\n        The returned ordered dictionary has the paths as keys and the state\n        as values. The state is `True` for active and `False` for inactive.\n\n        Example:\n            OrderedDict([('/some/path, True), ('/some/other/path, False)])\n        \"\"\"\nself.load_python_path()\npath_dict = OrderedDict()\nfor path in self.path:\n    path_dict[path] = path not in self.not_active_path\nfor path in self.project_path:\n    path_dict[path] = True\nreturn path_dict\n"
    },
    {
        "functionName": "test_get_installed_apps_and_icons",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "apps = get_installed_applications()\nassert apps\nfor app in apps:\n    fpath = apps[app]\n    icon = get_application_icon(fpath)\n    assert icon\n    assert osp.isdir(fpath) or osp.isfile(fpath)\n",
        "CUT_1": "\"\"\"Load installed applications.\"\"\"\nQApplication.setOverrideCursor(QCursor(Qt.WaitCursor))\nself.list.clear()\nif applications is None:\n    apps = get_installed_applications()\nelse:\n    apps = applications\nfor app in sorted(apps, key=lambda x: x.lower()):\n    fpath = apps[app]\n    icon = get_application_icon(fpath)\n    item = QListWidgetItem(icon, app)\n    item.setToolTip(fpath)\n    item.fpath = fpath\n    self.list.addItem(item)\nself.list.setMinimumWidth(self.list.sizeHintForColumn(0) + 24)\nQApplication.restoreOverrideCursor()\nself._refresh()\n",
        "CUT_2": "\"\"\"Load installed applications.\"\"\"\nQApplication.setOverrideCursor(QCursor(Qt.WaitCursor))\nself.list.clear()\nif applications is None:\n    apps = get_installed_applications()\nelse:\n    apps = applications\nfor app in sorted(apps, key=lambda x: x.lower()):\n    fpath = apps[app]\n    icon = get_application_icon(fpath)\n    item = QListWidgetItem(icon, app)\n    item.setToolTip(fpath)\n    item.fpath = fpath\n    self.list.addItem(item)\nself.list.setMinimumWidth(self.list.sizeHintForColumn(0) + 24)\nQApplication.restoreOverrideCursor()\nself._refresh()\n",
        "CUT_3": "\"\"\"Return all system installed osx applications.\"\"\"\napps = {}\napp_folders = ['/**/*.app', '/Users/{}/**/*.app'.format(get_username())]\nfpaths = []\nfor path in app_folders:\n    fpaths += glob.glob(path)\nfor fpath in fpaths:\n    if os.path.isdir(fpath):\n        name = os.path.basename(fpath).split('.app')[0]\n        apps[name] = fpath\nreturn apps\n",
        "CUT_4": "\"\"\"Return all system installed osx applications.\"\"\"\napps = {}\napp_folders = ['/**/*.app', '/Users/{}/**/*.app'.format(get_username())]\nfpaths = []\nfor path in app_folders:\n    fpaths += glob.glob(path)\nfor fpath in fpaths:\n    if os.path.isdir(fpath):\n        name = os.path.basename(fpath).split('.app')[0]\n        apps[name] = fpath\nreturn apps\n",
        "CUT_5": "\"\"\"\n    Return all system installed applications.\n\n    The return value is a list of tuples where the first item is the icon path\n    and the second item is the program executable path.\n    \"\"\"\napps = {}\nif sys.platform == 'darwin':\n    apps = _get_mac_applications()\nelif os.name == 'nt':\n    apps = _get_win_applications()\nelse:\n    apps = _get_linux_applications()\nif sys.platform == 'darwin':\n    apps = {key: val for key, val in apps.items() if osp.isdir(val)}\nelse:\n    apps = {key: val for key, val in apps.items() if osp.isfile(val)}\nreturn apps\n"
    },
    {
        "functionName": "test_parse_linux_desktop_entry",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "apps = get_installed_applications()\nfor app in apps:\n    fpath = apps[app]\n    data = parse_linux_desktop_entry(fpath)\n    assert data\n    for key in ['name', 'icon_path', 'hidden', 'exec', 'type', 'fpath']:\n        assert key in data\n    assert fpath == data['fpath']\npytest.mark.skipif(not sys.platform.startswith('linux'), reason=\n    'Test for linux only')",
        "CUT_1": "\"\"\"Load installed applications.\"\"\"\nQApplication.setOverrideCursor(QCursor(Qt.WaitCursor))\nself.list.clear()\nif applications is None:\n    apps = get_installed_applications()\nelse:\n    apps = applications\nfor app in sorted(apps, key=lambda x: x.lower()):\n    fpath = apps[app]\n    icon = get_application_icon(fpath)\n    item = QListWidgetItem(icon, app)\n    item.setToolTip(fpath)\n    item.fpath = fpath\n    self.list.addItem(item)\nself.list.setMinimumWidth(self.list.sizeHintForColumn(0) + 24)\nQApplication.restoreOverrideCursor()\nself._refresh()\n",
        "CUT_2": "\"\"\"Load installed applications.\"\"\"\nQApplication.setOverrideCursor(QCursor(Qt.WaitCursor))\nself.list.clear()\nif applications is None:\n    apps = get_installed_applications()\nelse:\n    apps = applications\nfor app in sorted(apps, key=lambda x: x.lower()):\n    fpath = apps[app]\n    icon = get_application_icon(fpath)\n    item = QListWidgetItem(icon, app)\n    item.setToolTip(fpath)\n    item.fpath = fpath\n    self.list.addItem(item)\nself.list.setMinimumWidth(self.list.sizeHintForColumn(0) + 24)\nQApplication.restoreOverrideCursor()\nself._refresh()\n",
        "CUT_3": "\"\"\"Prompt user to select an application not found on the list.\"\"\"\napp = None\nitem = None\nif sys.platform == 'darwin':\n    if fpath is None:\n        basedir = '/Applications/'\n        filters = _('Applications (*.app)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.app') and os.path.isdir(fpath):\n        app = os.path.basename(fpath).split('.app')[0]\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nelif os.name == 'nt':\n    if fpath is None:\n        basedir = 'C:\\\\'\n        filters = _('Applications (*.exe *.bat *.com)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath:\n        check_1 = fpath.endswith('.bat') and is_text_file(fpath)\n        check_2 = fpath.endswith(('.exe', '.com')) and not is_text_file(fpath)\n        if check_1 or check_2:\n            app = os.path.basename(fpath).capitalize().rsplit('.')[0]\n            for row in range(self.list.count()):\n                item = self.list.item(row)\n                if app == item.text() and fpath == item.fpath:\n                    break\n            else:\n                item = None\nelse:\n    if fpath is None:\n        basedir = '/'\n        filters = _('Applications (*.desktop)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.desktop') and is_text_file(fpath):\n        entry_data = parse_linux_desktop_entry(fpath)\n        app = entry_data['name']\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nif fpath:\n    if item:\n        self.list.setCurrentItem(item)\n    elif app:\n        icon = get_application_icon(fpath)\n        item = QListWidgetItem(icon, app)\n        item.fpath = fpath\n        self.list.addItem(item)\n        self.list.setCurrentItem(item)\nself.list.setFocus()\nself._refresh()\n",
        "CUT_4": "\"\"\"Prompt user to select an application not found on the list.\"\"\"\napp = None\nitem = None\nif sys.platform == 'darwin':\n    if fpath is None:\n        basedir = '/Applications/'\n        filters = _('Applications (*.app)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.app') and os.path.isdir(fpath):\n        app = os.path.basename(fpath).split('.app')[0]\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nelif os.name == 'nt':\n    if fpath is None:\n        basedir = 'C:\\\\'\n        filters = _('Applications (*.exe *.bat *.com)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath:\n        check_1 = fpath.endswith('.bat') and is_text_file(fpath)\n        check_2 = fpath.endswith(('.exe', '.com')) and not is_text_file(fpath)\n        if check_1 or check_2:\n            app = os.path.basename(fpath).capitalize().rsplit('.')[0]\n            for row in range(self.list.count()):\n                item = self.list.item(row)\n                if app == item.text() and fpath == item.fpath:\n                    break\n            else:\n                item = None\nelse:\n    if fpath is None:\n        basedir = '/'\n        filters = _('Applications (*.desktop)')\n        title = _('Select application')\n        fpath, __ = getopenfilename(self, title, basedir, filters)\n    if fpath and fpath.endswith('.desktop') and is_text_file(fpath):\n        entry_data = parse_linux_desktop_entry(fpath)\n        app = entry_data['name']\n        for row in range(self.list.count()):\n            item = self.list.item(row)\n            if app == item.text() and fpath == item.fpath:\n                break\n        else:\n            item = None\nif fpath:\n    if item:\n        self.list.setCurrentItem(item)\n    elif app:\n        icon = get_application_icon(fpath)\n        item = QListWidgetItem(icon, app)\n        item.fpath = fpath\n        self.list.addItem(item)\n        self.list.setCurrentItem(item)\nself.list.setFocus()\nself._refresh()\n",
        "CUT_5": "\"\"\"Return all system installed osx applications.\"\"\"\napps = {}\napp_folders = ['/**/*.app', '/Users/{}/**/*.app'.format(get_username())]\nfpaths = []\nfor path in app_folders:\n    fpaths += glob.glob(path)\nfor fpath in fpaths:\n    if os.path.isdir(fpath):\n        name = os.path.basename(fpath).split('.app')[0]\n        apps[name] = fpath\nreturn apps\n"
    },
    {
        "functionName": "test_open_files_with_application",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "fpath = tmp_path / 'file space.txt'\nfpath.write_text('Hello')\nfpath_2 = tmp_path / 'file2.txt'\nfpath_2.write_text('Hello 2')\nif os.name == 'nt':\n    ext = '.exe'\n    path_obj = tmp_path / ('some-new app' + ext)\n    path_obj.write_bytes(b'\\x00\\x00')\n    app_path = str(path_obj)\nelif sys.platform == 'darwin':\n    ext = '.app'\n    path_obj = tmp_path / ('some-new app' + ext)\n    path_obj.mkdir()\n    app_path = str(path_obj)\nelse:\n    ext = '.desktop'\n    path_obj = tmp_path / ('some-new app' + ext)\n    path_obj.write_text(\n        \"\"\"\n[Desktop Entry]\nName=Suer app\nType=Application\nExec=/something/bleerp\nIcon=/blah/blah.xpm\n\"\"\"\n        )\n    app_path = str(path_obj)\nfnames = [str(fpath), str(fpath_2)]\nreturn_codes = open_files_with_application(app_path, fnames)\nassert 0 not in return_codes.values()\nwith pytest.raises(ValueError):\n    return_codes = open_files_with_application('not-valid.ext', fnames)\n",
        "CUT_1": "widget = FileAssociationsWidget()\nqtbot.addWidget(widget)\nif os.name == 'nt':\n    ext = '.exe'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.write_bytes(b'Binary file contents')\n    fpath = str(path_obj)\nelif sys.platform == 'darwin':\n    ext = '.app'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.mkdir()\n    fpath = str(path_obj)\nelse:\n    ext = '.desktop'\n    path_obj = tmp_path / ('app 2' + ext)\n    path_obj.write_text('Text file contents')\n    fpath = str(path_obj)\ndata = {'*.csv': [('App name 1', '/path/to/app 1' + ext), ('App name 2',\n    fpath)], '*.txt': [('App name 2', fpath), ('App name 3', \n    '/path/to/app 3' + ext)]}\nwidget.load_values(data)\nwidget.show()\nwidget.test_data = data\nreturn qtbot, widget\npytest.fixture",
        "CUT_2": "path_obj = pathlib.Path(osp.abspath(path))\nif os.name == 'nt' and PY2:\n    return make_as_uri(path_obj)\nelse:\n    return path_obj.as_uri()\n",
        "CUT_3": "path_obj = pathlib.Path(osp.abspath(path))\nif os.name == 'nt' and PY2:\n    return make_as_uri(path_obj)\nelse:\n    return path_obj.as_uri()\n",
        "CUT_4": "\"\"\"Open files with given application executable path.\"\"\"\nif not (os.path.isdir(app_path) or os.path.isfile(app_path)):\n    return_codes = {app_path: 1}\n    app_path = None\nelse:\n    return_codes = {}\nif app_path:\n    fnames = self.get_selected_filenames()\n    return_codes = programs.open_files_with_application(app_path, fnames)\nself.check_launch_error_codes(return_codes)\nSlot()",
        "CUT_5": "\"\"\"Open files with given application executable path.\"\"\"\nif not (os.path.isdir(app_path) or os.path.isfile(app_path)):\n    return_codes = {app_path: 1}\n    app_path = None\nelse:\n    return_codes = {}\nif app_path:\n    fnames = self.get_selected_filenames()\n    return_codes = programs.open_files_with_application(app_path, fnames)\nself.check_launch_error_codes(return_codes)\nSlot()"
    },
    {
        "functionName": "test_get_package_version",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert get_package_version('IPython')\n",
        "CUT_1": "\"\"\"Return widget title\"\"\"\nreturn _('IPython console')\n",
        "CUT_2": "\"\"\"Return widget title\"\"\"\nreturn _('IPython console')\n",
        "CUT_3": "return _('Provide command history for IPython Consoles')\n",
        "CUT_4": "return _('Provide command history for IPython Consoles')\n",
        "CUT_5": "\"\"\"Show intro to IPython help\"\"\"\nfrom IPython.core.usage import interactive_usage\nself.sig_render_rich_text_requested.emit(interactive_usage, False)\nSlot()"
    },
    {
        "functionName": "test_get_module_version",
        "className": null,
        "fileName": "/spyder/utils/tests/test_programs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert get_module_version('pyls_black')\n",
        "CUT_1": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_4": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_5": "self.modname = modname\nself.package_name = package_name\nself.features = features\nself.required_version = required_version\nself.kind = kind\nif installed_version is None:\n    try:\n        self.installed_version = programs.get_module_version(modname)\n    except Exception:\n        self.installed_version = None\nelse:\n    self.installed_version = installed_version\n"
    },
    {
        "functionName": "test_vcs_tool",
        "className": null,
        "fileName": "/spyder/utils/tests/test_vcs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if not os.name == 'nt':\n    with pytest.raises(ActionToolNotFound):\n        run_vcs_tool(osp.dirname(__file__), 'browse')\nelse:\n    assert run_vcs_tool(osp.dirname(__file__), 'browse')\n    assert run_vcs_tool(osp.dirname(__file__), 'commit')\nskipnogitpytest.mark.skipif(os.environ.get('CI', None) is None, reason=\n    'Not to be run outside of CIs')",
        "CUT_1": "\"\"\"\n    Run Find in Files widget test.\n    \"\"\"\nfrom os.path import dirname\nimport sys\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\noptions = FindInFilesWidget.DEFAULT_OPTIONS.copy()\nwidget = FindInFilesWidget('find_in_files', options=options)\nwidget._setup(options=options)\nwidget.setup(options=options)\nwidget.resize(640, 480)\nwidget.show()\nexternal_paths = [dirname(__file__), dirname(dirname(__file__)), dirname(\n    dirname(dirname(__file__))), dirname(dirname(dirname(dirname(__file__))))]\nfor path in external_paths:\n    widget.add_external_path(path)\nsys.exit(app.exec_())\n",
        "CUT_2": "\"\"\"\n    Run Find in Files widget test.\n    \"\"\"\nfrom os.path import dirname\nimport sys\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\noptions = FindInFilesWidget.DEFAULT_OPTIONS.copy()\nwidget = FindInFilesWidget('find_in_files', options=options)\nwidget._setup(options=options)\nwidget.setup(options=options)\nwidget.resize(640, 480)\nwidget.show()\nexternal_paths = [dirname(__file__), dirname(dirname(__file__)), dirname(\n    dirname(dirname(__file__))), dirname(dirname(dirname(dirname(__file__))))]\nfor path in external_paths:\n    widget.add_external_path(path)\nsys.exit(app.exec_())\n",
        "CUT_3": "\"\"\"Check sys.path: is Spyder properly installed?\"\"\"\ndirname = osp.abspath(osp.join(osp.dirname(__file__), osp.pardir))\nif dirname not in sys.path:\n    show_warning(\n        \"\"\"Spyder must be installed properly (e.g. from source: 'python setup.py install'),\nor directory '%s' must be in PYTHONPATH environment variable.\"\"\"\n         % dirname)\n",
        "CUT_4": "\"\"\"Check sys.path: is Spyder properly installed?\"\"\"\ndirname = osp.abspath(osp.join(osp.dirname(__file__), osp.pardir))\nif dirname not in sys.path:\n    show_warning(\n        \"\"\"Spyder must be installed properly (e.g. from source: 'python setup.py install'),\nor directory '%s' must be in PYTHONPATH environment variable.\"\"\"\n         % dirname)\n",
        "CUT_5": "\"\"\"Return True if this is a pynsist installation of Spyder.\"\"\"\nbase_path = osp.abspath(osp.dirname(__file__))\npkgs_path = osp.abspath(osp.join(base_path, '..', '..', '..', 'pkgs'))\nif os.environ.get('PYTHONPATH') is not None:\n    return pkgs_path in os.environ.get('PYTHONPATH')\nreturn False\n"
    },
    {
        "functionName": "test_vcs_root",
        "className": null,
        "fileName": "/spyder/utils/tests/test_vcs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "directory = tmpdir.mkdir('foo')\nassert get_vcs_root(str(directory)) == None\nassert get_vcs_root(osp.dirname(__file__)) != None\nskipnogit",
        "CUT_1": "\"\"\"\n        Select working directory.\n\n        Parameters\n        ----------\n        directory: str, optional\n            The directory to change to.\n\n        Notes\n        -----\n        If directory is None, a get directorty dialog will be used.\n        \"\"\"\nif directory is None:\n    self.sig_redirect_stdio_requested.emit(False)\n    directory = getexistingdirectory(self, _('Select directory'),\n        getcwd_or_home())\n    self.sig_redirect_stdio_requested.emit(True)\nif directory:\n    self.chdir(directory)\nSlot()",
        "CUT_2": "\"\"\"\n        Select working directory.\n\n        Parameters\n        ----------\n        directory: str, optional\n            The directory to change to.\n\n        Notes\n        -----\n        If directory is None, a get directorty dialog will be used.\n        \"\"\"\nif directory is None:\n    self.sig_redirect_stdio_requested.emit(False)\n    directory = getexistingdirectory(self, _('Select directory'),\n        getcwd_or_home())\n    self.sig_redirect_stdio_requested.emit(True)\nif directory:\n    self.chdir(directory)\nSlot()",
        "CUT_3": "\"\"\"Return True if path is a supported VCS repository\"\"\"\nreturn get_vcs_root(path) is not None\n",
        "CUT_4": "\"\"\"Return True if path is a supported VCS repository\"\"\"\nreturn get_vcs_root(path) is not None\n",
        "CUT_5": "\"\"\"Select directory\"\"\"\nself.sig_redirect_stdio_requested.emit(False)\ndirectory = getexistingdirectory(self, _('Select directory'), self.path)\nif directory:\n    directory = to_unicode_from_fs(osp.abspath(directory))\nself.sig_redirect_stdio_requested.emit(True)\nreturn directory\nSlot()"
    },
    {
        "functionName": "test_git_revision",
        "className": null,
        "fileName": "/spyder/utils/tests/test_vcs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "root = get_vcs_root(osp.dirname(__file__))\nassert get_git_revision(osp.dirname(__file__)) == (None, None)\nassert all([isinstance(x, str) for x in get_git_revision(root)])\nskipnogitpytest.mark.skipif(os.name == 'nt' and os.environ.get('AZURE') is not None,\n    reason='Fails on Windows/Azure')",
        "CUT_1": "\"\"\"\n    Run Find in Files widget test.\n    \"\"\"\nfrom os.path import dirname\nimport sys\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\noptions = FindInFilesWidget.DEFAULT_OPTIONS.copy()\nwidget = FindInFilesWidget('find_in_files', options=options)\nwidget._setup(options=options)\nwidget.setup(options=options)\nwidget.resize(640, 480)\nwidget.show()\nexternal_paths = [dirname(__file__), dirname(dirname(__file__)), dirname(\n    dirname(dirname(__file__))), dirname(dirname(dirname(dirname(__file__))))]\nfor path in external_paths:\n    widget.add_external_path(path)\nsys.exit(app.exec_())\n",
        "CUT_2": "\"\"\"\n    Run Find in Files widget test.\n    \"\"\"\nfrom os.path import dirname\nimport sys\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\noptions = FindInFilesWidget.DEFAULT_OPTIONS.copy()\nwidget = FindInFilesWidget('find_in_files', options=options)\nwidget._setup(options=options)\nwidget.setup(options=options)\nwidget.resize(640, 480)\nwidget.show()\nexternal_paths = [dirname(__file__), dirname(dirname(__file__)), dirname(\n    dirname(dirname(__file__))), dirname(dirname(dirname(dirname(__file__))))]\nfor path in external_paths:\n    widget.add_external_path(path)\nsys.exit(app.exec_())\n",
        "CUT_3": "\"\"\"Return True if this is a pynsist installation of Spyder.\"\"\"\nbase_path = osp.abspath(osp.dirname(__file__))\npkgs_path = osp.abspath(osp.join(base_path, '..', '..', '..', 'pkgs'))\nif os.environ.get('PYTHONPATH') is not None:\n    return pkgs_path in os.environ.get('PYTHONPATH')\nreturn False\n",
        "CUT_4": "\"\"\"Return True if this is a pynsist installation of Spyder.\"\"\"\nbase_path = osp.abspath(osp.dirname(__file__))\npkgs_path = osp.abspath(osp.join(base_path, '..', '..', '..', 'pkgs'))\nif os.environ.get('PYTHONPATH') is not None:\n    return pkgs_path in os.environ.get('PYTHONPATH')\nreturn False\n",
        "CUT_5": "\"\"\"Set shell current working directory.\"\"\"\nif os.name == 'nt':\n    dirname = osp.normpath(dirname)\nif self.ipyclient.hostname is None:\n    self.call_kernel(interrupt=self.is_debugging()).set_cwd(dirname)\n    self._cwd = dirname\n"
    },
    {
        "functionName": "test_no_git",
        "className": null,
        "fileName": "/spyder/utils/tests/test_vcs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "def mockreturn(program_name):\n    return None\nmonkeypatch.setattr(programs, 'find_program', mockreturn)\nbranch_tags, branch, files_modified = get_git_refs(__file__)\nassert len(branch_tags) == 0\nassert branch == ''\nassert len(files_modified) == 0\n",
        "CUT_1": "\"\"\"Receive data from git and update gui.\"\"\"\nbranches, branch, files_modified = output\ntext = branch if branch else ''\nif len(files_modified):\n    text = text + ' [{}]'.format(len(files_modified))\nself.setVisible(bool(branch))\nself.set_value(text)\nself._git_is_working = False\nif self._git_job_queue:\n    self.update_vcs(*self._git_job_queue)\n",
        "CUT_2": "\"\"\"Receive data from git and update gui.\"\"\"\nbranches, branch, files_modified = output\ntext = branch if branch else ''\nif len(files_modified):\n    text = text + ' [{}]'.format(len(files_modified))\nself.setVisible(bool(branch))\nself.set_value(text)\nself._git_is_working = False\nif self._git_job_queue:\n    self.update_vcs(*self._git_job_queue)\n",
        "CUT_3": "\"\"\"Change current branch.\"\"\"\npass\n",
        "CUT_4": "\"\"\"Change current branch.\"\"\"\npass\n",
        "CUT_5": "\"\"\"Get Git active branch, state, branches (plus tags).\"\"\"\nreturn get_git_refs(osp.dirname(fname))\n"
    },
    {
        "functionName": "mockreturn",
        "className": null,
        "fileName": "/spyder/utils/tests/test_vcs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return None\n",
        "CUT_1": "return 2\n",
        "CUT_2": "return []\n",
        "CUT_3": "return 2\n",
        "CUT_4": "return 2\n",
        "CUT_5": "return 2\n"
    },
    {
        "functionName": "test_get_git_refs",
        "className": null,
        "fileName": "/spyder/utils/tests/test_vcs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "branch_tags, branch, files_modified = get_git_refs(__file__)\nassert bool(branch)\nassert len(files_modified) >= 0\nassert any([('master' in b or '4.x' in b) for b in branch_tags])\nskipnogit",
        "CUT_1": "\"\"\"Receive data from git and update gui.\"\"\"\nbranches, branch, files_modified = output\ntext = branch if branch else ''\nif len(files_modified):\n    text = text + ' [{}]'.format(len(files_modified))\nself.setVisible(bool(branch))\nself.set_value(text)\nself._git_is_working = False\nif self._git_job_queue:\n    self.update_vcs(*self._git_job_queue)\n",
        "CUT_2": "\"\"\"Receive data from git and update gui.\"\"\"\nbranches, branch, files_modified = output\ntext = branch if branch else ''\nif len(files_modified):\n    text = text + ' [{}]'.format(len(files_modified))\nself.setVisible(bool(branch))\nself.set_value(text)\nself._git_is_working = False\nif self._git_job_queue:\n    self.update_vcs(*self._git_job_queue)\n",
        "CUT_3": "\"\"\"Change current branch.\"\"\"\npass\n",
        "CUT_4": "\"\"\"Change current branch.\"\"\"\npass\n",
        "CUT_5": "\"\"\"Get Git active branch, state, branches (plus tags).\"\"\"\nreturn get_git_refs(osp.dirname(fname))\n"
    },
    {
        "functionName": "test_get_git_remotes",
        "className": null,
        "fileName": "/spyder/utils/tests/test_vcs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "remotes = get_git_remotes(HERE)\nassert 'origin' in remotes\nskipnogit",
        "CUT_1": "\"\"\"Go to url from cursor and defined hover patterns.\"\"\"\nkey = self._last_hover_pattern_key\nfull_uri = uri\nif key in ['file']:\n    fname = self._preprocess_file_uri(uri)\n    if osp.isfile(fname) and encoding.is_text_file(fname):\n        self.go_to_definition.emit(fname, 0, 0)\n    else:\n        fname = file_uri(fname)\n        programs.start_file(fname)\nelif key in ['mail', 'url']:\n    if '@' in uri and not uri.startswith('mailto:'):\n        full_uri = 'mailto:' + uri\n    quri = QUrl(full_uri)\n    QDesktopServices.openUrl(quri)\nelif key in ['issue']:\n    repo_url = uri.replace('#', '/issues/')\n    if uri.startswith(('gh-', 'bb-', 'gl-')):\n        number = uri[3:]\n        remotes = get_git_remotes(self.filename)\n        remote = remotes.get('upstream', remotes.get('origin'))\n        if remote:\n            full_uri = remote_to_url(remote) + '/issues/' + number\n        else:\n            full_uri = None\n    elif uri.startswith('gh:') or ':' not in uri:\n        repo_and_issue = repo_url\n        if uri.startswith('gh:'):\n            repo_and_issue = repo_url[3:]\n        full_uri = 'https://github.com/' + repo_and_issue\n    elif uri.startswith('gl:'):\n        full_uri = 'https://gitlab.com/' + repo_url[3:]\n    elif uri.startswith('bb:'):\n        full_uri = 'https://bitbucket.org/' + repo_url[3:]\n    if full_uri:\n        quri = QUrl(full_uri)\n        QDesktopServices.openUrl(quri)\n    else:\n        QMessageBox.information(self, _('Information'), _(\n            'This file is not part of a local repository or upstream/origin remotes are not defined!'\n            ), QMessageBox.Ok)\nself.sig_go_to_uri.emit(uri)\nself.hide_tooltip()\nreturn full_uri\n",
        "CUT_2": "\"\"\"Go to url from cursor and defined hover patterns.\"\"\"\nkey = self._last_hover_pattern_key\nfull_uri = uri\nif key in ['file']:\n    fname = self._preprocess_file_uri(uri)\n    if osp.isfile(fname) and encoding.is_text_file(fname):\n        self.go_to_definition.emit(fname, 0, 0)\n    else:\n        fname = file_uri(fname)\n        programs.start_file(fname)\nelif key in ['mail', 'url']:\n    if '@' in uri and not uri.startswith('mailto:'):\n        full_uri = 'mailto:' + uri\n    quri = QUrl(full_uri)\n    QDesktopServices.openUrl(quri)\nelif key in ['issue']:\n    repo_url = uri.replace('#', '/issues/')\n    if uri.startswith(('gh-', 'bb-', 'gl-')):\n        number = uri[3:]\n        remotes = get_git_remotes(self.filename)\n        remote = remotes.get('upstream', remotes.get('origin'))\n        if remote:\n            full_uri = remote_to_url(remote) + '/issues/' + number\n        else:\n            full_uri = None\n    elif uri.startswith('gh:') or ':' not in uri:\n        repo_and_issue = repo_url\n        if uri.startswith('gh:'):\n            repo_and_issue = repo_url[3:]\n        full_uri = 'https://github.com/' + repo_and_issue\n    elif uri.startswith('gl:'):\n        full_uri = 'https://gitlab.com/' + repo_url[3:]\n    elif uri.startswith('bb:'):\n        full_uri = 'https://bitbucket.org/' + repo_url[3:]\n    if full_uri:\n        quri = QUrl(full_uri)\n        QDesktopServices.openUrl(quri)\n    else:\n        QMessageBox.information(self, _('Information'), _(\n            'This file is not part of a local repository or upstream/origin remotes are not defined!'\n            ), QMessageBox.Ok)\nself.sig_go_to_uri.emit(uri)\nself.hide_tooltip()\nreturn full_uri\n",
        "CUT_3": "\"\"\"Return git remotes for repo on fpath.\"\"\"\nremote_data = {}\ndata, __ = programs.run_program('git', ['remote', '-v'], cwd=osp.dirname(fpath)\n    ).communicate()\nif PY3:\n    data = data.decode(sys.getdefaultencoding())\nlines = [line.strip() for line in data.split('\\n') if line]\nfor line in lines:\n    if line:\n        remote, value = line.split('\\t')\n        remote_data[remote] = value.split(' ')[0]\nreturn remote_data\n",
        "CUT_4": "\"\"\"Return git remotes for repo on fpath.\"\"\"\nremote_data = {}\ndata, __ = programs.run_program('git', ['remote', '-v'], cwd=osp.dirname(fpath)\n    ).communicate()\nif PY3:\n    data = data.decode(sys.getdefaultencoding())\nlines = [line.strip() for line in data.split('\\n') if line]\nfor line in lines:\n    if line:\n        remote, value = line.split('\\t')\n        remote_data[remote] = value.split(' ')[0]\nreturn remote_data\n",
        "CUT_5": "\"\"\"Return folder management actions\"\"\"\nactions = []\nif os.name == 'nt':\n    _title = _('Open command prompt here')\nelse:\n    _title = _('Open terminal here')\n_title = _('Open IPython console here')\naction = create_action(self, _title, triggered=lambda : self.\n    open_interpreter(fnames))\nactions.append(action)\nreturn actions\n"
    },
    {
        "functionName": "test_remote_to_url",
        "className": null,
        "fileName": "/spyder/utils/tests/test_vcs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "output = remote_to_url(input_text)\nassert expected_output == output\npytest.mark.parametrize('input_text, expected_output', [(\n    'https://github.com/neophnx/spyder.git',\n    'https://github.com/neophnx/spyder'), (\n    'http://github.com/neophnx/spyder.git',\n    'http://github.com/neophnx/spyder'), (\n    'git@github.com:goanpeca/spyder.git',\n    'https://github.com/goanpeca/spyder')])",
        "CUT_1": "\"\"\"\n        Generate authorize_url.\n\n        >>> GitHub(client_id='3ebf94c5776d565bcf75').authorize_url()\n        'https://github.com/login/oauth/authorize?client_id=3ebf94c5776d565bcf75'\n        \"\"\"\nif not self._client_id:\n    raise ApiAuthError('No client id.')\nkw = dict(client_id=self._client_id)\nif self._redirect_uri:\n    kw['redirect_uri'] = self._redirect_uri\nif self._scope:\n    kw['scope'] = self._scope\nif state:\n    kw['state'] = state\nreturn 'https://github.com/login/oauth/authorize?%s' % _encode_params(kw)\n",
        "CUT_2": "\"\"\"\n        Generate authorize_url.\n\n        >>> GitHub(client_id='3ebf94c5776d565bcf75').authorize_url()\n        'https://github.com/login/oauth/authorize?client_id=3ebf94c5776d565bcf75'\n        \"\"\"\nif not self._client_id:\n    raise ApiAuthError('No client id.')\nkw = dict(client_id=self._client_id)\nif self._redirect_uri:\n    kw['redirect_uri'] = self._redirect_uri\nif self._scope:\n    kw['scope'] = self._scope\nif state:\n    kw['state'] = state\nreturn 'https://github.com/login/oauth/authorize?%s' % _encode_params(kw)\n",
        "CUT_3": "_logger().debug(\"\"\"sending bug report on github\ntitle=%s\nbody=%s\"\"\", title,\n    body)\ncredentials = self.get_user_credentials()\ntoken = credentials['token']\nremember_token = credentials['remember_token']\nif token is None:\n    return False\n_logger().debug('got user credentials')\nif application_log:\n    url = self.upload_log_file(application_log)\n    body += '\\nApplication log: %s' % url\ntry:\n    gh = github.GitHub(access_token=token)\n    repo = gh.repos(self.gh_owner)(self.gh_repo)\n    ret = repo.issues.post(title=title, body=body)\nexcept github.ApiError as e:\n    _logger().warning('Failed to send bug report on Github. response=%r', e\n        .response)\n    if e.response.code == 401:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _('Invalid credentials'\n                ), _('Failed to create Github issue, invalid credentials...'))\n    elif self._show_msgbox:\n        QMessageBox.warning(self.parent_widget, _('Failed to create issue'),\n            _('Failed to create Github issue. Error %d') % e.response.code)\n    return False\nelse:\n    issue_nbr = ret['number']\n    if self._show_msgbox:\n        ret = QMessageBox.question(self.parent_widget, _(\n            'Issue created on Github'), _(\n            'Issue successfully created. Would you like to open the issue in your web browser?'\n            ))\n    if ret in [QMessageBox.Yes, QMessageBox.Ok]:\n        webbrowser.open('https://github.com/%s/%s/issues/%d' % (self.\n            gh_owner, self.gh_repo, issue_nbr))\n    return True\n",
        "CUT_4": "_logger().debug(\"\"\"sending bug report on github\ntitle=%s\nbody=%s\"\"\", title,\n    body)\ncredentials = self.get_user_credentials()\ntoken = credentials['token']\nremember_token = credentials['remember_token']\nif token is None:\n    return False\n_logger().debug('got user credentials')\nif application_log:\n    url = self.upload_log_file(application_log)\n    body += '\\nApplication log: %s' % url\ntry:\n    gh = github.GitHub(access_token=token)\n    repo = gh.repos(self.gh_owner)(self.gh_repo)\n    ret = repo.issues.post(title=title, body=body)\nexcept github.ApiError as e:\n    _logger().warning('Failed to send bug report on Github. response=%r', e\n        .response)\n    if e.response.code == 401:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _('Invalid credentials'\n                ), _('Failed to create Github issue, invalid credentials...'))\n    elif self._show_msgbox:\n        QMessageBox.warning(self.parent_widget, _('Failed to create issue'),\n            _('Failed to create Github issue. Error %d') % e.response.code)\n    return False\nelse:\n    issue_nbr = ret['number']\n    if self._show_msgbox:\n        ret = QMessageBox.question(self.parent_widget, _(\n            'Issue created on Github'), _(\n            'Issue successfully created. Would you like to open the issue in your web browser?'\n            ))\n    if ret in [QMessageBox.Yes, QMessageBox.Ok]:\n        webbrowser.open('https://github.com/%s/%s/issues/%d' % (self.\n            gh_owner, self.gh_repo, issue_nbr))\n    return True\n",
        "CUT_5": "\"\"\"Return a managed document if-present, else create one pointing at disk.\n\n        See https://github.com/Microsoft/language-server-protocol/issues/177\n        \"\"\"\nreturn self._docs.get(doc_uri) or self._create_document(doc_uri)\n"
    },
    {
        "functionName": "test_module_completion",
        "className": null,
        "fileName": "/spyder/utils/introspection/tests/test_modulecompletion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test module_completion.\"\"\"\nassert 'numpy.linalg' in get_preferred_submodules()\npytest.mark.skipif(sys.platform == 'darwin' and PY3, reason=\n    \"It's very slow in this combo\")",
        "CUT_1": "\"\"\"\n    Decide what tests to run (slow or fast) according to the --run-slow\n    option.\n    \"\"\"\nslow_option = config.getoption('--run-slow')\nskip_slow = pytest.mark.skip(reason='Need --run-slow option to run')\nskip_fast = pytest.mark.skip(reason=\"Don't need --run-slow option to run\")\nfor item in items:\n    if slow_option:\n        if 'slow' not in item.keywords:\n            item.add_marker(skip_fast)\n    elif 'slow' in item.keywords:\n        item.add_marker(skip_slow)\n",
        "CUT_2": "\"\"\" \"\"\"\nplatform = sys.platform.lower()\nif 'linux' in platform:\n    pass\nelif 'win' in platform:\n    for widget in widgets:\n        widget.setModal(value)\n        widget.hide()\n        widget.show()\nelif 'darwin' in platform:\n    pass\nelse:\n    pass\n",
        "CUT_3": "\"\"\" \"\"\"\nplatform = sys.platform.lower()\nif 'linux' in platform:\n    pass\nelif 'win' in platform:\n    for widget in widgets:\n        widget.setModal(value)\n        widget.hide()\n        widget.show()\nelif 'darwin' in platform:\n    pass\nelse:\n    pass\n",
        "CUT_4": "\"\"\"Override Qt method.\"\"\"\nevent.ignore()\nif sys.platform == 'darwin':\n    if event.reason() != Qt.ActiveWindowFocusReason:\n        self.hide()\nelse:\n    try:\n        self.hide()\n    except RuntimeError:\n        pass\n",
        "CUT_5": "\"\"\"Override Qt method.\"\"\"\nevent.ignore()\nif sys.platform == 'darwin':\n    if event.reason() != Qt.ActiveWindowFocusReason:\n        self.hide()\nelse:\n    try:\n        self.hide()\n    except RuntimeError:\n        pass\n"
    },
    {
        "functionName": "test_update",
        "className": null,
        "fileName": "/spyder/workers/tests/test_update.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test we offer updates for lower versions.\"\"\"\nworker = WorkerUpdates(None, False, version='1.0.0')\nworker.start()\nassert worker.update_available\npytest.mark.slow",
        "CUT_1": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_2": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_3": "\"\"\"Create a new process worker instance.\"\"\"\nworker = ProcessWorker(cmd_list, environ=environ)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_4": "\"\"\"Create a new process worker instance.\"\"\"\nworker = ProcessWorker(cmd_list, environ=environ)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_5": "\"\"\"Common worker setup.\"\"\"\nworker.sig_started.connect(self._start)\nself._workers.append(worker)\n"
    },
    {
        "functionName": "test_no_update",
        "className": null,
        "fileName": "/spyder/workers/tests/test_update.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test we don't offer updates for very high versions.\"\"\"\nworker = WorkerUpdates(None, False, version='1000.0.0')\nworker.start()\nassert not worker.update_available\npytest.mark.slow",
        "CUT_1": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_2": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_3": "\"\"\"Create a new process worker instance.\"\"\"\nworker = ProcessWorker(cmd_list, environ=environ)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_4": "\"\"\"Create a new process worker instance.\"\"\"\nworker = ProcessWorker(cmd_list, environ=environ)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_5": "\"\"\"Common worker setup.\"\"\"\nworker.sig_started.connect(self._start)\nself._workers.append(worker)\n"
    },
    {
        "functionName": "test_no_update_development",
        "className": null,
        "fileName": "/spyder/workers/tests/test_update.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test we don't offer updates for development versions.\"\"\"\nworker = WorkerUpdates(None, False, version='3.3.2.dev0', releases=['3.3.1'])\nworker.start()\nassert not worker.update_available\npytest.mark.slow",
        "CUT_1": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_2": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_3": "\"\"\"Create a new process worker instance.\"\"\"\nworker = ProcessWorker(cmd_list, environ=environ)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_4": "\"\"\"Create a new process worker instance.\"\"\"\nworker = ProcessWorker(cmd_list, environ=environ)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_5": "\"\"\"Common worker setup.\"\"\"\nworker.sig_started.connect(self._start)\nself._workers.append(worker)\n"
    },
    {
        "functionName": "test_update_pre_to_pre",
        "className": null,
        "fileName": "/spyder/workers/tests/test_update.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test we offer updates between prereleases.\"\"\"\nworker = WorkerUpdates(None, False, version='4.0.0a1', releases=['4.0.0b5'])\nworker.start()\nassert worker.update_available\npytest.mark.slow",
        "CUT_1": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_2": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_3": "\"\"\"Create a new process worker instance.\"\"\"\nworker = ProcessWorker(cmd_list, environ=environ)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_4": "\"\"\"Create a new process worker instance.\"\"\"\nworker = ProcessWorker(cmd_list, environ=environ)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_5": "\"\"\"Common worker setup.\"\"\"\nworker.sig_started.connect(self._start)\nself._workers.append(worker)\n"
    },
    {
        "functionName": "test_update_pre_to_final",
        "className": null,
        "fileName": "/spyder/workers/tests/test_update.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test we offer updates from prereleases to the final versions.\"\"\"\nworker = WorkerUpdates(None, False, version='4.0.0b3', releases=['4.0.0'])\nworker.start()\nassert worker.update_available\npytest.mark.slow",
        "CUT_1": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_2": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_3": "\"\"\"Create a new process worker instance.\"\"\"\nworker = ProcessWorker(cmd_list, environ=environ)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_4": "\"\"\"Create a new process worker instance.\"\"\"\nworker = ProcessWorker(cmd_list, environ=environ)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_5": "\"\"\"Common worker setup.\"\"\"\nworker.sig_started.connect(self._start)\nself._workers.append(worker)\n"
    },
    {
        "functionName": "test_releases_anaconda",
        "className": null,
        "fileName": "/spyder/workers/tests/test_update.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test we don't include spyder-kernels releases in detected releases.\"\"\"\nworker = WorkerUpdates(None, False, version='3.3.1')\nworker.start()\nassert '0.2.4' not in worker.releases\npytest.mark.slowpytest.mark.skipif(not is_anaconda(), reason=\n    'It only makes sense for Anaconda.')",
        "CUT_1": "\"\"\"Checks if there is an update available.\n\n        It takes as parameters the current version of Spyder and a list of\n        valid cleaned releases in chronological order.\n        Example: ['2.3.2', '2.3.3' ...] or with github ['2.3.4', '2.3.3' ...]\n        \"\"\"\nif 'dev' in self.version:\n    return False, latest_release\nif is_stable_version(self.version):\n    releases = [r for r in self.releases if is_stable_version(r)]\nelse:\n    releases = [r for r in self.releases if not is_stable_version(r) or r in\n        self.version]\nlatest_release = releases[-1]\nreturn check_version(self.version, latest_release, '<'), latest_release\n",
        "CUT_2": "\"\"\"Checks if there is an update available.\n\n        It takes as parameters the current version of Spyder and a list of\n        valid cleaned releases in chronological order.\n        Example: ['2.3.2', '2.3.3' ...] or with github ['2.3.4', '2.3.3' ...]\n        \"\"\"\nif 'dev' in self.version:\n    return False, latest_release\nif is_stable_version(self.version):\n    releases = [r for r in self.releases if is_stable_version(r)]\nelse:\n    releases = [r for r in self.releases if not is_stable_version(r) or r in\n        self.version]\nlatest_release = releases[-1]\nreturn check_version(self.version, latest_release, '<'), latest_release\n",
        "CUT_3": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_4": "\"\"\"Create a new python worker instance.\"\"\"\nworker = PythonWorker(func, args, kwargs)\nself._create_worker(worker)\nreturn worker\n",
        "CUT_5": "\"\"\"Mark the worker as finished.\"\"\"\nself._is_finished = True\n"
    },
    {
        "functionName": "test_msgcheckbox",
        "className": null,
        "fileName": "/spyder/widgets/helperwidgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nbox = MessageCheckBox()\nbox.setWindowTitle(_('Spyder updates'))\nbox.setText('Testing checkbox')\nbox.set_checkbox_text('Check for updates on startup?')\nbox.setStandardButtons(QMessageBox.Ok)\nbox.setDefaultButton(QMessageBox.Ok)\nbox.setIcon(QMessageBox.Information)\nbox.exec_()\n",
        "CUT_1": "\"\"\"\n        Create a textbox field.\n        \"\"\"\nif default is not None and len(default) > 30:\n    box = QtWidgets.QTextEdit(parent=self)\n    box.setText = box.setPlainText\n    box.text = box.toPlainText\nelse:\n    box = QtWidgets.QLineEdit(parent=self)\nbox.setting = setting\nif default is not None:\n    box.setText(default)\n    box.textChanged.connect(lambda x=None: self.render())\nbox.get_value = lambda : box.text()\nbox.set_value = lambda text: box.setText(text)\nreturn box\n",
        "CUT_2": "\"\"\"\n        Create a textbox field.\n        \"\"\"\nif default is not None and len(default) > 30:\n    box = QtWidgets.QTextEdit(parent=self)\n    box.setText = box.setPlainText\n    box.text = box.toPlainText\nelse:\n    box = QtWidgets.QLineEdit(parent=self)\nbox.setting = setting\nif default is not None:\n    box.setText(default)\n    box.textChanged.connect(lambda x=None: self.render())\nbox.get_value = lambda : box.text()\nbox.set_value = lambda text: box.setText(text)\nreturn box\n",
        "CUT_3": "\"\"\"Called by WorkerUpdates when ready\"\"\"\nfrom spyder.widgets.helperwidgets import MessageCheckBox\nfeedback = self.give_updates_feedback\nupdate_available = self.worker_updates.update_available\nlatest_release = self.worker_updates.latest_release\nerror_msg = self.worker_updates.error\nurl_r = __project_url__ + '/releases/tag/v{}'.format(latest_release)\nurl_i = 'https://docs.spyder-ide.org/installation.html'\nbox = MessageCheckBox(icon=QMessageBox.Information, parent=self)\nbox.setWindowTitle(_('New Spyder version'))\nbox.set_checkbox_text(_('Check for updates at startup'))\nbox.setStandardButtons(QMessageBox.Ok)\nbox.setDefaultButton(QMessageBox.Ok)\nsection, option = 'main', 'check_updates_on_startup'\ncheck_updates = CONF.get(section, option)\nbox.set_checked(check_updates)\nif error_msg is not None:\n    msg = error_msg\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nelif update_available:\n    header = _('<b>Spyder {} is available!</b><br><br>').format(latest_release)\n    footer = _(\n        'For more information visit our <a href=\"{}\">installation guide</a>.'\n        ).format(url_i)\n    if is_anaconda():\n        content = _(\n            \"<b>Important note:</b> Since you installed Spyder with Anaconda, please <b>don't</b> use <code>pip</code> to update it as that will break your installation.<br><br>Instead, run the following commands in a terminal:<br><code>conda update anaconda</code><br><code>conda install spyder={}</code><br><br>\"\n            ).format(latest_release)\n    else:\n        content = _(\n            'Please go to <a href=\"{}\">this page</a> to download it.<br><br>'\n            ).format(url_r)\n    msg = header + content + footer\n    box.setText(msg)\n    box.set_check_visible(True)\n    box.exec_()\n    check_updates = box.is_checked()\nelif feedback:\n    msg = _('Spyder is up to date.')\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nCONF.set(section, option, check_updates)\nself.check_updates_action.setDisabled(False)\nself.give_updates_feedback = True\n",
        "CUT_4": "\"\"\"Called by WorkerUpdates when ready\"\"\"\nfrom spyder.widgets.helperwidgets import MessageCheckBox\nfeedback = self.give_updates_feedback\nupdate_available = self.worker_updates.update_available\nlatest_release = self.worker_updates.latest_release\nerror_msg = self.worker_updates.error\nurl_r = __project_url__ + '/releases/tag/v{}'.format(latest_release)\nurl_i = 'https://docs.spyder-ide.org/installation.html'\nbox = MessageCheckBox(icon=QMessageBox.Information, parent=self)\nbox.setWindowTitle(_('New Spyder version'))\nbox.set_checkbox_text(_('Check for updates at startup'))\nbox.setStandardButtons(QMessageBox.Ok)\nbox.setDefaultButton(QMessageBox.Ok)\nsection, option = 'main', 'check_updates_on_startup'\ncheck_updates = CONF.get(section, option)\nbox.set_checked(check_updates)\nif error_msg is not None:\n    msg = error_msg\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nelif update_available:\n    header = _('<b>Spyder {} is available!</b><br><br>').format(latest_release)\n    footer = _(\n        'For more information visit our <a href=\"{}\">installation guide</a>.'\n        ).format(url_i)\n    if is_anaconda():\n        content = _(\n            \"<b>Important note:</b> Since you installed Spyder with Anaconda, please <b>don't</b> use <code>pip</code> to update it as that will break your installation.<br><br>Instead, run the following commands in a terminal:<br><code>conda update anaconda</code><br><code>conda install spyder={}</code><br><br>\"\n            ).format(latest_release)\n    else:\n        content = _(\n            'Please go to <a href=\"{}\">this page</a> to download it.<br><br>'\n            ).format(url_r)\n    msg = header + content + footer\n    box.setText(msg)\n    box.set_check_visible(True)\n    box.exec_()\n    check_updates = box.is_checked()\nelif feedback:\n    msg = _('Spyder is up to date.')\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nCONF.set(section, option, check_updates)\nself.check_updates_action.setDisabled(False)\nself.give_updates_feedback = True\n",
        "CUT_5": "\"\"\"\n        Report that either the transport layer or the LSP server are\n        down.\n        \"\"\"\nself.update_status(language, ClientStatus.DOWN)\nif not self.get_option('show_lsp_down_warning'):\n    return\nif os.name == 'nt':\n    os_message = (\n        'To try to fix this, please verify that your firewall or antivirus allows Python processes to open ports in your system, or restart Spyder.<br><br>'\n        )\nelse:\n    os_message = 'This problem could be fixed by restarting Spyder. '\nwarn_str = _(\n    'Completion and linting in the editor for {language} files will not work during the current session, or stopped working.<br><br>'\n    ).format(language=language.capitalize()) + os_message + _(\n    'Do you want to restart Spyder now?')\nbox = MessageCheckBox(icon=QMessageBox.Warning, parent=self.main)\nbox.setWindowTitle(_('Warning'))\nbox.set_checkbox_text(_(\"Don't show again\"))\nbox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\nbox.setDefaultButton(QMessageBox.No)\nbox.set_checked(False)\nbox.set_check_visible(True)\nbox.setText(warn_str)\nanswer = box.exec_()\nself.set_option('show_lsp_down_warning', not box.is_checked())\nif answer == QMessageBox.Yes:\n    self.main.restart()\nSlot(str)"
    },
    {
        "functionName": "error_dialog",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_reporterror.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up error report dialog.\"\"\"\nwidget = SpyderErrorDialog(None)\nqtbot.addWidget(widget)\nwidget.show()\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_dialog",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_reporterror.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that error report dialog UI behaves properly.\"\"\"\ndlg = error_dialog\ndesc_text = '1' * DESC_MIN_CHARS\ntitle_text = '1' * TITLE_MIN_CHARS\nassert not dlg.submit_btn.isEnabled()\nqtbot.keyClicks(dlg.input_description, desc_text)\nqtbot.keyClicks(dlg.title, title_text)\nassert dlg.submit_btn.isEnabled()\ndlg.input_description.selectAll()\ndlg.input_description.cut()\nassert dlg.input_description.toPlainText() == dlg.input_description.header\nqtbot.keyClicks(dlg.input_description, desc_text)\ndlg.input_description.selectAll()\ndlg.input_description.delete()\nassert dlg.input_description.toPlainText() == dlg.input_description.header\nini_pos = dlg.input_description.get_position('sof')\ndlg.input_description.set_cursor_position(ini_pos)\ndlg.input_description.delete()\nassert dlg.input_description.toPlainText() == dlg.input_description.header\nqtbot.keyClicks(dlg.input_description, desc_text)\nqtbot.keyPress(dlg.input_description, Qt.Key_Backspace)\nassert not dlg.submit_btn.isEnabled()\ndlg.input_description.selectAll()\nqtbot.keyPress(dlg.input_description, Qt.Key_Backspace)\nassert dlg.input_description.toPlainText() == dlg.input_description.header\nini_pos = dlg.input_description.get_position('sof')\ndlg.input_description.set_cursor_position(ini_pos)\ndlg.input_description.set_cursor_position('eol')\nqtbot.keyPress(dlg.input_description, Qt.Key_Backspace)\nassert dlg.input_description.toPlainText() == dlg.input_description.header\nassert dlg.desc_chars_label.text() == '{} more characters to go...'.format(\n    DESC_MIN_CHARS)\nqtbot.keyClicks(dlg.input_description, desc_text)\nassert dlg.desc_chars_label.text() == 'Description complete; thanks!'\n",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_3": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n"
    },
    {
        "functionName": "test_report_issue_url",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_reporterror.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that report_issue sends the data, and to correct url.\"\"\"\nbody = 'This is an example error report body text.'\ntitle = 'Uncreative issue title here'\ntarget_url_base = __project_url__ + '/issues/new'\nMockQDesktopServices = MagicMock()\nmockQDesktopServices_instance = MockQDesktopServices()\nattr_to_patch = 'spyder.widgets.reporterror.QDesktopServices'\nmonkeypatch.setattr(attr_to_patch, MockQDesktopServices)\ntarget_url = QUrl(target_url_base + '?body=' + body)\nSpyderErrorDialog.open_web_report(body=body, title=None)\nassert MockQDesktopServices.openUrl.call_count == 1\nmockQDesktopServices_instance.openUrl.called_with(target_url)\ntarget_url = QUrl(target_url_base + '?body=' + body + '&title=' + title)\nSpyderErrorDialog.open_web_report(body=body, title=None)\nassert MockQDesktopServices.openUrl.call_count == 2\nmockQDesktopServices_instance.openUrl.called_with(target_url)\n",
        "CUT_1": "\"\"\"\n        Open a new issue on Github with prefilled information.\n\n        Parameters\n        ----------\n        body: str\n            The body content of the report.\n        title: str or None, optional\n            The title of the report. Default is None.\n        \"\"\"\nurl = QUrl(__project_url__ + '/issues/new')\nquery = QUrlQuery()\nquery.addQueryItem('body', quote(body))\nif title:\n    query.addQueryItem('title', quote(title))\nurl.setQuery(query)\nQDesktopServices.openUrl(url)\nstaticmethod",
        "CUT_2": "\"\"\"\n        Open a new issue on Github with prefilled information.\n\n        Parameters\n        ----------\n        body: str\n            The body content of the report.\n        title: str or None, optional\n            The title of the report. Default is None.\n        \"\"\"\nurl = QUrl(__project_url__ + '/issues/new')\nquery = QUrlQuery()\nquery.addQueryItem('body', quote(body))\nif title:\n    query.addQueryItem('title', quote(title))\nurl.setQuery(query)\nQDesktopServices.openUrl(url)\nstaticmethod",
        "CUT_3": "body = stack[skip]\nchildren = [body]\nif hasattr(body, 'children'):\n    children = body.children\nstack = stack[:skip] + children + stack[skip + 1:]\nnode = body\nend_line, _ = body.end_pos\nreturn node, end_line\n",
        "CUT_4": "while True:\n    with self.mutex:\n        if self.stopped:\n            logger.debug('Stopping Thread...')\n            break\n    try:\n        body = self.read_incoming()\n        err = False\n        try:\n            body = json.loads(body)\n        except (ValueError, TypeError) as e:\n            err = True\n            logger.error(e)\n        if not err:\n            logger.debug(body)\n            self.zmq_sock.send_pyobj(body)\n            logger.debug('Message sent')\n    except socket.error as e:\n        logger.error(e)\nlogger.debug('Thread stopped.')\n",
        "CUT_5": "while True:\n    with self.mutex:\n        if self.stopped:\n            logger.debug('Stopping Thread...')\n            break\n    try:\n        body = self.read_incoming()\n        err = False\n        try:\n            body = json.loads(body)\n        except (ValueError, TypeError) as e:\n            err = True\n            logger.error(e)\n        if not err:\n            logger.debug(body)\n            self.zmq_sock.send_pyobj(body)\n            logger.debug('Message sent')\n    except socket.error as e:\n        logger.error(e)\nlogger.debug('Thread stopped.')\n"
    },
    {
        "functionName": "test_render_issue",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_reporterror.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that render issue works without errors and returns text.\"\"\"\ntest_description = 'This is a test description'\ntest_traceback = 'An error occurred. Oh no!'\ntest_issue_1 = SpyderErrorDialog.render_issue()\nassert type(test_issue_1) == str\nassert len(test_issue_1) > 100\ntest_issue_2 = SpyderErrorDialog.render_issue(test_description, test_traceback)\nassert type(test_issue_2) == str\nassert len(test_issue_2) > 100\nassert test_description in test_issue_2\nassert test_traceback in test_issue_2\n",
        "CUT_1": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_4": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_5": "\"\"\"Report a Spyder issue to github.\"\"\"\nfrom spyder.widgets.reporterror import SpyderErrorDialog\nself._report_dlg = SpyderErrorDialog(self, is_report=True)\nself._report_dlg.set_color_scheme(CONF.get('appearance', 'selected'))\nself._report_dlg.show()\nSlot()"
    },
    {
        "functionName": "botinline",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "dialog = ArrayBuilderDialog(inline=True)\nqtbot.addWidget(dialog)\ndialog.show()\nreturn qtbot, dialog, dialog.array_widget\npytest.fixture",
        "CUT_1": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_3": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_4": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_5": "\"\"\"\n        Set maximum amount of results to add to the result browser.\n\n        Parameters\n        ----------\n        value: int, optional\n            Number of results. If None an input dialog will be used.\n            Default is None.\n        \"\"\"\nif value is None:\n    dialog = QInputDialog(self)\n    dialog.setModal(False)\n    dialog.setWindowTitle(self.get_name())\n    dialog.setLabelText(_('Set maximum number of results: '))\n    dialog.setInputMode(QInputDialog.IntInput)\n    dialog.setIntRange(1, 10000)\n    dialog.setIntStep(1)\n    dialog.setIntValue(self.get_option('max_results'))\n    dialog.intValueSelected.connect(lambda value: self.set_option(\n        'max_results', value))\n    dialog.show()\nelse:\n    self.set_option('max_results', value)\n"
    },
    {
        "functionName": "botinlinefloat",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "dialog = ArrayBuilderDialog(inline=True, force_float=True)\nqtbot.addWidget(dialog)\ndialog.show()\nreturn qtbot, dialog, dialog.array_widget\npytest.fixture",
        "CUT_1": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_3": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_4": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_5": "\"\"\"\n        Set maximum amount of results to add to the result browser.\n\n        Parameters\n        ----------\n        value: int, optional\n            Number of results. If None an input dialog will be used.\n            Default is None.\n        \"\"\"\nif value is None:\n    dialog = QInputDialog(self)\n    dialog.setModal(False)\n    dialog.setWindowTitle(self.get_name())\n    dialog.setLabelText(_('Set maximum number of results: '))\n    dialog.setInputMode(QInputDialog.IntInput)\n    dialog.setIntRange(1, 10000)\n    dialog.setIntStep(1)\n    dialog.setIntValue(self.get_option('max_results'))\n    dialog.intValueSelected.connect(lambda value: self.set_option(\n        'max_results', value))\n    dialog.show()\nelse:\n    self.set_option('max_results', value)\n"
    },
    {
        "functionName": "botarray",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "dialog = ArrayBuilderDialog(inline=False)\nqtbot.addWidget(dialog)\ndialog.show()\nreturn qtbot, dialog, dialog.array_widget\npytest.fixture",
        "CUT_1": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_3": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_4": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_5": "\"\"\"\n        Set maximum amount of results to add to the result browser.\n\n        Parameters\n        ----------\n        value: int, optional\n            Number of results. If None an input dialog will be used.\n            Default is None.\n        \"\"\"\nif value is None:\n    dialog = QInputDialog(self)\n    dialog.setModal(False)\n    dialog.setWindowTitle(self.get_name())\n    dialog.setLabelText(_('Set maximum number of results: '))\n    dialog.setInputMode(QInputDialog.IntInput)\n    dialog.setIntRange(1, 10000)\n    dialog.setIntStep(1)\n    dialog.setIntValue(self.get_option('max_results'))\n    dialog.intValueSelected.connect(lambda value: self.set_option(\n        'max_results', value))\n    dialog.show()\nelse:\n    self.set_option('max_results', value)\n"
    },
    {
        "functionName": "test_array_inline_array",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botinline\nqtbot.keyClicks(widget, '1 2 3  4 5 6')\nqtbot.keyPress(widget, Qt.Key_Return)\nvalue = dialog.text()\nassert value == \"\"\"np.array([[1, 2, 3],\n          [4, 5, 6]])\"\"\"\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_array_inline_matrix",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botinline\nqtbot.keyClicks(widget, '4 5 6  7 8 9')\nqtbot.keyPress(widget, Qt.Key_Return, modifier=Qt.ControlModifier)\nvalue = dialog.text()\nassert value == \"\"\"np.matrix([[4, 5, 6],\n           [7, 8, 9]])\"\"\"\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_array_inline_array_invalid",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botinline\nqtbot.keyClicks(widget, '1 2  3 4  5 6 7')\nqtbot.keyPress(widget, Qt.Key_Return)\ndialog.update_warning()\nassert not dialog.is_valid()\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_3": "\"\"\"Change history max entries.\"\"\"\ndialog.setWindowTitle(_('History'))\ndialog.setLabelText(_('Maximum entries'))\ndialog.setInputMode(QInputDialog.IntInput)\ndialog.setIntRange(MIN_HISTORY_ENTRIES, MAX_HISTORY_ENTRIES)\ndialog.setIntStep(1)\ndialog.setIntValue(self.get_option('max_entries'))\ndialog.intValueSelected.connect(lambda value: self.set_history_limit(value))\ndialog.show()\nSlot()",
        "CUT_4": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n",
        "CUT_5": "self.dialogs[id(dialog)] = dialog, refname, func\ndialog.accepted.connect(lambda eid=id(dialog): self.editor_accepted(eid))\ndialog.rejected.connect(lambda eid=id(dialog): self.editor_rejected(eid))\ndialog.show()\ndialog.activateWindow()\ndialog.raise_()\n"
    },
    {
        "functionName": "test_array_inline_1d_array",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botinline\nqtbot.keyClicks(widget, '4 5 6')\nqtbot.keyPress(widget, Qt.Key_Return, modifier=Qt.ControlModifier)\nvalue = dialog.text()\nassert value == 'np.matrix([4, 5, 6])'\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_array_inline_nan_array",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botinline\nqtbot.keyClicks(widget, '4 nan 6 8 9')\nqtbot.keyPress(widget, Qt.Key_Return, modifier=Qt.ControlModifier)\nvalue = dialog.text()\nassert value == 'np.matrix([4, np.nan, 6, 8, 9])'\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_3": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "test_array_inline_inf_array",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botinline\nqtbot.keyClicks(widget, '4 inf 6 8 9')\nqtbot.keyPress(widget, Qt.Key_Return, modifier=Qt.ControlModifier)\nvalue = dialog.text()\nassert value == 'np.matrix([4, np.inf, 6, 8, 9])'\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_3": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "test_array_inline_force_float_array",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botinlinefloat\nqtbot.keyClicks(widget, '4 5 6 8 9')\nqtbot.keyPress(widget, Qt.Key_Return, modifier=Qt.ControlModifier)\nvalue = dialog.text()\nassert value == 'np.matrix([4.0, 5.0, 6.0, 8.0, 9.0])'\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_array_inline_force_float_error_array",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botinlinefloat\nqtbot.keyClicks(widget, '4 5 6 a 9')\nqtbot.keyPress(widget, Qt.Key_Return, modifier=Qt.ControlModifier)\nvalue = dialog.text()\nassert value == 'np.matrix([4.0, 5.0, 6.0, a, 9.0])'\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_array_table_array",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botarray\nqtbot.keyClick(widget, Qt.Key_1)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_2)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_Backtab)\nqtbot.keyClick(widget, Qt.Key_3)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_4)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_5)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_6)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_Return, modifier=Qt.NoModifier)\nvalue = dialog.text()\nassert value == \"\"\"np.array([[1, 2, 3],\n          [4, 5, 6]])\"\"\"\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "test_array_table_matrix",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botarray\nqtbot.keyClick(widget, Qt.Key_1)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_2)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_Backtab)\nqtbot.keyClick(widget, Qt.Key_3)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_4)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_5)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_6)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_Return, modifier=Qt.ControlModifier)\nvalue = dialog.text()\nassert value == \"\"\"np.matrix([[1, 2, 3],\n           [4, 5, 6]])\"\"\"\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "test_array_table_array_empty_items",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botarray\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_2)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_Backtab)\nqtbot.keyClick(widget, Qt.Key_3)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_5)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_6)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_Return, modifier=Qt.NoModifier)\nvalue = dialog.text()\nassert value == \"\"\"np.array([[0, 2, 3],\n          [0, 5, 6]])\"\"\"\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "test_array_table_array_spaces_in_item",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botarray\nqtbot.keyClicks(widget, '   ')\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_2)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_Backtab)\nqtbot.keyClick(widget, Qt.Key_3)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_5)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_6)\nqtbot.keyClick(widget, Qt.Key_Tab)\nqtbot.keyClick(widget, Qt.Key_Return, modifier=Qt.NoModifier)\nvalue = dialog.text()\nassert value == \"\"\"np.array([[0, 2, 3],\n          [0, 5, 6]])\"\"\"\n",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_3": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "test_array_table_matrix_empty",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_array_builder.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, dialog, widget = botarray\nqtbot.keyClick(widget, Qt.Key_Return, modifier=Qt.NoModifier)\nvalue = dialog.text()\nassert value == ''\npytest.mark.skipif(sys.platform == 'darwin', reason='It fails on macOS')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"\n        Set maximum amount of results to add to the result browser.\n\n        Parameters\n        ----------\n        value: int, optional\n            Number of results. If None an input dialog will be used.\n            Default is None.\n        \"\"\"\nif value is None:\n    dialog = QInputDialog(self)\n    dialog.setModal(False)\n    dialog.setWindowTitle(self.get_name())\n    dialog.setLabelText(_('Set maximum number of results: '))\n    dialog.setInputMode(QInputDialog.IntInput)\n    dialog.setIntRange(1, 10000)\n    dialog.setIntStep(1)\n    dialog.setIntValue(self.get_option('max_results'))\n    dialog.intValueSelected.connect(lambda value: self.set_option(\n        'max_results', value))\n    dialog.show()\nelse:\n    self.set_option('max_results', value)\n",
        "CUT_3": "\"\"\"\n        Set maximum amount of results to add to the result browser.\n\n        Parameters\n        ----------\n        value: int, optional\n            Number of results. If None an input dialog will be used.\n            Default is None.\n        \"\"\"\nif value is None:\n    dialog = QInputDialog(self)\n    dialog.setModal(False)\n    dialog.setWindowTitle(self.get_name())\n    dialog.setLabelText(_('Set maximum number of results: '))\n    dialog.setInputMode(QInputDialog.IntInput)\n    dialog.setIntRange(1, 10000)\n    dialog.setIntStep(1)\n    dialog.setIntValue(self.get_option('max_results'))\n    dialog.intValueSelected.connect(lambda value: self.set_option(\n        'max_results', value))\n    dialog.show()\nelse:\n    self.set_option('max_results', value)\n",
        "CUT_4": "\"\"\" \"\"\"\nplatform = sys.platform.lower()\nif 'linux' in platform:\n    pass\nelif 'win' in platform:\n    for widget in widgets:\n        widget.setModal(value)\n        widget.hide()\n        widget.show()\nelif 'darwin' in platform:\n    pass\nelse:\n    pass\n",
        "CUT_5": "\"\"\" \"\"\"\nplatform = sys.platform.lower()\nif 'linux' in platform:\n    pass\nelif 'win' in platform:\n    for widget in widgets:\n        widget.setModal(value)\n        widget.hide()\n        widget.show()\nelif 'darwin' in platform:\n    pass\nelse:\n    pass\n"
    },
    {
        "functionName": "dependencies_dialog",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_dependencies.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up dependency widget test.\"\"\"\nwidget = DependenciesDialog(None)\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_dependencies",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_dependencies.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run dependency widget test.\"\"\"\ndependencies.add('zmq', 'zmq', 'Run introspection services', '>=10.0')\ndependencies.add('foo', 'foo', 'Non-existent module', '>=1.0')\ndependencies.add('bar', 'bar', 'Non-existing optional module', '>=10.0',\n    kind=dependencies.OPTIONAL)\ndependencies_dialog.set_data(dependencies.DEPENDENCIES)\ndependencies_dialog.show()\nassert dependencies_dialog\n",
        "CUT_1": "\"\"\"Run dependency widget test\"\"\"\nfrom spyder import dependencies\ndependencies.add('IPython', 'IPython', 'Enhanced Python interpreter', '>=20.0')\ndependencies.add('matplotlib', 'matplotlib', 'Interactive data plotting',\n    '>=1.0')\ndependencies.add('sympy', 'sympy', 'Symbolic Mathematics', '>=10.0', kind=\n    OPTIONAL)\ndependencies.add('foo', 'foo', 'Non-existent module', '>=1.0')\ndependencies.add('numpy', 'numpy', 'Edit arrays in Variable Explorer',\n    '>=0.10', kind=OPTIONAL)\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DependenciesDialog(None)\ndlg.set_data(dependencies.DEPENDENCIES)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_2": "\"\"\"Run dependency widget test\"\"\"\nfrom spyder import dependencies\ndependencies.add('IPython', 'IPython', 'Enhanced Python interpreter', '>=20.0')\ndependencies.add('matplotlib', 'matplotlib', 'Interactive data plotting',\n    '>=1.0')\ndependencies.add('sympy', 'sympy', 'Symbolic Mathematics', '>=10.0', kind=\n    OPTIONAL)\ndependencies.add('foo', 'foo', 'Non-existent module', '>=1.0')\ndependencies.add('numpy', 'numpy', 'Edit arrays in Variable Explorer',\n    '>=0.10', kind=OPTIONAL)\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DependenciesDialog(None)\ndlg.set_data(dependencies.DEPENDENCIES)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_3": "\"\"\"Show Spyder's Dependencies dialog box\"\"\"\nfrom spyder.widgets.dependencies import DependenciesDialog\ndlg = DependenciesDialog(self)\ndlg.set_data(dependencies.DEPENDENCIES)\ndlg.show()\nSlot()",
        "CUT_4": "\"\"\"Show Spyder's Dependencies dialog box\"\"\"\nfrom spyder.widgets.dependencies import DependenciesDialog\ndlg = DependenciesDialog(self)\ndlg.set_data(dependencies.DEPENDENCIES)\ndlg.show()\nSlot()",
        "CUT_5": "\"\"\"Add Spyder dependency\"\"\"\nglobal DEPENDENCIES\nfor dependency in DEPENDENCIES:\n    if dependency.modname == modname:\n        raise ValueError('Dependency has already been registered: %s' % modname\n            )\nDEPENDENCIES += [Dependency(modname, package_name, features,\n    required_version, installed_version, kind)]\n"
    },
    {
        "functionName": "dlg_switcher",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_switcher.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up switcher widget.\"\"\"\nfrom spyder.widgets.switcher import Switcher, create_options_example_switcher, create_help_example_switcher, create_line_example_switcher, create_symbol_example_switcher, create_vcs_example_switcher\ndlg_switcher = Switcher(None, item_styles=None, item_separator_styles=None)\ndlg_switcher.add_mode('>', _('Commands'))\ndlg_switcher.add_mode('?', _('Help'))\ndlg_switcher.add_mode(':', _('Go to Line'))\ndlg_switcher.add_mode('@', _('Go to Symbol in File'))\ndef handle_modes(mode):\n    if mode == '>':\n        create_options_example_switcher(dlg_switcher)\n    elif mode == '?':\n        create_help_example_switcher(dlg_switcher)\n    elif mode == ':':\n        create_line_example_switcher(dlg_switcher)\n    elif mode == '@':\n        create_symbol_example_switcher(dlg_switcher)\n    elif mode == '':\n        create_vcs_example_switcher(dlg_switcher)\ndef item_selected(item, mode, search_text):\n    print([item, mode, search_text])\n    print([item.get_title(), mode, search_text])\ndlg_switcher.sig_mode_selected.connect(handle_modes)\ndlg_switcher.sig_item_selected.connect(item_selected)\nqtbot.addWidget(dlg_switcher)\ncreate_vcs_example_switcher(dlg_switcher)\nreturn dlg_switcher\npytest.fixture",
        "CUT_1": "\"\"\"Create example switcher.\"\"\"\nif main is None:\n    main = QLineEdit()\nsw = Switcher(main)\nsw.add_mode('>', _('Commands'))\nsw.add_mode('?', _('Help'))\nsw.add_mode(':', _('Go to Line'))\nsw.add_mode('@', _('Go to Symbol in File'))\ndef handle_modes(mode):\n    if mode == '>':\n        create_options_example_switcher(sw)\n    elif mode == '?':\n        create_help_example_switcher(sw)\n    elif mode == ':':\n        create_line_example_switcher(sw)\n    elif mode == '@':\n        create_symbol_example_switcher(sw)\n    elif mode == '':\n        create_vcs_example_switcher(sw)\ndef item_selected(item, mode, search_text):\n    print([item, mode, search_text])\n    print([item.get_title(), mode, search_text])\nsw.sig_mode_selected.connect(handle_modes)\nsw.sig_item_selected.connect(item_selected)\ncreate_vcs_example_switcher(sw)\nsw.show()\n",
        "CUT_2": "\"\"\"Create example switcher.\"\"\"\nif main is None:\n    main = QLineEdit()\nsw = Switcher(main)\nsw.add_mode('>', _('Commands'))\nsw.add_mode('?', _('Help'))\nsw.add_mode(':', _('Go to Line'))\nsw.add_mode('@', _('Go to Symbol in File'))\ndef handle_modes(mode):\n    if mode == '>':\n        create_options_example_switcher(sw)\n    elif mode == '?':\n        create_help_example_switcher(sw)\n    elif mode == ':':\n        create_line_example_switcher(sw)\n    elif mode == '@':\n        create_symbol_example_switcher(sw)\n    elif mode == '':\n        create_vcs_example_switcher(sw)\ndef item_selected(item, mode, search_text):\n    print([item, mode, search_text])\n    print([item.get_title(), mode, search_text])\nsw.sig_mode_selected.connect(handle_modes)\nsw.sig_item_selected.connect(item_selected)\ncreate_vcs_example_switcher(sw)\nsw.show()\n",
        "CUT_3": "if mode == '>':\n    create_options_example_switcher(sw)\nelif mode == '?':\n    create_help_example_switcher(sw)\nelif mode == ':':\n    create_line_example_switcher(sw)\nelif mode == '@':\n    create_symbol_example_switcher(sw)\nelif mode == '':\n    create_vcs_example_switcher(sw)\n",
        "CUT_4": "if mode == '>':\n    create_options_example_switcher(sw)\nelif mode == '?':\n    create_help_example_switcher(sw)\nelif mode == ':':\n    create_line_example_switcher(sw)\nelif mode == '@':\n    create_symbol_example_switcher(sw)\nelif mode == '':\n    create_vcs_example_switcher(sw)\n",
        "CUT_5": "print([item, mode, search_text])\nprint([item.get_title(), mode, search_text])\n"
    },
    {
        "functionName": "handle_modes",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_switcher.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if mode == '>':\n    create_options_example_switcher(dlg_switcher)\nelif mode == '?':\n    create_help_example_switcher(dlg_switcher)\nelif mode == ':':\n    create_line_example_switcher(dlg_switcher)\nelif mode == '@':\n    create_symbol_example_switcher(dlg_switcher)\nelif mode == '':\n    create_vcs_example_switcher(dlg_switcher)\n",
        "CUT_1": "if mode == '>':\n    create_options_example_switcher(sw)\nelif mode == '?':\n    create_help_example_switcher(sw)\nelif mode == ':':\n    create_line_example_switcher(sw)\nelif mode == '@':\n    create_symbol_example_switcher(sw)\nelif mode == '':\n    create_vcs_example_switcher(sw)\n",
        "CUT_2": "if mode == '>':\n    create_options_example_switcher(sw)\nelif mode == '?':\n    create_help_example_switcher(sw)\nelif mode == ':':\n    create_line_example_switcher(sw)\nelif mode == '@':\n    create_symbol_example_switcher(sw)\nelif mode == '':\n    create_vcs_example_switcher(sw)\n",
        "CUT_3": "\"\"\"Handle switcher for registered modes.\"\"\"\nif mode == self.SYMBOL_MODE:\n    self.create_symbol_switcher()\nelif mode == self.LINE_MODE:\n    self.create_line_switcher()\nelif mode == self.FILES_MODE:\n    self.create_editor_switcher()\n",
        "CUT_4": "\"\"\"Handle switcher for registered modes.\"\"\"\nif mode == self.SYMBOL_MODE:\n    self.create_symbol_switcher()\nelif mode == self.LINE_MODE:\n    self.create_line_switcher()\nelif mode == self.FILES_MODE:\n    self.create_editor_switcher()\n",
        "CUT_5": "\"\"\"Create example switcher.\"\"\"\nif main is None:\n    main = QLineEdit()\nsw = Switcher(main)\nsw.add_mode('>', _('Commands'))\nsw.add_mode('?', _('Help'))\nsw.add_mode(':', _('Go to Line'))\nsw.add_mode('@', _('Go to Symbol in File'))\ndef handle_modes(mode):\n    if mode == '>':\n        create_options_example_switcher(sw)\n    elif mode == '?':\n        create_help_example_switcher(sw)\n    elif mode == ':':\n        create_line_example_switcher(sw)\n    elif mode == '@':\n        create_symbol_example_switcher(sw)\n    elif mode == '':\n        create_vcs_example_switcher(sw)\ndef item_selected(item, mode, search_text):\n    print([item, mode, search_text])\n    print([item.get_title(), mode, search_text])\nsw.sig_mode_selected.connect(handle_modes)\nsw.sig_item_selected.connect(item_selected)\ncreate_vcs_example_switcher(sw)\nsw.show()\n"
    },
    {
        "functionName": "item_selected",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_switcher.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "print([item, mode, search_text])\nprint([item.get_title(), mode, search_text])\n",
        "CUT_1": "print([item, mode, search_text])\nprint([item.get_title(), mode, search_text])\n",
        "CUT_2": "print([item, mode, search_text])\nprint([item.get_title(), mode, search_text])\n",
        "CUT_3": "\"\"\"Set-up list widget content based on the filtering.\"\"\"\nmode = self._mode_on\nif mode:\n    search_text = self.search_text()[len(mode):]\nelse:\n    search_text = self.search_text()\nif self.search_text() == '':\n    self._mode_on = ''\n    self.clear()\n    self.proxy.set_filter_by_score(False)\n    self.sig_mode_selected.emit(self._mode_on)\n    return\nfor key in self._modes:\n    if self.search_text().startswith(key) and not mode:\n        self._mode_on = key\n        self.sig_mode_selected.emit(key)\n        return\ntitles = []\nfor row in range(self.model.rowCount()):\n    item = self.model.item(row)\n    if isinstance(item, SwitcherItem):\n        title = item.get_title()\n    else:\n        title = ''\n    titles.append(title)\nsearch_text = clean_string(search_text)\nscores = get_search_scores(to_text_string(search_text), titles, template=\n    '<b>{0}</b>')\nfor idx, (title, rich_title, score_value) in enumerate(scores):\n    item = self.model.item(idx)\n    if not self._is_separator(item) and not item.is_action_item():\n        rich_title = rich_title.replace(' ', '&nbsp;')\n        item.set_rich_title(rich_title)\n    item.set_score(score_value)\nself.proxy.set_filter_by_score(True)\nself.setup_sections()\nif self.count():\n    self.set_current_row(0)\nelse:\n    self.set_current_row(-1)\nself.set_height()\n",
        "CUT_4": "\"\"\"Set-up list widget content based on the filtering.\"\"\"\nmode = self._mode_on\nif mode:\n    search_text = self.search_text()[len(mode):]\nelse:\n    search_text = self.search_text()\nif self.search_text() == '':\n    self._mode_on = ''\n    self.clear()\n    self.proxy.set_filter_by_score(False)\n    self.sig_mode_selected.emit(self._mode_on)\n    return\nfor key in self._modes:\n    if self.search_text().startswith(key) and not mode:\n        self._mode_on = key\n        self.sig_mode_selected.emit(key)\n        return\ntitles = []\nfor row in range(self.model.rowCount()):\n    item = self.model.item(row)\n    if isinstance(item, SwitcherItem):\n        title = item.get_title()\n    else:\n        title = ''\n    titles.append(title)\nsearch_text = clean_string(search_text)\nscores = get_search_scores(to_text_string(search_text), titles, template=\n    '<b>{0}</b>')\nfor idx, (title, rich_title, score_value) in enumerate(scores):\n    item = self.model.item(idx)\n    if not self._is_separator(item) and not item.is_action_item():\n        rich_title = rich_title.replace(' ', '&nbsp;')\n        item.set_rich_title(rich_title)\n    item.set_score(score_value)\nself.proxy.set_filter_by_score(True)\nself.setup_sections()\nif self.count():\n    self.set_current_row(0)\nelse:\n    self.set_current_row(-1)\nself.set_height()\n",
        "CUT_5": "\"\"\"Set-up which sections appear on the item list.\"\"\"\nmode = self._mode_on\nif mode:\n    search_text = self.search_text()[len(mode):]\nelse:\n    search_text = self.search_text()\nif search_text:\n    for row in range(self.model.rowCount()):\n        item = self.model.item(row)\n        if isinstance(item, SwitcherItem):\n            item.set_section_visible(False)\nelse:\n    sections = []\n    for row in range(self.model.rowCount()):\n        item = self.model.item(row)\n        if isinstance(item, SwitcherItem):\n            sections.append(item.get_section())\n            item.set_section_visible(bool(search_text))\n        else:\n            sections.append('')\n        if row != 0:\n            visible = sections[row] != sections[row - 1]\n            if not self._is_separator(item):\n                item.set_section_visible(visible)\n        else:\n            item.set_section_visible(True)\nself.proxy.sortBy('_score')\nself.sig_item_changed.emit(self.current_item())\n"
    },
    {
        "functionName": "test_switcher",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_switcher.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that shortcut summary is visible and is not empty\"\"\"\ndlg_switcher.show()\nassert dlg_switcher.isVisible()\nqtbot.keyClick(dlg_switcher.edit, Qt.Key_Escape)\nassert not dlg_switcher.isVisible()\n",
        "CUT_1": "\"\"\"Return True is completion list widget is visible\"\"\"\nreturn self.completion_widget.isVisible()\n",
        "CUT_2": "\"\"\"Return True is completion list widget is visible\"\"\"\nreturn self.completion_widget.isVisible()\n",
        "CUT_3": "self._checkbox.isVisible()\n",
        "CUT_4": "self._checkbox.isVisible()\n",
        "CUT_5": "\"\"\"Update status label widget, if widget is visible.\"\"\"\nif self.isVisible():\n    self.label_value.setText(self.get_value())\n"
    },
    {
        "functionName": "test_switcher_filter_and_mode",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_switcher.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test filter and mode change.\"\"\"\nedit = dlg_switcher.edit\nassert dlg_switcher.count() == 6\nedit.setText('master')\nqtbot.wait(1000)\nassert dlg_switcher.count() == 2\nedit.setText('')\nedit.setText('?')\nqtbot.wait(1000)\nassert dlg_switcher.count() == 5\nedit.setText('')\nedit.setText('@')\nqtbot.wait(1000)\nassert dlg_switcher.count() == 2\nedit.setText('')\nedit.setText('>')\nqtbot.wait(1000)\nassert dlg_switcher.count() == 7\nedit.setText('')\nedit.setText(':')\nqtbot.wait(1000)\nassert dlg_switcher.count() == 1\n",
        "CUT_1": "\"\"\"Set the content of the search text.\"\"\"\nself.edit.setText(string)\n",
        "CUT_2": "\"\"\"Set the content of the search text.\"\"\"\nself.edit.setText(string)\n",
        "CUT_3": "label = QLabel(text)\nlabel.setWordWrap(word_wrap)\nedit = QLineEdit()\nedit.content_type = content_type\nlayout = QVBoxLayout() if alignment == Qt.Vertical else QHBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(edit)\nlayout.setContentsMargins(0, 0, 0, 0)\nif tip:\n    edit.setToolTip(tip)\nif regex:\n    edit.setValidator(QRegExpValidator(QRegExp(regex)))\nif placeholder:\n    edit.setPlaceholderText(placeholder)\nself.lineedits[edit] = section, option, default\nwidget = QWidget(self)\nwidget.label = label\nwidget.textbox = edit\nwidget.setLayout(layout)\nedit.restart_required = restart\nedit.label_text = text\nreturn widget\n",
        "CUT_4": "label = QLabel(text)\nlabel.setWordWrap(word_wrap)\nedit = QLineEdit()\nedit.content_type = content_type\nlayout = QVBoxLayout() if alignment == Qt.Vertical else QHBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(edit)\nlayout.setContentsMargins(0, 0, 0, 0)\nif tip:\n    edit.setToolTip(tip)\nif regex:\n    edit.setValidator(QRegExpValidator(QRegExp(regex)))\nif placeholder:\n    edit.setPlaceholderText(placeholder)\nself.lineedits[edit] = section, option, default\nwidget = QWidget(self)\nwidget.label = label\nwidget.textbox = edit\nwidget.setLayout(layout)\nedit.restart_required = restart\nedit.label_text = text\nreturn widget\n",
        "CUT_5": "label = QLabel(text)\nlabel.setWordWrap(True)\nedit = QPlainTextEdit()\nedit.content_type = content_type\nedit.setWordWrapMode(QTextOption.WordWrap)\nlayout = QVBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(edit)\nlayout.setContentsMargins(0, 0, 0, 0)\nif tip:\n    edit.setToolTip(tip)\nself.textedits[edit] = section, option, default\nwidget = QWidget(self)\nwidget.label = label\nwidget.textbox = edit\nwidget.setLayout(layout)\nedit.restart_required = restart\nedit.label_text = text\nreturn widget\n"
    },
    {
        "functionName": "test_switcher_filter_unicode",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_switcher.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test filter with unicode.\"\"\"\nedit = dlg_switcher.edit\nassert dlg_switcher.count() == 6\ndlg_switcher.show()\nedit.setText('\u8bd5')\nqtbot.wait(1000)\nassert dlg_switcher.count() == 2\n",
        "CUT_1": "label = QLabel(text)\nlabel.setWordWrap(word_wrap)\nedit = QLineEdit()\nedit.content_type = content_type\nlayout = QVBoxLayout() if alignment == Qt.Vertical else QHBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(edit)\nlayout.setContentsMargins(0, 0, 0, 0)\nif tip:\n    edit.setToolTip(tip)\nif regex:\n    edit.setValidator(QRegExpValidator(QRegExp(regex)))\nif placeholder:\n    edit.setPlaceholderText(placeholder)\nself.lineedits[edit] = section, option, default\nwidget = QWidget(self)\nwidget.label = label\nwidget.textbox = edit\nwidget.setLayout(layout)\nedit.restart_required = restart\nedit.label_text = text\nreturn widget\n",
        "CUT_2": "label = QLabel(text)\nlabel.setWordWrap(word_wrap)\nedit = QLineEdit()\nedit.content_type = content_type\nlayout = QVBoxLayout() if alignment == Qt.Vertical else QHBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(edit)\nlayout.setContentsMargins(0, 0, 0, 0)\nif tip:\n    edit.setToolTip(tip)\nif regex:\n    edit.setValidator(QRegExpValidator(QRegExp(regex)))\nif placeholder:\n    edit.setPlaceholderText(placeholder)\nself.lineedits[edit] = section, option, default\nwidget = QWidget(self)\nwidget.label = label\nwidget.textbox = edit\nwidget.setLayout(layout)\nedit.restart_required = restart\nedit.label_text = text\nreturn widget\n",
        "CUT_3": "label = QLabel(text)\nlabel.setWordWrap(True)\nedit = QPlainTextEdit()\nedit.content_type = content_type\nedit.setWordWrapMode(QTextOption.WordWrap)\nlayout = QVBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(edit)\nlayout.setContentsMargins(0, 0, 0, 0)\nif tip:\n    edit.setToolTip(tip)\nself.textedits[edit] = section, option, default\nwidget = QWidget(self)\nwidget.label = label\nwidget.textbox = edit\nwidget.setLayout(layout)\nedit.restart_required = restart\nedit.label_text = text\nreturn widget\n",
        "CUT_4": "label = QLabel(text)\nlabel.setWordWrap(True)\nedit = QPlainTextEdit()\nedit.content_type = content_type\nedit.setWordWrapMode(QTextOption.WordWrap)\nlayout = QVBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(edit)\nlayout.setContentsMargins(0, 0, 0, 0)\nif tip:\n    edit.setToolTip(tip)\nself.textedits[edit] = section, option, default\nwidget = QWidget(self)\nwidget.label = label\nwidget.textbox = edit\nwidget.setLayout(layout)\nedit.restart_required = restart\nedit.label_text = text\nreturn widget\n",
        "CUT_5": "return ima.icon('edit')\n"
    },
    {
        "functionName": "pathmanager",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up PathManager.\"\"\"\npath, read_only_path, not_active_path = request.param\nwidget = pathmanager_mod.PathManager(None, path=tuple(path), read_only_path\n    =tuple(read_only_path), not_active_path=tuple(not_active_path))\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_3": "\"\"\"Load path stored in Spyder configuration folder.\"\"\"\nif osp.isfile(self.SPYDER_PATH):\n    path, _x = encoding.readlines(self.SPYDER_PATH)\n    self.path = tuple(name for name in path if osp.isdir(name))\nif osp.isfile(self.SPYDER_NOT_ACTIVE_PATH):\n    not_active_path, _x = encoding.readlines(self.SPYDER_NOT_ACTIVE_PATH)\n    self.not_active_path = tuple(name for name in not_active_path if osp.\n        isdir(name))\n",
        "CUT_4": "\"\"\"Load path stored in Spyder configuration folder.\"\"\"\nif osp.isfile(self.SPYDER_PATH):\n    path, _x = encoding.readlines(self.SPYDER_PATH)\n    self.path = tuple(name for name in path if osp.isdir(name))\nif osp.isfile(self.SPYDER_NOT_ACTIVE_PATH):\n    not_active_path, _x = encoding.readlines(self.SPYDER_NOT_ACTIVE_PATH)\n    self.not_active_path = tuple(name for name in not_active_path if osp.\n        isdir(name))\n",
        "CUT_5": "\"\"\"Run path manager test.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_ = qapplication()\ndlg = PathManager(None, path=tuple(sys.path[:-2]), read_only_path=tuple(sys\n    .path[-2:]))\ndef callback(path_dict):\n    sys.stdout.write(str(path_dict))\ndlg.sig_path_changed.connect(callback)\ndlg.exec_()\n"
    },
    {
        "functionName": "test_pathmanager",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run PathManager test\"\"\"\npathmanager.show()\nassert pathmanager\npytest.mark.parametrize('pathmanager', [(sys.path[:-10], sys.path[-10:], ()\n    )], indirect=True)",
        "CUT_1": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_3": "\"\"\"Run path manager test.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_ = qapplication()\ndlg = PathManager(None, path=tuple(sys.path[:-2]), read_only_path=tuple(sys\n    .path[-2:]))\ndef callback(path_dict):\n    sys.stdout.write(str(path_dict))\ndlg.sig_path_changed.connect(callback)\ndlg.exec_()\n",
        "CUT_4": "\"\"\"Run path manager test.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\n_ = qapplication()\ndlg = PathManager(None, path=tuple(sys.path[:-2]), read_only_path=tuple(sys\n    .path[-2:]))\ndef callback(path_dict):\n    sys.stdout.write(str(path_dict))\ndlg.sig_path_changed.connect(callback)\ndlg.exec_()\n",
        "CUT_5": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n"
    },
    {
        "functionName": "test_check_uncheck_path",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that checking and unchecking a path in the PathManager correctly\n    update the not active path list.\n    \"\"\"\nfor row in range(pathmanager.listwidget.count()):\n    assert pathmanager.listwidget.item(row).checkState() == Qt.Checked\npytest.mark.parametrize('pathmanager', [(sys.path[:-10], sys.path[-10:], ()\n    )], indirect=True)",
        "CUT_1": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_3": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n",
        "CUT_4": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n",
        "CUT_5": "\"\"\"Retunr the checked state for item in row.\"\"\"\nitem = self.listwidget.item(row)\nreturn item.checkState()\n"
    },
    {
        "functionName": "test_synchronize_with_PYTHONPATH",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "from spyder.utils.environ import get_user_env, set_user_env, listdict2envdict\nenv = get_user_env()\noriginal_pathlist = env.get('PYTHONPATH', [])\nmocker.patch.object(pathmanager_mod.QMessageBox, 'question', return_value=\n    pathmanager_mod.QMessageBox.Yes)\npathmanager.synchronize()\nexpected_pathlist = ['p1', 'p2', 'p3', 'p4', 'p5', 'p6']\nenv = get_user_env()\nassert env['PYTHONPATH'] == expected_pathlist\npathmanager.listwidget.item(1).setCheckState(Qt.Unchecked)\npathmanager.synchronize()\nexpected_pathlist = ['p1', 'p3', 'p4', 'p5', 'p6']\nenv = get_user_env()\nassert env['PYTHONPATH'] == expected_pathlist\nmocker.patch.object(pathmanager_mod.QMessageBox, 'question', return_value=\n    pathmanager_mod.QMessageBox.No)\npathmanager.listwidget.item(2).setCheckState(Qt.Unchecked)\npathmanager.synchronize()\nexpected_pathlist = ['p3', 'p1', 'p4', 'p5', 'p6']\nenv = get_user_env()\nassert env['PYTHONPATH'] == expected_pathlist\nenv['PYTHONPATH'] = original_pathlist\nset_user_env(listdict2envdict(env))\npytest.mark.skipif(os.name != 'nt' or not is_module_installed('win32con'),\n    reason=\n    'This feature is not applicable for Unix systems and pywin32 is needed')pytest.mark.parametrize('pathmanager', [(['p1', 'p2', 'p3'], ['p4', 'p5',\n    'p6'], [])], indirect=True)",
        "CUT_1": "\"\"\"Process conda environment information.\"\"\"\nout, err = self._get_interpreter_env_info()\nout = out or err\nout = out.split('\\n')[0]\nparts = out.split()\nif len(parts) >= 2:\n    out = ' '.join(parts[:2])\nif is_conda_env(pyexec=self._interpreter):\n    envs_folder = os.path.sep + 'envs' + os.path.sep\n    if envs_folder in self._interpreter:\n        if os.name == 'nt':\n            env = os.path.dirname(self._interpreter)\n        else:\n            env = os.path.dirname(os.path.dirname(self._interpreter))\n        env = os.path.basename(env)\n    else:\n        env = 'base'\n    env = 'conda: ' + env\nelif running_in_mac_app(self._interpreter):\n    env = 'internal'\nelse:\n    env = 'venv'\ntext = '{env} ({version})'.format(env=env, version=out)\nreturn text\n",
        "CUT_2": "\"\"\"Process conda environment information.\"\"\"\nout, err = self._get_interpreter_env_info()\nout = out or err\nout = out.split('\\n')[0]\nparts = out.split()\nif len(parts) >= 2:\n    out = ' '.join(parts[:2])\nif is_conda_env(pyexec=self._interpreter):\n    envs_folder = os.path.sep + 'envs' + os.path.sep\n    if envs_folder in self._interpreter:\n        if os.name == 'nt':\n            env = os.path.dirname(self._interpreter)\n        else:\n            env = os.path.dirname(os.path.dirname(self._interpreter))\n        env = os.path.basename(env)\n    else:\n        env = 'base'\n    env = 'conda: ' + env\nelif running_in_mac_app(self._interpreter):\n    env = 'internal'\nelse:\n    env = 'venv'\ntext = '{env} ({version})'.format(env=env, version=out)\nreturn text\n",
        "CUT_3": "\"\"\"\n        Synchronize Spyder's path list with PYTHONPATH environment variable\n        Only apply to: current user, on Windows platforms.\n        \"\"\"\nanswer = QMessageBox.question(self, _('Synchronize'), _(\n    \"This will synchronize Spyder's path list with <b>PYTHONPATH</b> environment variable for the current user, allowing you to run your Python modules outside Spyder without having to configure sys.path. <br>Do you want to clear contents of PYTHONPATH before adding Spyder's path list?\"\n    ), QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)\nif answer == QMessageBox.Cancel:\n    return\nelif answer == QMessageBox.Yes:\n    remove = True\nelse:\n    remove = False\nfrom spyder.utils.environ import get_user_env, listdict2envdict, set_user_env\nenv = get_user_env()\nactive_path = tuple(k for k, v in self.get_path_dict(True).items() if v)\nif remove:\n    ppath = active_path\nelse:\n    ppath = env.get('PYTHONPATH', [])\n    if not isinstance(ppath, list):\n        ppath = [ppath]\n    ppath = tuple(p for p in ppath if p not in active_path)\n    ppath = ppath + active_path\nenv['PYTHONPATH'] = list(ppath)\nset_user_env(listdict2envdict(env), parent=self)\nSlot()",
        "CUT_4": "\"\"\"\n        Synchronize Spyder's path list with PYTHONPATH environment variable\n        Only apply to: current user, on Windows platforms.\n        \"\"\"\nanswer = QMessageBox.question(self, _('Synchronize'), _(\n    \"This will synchronize Spyder's path list with <b>PYTHONPATH</b> environment variable for the current user, allowing you to run your Python modules outside Spyder without having to configure sys.path. <br>Do you want to clear contents of PYTHONPATH before adding Spyder's path list?\"\n    ), QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)\nif answer == QMessageBox.Cancel:\n    return\nelif answer == QMessageBox.Yes:\n    remove = True\nelse:\n    remove = False\nfrom spyder.utils.environ import get_user_env, listdict2envdict, set_user_env\nenv = get_user_env()\nactive_path = tuple(k for k, v in self.get_path_dict(True).items() if v)\nif remove:\n    ppath = active_path\nelse:\n    ppath = env.get('PYTHONPATH', [])\n    if not isinstance(ppath, list):\n        ppath = [ppath]\n    ppath = tuple(p for p in ppath if p not in active_path)\n    ppath = ppath + active_path\nenv['PYTHONPATH'] = list(ppath)\nset_user_env(listdict2envdict(env), parent=self)\nSlot()",
        "CUT_5": "\"\"\"\n    Add a PYTHONPATH entry to a list of enviroment variables.\n\n    This allows to extend the environment of an external process\n    created with QProcess with our additions to PYTHONPATH.\n\n    Parameters\n    ----------\n    env: list\n        List of environment variables in the format of\n        QProcessEnvironment.\n    pathlist: list\n        List of paths to add to PYTHONPATH\n    drop_env: bool\n        Whether to drop PYTHONPATH previously found in the environment.\n    \"\"\"\nassert isinstance(env, list)\nassert all([is_text_string(path) for path in env])\npypath = 'PYTHONPATH'\npathstr = os.pathsep.join(pathlist)\nif not drop_env:\n    for index, var in enumerate(env[:]):\n        if var.startswith(pypath + '='):\n            env[index] = var.replace(pypath + '=', pypath + '=' + pathstr +\n                os.pathsep)\nelse:\n    env.append(pypath + '=' + pathstr)\n"
    },
    {
        "functionName": "test_invalid_directories",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Check [site/dist]-packages are invalid paths.\"\"\"\nif os.name == 'nt':\n    paths = ['/lib/site-packages/foo', '/lib/dist-packages/foo']\nelse:\n    paths = ['/lib/python3.6/site-packages/foo',\n        '/lib/python3.6/dist-packages/foo']\ndef interact_message_box():\n    child = pathmanager.findChild(QMessageBox)\n    qtbot.keyPress(child, Qt.Key_Enter)\nfor path in paths:\n    timer = QTimer()\n    timer.setSingleShot(True)\n    timer.timeout.connect(interact_message_box)\n    timer.start(300)\n    assert not pathmanager.check_path(path)\n    pathmanager.add_path(path)\npytest.mark.parametrize('pathmanager', [(sys.path[:-10], sys.path[-10:], ()\n    )], indirect=True)",
        "CUT_1": "\"\"\"Check that the path is not a [site|dist]-packages folder.\"\"\"\nif os.name == 'nt':\n    pat = re.compile('.*lib/(?:site|dist)-packages.*')\nelse:\n    pat = re.compile('.*lib/python.../(?:site|dist)-packages.*')\npath_norm = path.replace('\\\\', '/')\nreturn pat.match(path_norm) is None\n",
        "CUT_2": "\"\"\"Check that the path is not a [site|dist]-packages folder.\"\"\"\nif os.name == 'nt':\n    pat = re.compile('.*lib/(?:site|dist)-packages.*')\nelse:\n    pat = re.compile('.*lib/python.../(?:site|dist)-packages.*')\npath_norm = path.replace('\\\\', '/')\nreturn pat.match(path_norm) is None\n",
        "CUT_3": "\"\"\"\n    Make macOS application bundle.\n\n    Parameters\n    ----------\n    dist_dir : str\n        Directory in which to put the application bundle.\n    make_lite : bool, optional\n        Whether to create the application bundle with minimal packages.\n        The default is False.\n\n    NOTES\n    -----\n    py2app includes all packages in Spyder.app/Contents/Resources/lib/\n    python<ver>.zip, but some packages have issues when placed there.\n    The following packages are included in py2app's PACKAGES option so that\n    they will be placed in Spyder.app/Contents/Resources/lib/python<ver>\n    instead.\n\n    alabaster :\n        Error message: [Errno 20] Not a directory: '<path>/Resources/lib/\n        python38.zip/alabaster'\n    astroid :\n        ImportError: cannot import name 'context' from 'astroid'\n        (<path>/Resources/lib/python38.zip/astroid/__init__.pyc)\n    ipykernel :\n        ModuleNotFoundError: No module named 'ipykernel.datapub'\n    ipython :\n        [IPKernelApp] WARNING | Could not copy README_STARTUP to startup dir.\n        Source file\n        <path>/Resources/lib/python38.zip/IPython/core/profile/README_STARTUP\n        does not exist\n    jedi :\n        jedi.api.environment.InvalidPythonEnvironment: Could not get version\n        information for '<path>/Contents/MacOS/python': InternalError(\"The\n        subprocess <path>/Contents/MacOS/python has crashed (EOFError('Ran out\n        of input'), stderr=).\")\n    jinja2 :\n        No module named 'jinja2.ext'\n    keyring :\n        ModuleNotFoundError: No module named 'keyring.backends.<mod>'\n    parso :\n        NotADirectoryError: [Errno 20] Not a directory:\n        '<path>/Resources/lib/python38.zip/parso/python/grammar38.txt'\n    PIL :\n        Library not loaded: @loader_path/.dylibs/libjpeg.9.dylib\n        Note: only applicable to not-Lite build\n    pygments :\n        ModuleNotFoundError: No module named 'pygments.formatters.latex'\n    pyls :\n        <path>/Contents/MacOS/python: No module named pyls\n        Note: still occurs in alias mode\n    qtawesome :\n        NotADirectoryError: [Errno 20] Not a directory: '<path>/Resourses/lib/\n        python38.zip/qtawesome/fonts/fontawesome4.7-webfont.ttf'\n    spyder :\n        NotADirectoryError: [Errno 20] Not a directory: '<path>/Resources/lib/\n        python38.zip/spyder/app/mac_stylesheet.qss'\n    spyder_kernels :\n        No module named spyder_kernels.console.__main__\n    sphinx :\n        No module named 'sphinx.builders.changes'\n\n   \"\"\"\nbuild_type = 'lite' if make_lite else 'full'\nlogger.info('Creating %s app bundle...', build_type)\nPACKAGES = ['alabaster', 'astroid', 'ipykernel', 'IPython', 'jedi',\n    'jinja2', 'keyring', 'parso', 'pygments', 'pyls', 'qtawesome', 'spyder',\n    'spyder_kernels', 'sphinx']\nif make_lite:\n    INCLUDES = []\n    EXCLUDES = ['numpy', 'scipy', 'pandas', 'matplotlib', 'cython', 'sympy']\nelse:\n    INCLUDES = ['numpy', 'scipy', 'pandas', 'matplotlib', 'cython', 'sympy']\n    EXCLUDES = []\n    PACKAGES.append('PIL')\nEDIT_EXT = [ext[1:] for ext in _get_extensions(EDIT_FILETYPES)]\nOPTIONS = {'optimize': 0, 'packages': PACKAGES, 'includes': INCLUDES,\n    'excludes': EXCLUDES, 'iconfile': ICONFILE, 'dist_dir': dist_dir,\n    'plist': {'CFBundleDocumentTypes': [{'CFBundleTypeExtensions': EDIT_EXT,\n    'CFBundleTypeName': 'Text File', 'CFBundleTypeRole': 'Editor'}],\n    'CFBundleIdentifier': 'org.spyder-ide', 'CFBundleShortVersionString':\n    SPYVER}}\napp_script_name = MAC_APP_NAME.replace('.app', '.py')\napp_script_path = os.path.join(SPYREPO, 'scripts', app_script_name)\nshutil.copy2(os.path.join(SPYREPO, 'scripts', 'spyder'), app_script_path)\ntry:\n    setup(app=[app_script_path], options={'py2app': OPTIONS})\nfinally:\n    os.remove(app_script_path)\ndest_dir = os.path.join(dist_dir, MAC_APP_NAME, 'Contents', 'Resources',\n    'lib', f'python{PYVER[0]}.{PYVER[1]}')\nfor dist in pkg_resources.working_set:\n    if dist.egg_info is None:\n        continue\n    dest = os.path.join(dest_dir, os.path.basename(dist.egg_info))\n    shutil.copytree(dist.egg_info, dest)\nlogger.info('App bundle complete.')\nreturn\n",
        "CUT_4": "\"\"\"\n    Return package list.\n    \"\"\"\npackages = get_subpackages(LIBNAME)\nreturn packages\n",
        "CUT_5": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n"
    },
    {
        "functionName": "interact_message_box",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "child = pathmanager.findChild(QMessageBox)\nqtbot.keyPress(child, Qt.Key_Enter)\n",
        "CUT_1": "self.collapseItem(item)\nfor index in range(item.childCount()):\n    child = item.child(index)\n    self.__collapse_item(child)\n",
        "CUT_2": "self.collapseItem(item)\nfor index in range(item.childCount()):\n    child = item.child(index)\n    self.__collapse_item(child)\n",
        "CUT_3": "if self.is_item_expandable(item):\n    self.expandItem(item)\n    for index in range(item.childCount()):\n        child = item.child(index)\n        self.__expand_item(child)\n",
        "CUT_4": "if self.is_item_expandable(item):\n    self.expandItem(item)\n    for index in range(item.childCount()):\n        child = item.child(index)\n        self.__expand_item(child)\n",
        "CUT_5": "\"\"\"\n    Closes QMessageBox's that can appear when testing.\n\n    You can use this with QTimer to close a QMessageBox.\n    Before calling anything that may show a QMessageBox call:\n    QTimer.singleShot(1000, lambda: close_message_box(qtbot))\n    \"\"\"\ntop_level_widgets = QApplication.topLevelWidgets()\nfor w in top_level_widgets:\n    if isinstance(w, QMessageBox):\n        qtbot.keyClick(w, Qt.Key_Enter)\n"
    },
    {
        "functionName": "test_remove_item_and_reply_no",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Check that the item is not removed after answering 'No'.\"\"\"\npathmanager.show()\ncount = pathmanager.count()\ndef interact_message_box():\n    messagebox = pathmanager.findChild(QMessageBox)\n    buttons = messagebox.findChildren(QPushButton)\n    for button in buttons:\n        if 'no' in button.text().lower():\n            qtbot.mouseClick(button, Qt.LeftButton)\n            break\ntimer = QTimer()\ntimer.setSingleShot(True)\ntimer.timeout.connect(interact_message_box)\ntimer.start(100)\nqtbot.mouseClick(pathmanager.remove_button, Qt.LeftButton)\nassert pathmanager.count() == count\npytest.mark.parametrize('pathmanager', [(('/spam', '/bar'), ('/foo',), ())],\n    indirect=True)",
        "CUT_1": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_3": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n",
        "CUT_4": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n",
        "CUT_5": "\"\"\"Stop the autosave timer.\"\"\"\nself.timer.stop()\n"
    },
    {
        "functionName": "test_remove_item_and_reply_yes",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Check that the item is indeed removed after answering 'Yes'.\"\"\"\npathmanager.show()\ncount = pathmanager.count()\ndef interact_message_box():\n    messagebox = pathmanager.findChild(QMessageBox)\n    buttons = messagebox.findChildren(QPushButton)\n    for button in buttons:\n        if 'yes' in button.text().lower():\n            qtbot.mouseClick(button, Qt.LeftButton)\n            break\ntimer = QTimer()\ntimer.setSingleShot(True)\ntimer.timeout.connect(interact_message_box)\ntimer.start(100)\nqtbot.mouseClick(pathmanager.remove_button, Qt.LeftButton)\nassert pathmanager.count() == count - 1\npytest.mark.parametrize('pathmanager', [(('/spam', '/bar'), ('/foo',), ())],\n    indirect=True)",
        "CUT_1": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_3": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n",
        "CUT_4": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n",
        "CUT_5": "\"\"\"Stop the autosave timer.\"\"\"\nself.timer.stop()\n"
    },
    {
        "functionName": "test_add_repeated_item",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Check behavior when an uncheked item that is already on the list is added.\n    The checkbox should then be checked and if replying 'yes' to the question,\n    then the item should be moved to the top.\n    \"\"\"\npathmanager.show()\ndir1 = str(tmpdir.mkdir('foo'))\ndir2 = str(tmpdir.mkdir('bar'))\ndir3 = str(tmpdir.mkdir('spam'))\npathmanager.add_path(dir1)\npathmanager.add_path(dir2)\npathmanager.add_path(dir3)\npathmanager.set_row_check_state(1, Qt.Unchecked)\nassert not all(pathmanager.get_path_dict().values())\ndef interact_message_box():\n    messagebox = pathmanager.findChild(QMessageBox)\n    buttons = messagebox.findChildren(QPushButton)\n    for button in buttons:\n        if 'yes' in button.text().lower():\n            qtbot.mouseClick(button, Qt.LeftButton)\n            break\ntimer = QTimer()\ntimer.setSingleShot(True)\ntimer.timeout.connect(interact_message_box)\ntimer.start(500)\npathmanager.add_path(dir2)\nprint(pathmanager.get_path_dict())\nassert pathmanager.count() == 3\nassert list(pathmanager.get_path_dict().keys())[0] == dir2\nassert all(pathmanager.get_path_dict().values())\npytest.mark.parametrize('pathmanager', [((), (), ())], indirect=True)",
        "CUT_1": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_3": "\"\"\"Override Qt method.\"\"\"\npath_dict = self.get_path_dict()\nif self.original_path_dict != path_dict:\n    self.sig_path_changed.emit(path_dict)\nsuper(PathManager, self).accept()\n",
        "CUT_4": "\"\"\"Override Qt method.\"\"\"\npath_dict = self.get_path_dict()\nif self.original_path_dict != path_dict:\n    self.sig_path_changed.emit(path_dict)\nsuper(PathManager, self).accept()\n",
        "CUT_5": "\"\"\"A project directory with dirs and files for testing.\"\"\"\nproject_dir = to_text_string(tmpdir.mkdir('project'))\ndestination_dir = to_text_string(tmpdir.mkdir('destination'))\ntop_folder = osp.join(project_dir, 'top_folder_in_proj')\nif not osp.exists(top_folder):\n    os.mkdir(top_folder)\nlist_paths = []\nfor item in request.param:\n    if osp.splitext(item)[1]:\n        if osp.split(item)[0]:\n            dirs, fname = osp.split(item)\n            dirpath = osp.join(top_folder, dirs)\n            if not osp.exists(dirpath):\n                os.makedirs(dirpath)\n                item_path = osp.join(dirpath, fname)\n        else:\n            item_path = osp.join(top_folder, item)\n    else:\n        dirpath = osp.join(top_folder, item)\n        if not osp.exists(dirpath):\n            os.makedirs(dirpath)\n            item_path = dirpath\n    if not osp.isdir(item_path):\n        with open(item_path, 'w') as fh:\n            fh.write('File Path:\\n' + str(item_path).replace(os.sep, '/'))\n    list_paths.append(item_path)\nreturn list_paths, project_dir, destination_dir, top_folder\npytest.fixture(params=[['script.py', 'dir1/dir2/dir3/dir4'], ['script.py',\n    'script1.py', 'testdir/dir1/script2.py'], [\n    'subdir/innerdir/dir3/text.txt', 'dir1/dir2/dir3',\n    'dir1/dir2/dir3/file.txt', 'dir1/dir2/dir3/dir4/python.py']])"
    },
    {
        "functionName": "test_add_invalid_path",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Checks for unicode on python 2.\"\"\"\npathmanager.show()\ncount = pathmanager.count()\ndef interact_message_box():\n    qtbot.wait(500)\n    messagebox = pathmanager.findChild(QMessageBox)\n    button = messagebox.findChild(QPushButton)\n    qtbot.mouseClick(button, Qt.LeftButton)\ntimer = QTimer()\ntimer.setSingleShot(True)\ntimer.timeout.connect(interact_message_box)\ntimer.start(500)\npathmanager.add_path('/foo/bar/\u6e2c\u8a66')\nqtbot.wait(500)\nassert len(pathmanager.get_path_dict()) == 2\nassert len(pathmanager.get_path_dict(True)) == 3\npytest.mark.skipif(PY3 or os.environ.get('CI') is not None and sys.platform\n    .startswith('linux'), reason=\n    'This tests only applies to Python 2.It is failing on Linux CI. Works locally!'\n    )pytest.mark.parametrize('pathmanager', [(('/spam', '/bar'), ('/foo',), (\n    '/bar',))], indirect=True)",
        "CUT_1": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_3": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n",
        "CUT_4": "\"\"\"Show symbols for all `language` files.\"\"\"\nself._languages.append(language)\ntimer = QTimer(self)\ntimer.setSingleShot(True)\ntimer.setInterval(700)\ntimer.timeout.connect(lambda : self.update_editors(language))\nself.update_timers[language] = timer\nself.set_editors_to_update(language)\ntimer.start()\n",
        "CUT_5": "\"\"\"Override Qt method.\"\"\"\npath_dict = self.get_path_dict()\nif self.original_path_dict != path_dict:\n    self.sig_path_changed.emit(path_dict)\nsuper(PathManager, self).accept()\n"
    },
    {
        "functionName": "test_buttons_state",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_pathmanager.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Check buttons are enabled/disabled based on items and position.\"\"\"\npathmanager.show()\nassert not pathmanager.button_ok.isEnabled()\nassert not pathmanager.movetop_button.isEnabled()\nassert not pathmanager.moveup_button.isEnabled()\nassert pathmanager.movebottom_button.isEnabled()\nassert pathmanager.movedown_button.isEnabled()\npathmanager.set_current_row(1)\nassert not pathmanager.button_ok.isEnabled()\nassert pathmanager.movetop_button.isEnabled()\nassert pathmanager.moveup_button.isEnabled()\nassert not pathmanager.movebottom_button.isEnabled()\nassert not pathmanager.movedown_button.isEnabled()\npath = tmpdir.mkdir('bloop')\npathmanager.add_path(str(path))\nassert pathmanager.button_ok.isEnabled()\nassert not pathmanager.movetop_button.isEnabled()\nassert not pathmanager.moveup_button.isEnabled()\npathmanager.movebottom_button.animateClick()\nqtbot.waitUntil(pathmanager.movetop_button.isEnabled)\nassert pathmanager.movetop_button.isEnabled()\nassert pathmanager.moveup_button.isEnabled()\nassert not pathmanager.movebottom_button.isEnabled()\nassert not pathmanager.movedown_button.isEnabled()\nassert pathmanager.current_row() == 2\npathmanager.remove_path(True)\nassert not pathmanager.button_ok.isEnabled()\npytest.mark.skipif(os.name != 'nt' or not is_module_installed('win32con'),\n    reason=\n    'This feature is not applicable for Unix systems and pywin32 is needed')pytest.mark.parametrize('pathmanager', [(('/spam', '/bar'), ('/foo',), ())],\n    indirect=True)",
        "CUT_1": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_2": "\"\"\"Show path manager dialog.\"\"\"\nfrom spyder.widgets.pathmanager import PathManager\nread_only_path = tuple(self.projects.get_pythonpath())\ndialog = PathManager(self, self.path, read_only_path, self.not_active_path,\n    sync=True)\nself._path_manager = dialog\ndialog.sig_path_changed.connect(self.update_python_path)\ndialog.redirect_stdio.connect(self.redirect_internalshell_stdio)\ndialog.show()\nSlot()",
        "CUT_3": "\"\"\"Override Qt method.\"\"\"\npath_dict = self.get_path_dict()\nif self.original_path_dict != path_dict:\n    self.sig_path_changed.emit(path_dict)\nsuper(PathManager, self).accept()\n",
        "CUT_4": "\"\"\"Override Qt method.\"\"\"\npath_dict = self.get_path_dict()\nif self.original_path_dict != path_dict:\n    self.sig_path_changed.emit(path_dict)\nsuper(PathManager, self).accept()\n",
        "CUT_5": "\"\"\"Update actions following the execution state of the kernel.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    executing = client.stop_button.isEnabled()\n    self.interrupt_action.setEnabled(executing)\n"
    },
    {
        "functionName": "status_bar",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_status.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up StatusBarWidget.\"\"\"\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nqtbot.addWidget(win)\nreturn win, statusbar\npytest.fixture",
        "CUT_1": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_2": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_3": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_4": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = TestWidget(None)\nwin.show()\nwin.load(fname)\nwin.resize(900, 700)\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_status_bar_time_based_widgets",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_status.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run StatusBarWidget.\"\"\"\nwin, statusbar = status_bar\nswidgets = []\nfor klass in (MemoryStatus, CPUStatus):\n    swidget = klass(win, statusbar)\n    swidgets.append(swidget)\nassert win\nassert len(swidgets) == 2\n",
        "CUT_1": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_2": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_3": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_4": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = TestWidget(None)\nwin.show()\nwin.load(fname)\nwin.resize(900, 700)\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "get_tooltip",
        "className": "StatusBarWidgetTest",
        "fileName": "/spyder/widgets/tests/test_status.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return 'tooltip'\n",
        "CUT_1": "\"\"\"Return the widget tooltip text.\"\"\"\nreturn ''\n",
        "CUT_2": "\"\"\"Return the widget tooltip text.\"\"\"\nreturn ''\n",
        "CUT_3": "\"\"\"Update tooltip for widget.\"\"\"\ntooltip = self.get_tooltip()\nif tooltip:\n    self.label_value.setToolTip(tooltip)\n    if self.label_icon:\n        self.label_icon.setToolTip(tooltip)\n    self.setToolTip(tooltip)\n",
        "CUT_4": "\"\"\"Update tooltip for widget.\"\"\"\ntooltip = self.get_tooltip()\nif tooltip:\n    self.label_value.setToolTip(tooltip)\n    if self.label_icon:\n        self.label_icon.setToolTip(tooltip)\n    self.setToolTip(tooltip)\n",
        "CUT_5": "\"\"\"Return the widget tooltip text.\"\"\"\nreturn None\n"
    },
    {
        "functionName": "get_icon",
        "className": "StatusBarWidgetTest",
        "fileName": "/spyder/widgets/tests/test_status.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return 'icon'\n",
        "CUT_1": "if self.fullscreen_flag:\n    icon = ima.icon('window_nofullscreen')\nelse:\n    icon = ima.icon('window_fullscreen')\nif is_text_string(icon):\n    icon = get_icon(icon)\nself.fullscreen_action.setIcon(icon)\n",
        "CUT_2": "if self.fullscreen_flag:\n    icon = ima.icon('window_nofullscreen')\nelse:\n    icon = ima.icon('window_fullscreen')\nif is_text_string(icon):\n    icon = get_icon(icon)\nself.fullscreen_action.setIcon(icon)\n",
        "CUT_3": "\"\"\"Return widget icon.\"\"\"\nreturn ima.icon('edit')\n",
        "CUT_4": "\"\"\"Return widget icon.\"\"\"\nreturn ima.icon('edit')\n",
        "CUT_5": "\"\"\"Return widget icon\"\"\"\nreturn ima.icon('ipython_console')\n"
    },
    {
        "functionName": "test_status_bar_widget_signal",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_status.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "win, statusbar = status_bar\nw = StatusBarWidgetTest(win, statusbar)\nwith qtbot.waitSignal(w.sig_clicked, timeout=1000):\n    qtbot.mouseRelease(w, Qt.LeftButton)\nassert w.get_tooltip() == 'tooltip'\nassert w.get_icon() == 'icon'\n",
        "CUT_1": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_2": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_3": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_4": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_5": "\"\"\"\n        Show a status message in the Spyder widget.\n        \"\"\"\nstatus_bar = self.statusBar()\nif status_bar.isVisible():\n    status_bar.showMessage(message, timeout)\n"
    },
    {
        "functionName": "test_status_bar_conda_interpreter_status",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_status.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "mocker.patch.object(spyder.widgets.status, 'is_conda_env', return_value=True)\nmock_py_ver = 'Python 6.6.6'\nwin, statusbar = status_bar\nw = InterpreterStatus(win, statusbar)\nout_or_err = mock_py_ver + ' (hello!)'\nfor out, err in [(out_or_err, ''), ('', out_or_err)]:\n    mocker.patch.object(w, '_get_interpreter_env_info', return_value=(out, err)\n        )\n    if os.name == 'nt':\n        interpreter = os.sep.join(['miniconda', 'python'])\n    else:\n        interpreter = os.sep.join(['miniconda', 'bin', 'python'])\n    w.update_interpreter(interpreter)\n    expected = 'conda: base (Python 6.6.6)'\n    assert w.get_tooltip() == interpreter\n    assert expected == w._process_interpreter_env_info()\n    if os.name == 'nt':\n        interpreter = os.sep.join(['miniconda', 'envs', 'foo', 'python'])\n    else:\n        interpreter = os.sep.join(['miniconda', 'envs', 'foo', 'bin', 'python']\n            )\n    w.update_interpreter(interpreter)\n    expected = 'conda: foo (Python 6.6.6)'\n    assert w.get_tooltip() == interpreter\n    assert expected == w._process_interpreter_env_info()\n",
        "CUT_1": "\"\"\"Exit interpreter\"\"\"\nself.interpreter.exit_flag = True\nif self.multithreaded:\n    self.interpreter.stdin_write.write(to_binary_string('\\n'))\nself.interpreter.restore_stds()\n",
        "CUT_2": "\"\"\"Exit interpreter\"\"\"\nself.interpreter.exit_flag = True\nif self.multithreaded:\n    self.interpreter.stdin_write.write(to_binary_string('\\n'))\nself.interpreter.restore_stds()\n",
        "CUT_3": "\"\"\"Start Python interpreter.\"\"\"\nself.clear()\nif self.interpreter is not None:\n    self.interpreter.closing()\nself.interpreter = Interpreter(namespace, self.exitfunc, SysOutput,\n    WidgetProxy, get_debug_level())\nself.interpreter.stdout_write.data_avail.connect(self.stdout_avail)\nself.interpreter.stderr_write.data_avail.connect(self.stderr_avail)\nself.interpreter.widget_proxy.sig_set_readonly.connect(self.setReadOnly)\nself.interpreter.widget_proxy.sig_new_prompt.connect(self.new_prompt)\nself.interpreter.widget_proxy.sig_edit.connect(self.edit_script)\nself.interpreter.widget_proxy.sig_wait_input.connect(self.wait_input)\nif self.multithreaded:\n    self.interpreter.start()\nbanner = create_banner(self.message)\nself.write(banner, prompt=True)\nfor cmd in self.commands:\n    self.run_command(cmd, history=False, new_prompt=False)\nself.new_prompt(self.interpreter.p1)\nself.sig_refreshed.emit()\nreturn self.interpreter\n",
        "CUT_4": "\"\"\"Start Python interpreter.\"\"\"\nself.clear()\nif self.interpreter is not None:\n    self.interpreter.closing()\nself.interpreter = Interpreter(namespace, self.exitfunc, SysOutput,\n    WidgetProxy, get_debug_level())\nself.interpreter.stdout_write.data_avail.connect(self.stdout_avail)\nself.interpreter.stderr_write.data_avail.connect(self.stderr_avail)\nself.interpreter.widget_proxy.sig_set_readonly.connect(self.setReadOnly)\nself.interpreter.widget_proxy.sig_new_prompt.connect(self.new_prompt)\nself.interpreter.widget_proxy.sig_edit.connect(self.edit_script)\nself.interpreter.widget_proxy.sig_wait_input.connect(self.wait_input)\nif self.multithreaded:\n    self.interpreter.start()\nbanner = create_banner(self.message)\nself.write(banner, prompt=True)\nfor cmd in self.commands:\n    self.run_command(cmd, history=False, new_prompt=False)\nself.new_prompt(self.interpreter.p1)\nself.sig_refreshed.emit()\nreturn self.interpreter\n",
        "CUT_5": "\"\"\"Simulate keyboard interrupt\"\"\"\nif self.multithreaded:\n    self.interpreter.raise_keyboard_interrupt()\nelif self.interpreter.more:\n    self.write_error('\\nKeyboardInterrupt\\n')\n    self.interpreter.more = False\n    self.new_prompt(self.interpreter.p1)\n    self.interpreter.resetbuffer()\nelse:\n    self.interrupted = True\n"
    },
    {
        "functionName": "test_status_bar_other_interpreter_status",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_status.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "mocker.patch.object(spyder.widgets.status, 'is_conda_env', return_value=False)\nwin, statusbar = status_bar\nw = InterpreterStatus(win, statusbar)\nmocker.patch.object(w, '_get_interpreter_env_info', return_value=(\n    'Python 3.6.6', ''))\ninterpreter = os.sep.join(['some-other', 'bin', 'python'])\nw.update_interpreter(interpreter)\nassert w.get_tooltip() == interpreter\nassert 'venv (Python 3.6.6)' == w._process_interpreter_env_info()\n",
        "CUT_1": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_2": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_3": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_4": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_5": "\"\"\"Start Python interpreter.\"\"\"\nself.clear()\nif self.interpreter is not None:\n    self.interpreter.closing()\nself.interpreter = Interpreter(namespace, self.exitfunc, SysOutput,\n    WidgetProxy, get_debug_level())\nself.interpreter.stdout_write.data_avail.connect(self.stdout_avail)\nself.interpreter.stderr_write.data_avail.connect(self.stderr_avail)\nself.interpreter.widget_proxy.sig_set_readonly.connect(self.setReadOnly)\nself.interpreter.widget_proxy.sig_new_prompt.connect(self.new_prompt)\nself.interpreter.widget_proxy.sig_edit.connect(self.edit_script)\nself.interpreter.widget_proxy.sig_wait_input.connect(self.wait_input)\nif self.multithreaded:\n    self.interpreter.start()\nbanner = create_banner(self.message)\nself.write(banner, prompt=True)\nfor cmd in self.commands:\n    self.run_command(cmd, history=False, new_prompt=False)\nself.new_prompt(self.interpreter.p1)\nself.sig_refreshed.emit()\nreturn self.interpreter\n"
    },
    {
        "functionName": "test_status_bar_internal_interpreter_status",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_status.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "mocker.patch.object(spyder.widgets.status, 'is_conda_env', return_value=False)\nmocker.patch.object(spyder.widgets.status, 'running_in_mac_app',\n    return_value=True)\nwin, statusbar = status_bar\nw = InterpreterStatus(win, statusbar)\nmocker.patch.object(w, '_get_interpreter_env_info', return_value=(\n    'Python 3.6.6', ''))\ninterpreter = os.sep.join(['Spyder.app', 'Contents', 'MacOS', 'Python'])\nw.update_interpreter(interpreter)\nassert w.get_tooltip() == interpreter\nassert 'internal (Python 3.6.6)' == w._process_interpreter_env_info()\npytest.mark.skipif(sys.platform != 'darwin', reason='Only valid on Mac')",
        "CUT_1": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_2": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (MemoryStatus, CPUStatus, ClockStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_3": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_4": "from qtpy.QtWidgets import QMainWindow\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=5)\nwin = QMainWindow()\nwin.setWindowTitle('Status widgets test')\nwin.resize(900, 300)\nstatusbar = win.statusBar()\nstatus_widgets = []\nfor status_class in (ReadWriteStatus, EOLStatus, EncodingStatus,\n    CursorPositionStatus):\n    status_widget = status_class(win, statusbar)\n    status_widgets.append(status_widget)\nwin.show()\napp.exec_()\n",
        "CUT_5": "\"\"\"Is text a valid object?\"\"\"\nreturn self.interpreter.eval(text)\n"
    },
    {
        "functionName": "messagecheckbox",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_helperwidgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up MessageCheckBox.\"\"\"\nwidget = MessageCheckBox()\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "test_messagecheckbox",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_helperwidgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run Message Checkbox.\"\"\"\nbox = messagecheckbox\nbox.setWindowTitle('Spyder updates')\nbox.setText('Testing checkbox')\nbox.set_checkbox_text('Check for updates on startup?')\nbox.setStandardButtons(QMessageBox.Ok)\nbox.setDefaultButton(QMessageBox.Ok)\nbox.setIcon(QMessageBox.Information)\nbox.show()\nassert box\n",
        "CUT_1": "\"\"\"\n        Create a textbox field.\n        \"\"\"\nif default is not None and len(default) > 30:\n    box = QtWidgets.QTextEdit(parent=self)\n    box.setText = box.setPlainText\n    box.text = box.toPlainText\nelse:\n    box = QtWidgets.QLineEdit(parent=self)\nbox.setting = setting\nif default is not None:\n    box.setText(default)\n    box.textChanged.connect(lambda x=None: self.render())\nbox.get_value = lambda : box.text()\nbox.set_value = lambda text: box.setText(text)\nreturn box\n",
        "CUT_2": "\"\"\"\n        Create a textbox field.\n        \"\"\"\nif default is not None and len(default) > 30:\n    box = QtWidgets.QTextEdit(parent=self)\n    box.setText = box.setPlainText\n    box.text = box.toPlainText\nelse:\n    box = QtWidgets.QLineEdit(parent=self)\nbox.setting = setting\nif default is not None:\n    box.setText(default)\n    box.textChanged.connect(lambda x=None: self.render())\nbox.get_value = lambda : box.text()\nbox.set_value = lambda text: box.setText(text)\nreturn box\n",
        "CUT_3": "\"\"\"Called by WorkerUpdates when ready\"\"\"\nfrom spyder.widgets.helperwidgets import MessageCheckBox\nfeedback = self.give_updates_feedback\nupdate_available = self.worker_updates.update_available\nlatest_release = self.worker_updates.latest_release\nerror_msg = self.worker_updates.error\nurl_r = __project_url__ + '/releases/tag/v{}'.format(latest_release)\nurl_i = 'https://docs.spyder-ide.org/installation.html'\nbox = MessageCheckBox(icon=QMessageBox.Information, parent=self)\nbox.setWindowTitle(_('New Spyder version'))\nbox.set_checkbox_text(_('Check for updates at startup'))\nbox.setStandardButtons(QMessageBox.Ok)\nbox.setDefaultButton(QMessageBox.Ok)\nsection, option = 'main', 'check_updates_on_startup'\ncheck_updates = CONF.get(section, option)\nbox.set_checked(check_updates)\nif error_msg is not None:\n    msg = error_msg\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nelif update_available:\n    header = _('<b>Spyder {} is available!</b><br><br>').format(latest_release)\n    footer = _(\n        'For more information visit our <a href=\"{}\">installation guide</a>.'\n        ).format(url_i)\n    if is_anaconda():\n        content = _(\n            \"<b>Important note:</b> Since you installed Spyder with Anaconda, please <b>don't</b> use <code>pip</code> to update it as that will break your installation.<br><br>Instead, run the following commands in a terminal:<br><code>conda update anaconda</code><br><code>conda install spyder={}</code><br><br>\"\n            ).format(latest_release)\n    else:\n        content = _(\n            'Please go to <a href=\"{}\">this page</a> to download it.<br><br>'\n            ).format(url_r)\n    msg = header + content + footer\n    box.setText(msg)\n    box.set_check_visible(True)\n    box.exec_()\n    check_updates = box.is_checked()\nelif feedback:\n    msg = _('Spyder is up to date.')\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nCONF.set(section, option, check_updates)\nself.check_updates_action.setDisabled(False)\nself.give_updates_feedback = True\n",
        "CUT_4": "\"\"\"Called by WorkerUpdates when ready\"\"\"\nfrom spyder.widgets.helperwidgets import MessageCheckBox\nfeedback = self.give_updates_feedback\nupdate_available = self.worker_updates.update_available\nlatest_release = self.worker_updates.latest_release\nerror_msg = self.worker_updates.error\nurl_r = __project_url__ + '/releases/tag/v{}'.format(latest_release)\nurl_i = 'https://docs.spyder-ide.org/installation.html'\nbox = MessageCheckBox(icon=QMessageBox.Information, parent=self)\nbox.setWindowTitle(_('New Spyder version'))\nbox.set_checkbox_text(_('Check for updates at startup'))\nbox.setStandardButtons(QMessageBox.Ok)\nbox.setDefaultButton(QMessageBox.Ok)\nsection, option = 'main', 'check_updates_on_startup'\ncheck_updates = CONF.get(section, option)\nbox.set_checked(check_updates)\nif error_msg is not None:\n    msg = error_msg\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nelif update_available:\n    header = _('<b>Spyder {} is available!</b><br><br>').format(latest_release)\n    footer = _(\n        'For more information visit our <a href=\"{}\">installation guide</a>.'\n        ).format(url_i)\n    if is_anaconda():\n        content = _(\n            \"<b>Important note:</b> Since you installed Spyder with Anaconda, please <b>don't</b> use <code>pip</code> to update it as that will break your installation.<br><br>Instead, run the following commands in a terminal:<br><code>conda update anaconda</code><br><code>conda install spyder={}</code><br><br>\"\n            ).format(latest_release)\n    else:\n        content = _(\n            'Please go to <a href=\"{}\">this page</a> to download it.<br><br>'\n            ).format(url_r)\n    msg = header + content + footer\n    box.setText(msg)\n    box.set_check_visible(True)\n    box.exec_()\n    check_updates = box.is_checked()\nelif feedback:\n    msg = _('Spyder is up to date.')\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nCONF.set(section, option, check_updates)\nself.check_updates_action.setDisabled(False)\nself.give_updates_feedback = True\n",
        "CUT_5": "\"\"\"\n        Report that either the transport layer or the LSP server are\n        down.\n        \"\"\"\nself.update_status(language, ClientStatus.DOWN)\nif not self.get_option('show_lsp_down_warning'):\n    return\nif os.name == 'nt':\n    os_message = (\n        'To try to fix this, please verify that your firewall or antivirus allows Python processes to open ports in your system, or restart Spyder.<br><br>'\n        )\nelse:\n    os_message = 'This problem could be fixed by restarting Spyder. '\nwarn_str = _(\n    'Completion and linting in the editor for {language} files will not work during the current session, or stopped working.<br><br>'\n    ).format(language=language.capitalize()) + os_message + _(\n    'Do you want to restart Spyder now?')\nbox = MessageCheckBox(icon=QMessageBox.Warning, parent=self.main)\nbox.setWindowTitle(_('Warning'))\nbox.set_checkbox_text(_(\"Don't show again\"))\nbox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\nbox.setDefaultButton(QMessageBox.No)\nbox.set_checked(False)\nbox.set_check_visible(True)\nbox.setText(warn_str)\nanswer = box.exec_()\nself.set_option('show_lsp_down_warning', not box.is_checked())\nif answer == QMessageBox.Yes:\n    self.main.restart()\nSlot(str)"
    },
    {
        "functionName": "findreplace_editor",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_findreplace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up PathManager.\"\"\"\neditor = CodeEditor()\neditor.setup_editor()\nwidget = FindReplace(None)\nwidget.set_editor(editor)\nqtbot.addWidget(widget)\nqtbot.addWidget(editor)\nreturn widget, editor\npytest.fixture",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Refresh widget and update find widget on current editor.\"\"\"\nif self.tabwidget.count():\n    editor = self.tabwidget.currentWidget()\nelse:\n    editor = None\nself.find_widget.set_editor(editor)\n",
        "CUT_4": "\"\"\"Refresh widget and update find widget on current editor.\"\"\"\nif self.tabwidget.count():\n    editor = self.tabwidget.currentWidget()\nelse:\n    editor = None\nself.find_widget.set_editor(editor)\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_findreplace_multiline_replacement",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_findreplace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test find replace widget for multiline regex replacements\n    See: spyder-ide/spyder#2675\n    \"\"\"\nexpected = \"\"\"\n\nhello world!\n\n\"\"\"\nfindreplace, editor = findreplace_editor\neditor.set_text(\"\"\"\n\nhello\n\n\nworld!\n\n\"\"\")\neditor.show()\nfindreplace.show()\nfindreplace.show_replace()\nfindreplace.re_button.setChecked(True)\nedit = findreplace.search_text.lineEdit()\nedit.clear()\nedit.setText('\\\\n\\\\n\\\\n')\nfindreplace.replace_text.setCurrentText(' ')\nqtbot.wait(1000)\nfindreplace.replace_find_all()\nqtbot.wait(1000)\nassert editor.toPlainText() == expected\n",
        "CUT_1": "label = QLabel(text)\nlabel.setWordWrap(word_wrap)\nedit = QLineEdit()\nedit.content_type = content_type\nlayout = QVBoxLayout() if alignment == Qt.Vertical else QHBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(edit)\nlayout.setContentsMargins(0, 0, 0, 0)\nif tip:\n    edit.setToolTip(tip)\nif regex:\n    edit.setValidator(QRegExpValidator(QRegExp(regex)))\nif placeholder:\n    edit.setPlaceholderText(placeholder)\nself.lineedits[edit] = section, option, default\nwidget = QWidget(self)\nwidget.label = label\nwidget.textbox = edit\nwidget.setLayout(layout)\nedit.restart_required = restart\nedit.label_text = text\nreturn widget\n",
        "CUT_2": "label = QLabel(text)\nlabel.setWordWrap(word_wrap)\nedit = QLineEdit()\nedit.content_type = content_type\nlayout = QVBoxLayout() if alignment == Qt.Vertical else QHBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(edit)\nlayout.setContentsMargins(0, 0, 0, 0)\nif tip:\n    edit.setToolTip(tip)\nif regex:\n    edit.setValidator(QRegExpValidator(QRegExp(regex)))\nif placeholder:\n    edit.setPlaceholderText(placeholder)\nself.lineedits[edit] = section, option, default\nwidget = QWidget(self)\nwidget.label = label\nwidget.textbox = edit\nwidget.setLayout(layout)\nedit.restart_required = restart\nedit.label_text = text\nreturn widget\n",
        "CUT_3": "QWidget.__init__(self, parent)\nself.editor = None\nself.editor = SimpleCodeEditor(self)\nself.editor.setup_editor(language='py', highlight_current_line=False,\n    linenumbers=False)\nself.editor.sig_focus_changed.connect(self.focus_changed)\nself.editor.setReadOnly(True)\nself.editor.setContextMenuPolicy(Qt.CustomContextMenu)\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.editor)\nself.find_widget.hide()\nlayout = QVBoxLayout()\nlayout.setContentsMargins(0, 0, 0, 0)\nlayout.addWidget(self.editor)\nlayout.addWidget(self.find_widget)\nself.setLayout(layout)\nself.editor.customContextMenuRequested.connect(self.\n    sig_custom_context_menu_requested)\n",
        "CUT_4": "QWidget.__init__(self, parent)\nself.editor = None\nself.editor = SimpleCodeEditor(self)\nself.editor.setup_editor(language='py', highlight_current_line=False,\n    linenumbers=False)\nself.editor.sig_focus_changed.connect(self.focus_changed)\nself.editor.setReadOnly(True)\nself.editor.setContextMenuPolicy(Qt.CustomContextMenu)\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.editor)\nself.find_widget.hide()\nlayout = QVBoxLayout()\nlayout.setContentsMargins(0, 0, 0, 0)\nlayout.addWidget(self.editor)\nlayout.addWidget(self.find_widget)\nself.setLayout(layout)\nself.editor.customContextMenuRequested.connect(self.\n    sig_custom_context_menu_requested)\n",
        "CUT_5": "label = QLabel(text)\nlabel.setWordWrap(True)\nedit = QPlainTextEdit()\nedit.content_type = content_type\nedit.setWordWrapMode(QTextOption.WordWrap)\nlayout = QVBoxLayout()\nlayout.addWidget(label)\nlayout.addWidget(edit)\nlayout.setContentsMargins(0, 0, 0, 0)\nif tip:\n    edit.setToolTip(tip)\nself.textedits[edit] = section, option, default\nwidget = QWidget(self)\nwidget.label = label\nwidget.textbox = edit\nwidget.setLayout(layout)\nedit.restart_required = restart\nedit.label_text = text\nreturn widget\n"
    },
    {
        "functionName": "test_replace_selection",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_findreplace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test find replace final selection in the editor.\n    For further information see spyder-ide/spyder#12745\n    \"\"\"\nexpected = \"\"\"Spyder is greit!\nSpyder is greit!\"\"\"\nfindreplace, editor = findreplace_editor\neditor.set_text(\"\"\"Spyder as great!\nSpyder as great!\"\"\")\neditor.show()\neditor.select_lines(0, 2)\nfindreplace.show()\nfindreplace.show_replace()\nedit = findreplace.search_text.lineEdit()\nedit.clear()\nedit.setText('a')\nfindreplace.replace_text.setCurrentText('i')\nfindreplace.replace_find_selection()\nqtbot.wait(1000)\nassert editor.get_selected_text() == expected\nassert len(editor.get_selected_text()) == len(expected)\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "self.editor.clear()\n",
        "CUT_4": "self.editor.clear()\n",
        "CUT_5": "QWidget.__init__(self, parent)\nself.editor = None\nself.editor = SimpleCodeEditor(self)\nself.editor.setup_editor(language='py', highlight_current_line=False,\n    linenumbers=False)\nself.editor.sig_focus_changed.connect(self.focus_changed)\nself.editor.setReadOnly(True)\nself.editor.setContextMenuPolicy(Qt.CustomContextMenu)\nself.find_widget = FindReplace(self)\nself.find_widget.set_editor(self.editor)\nself.find_widget.hide()\nlayout = QVBoxLayout()\nlayout.setContentsMargins(0, 0, 0, 0)\nlayout.addWidget(self.editor)\nlayout.addWidget(self.find_widget)\nself.setLayout(layout)\nself.editor.customContextMenuRequested.connect(self.\n    sig_custom_context_menu_requested)\n"
    },
    {
        "functionName": "mixinsbot",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_mixins.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "widget = BaseWidget()\nqtbot.addWidget(widget)\nwidget.show()\nreturn qtbot, widget\npytest.fixture",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "test_get_current_object",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_mixins.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that we can get the current object to get help for the console.\n\n    For spyder-ide/spyder#11821\n    \"\"\"\nqtbot, widget = mixinsbot\nget_current_object = widget.get_current_object\ncode, matches = test_object\nwidget.setPlainText(code)\ncursor = widget.textCursor()\ncursor.setPosition(widget.get_position('sof'))\nfor move, match in matches:\n    if move is not None:\n        widget.move_cursor(move)\n    current_word = get_current_object()\n    current_word == match\npytest.mark.parametrize('test_object', [('test.attr = np.linalg.norm()\\n',\n    [(None, 'test'), (4, 'test'), (1, 'test.attr'), (4, 'test.attr'), (1,\n    None), (1, 'np'), (4, 'np.linalg'), (6, 'np.linalg'), (1,\n    'np.linalg.norm'), (4, 'np.linalg.norm'), (1, None)]), (\n    \"\"\"test$attr = np$linalg$norm()\n\"\"\", [(None, 'test'), (4, 'test'), (1,\n    'test$attr'), (4, 'test$attr'), (1, None), (1, 'np'), (4, 'np$linalg'),\n    (6, 'np$linalg'), (1, 'np$linalg$norm'), (4, 'np$linalg$norm'), (1,\n    None)])])",
        "CUT_1": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_2": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n"
    },
    {
        "functionName": "test_get_current_word",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_mixins.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that we can get the current word to get help for the editor.\n\n    For spyder-ide/spyder#11267\n    \"\"\"\nqtbot, widget = mixinsbot\nget_current_word = widget.get_current_word\ncode = 'def foo(a, b, c)\\n'\nwidget.setPlainText(code)\ncursor = widget.textCursor()\ncursor.setPosition(widget.get_position('sof'))\nwidget.move_cursor(7)\ncurrent_word = get_current_word()\nassert current_word is None\ncurrent_word = get_current_word(help_req=True)\nassert current_word == 'foo'\n",
        "CUT_1": "\"\"\"\n        Update the displayed list.\n        \"\"\"\nif not self.is_position_correct():\n    self.hide()\n    return\ncurrent_word = self.textedit.get_current_word(completion=True)\nself.update_list(current_word, new=new)\n",
        "CUT_2": "\"\"\"\n        Update the displayed list.\n        \"\"\"\nif not self.is_position_correct():\n    self.hide()\n    return\ncurrent_word = self.textedit.get_current_word(completion=True)\nself.update_list(current_word, new=new)\n",
        "CUT_3": "\"\"\"Trigger completion.\"\"\"\ncursor = self.textCursor()\ncurrent_word = self.get_current_word(completion=True, valid_python_variable\n    =False)\nparams = {'file': self.filename, 'line': cursor.blockNumber(), 'column':\n    cursor.columnNumber(), 'offset': cursor.position(), 'selection_start':\n    cursor.selectionStart(), 'selection_end': cursor.selectionEnd(),\n    'current_word': current_word}\nself.completion_args = self.textCursor().position(), automatic\nreturn params\nrequest(method=LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_4": "\"\"\"Trigger completion.\"\"\"\ncursor = self.textCursor()\ncurrent_word = self.get_current_word(completion=True, valid_python_variable\n    =False)\nparams = {'file': self.filename, 'line': cursor.blockNumber(), 'column':\n    cursor.columnNumber(), 'offset': cursor.position(), 'selection_start':\n    cursor.selectionStart(), 'selection_end': cursor.selectionEnd(),\n    'current_word': current_word}\nself.completion_args = self.textCursor().position(), automatic\nreturn params\nrequest(method=LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_5": "\"\"\"\n        Return current object under cursor.\n\n        Get the text of the current word plus all the characters\n        to the left until a space is found. Used to get text to inspect\n        for Help of elements following dot notation for example\n        np.linalg.norm\n        \"\"\"\ncursor = self.textCursor()\ncursor_pos = cursor.position()\ncurrent_word = self.get_current_word(help_req=True)\ncursor.movePosition(QTextCursor.PreviousCharacter)\nwhile self.get_character(cursor.position()).strip():\n    cursor.movePosition(QTextCursor.PreviousCharacter)\n    if cursor.atBlockStart():\n        break\ncursor_pos_left = cursor.position()\ncursor.setPosition(cursor_pos)\nwhile self.get_character(cursor.position()).strip():\n    cursor.movePosition(QTextCursor.NextCharacter)\n    if cursor.atBlockEnd():\n        break\ncursor_pos_right = cursor.position()\ncurrent_text = self.get_text(cursor_pos_left, cursor_pos_right).strip()\ncurrent_object = current_word\nif current_text and current_word is not None:\n    if current_word != current_text and current_word in current_text:\n        current_object = current_text.split(current_word)[0] + current_word\nreturn current_object\n"
    },
    {
        "functionName": "test_get_unicode_regexp",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_mixins.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that we can search with regexp's containing unicode\n    characters.\n\n    For spyder-ide/spyder#6812.\n    \"\"\"\nqtbot, widget = mixinsbot\nget = widget.get_number_matches\ncode = \"\"\"print(\"\u0418\")\nfoo(\"\u0418\")\"\"\"\nwidget.setPlainText(code)\ncursor = widget.textCursor()\ncursor.setPosition(widget.get_position('sof'))\nassert widget.find_text('t.*\u0418', regexp=True)\nassert get('t.*\u0418', source_text=code, regexp=True) == 1\n",
        "CUT_1": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "\"\"\" \"\"\"\nfor widget in self.widgets:\n    widget.setDisabled(True)\n"
    },
    {
        "functionName": "test_get_number_matches",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_mixins.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, widget = mixinsbot\nget = widget.get_number_matches\ncode = \"\"\"class C():\n    def __init__(self):\n        pass\n    def f(self, a, b):\n        pass\n\"\"\"\nassert get('') == 0\nassert get('self', source_text=code) == 2\nassert get('c', source_text=code) == 2\nassert get('self', source_text=code, case=True) == 2\nassert get('c', source_text=code, case=True) == 1\nassert get('e[a-z]?f', source_text=code, regexp=True) == 4\nassert get('e[A-Z]?f', source_text=code, regexp=True) == 4\nassert get('e[a-z]?f', source_text=code, case=True, regexp=True) == 4\nassert get('e[A-Z]?f', source_text=code, case=True, regexp=True) == 2\nassert get('e[a-z]?f', source_text=code, regexp=True, word=True) == 0\nassert get('e[A-Z]?f', source_text=code, regexp=True, word=True) == 0\nassert get('e[a-z]?f', source_text=code, case=True, regexp=True, word=True\n    ) == 0\nassert get('e[A-Z]?f', source_text=code, case=True, regexp=True, word=True\n    ) == 0\nassert get('(', source_text=code) == 3\nassert get('(', source_text=code, case=True) == 3\nassert get('(', source_text=code, regexp=True) is None\nassert get('(', source_text=code, case=True, regexp=True) is None\nassert get('a', source_text=code) == 4\nassert get('a', source_text=code, case=True) == 4\nassert get('a', source_text=code, regexp=True) == 4\nassert get('a', source_text=code, case=True, regexp=True) == 4\nassert get('a', source_text=code, case=True, regexp=True, word=True) == 1\nassert get('a', source_text=code, regexp=True, word=True) == 1\nassert get('a', source_text=code, case=True, word=True) == 1\n",
        "CUT_1": "\"\"\"Get number of the match for the searched text.\"\"\"\nposition = self.textCursor().position()\nsource_text = self.get_text(position_from='sof', position_to=position)\nmatch_number = self.get_number_matches(pattern, source_text=source_text,\n    case=case, regexp=regexp, word=word)\nreturn match_number\n",
        "CUT_2": "\"\"\"Get number of the match for the searched text.\"\"\"\nposition = self.textCursor().position()\nsource_text = self.get_text(position_from='sof', position_to=position)\nmatch_number = self.get_number_matches(pattern, source_text=source_text,\n    case=case, regexp=regexp, word=word)\nreturn match_number\n",
        "CUT_3": "\"\"\"Set source text of the page. Callback for QWebEngineView.\"\"\"\nself.source_text = source_text\n",
        "CUT_4": "\"\"\"Set source text of the page. Callback for QWebEngineView.\"\"\"\nself.source_text = source_text\n",
        "CUT_5": "assert isinstance(code, int)\nif code == 0:\n    self.reset()\nelif code == 1:\n    self.intensity = 1\nelif code == 3:\n    self.italic = True\nelif code == 4:\n    self.underline = True\nelif code == 22:\n    self.intensity = 0\n    self.bold = False\nelif code == 23:\n    self.italic = False\nelif code == 24:\n    self.underline = False\nelif code >= 30 and code <= 37:\n    self.foreground_color = code\nelif code == 39:\n    self.foreground_color = self.default_foreground_color\nelif code >= 40 and code <= 47:\n    self.background_color = code\nelif code == 49:\n    self.background_color = self.default_background_color\nself.set_style()\n"
    },
    {
        "functionName": "test_get_match_number",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_mixins.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "qtbot, widget = mixinsbot\nget = widget.get_match_number\ncode = \"\"\"class C():\n    def __init__(self):\n        pass\n    def f(self, a, b):\n        pass\n\"\"\"\nwidget.setPlainText(code)\ncursor = widget.textCursor()\ncursor.setPosition(widget.get_position('sof'))\nassert get('') == 0\nwidget.find_text('(')\nassert get('(') == 1\nwidget.find_text('self')\nassert get('self') == 1\nassert get('self', case=True) == 1\nwidget.find_text('pass')\nwidget.find_text('self')\nassert get('self') == 2\nassert get('self', case=True) == 2\n",
        "CUT_1": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "for index in range(self.count()):\n    widget = self._stack.widget(index)\n    if widget:\n        widget.setup({option: value})\n        self.update_actions()\n"
    },
    {
        "functionName": "test_get_number_with_words",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_mixins.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that find count honours the word setting.\n\n    Dedicated test for spyder-ide/spyder#7960.\n    \"\"\"\nqtbot, widget = mixinsbot\ngetn = widget.get_number_matches\ngetm = widget.get_match_number\ncode = \"\"\"word\nwords\nWord\nWords\nsword\nword\n\"\"\"\nwidget.setPlainText(code)\ncursor = widget.textCursor()\ncursor.setPosition(widget.get_position('sof'))\nwidget.find_text('Word')\nassert getn('Word', source_text=code) == 6\nassert getm('Word') == 1\nassert getn('Word', source_text=code, case=True) == 2\nassert getn('Word', source_text=code, word=True) == 3\nassert getn('Word', source_text=code, word=True, case=True) == 1\nwidget.find_text('Word', case=True)\nassert getm('Word', case=True) == 1\nassert getm('Word') == 3\nassert getm('Word', word=True) == 2\nwidget.find_text('Words')\nwidget.find_text('Word', word=True)\nassert getm('Word') == 6\nassert getm('Word', word=True) == 3\n",
        "CUT_1": "\"\"\"Return word at *coordinates* (QPoint).\"\"\"\ncursor = self.cursorForPosition(coordinates)\ncursor.select(QTextCursor.WordUnderCursor)\nif self._is_point_inside_word_rect(coordinates):\n    word = to_text_string(cursor.selectedText())\nelse:\n    word = ''\nreturn word\n",
        "CUT_2": "\"\"\"Return word at *coordinates* (QPoint).\"\"\"\ncursor = self.cursorForPosition(coordinates)\ncursor.select(QTextCursor.WordUnderCursor)\nif self._is_point_inside_word_rect(coordinates):\n    word = to_text_string(cursor.selectedText())\nelse:\n    word = ''\nreturn word\n",
        "CUT_3": "\"\"\"Get number of the match for the searched text.\"\"\"\nposition = self.textCursor().position()\nsource_text = self.get_text(position_from='sof', position_to=position)\nmatch_number = self.get_number_matches(pattern, source_text=source_text,\n    case=case, regexp=regexp, word=word)\nreturn match_number\n",
        "CUT_4": "\"\"\"Get number of the match for the searched text.\"\"\"\nposition = self.textCursor().position()\nsource_text = self.get_text(position_from='sof', position_to=position)\nmatch_number = self.get_number_matches(pattern, source_text=source_text,\n    case=case, regexp=regexp, word=word)\nreturn match_number\n",
        "CUT_5": "\"\"\"Highlight found results\"\"\"\nif self.is_code_editor and self.highlight_button.isChecked():\n    text = self.search_text.currentText()\n    case = self.case_button.isChecked()\n    word = self.words_button.isChecked()\n    regexp = self.re_button.isChecked()\n    self.editor.highlight_found_results(text, word=word, regexp=regexp,\n        case=case)\n"
    },
    {
        "functionName": "browser",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_browser.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up WebBrowser.\"\"\"\nwidget = WebBrowser()\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "import webbrowser\ntry:\n    webbrowser.open(to_text_string(self.url().toString()))\nexcept ValueError:\n    pass\n",
        "CUT_2": "import webbrowser\ntry:\n    webbrowser.open(to_text_string(self.url().toString()))\nexcept ValueError:\n    pass\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_5": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n"
    },
    {
        "functionName": "test_browser",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_browser.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Run web browser.\"\"\"\nbrowser.set_home_url('https://www.google.com/')\nbrowser.go_home()\nbrowser.show()\nassert browser\n",
        "CUT_1": "\"\"\"Run web browser\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\nwidget = WebBrowser()\nwidget.show()\nwidget.set_home_url('https://www.google.com/')\nwidget.go_home()\nsys.exit(app.exec_())\n",
        "CUT_2": "\"\"\"Run web browser\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication(test_time=8)\nwidget = WebBrowser()\nwidget.show()\nwidget.set_home_url('https://www.google.com/')\nwidget.go_home()\nsys.exit(app.exec_())\n",
        "CUT_3": "\"\"\"Open Spyder Google Group in a web browser.\"\"\"\nurl = QUrl(__forum_url__)\nQDesktopServices.openUrl(url)\nSlot()",
        "CUT_4": "\"\"\"Open Spyder Google Group in a web browser.\"\"\"\nurl = QUrl(__forum_url__)\nQDesktopServices.openUrl(url)\nSlot()",
        "CUT_5": "\"\"\"Set namespace browser widget\"\"\"\nself.namespacebrowser = namespacebrowser\n"
    },
    {
        "functionName": "data",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return cm.data(cm.index(i, j))\n",
        "CUT_1": "finfo.editor.oe_proxy = None\nindex = 0 if add_where == 'start' else len(self.data)\nself.data.insert(index, finfo)\nindex = self.data.index(finfo)\neditor = finfo.editor\nself.tabs.insertTab(index, editor, self.get_tab_text(index))\nself.set_stack_title(index, False)\nif set_current:\n    self.set_stack_index(index)\n    self.current_changed(index)\nself.update_actions()\n",
        "CUT_2": "finfo.editor.oe_proxy = None\nindex = 0 if add_where == 'start' else len(self.data)\nself.data.insert(index, finfo)\nindex = self.data.index(finfo)\neditor = finfo.editor\nself.tabs.insertTab(index, editor, self.get_tab_text(index))\nself.set_stack_title(index, False)\nif set_current:\n    self.set_stack_index(index)\n    self.current_changed(index)\nself.update_actions()\n",
        "CUT_3": "if index.isValid():\n    return index.model().get_value(index)\n",
        "CUT_4": "if index.isValid():\n    return index.model().get_value(index)\n",
        "CUT_5": "\"\"\"Return a data element\"\"\"\nreturn to_qvariant(self._data[index.row()][index.column()])\n"
    },
    {
        "functionName": "data_table",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return [[data(cm, i, j) for i in range(n_rows)] for j in range(n_cols)]\n",
        "CUT_1": "for i in range(3):\n    print(i)\n",
        "CUT_2": "for i in range(3):\n    print(i)\n",
        "CUT_3": "for i in range(3):\n    print(i)\n",
        "CUT_4": "for i in range(3):\n    print(i)\n",
        "CUT_5": "for i in range(3):\n    print(i)\n"
    },
    {
        "functionName": "__init__",
        "className": "MockParent",
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "super(QWidget, self).__init__(None)\nself.proxy_model = None\n",
        "CUT_1": "QTableView.__init__(self, parent)\nself.array_filename = None\nself.menu = None\nself.empty_ws_menu = None\nself.paste_action = None\nself.copy_action = None\nself.edit_action = None\nself.plot_action = None\nself.hist_action = None\nself.imshow_action = None\nself.save_array_action = None\nself.insert_action = None\nself.insert_action_above = None\nself.insert_action_below = None\nself.remove_action = None\nself.minmax_action = None\nself.rename_action = None\nself.duplicate_action = None\nself.last_regex = ''\nself.view_action = None\nself.delegate = None\nself.proxy_model = None\nself.source_model = None\nself.setAcceptDrops(True)\nself.automatic_column_width = True\nself.setHorizontalHeader(BaseHeaderView(parent=self))\nself.horizontalHeader().sig_user_resized_section.connect(self.\n    user_resize_columns)\n",
        "CUT_2": "QTableView.__init__(self, parent)\nself.array_filename = None\nself.menu = None\nself.empty_ws_menu = None\nself.paste_action = None\nself.copy_action = None\nself.edit_action = None\nself.plot_action = None\nself.hist_action = None\nself.imshow_action = None\nself.save_array_action = None\nself.insert_action = None\nself.insert_action_above = None\nself.insert_action_below = None\nself.remove_action = None\nself.minmax_action = None\nself.rename_action = None\nself.duplicate_action = None\nself.last_regex = ''\nself.view_action = None\nself.delegate = None\nself.proxy_model = None\nself.source_model = None\nself.setAcceptDrops(True)\nself.automatic_column_width = True\nself.setHorizontalHeader(BaseHeaderView(parent=self))\nself.horizontalHeader().sig_user_resized_section.connect(self.\n    user_resize_columns)\n",
        "CUT_3": "QTableView.__init__(self, parent)\nself._parent = parent\nself.finder = None\nself.shortcut_data = None\nself.source_model = ShortcutsModel(self, text_color=text_color,\n    text_color_highlight=text_color_highlight)\nself.proxy_model = ShortcutsSortFilterProxy(self)\nself.last_regex = ''\nself.proxy_model.setSourceModel(self.source_model)\nself.proxy_model.setDynamicSortFilter(True)\nself.proxy_model.setFilterByColumn(CONTEXT)\nself.proxy_model.setFilterByColumn(NAME)\nself.proxy_model.setFilterCaseSensitivity(Qt.CaseInsensitive)\nself.setModel(self.proxy_model)\nself.hideColumn(SEARCH_SCORE)\nself.setItemDelegateForColumn(NAME, HTMLDelegate(self, margin=9))\nself.setItemDelegateForColumn(CONTEXT, HTMLDelegate(self, margin=9))\nself.setSelectionBehavior(QAbstractItemView.SelectRows)\nself.setSelectionMode(QAbstractItemView.SingleSelection)\nself.setSortingEnabled(True)\nself.setEditTriggers(QAbstractItemView.AllEditTriggers)\nself.selectionModel().selectionChanged.connect(self.selection)\nself.verticalHeader().hide()\n",
        "CUT_4": "QTableView.__init__(self, parent)\nself._parent = parent\nself.finder = None\nself.shortcut_data = None\nself.source_model = ShortcutsModel(self, text_color=text_color,\n    text_color_highlight=text_color_highlight)\nself.proxy_model = ShortcutsSortFilterProxy(self)\nself.last_regex = ''\nself.proxy_model.setSourceModel(self.source_model)\nself.proxy_model.setDynamicSortFilter(True)\nself.proxy_model.setFilterByColumn(CONTEXT)\nself.proxy_model.setFilterByColumn(NAME)\nself.proxy_model.setFilterCaseSensitivity(Qt.CaseInsensitive)\nself.setModel(self.proxy_model)\nself.hideColumn(SEARCH_SCORE)\nself.setItemDelegateForColumn(NAME, HTMLDelegate(self, margin=9))\nself.setItemDelegateForColumn(CONTEXT, HTMLDelegate(self, margin=9))\nself.setSelectionBehavior(QAbstractItemView.SelectRows)\nself.setSelectionMode(QAbstractItemView.SingleSelection)\nself.setSortingEnabled(True)\nself.setEditTriggers(QAbstractItemView.AllEditTriggers)\nself.selectionModel().selectionChanged.connect(self.selection)\nself.verticalHeader().hide()\n",
        "CUT_5": "QWidget.__init__(self, parent)\nself.shellwidget = None\nself.is_visible = True\nself.setup_in_progress = None\nself.check_all = None\nself.exclude_private = None\nself.exclude_uppercase = None\nself.exclude_capitalized = None\nself.exclude_unsupported = None\nself.exclude_callables_and_modules = None\nself.excluded_names = None\nself.minmax = None\nself.dataframe_format = None\nself.show_callable_attributes = None\nself.show_special_attributes = None\nself.editor = None\nself.exclude_private_action = None\nself.exclude_uppercase_action = None\nself.exclude_capitalized_action = None\nself.exclude_unsupported_action = None\nself.exclude_callables_and_modules_action = None\nself.finder = None\nself.options_button = options_button\nself.actions = None\nself.plugin_actions = plugin_actions\nself.filename = None\n"
    },
    {
        "functionName": "nonsettable_objects_data",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Rturn Python objects with immutable attribs to test CollectionEditor.\"\"\"\ntest_objs = [pandas.Period('2018-03'), pandas.Categorical([1, 2, 42])]\nexpected_objs = [pandas.Period('2018-03'), pandas.Categorical([1, 2, 42])]\nkeys_test = [['_typ', 'day', 'dayofyear', 'hour'], ['_typ', 'nbytes', 'ndim']]\nreturn zip(test_objs, expected_objs, keys_test)\npytest.fixture",
        "CUT_1": "\"\"\"Return True if variable is a DataFrame\"\"\"\ntry:\n    from pandas import DataFrame\n    return isinstance(var, DataFrame)\nexcept:\n    return False\n",
        "CUT_2": "\"\"\"Return True if variable is a Series\"\"\"\ntry:\n    from pandas import Series\n    return isinstance(var, Series)\nexcept:\n    return False\n",
        "CUT_3": "\"\"\"Return array's ndim\"\"\"\ndata = self.source_model.get_data()\nreturn data[key].ndim\n",
        "CUT_4": "\"\"\"Return array's ndim\"\"\"\ndata = self.source_model.get_data()\nreturn data[key].ndim\n",
        "CUT_5": "return Document(DOC_URI, workspace, DOC)\npytest.fixture"
    },
    {
        "functionName": "test_rename_variable",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test renaming of the correct variable.\"\"\"\nvariables = {'a': 1, 'b': 2, 'c': 3, 'd': '4', 'e': 5}\neditor = CollectionsEditorTableView(None, variables.copy())\nqtbot.addWidget(editor)\neditor.setCurrentIndex(editor.model.index(1, 0))\neditor.rename_item(new_name='b2')\nassert editor.model.rowCount() == 5\nassert data(editor.model, 0, 0) == 'a'\nassert data(editor.model, 1, 0) == 'b2'\nassert data(editor.model, 2, 0) == 'c'\nassert data(editor.model, 3, 0) == 'd'\nassert data(editor.model, 4, 0) == 'e'\nnew_variables = {'a': 1, 'b': 2, 'b2': 2, 'c': 3, 'd': '4', 'e': 5}\neditor.set_data(new_variables.copy())\neditor.adjust_columns()\neditor.setCurrentIndex(editor.model.index(1, 0))\neditor.rename_item(new_name='b3')\nassert editor.model.rowCount() == 6\nassert data(editor.model, 0, 0) == 'a'\nassert data(editor.model, 1, 0) == 'b2'\nassert data(editor.model, 2, 0) == 'b3'\nassert data(editor.model, 3, 0) == 'c'\nassert data(editor.model, 4, 0) == 'd'\nassert data(editor.model, 5, 0) == 'e'\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Set data.\"\"\"\nif data != self.editor.source_model.get_data():\n    self.editor.set_data(data)\n    self.editor.adjust_columns()\n",
        "CUT_4": "\"\"\"Set data.\"\"\"\nif data != self.editor.source_model.get_data():\n    self.editor.set_data(data)\n    self.editor.adjust_columns()\n",
        "CUT_5": "\"\"\"Set model data\"\"\"\nreturn False\n"
    },
    {
        "functionName": "test_remove_variable",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test removing of the correct variable.\"\"\"\nvariables = {'a': 1, 'b': 2, 'c': 3, 'd': '4', 'e': 5}\neditor = CollectionsEditorTableView(None, variables.copy())\nqtbot.addWidget(editor)\neditor.setCurrentIndex(editor.model.index(1, 0))\neditor.remove_item(force=True)\nassert editor.model.rowCount() == 4\nassert data(editor.model, 0, 0) == 'a'\nassert data(editor.model, 1, 0) == 'c'\nassert data(editor.model, 2, 0) == 'd'\nassert data(editor.model, 3, 0) == 'e'\neditor.set_data(variables.copy())\neditor.adjust_columns()\neditor.setCurrentIndex(editor.model.index(1, 0))\neditor.remove_item(force=True)\nassert editor.model.rowCount() == 4\nassert data(editor.model, 0, 0) == 'a'\nassert data(editor.model, 1, 0) == 'c'\nassert data(editor.model, 2, 0) == 'd'\nassert data(editor.model, 3, 0) == 'e'\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Set data.\"\"\"\nif data != self.editor.source_model.get_data():\n    self.editor.set_data(data)\n    self.editor.adjust_columns()\n",
        "CUT_4": "\"\"\"Set data.\"\"\"\nif data != self.editor.source_model.get_data():\n    self.editor.set_data(data)\n    self.editor.adjust_columns()\n",
        "CUT_5": "\"\"\"Create editor widget\"\"\"\nmodel = index.model()\nvalue = model.get_value(index)\nif model._data.dtype.name == 'bool':\n    value = not value\n    model.setData(index, to_qvariant(value))\n    return\nelif value is not np.ma.masked:\n    editor = QLineEdit(parent)\n    editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n    editor.setAlignment(Qt.AlignCenter)\n    if is_number(self.dtype):\n        validator = QDoubleValidator(editor)\n        validator.setLocale(QLocale('C'))\n        editor.setValidator(validator)\n    editor.returnPressed.connect(self.commitAndCloseEditor)\n    return editor\n"
    },
    {
        "functionName": "test_remove_remote_variable",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the removing of the correct remote variable.\"\"\"\nvariables = {'a': {'type': 'int', 'size': 1, 'color': '#0000ff', 'view':\n    '1'}, 'b': {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '2'},\n    'c': {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '3'}, 'd':\n    {'type': 'str', 'size': 1, 'color': '#800000', 'view': '4'}, 'e': {\n    'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '5'}}\neditor = RemoteCollectionsEditorTableView(None, variables.copy())\nqtbot.addWidget(editor)\neditor.setCurrentIndex(editor.model.index(1, 0))\ndef remove_values(ins, names):\n    assert names == ['b']\n    data = {'a': {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '1'\n        }, 'c': {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '3'},\n        'd': {'type': 'str', 'size': 1, 'color': '#800000', 'view': '4'},\n        'e': {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '5'}}\n    editor.set_data(data)\nmonkeypatch.setattr(\n    'spyder.widgets.collectionseditor.RemoteCollectionsEditorTableView.remove_values'\n    , remove_values)\neditor.remove_item(force=True)\nassert editor.model.rowCount() == 4\nassert data(editor.model, 0, 0) == 'a'\nassert data(editor.model, 1, 0) == 'c'\nassert data(editor.model, 2, 0) == 'd'\nassert data(editor.model, 3, 0) == 'e'\neditor.set_data(variables.copy())\neditor.adjust_columns()\neditor.setCurrentIndex(editor.model.index(1, 0))\neditor.remove_item(force=True)\nassert editor.model.rowCount() == 4\nassert data(editor.model, 0, 0) == 'a'\nassert data(editor.model, 1, 0) == 'c'\nassert data(editor.model, 2, 0) == 'd'\nassert data(editor.model, 3, 0) == 'e'\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Set data.\"\"\"\nif data != self.editor.source_model.get_data():\n    self.editor.set_data(data)\n    self.editor.adjust_columns()\n",
        "CUT_4": "\"\"\"Set data.\"\"\"\nif data != self.editor.source_model.get_data():\n    self.editor.set_data(data)\n    self.editor.adjust_columns()\n",
        "CUT_5": "\"\"\"Set editor widget's data\"\"\"\ntext = from_qvariant(index.model().data(index, Qt.DisplayRole), str)\neditor.setText(text)\n"
    },
    {
        "functionName": "remove_values",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert names == ['b']\ndata = {'a': {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '1'},\n    'c': {'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '3'}, 'd':\n    {'type': 'str', 'size': 1, 'color': '#800000', 'view': '4'}, 'e': {\n    'type': 'int', 'size': 1, 'color': '#0000ff', 'view': '5'}}\neditor.set_data(data)\n",
        "CUT_1": "\"\"\"\n        Return the namespace view\n\n        This is a dictionary with the following structure\n\n        {'a': {'color': '#800000', 'size': 1, 'type': 'str', 'view': '1'}}\n\n        Here:\n        * 'a' is the variable name\n        * 'color' is the color used to show it\n        * 'size' and 'type' are self-evident\n        * and'view' is its value or the text shown in the last column\n        \"\"\"\nfrom spyder_kernels.utils.nsview import make_remote_view\nsettings = self.namespace_view_settings\nif settings:\n    ns = self._get_current_namespace()\n    view = make_remote_view(ns, settings, EXCLUDED_NAMES)\n    return view\nelse:\n    return None\n",
        "CUT_2": "\"\"\"Sets the foreground color.\n        :param color: Color\n        :type color: QtGui.QColor\n        \"\"\"\nself.format.setForeground(color)\n",
        "CUT_3": "\"\"\"Sets the foreground color.\n        :param color: Color\n        :type color: QtGui.QColor\n        \"\"\"\nself.format.setForeground(color)\n",
        "CUT_4": "\"\"\"Override Qt method\"\"\"\npainter = QPainter(self)\nsize = self.size()\ncolor = QColor(self.color)\ncolor.setAlphaF(0.5)\npainter.setPen(color)\nfor column in self.columns:\n    x = self.editor.fontMetrics().width(column * '9')\n    painter.drawLine(x, 0, x, size.height())\n",
        "CUT_5": "\"\"\"Override Qt method\"\"\"\npainter = QPainter(self)\nsize = self.size()\ncolor = QColor(self.color)\ncolor.setAlphaF(0.5)\npainter.setPen(color)\nfor column in self.columns:\n    x = self.editor.fontMetrics().width(column * '9')\n    painter.drawLine(x, 0, x, size.height())\n"
    },
    {
        "functionName": "test_filter_rows",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test rows filtering.\"\"\"\ndata = {'dfa': {'type': 'DataFrame', 'size': (2, 1), 'color': '#00ff00',\n    'view': 'Column names: 0'}, 'dfb': {'type': 'DataFrame', 'size': (2, 1),\n    'color': '#00ff00', 'view': 'Column names: 0'}}\neditor = RemoteCollectionsEditorTableView(None, data)\neditor.finder = NamespacesBrowserFinder(editor, editor.set_regex)\nqtbot.addWidget(editor)\nassert editor.model.rowCount() == 2\neditor.finder.setText('df')\nassert editor.model.rowCount() == 2\neditor.finder.setText('DataFrame')\nassert editor.model.rowCount() == 2\neditor.finder.setText('dfb')\nassert editor.model.rowCount() == 1\neditor.finder.setText('dfbc')\nassert editor.model.rowCount() == 0\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Set editor widget's data\"\"\"\ntext = from_qvariant(index.model().data(index, Qt.DisplayRole), str)\neditor.setText(text)\n",
        "CUT_4": "\"\"\"Set editor widget's data\"\"\"\ntext = from_qvariant(index.model().data(index, Qt.DisplayRole), str)\neditor.setText(text)\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_create_dataframeeditor_with_correct_format",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "MockDataFrameEditor = Mock()\nmockDataFrameEditor_instance = MockDataFrameEditor()\nmonkeypatch.setattr(\n    'spyder.plugins.variableexplorer.widgets.collectionsdelegate.DataFrameEditor'\n    , MockDataFrameEditor)\ndf = pandas.DataFrame(['foo', 'bar'])\neditor = CollectionsEditorTableView(None, {'df': df})\nqtbot.addWidget(editor)\neditor.set_dataframe_format('%10d')\neditor.delegate.createEditor(None, None, editor.model.index(0, 3))\nmockDataFrameEditor_instance.dataModel.set_format.assert_called_once_with(\n    '%10d')\n",
        "CUT_1": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_2": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_3": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_4": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "test_accept_sig_option_changed_from_dataframeeditor",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "df = pandas.DataFrame(['foo', 'bar'])\neditor = CollectionsEditorTableView(None, {'df': df})\nqtbot.addWidget(editor)\neditor.set_dataframe_format('%10d')\nassert editor.source_model.dataframe_format == '%10d'\neditor.delegate.createEditor(None, None, editor.model.index(0, 3))\ndataframe_editor = next(iter(editor.delegate._editors.values()))['editor']\nqtbot.addWidget(dataframe_editor)\ndataframe_editor.sig_option_changed.emit('dataframe_format', '%5f')\nassert editor.source_model.dataframe_format == '%5f'\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_4": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n",
        "CUT_5": "\"\"\"Set data.\"\"\"\nif data != self.editor.source_model.get_data():\n    self.editor.set_data(data)\n    self.editor.adjust_columns()\n"
    },
    {
        "functionName": "test_collectionsmodel_with_two_ints",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coll = {'x': 1, 'y': 2}\ncm = CollectionsModel(MockParent(), coll)\nassert cm.rowCount() == 2\nassert cm.columnCount() == 4\nassert data(cm, 0, 0) in {'x', 'y'}\nif data(cm, 0, 0) == 'x':\n    row_with_x = 0\n    row_with_y = 1\nelse:\n    row_with_x = 1\n    row_with_y = 0\nassert data(cm, row_with_x, 1) == 'int'\nassert data(cm, row_with_x, 2) == 1\nassert data(cm, row_with_x, 3) == '1'\nassert data(cm, row_with_y, 0) == 'y'\nassert data(cm, row_with_y, 1) == 'int'\nassert data(cm, row_with_y, 2) == 1\nassert data(cm, row_with_y, 3) == '2'\n",
        "CUT_1": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_2": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_3": "\"\"\"\n        Set breakpoint data on widget.\n\n        Parameters\n        ----------\n        data: dict, optional\n            Breakpoint data to use. If None, data from the configuration\n            will be loaded. Default is None.\n        \"\"\"\nif data is None:\n    data = self._load_data()\nself.get_widget().set_data(data)\n",
        "CUT_4": "\"\"\"\n        Set breakpoint data on widget.\n\n        Parameters\n        ----------\n        data: dict, optional\n            Breakpoint data to use. If None, data from the configuration\n            will be loaded. Default is None.\n        \"\"\"\nif data is None:\n    data = self._load_data()\nself.get_widget().set_data(data)\n",
        "CUT_5": "if self.data:\n    return self.data[self.get_stack_index()]\n"
    },
    {
        "functionName": "test_collectionsmodel_with_index",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "for rng_name, rng in generate_pandas_indexes().items():\n    coll = {'rng': rng}\n    cm = CollectionsModel(MockParent(), coll)\n    assert data(cm, 0, 0) == 'rng'\n    assert data(cm, 0, 1) == rng_name\n    assert data(cm, 0, 2) == '(20,)' or data(cm, 0, 2) == '(20L,)'\ntry:\n    assert data(cm, 0, 3) == rng._summary()\nexcept AttributeError:\n    assert data(cm, 0, 3) == rng.summary()\n",
        "CUT_1": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_2": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_3": "\"\"\"\n        Set breakpoint data on widget.\n\n        Parameters\n        ----------\n        data: dict, optional\n            Breakpoint data to use. If None, data from the configuration\n            will be loaded. Default is None.\n        \"\"\"\nif data is None:\n    data = self._load_data()\nself.get_widget().set_data(data)\n",
        "CUT_4": "\"\"\"\n        Set breakpoint data on widget.\n\n        Parameters\n        ----------\n        data: dict, optional\n            Breakpoint data to use. If None, data from the configuration\n            will be loaded. Default is None.\n        \"\"\"\nif data is None:\n    data = self._load_data()\nself.get_widget().set_data(data)\n",
        "CUT_5": "\"\"\"Create new value in data\"\"\"\ndata = self.source_model.get_data()\ndata[key] = value\nself.set_data(data)\n"
    },
    {
        "functionName": "test_shows_dataframeeditor_when_editing_index",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "for rng_name, rng in generate_pandas_indexes().items():\n    MockDataFrameEditor = Mock()\n    mockDataFrameEditor_instance = MockDataFrameEditor()\n    monkeypatch.setattr(\n        'spyder.plugins.variableexplorer.widgets.collectionsdelegate.DataFrameEditor'\n        , MockDataFrameEditor)\n    coll = {'rng': rng}\n    editor = CollectionsEditorTableView(None, coll)\n    editor.delegate.createEditor(None, None, editor.model.index(0, 3))\n    mockDataFrameEditor_instance.show.assert_called_once_with()\n",
        "CUT_1": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture",
        "CUT_5": "\"\"\"Overriding method createEditor\"\"\"\nval_type = index.sibling(index.row(), 1).data()\nself.sig_open_editor.emit()\nif index.column() < 3:\n    return None\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    if value is None:\n        return None\nexcept ImportError as msg:\n    self.sig_editor_shown.emit()\n    module = str(msg).split(\"'\")[1]\n    if module in ['pandas', 'numpy']:\n        if module == 'numpy':\n            val_type = 'array'\n        else:\n            val_type = 'dataframe, series'\n        message = _(\n            \"Spyder is unable to show the {val_type} or object you're trying to view because <tt>{module}</tt> is not installed. \"\n            )\n        if running_in_mac_app():\n            message += _(\n                'Please consider using the full version of the Spyder MacOS application.<br>'\n                )\n        else:\n            message += _(\n                'Please install this package in your Spyder environment.<br>')\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            val_type=val_type, module=module))\n        return\n    else:\n        message = _(\n            \"Spyder is unable to show the variable you're trying to view because the module <tt>{module}</tt> is not \"\n            )\n        if running_in_mac_app():\n            message += _('supported in the Spyder MacOS application.<br>')\n        else:\n            message += _(\n                'found in your Spyder environment. Please install this package in your Spyder environment.<br>'\n                )\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            module=module))\n        return\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br>%s'\n        ) % to_text_string(msg))\n    return\nkey = index.model().get_key(index)\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)) and not object_explorer:\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)\n    ) and ndarray is not FakeObject and not object_explorer:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject and not object_explorer:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject and not object_explorer:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n            try:\n                value.time()\n            except ValueError:\n                self.sig_editor_shown.emit()\n                return None\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        self.sig_editor_shown.emit()\n        return editor\nelif is_text_string(value) and len(value) > 40 and not object_explorer:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        self.sig_editor_shown.emit()\n        return editor\nelse:\n    show_callable_attributes = index.model().show_callable_attributes\n    show_special_attributes = index.model().show_special_attributes\n    dataframe_format = index.model().dataframe_format\n    if show_callable_attributes is None:\n        show_callable_attributes = False\n    if show_special_attributes is None:\n        show_special_attributes = False\n    from spyder.plugins.variableexplorer.widgets.objectexplorer import ObjectExplorer\n    editor = ObjectExplorer(value, name=key, parent=parent,\n        show_callable_attributes=show_callable_attributes,\n        show_special_attributes=show_special_attributes, dataframe_format=\n        dataframe_format, readonly=readonly)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\n"
    },
    {
        "functionName": "test_sort_numpy_numeric_collectionsmodel",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "var_list = [numpy.float64(1e+16), numpy.float64(10), numpy.float64(1),\n    numpy.float64(0.1), numpy.float64(1e-06), numpy.float64(0), numpy.\n    float64(-1e-06), numpy.float64(-1), numpy.float64(-10), numpy.float64(-\n    1e+16)]\ncm = CollectionsModel(MockParent(), var_list)\nassert cm.rowCount() == 10\nassert cm.columnCount() == 4\ncm.sort(0)\nassert data_table(cm, 10, 4) == [list(range(0, 10)), ['float64'] * 10, [1] *\n    10, ['1e+16', '10.0', '1.0', '0.1', '1e-06', '0.0', '-1e-06', '-1.0',\n    '-10.0', '-1e+16']]\ncm.sort(3)\nassert data_table(cm, 10, 4) == [list(range(9, -1, -1)), ['float64'] * 10, \n    [1] * 10, ['-1e+16', '-10.0', '-1.0', '-1e-06', '0.0', '1e-06', '0.1',\n    '1.0', '10.0', '1e+16']]\n",
        "CUT_1": "\"\"\"Return True if variable is a NumPy array\"\"\"\ntry:\n    import numpy\n    return isinstance(var, numpy.ndarray)\nexcept:\n    return False\n",
        "CUT_2": "\"\"\"Return True if variable is a numpy array\"\"\"\nraise NotImplementedError\n",
        "CUT_3": "\"\"\"Return True if variable is a numpy array\"\"\"\nraise NotImplementedError\n",
        "CUT_4": "\"\"\"Return NumPy data type associated to obj\n    Return None if NumPy is not available\n    or if obj is not a NumPy array or scalar\"\"\"\nif ndarray is not FakeObject:\n    import numpy as np\n    if isinstance(obj, np.generic) or isinstance(obj, np.ndarray):\n        try:\n            return obj.dtype.type\n        except (AttributeError, RuntimeError):\n            return\n",
        "CUT_5": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n"
    },
    {
        "functionName": "test_sort_float_collectionsmodel",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "var_list = [float(1e+16), float(10), float(1), float(0.1), float(1e-06),\n    float(0), float(-1e-06), float(-1), float(-10), float(-1e+16)]\ncm = CollectionsModel(MockParent(), var_list)\nassert cm.rowCount() == 10\nassert cm.columnCount() == 4\ncm.sort(0)\nassert data_table(cm, 10, 4) == [list(range(0, 10)), ['float'] * 10, [1] * \n    10, ['1e+16', '10.0', '1.0', '0.1', '1e-06', '0.0', '-1e-06', '-1.0',\n    '-10.0', '-1e+16']]\ncm.sort(3)\nassert data_table(cm, 10, 4) == [list(range(9, -1, -1)), ['float'] * 10, [1\n    ] * 10, ['-1e+16', '-10.0', '-1.0', '-1e-06', '0.0', '1e-06', '0.1',\n    '1.0', '10.0', '1e+16']]\n",
        "CUT_1": "\"\"\"Return True if datatype dtype is a float kind\"\"\"\nreturn 'float' in dtype.name or dtype.name in ['single', 'double']\n",
        "CUT_2": "\"\"\"Return True if datatype dtype is a float kind\"\"\"\nreturn 'float' in dtype.name or dtype.name in ['single', 'double']\n",
        "CUT_3": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n",
        "CUT_4": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n",
        "CUT_5": "\"\"\"\n    Parse text and return a time in seconds.\n\n    The text is of the format 0h : 0.min:0.0s:0 ms:0us:0 ns.\n    Spaces are not taken into account and any of the specifiers can be ignored.\n    \"\"\"\npattern = '([+-]?\\\\d+\\\\.?\\\\d*) ?([m\u03bcnsinh]+)'\nmatches = re.findall(pattern, text)\nif len(matches) == 0:\n    return None\ntime = 0.0\nfor res in matches:\n    tmp = float(res[0])\n    if res[1] == 'ns':\n        tmp *= 1e-09\n    elif res[1] == '\u03bcs':\n        tmp *= 1e-06\n    elif res[1] == 'ms':\n        tmp *= 0.001\n    elif res[1] == 'min':\n        tmp *= 60\n    elif res[1] == 'h':\n        tmp *= 3600\n    time += tmp\nreturn time\n"
    },
    {
        "functionName": "test_sort_collectionsmodel",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "var_list1 = [0, 1, 2]\nvar_list2 = [3, 4, 5, 6]\nvar_dataframe1 = pandas.DataFrame([[1, 2, 3], [20, 30, 40], [2, 2, 2]])\nvar_dataframe2 = pandas.DataFrame([[1, 2, 3], [20, 30, 40]])\nvar_series1 = pandas.Series(var_list1)\nvar_series2 = pandas.Series(var_list2)\ncoll = [1, 3, 2]\ncm = CollectionsModel(MockParent(), coll)\nassert cm.rowCount() == 3\nassert cm.columnCount() == 4\ncm.sort(0)\nassert data_table(cm, 3, 4) == [[0, 1, 2], ['int', 'int', 'int'], [1, 1, 1],\n    ['1', '3', '2']]\ncm.sort(3)\nassert data_table(cm, 3, 4) == [[0, 2, 1], ['int', 'int', 'int'], [1, 1, 1],\n    ['1', '2', '3']]\ncoll = [1, var_list1, var_list2, var_dataframe1, var_dataframe2,\n    var_series1, var_series2]\ncm = CollectionsModel(MockParent(), coll)\nassert cm.rowCount() == 7\nassert cm.columnCount() == 4\ncm.sort(1)\nassert data_table(cm, 7, 4) == [[3, 4, 5, 6, 0, 1, 2], ['DataFrame',\n    'DataFrame', 'Series', 'Series', 'int', 'list', 'list'], ['(3, 3)',\n    '(2, 3)', '(3,)', '(4,)', 1, 3, 4], ['Column names: 0, 1, 2',\n    'Column names: 0, 1, 2', 'Series object of pandas.core.series module',\n    'Series object of pandas.core.series module', '1', '[0, 1, 2]',\n    '[3, 4, 5, 6]']]\ncm.sort(2)\nassert data_table(cm, 7, 4) == [[3, 4, 5, 6, 0, 1, 2], ['DataFrame',\n    'DataFrame', 'Series', 'Series', 'int', 'list', 'list'], ['(2, 3)',\n    '(3,)', '(3, 3)', '(4,)', 1, 3, 4], ['Column names: 0, 1, 2',\n    'Column names: 0, 1, 2', 'Series object of pandas.core.series module',\n    'Series object of pandas.core.series module', '1', '[0, 1, 2]',\n    '[3, 4, 5, 6]']] or data_table(cm, 7, 4) == [[0, 1, 2, 4, 5, 3, 6], [\n    'int', 'list', 'list', 'DataFrame', 'Series', 'DataFrame', 'Series'], [\n    1, 3, 4, '(2, 3)', '(3,)', '(3, 3)', '(4,)'], ['1', '[0, 1, 2]',\n    '[3, 4, 5, 6]', 'Column names: 0, 1, 2',\n    'Series object of pandas.core.series module', 'Column names: 0, 1, 2',\n    'Series object of pandas.core.series module']]\npytest.mark.skipif(os.name == 'nt' and PY2, reason='Fails on Win and py2')",
        "CUT_1": "\"\"\"Return True if variable is a Series\"\"\"\ntry:\n    from pandas import Series\n    return isinstance(var, Series)\nexcept:\n    return False\n",
        "CUT_2": "\"\"\"Return True if variable is a Series\"\"\"\nreturn self.var_properties[name]['is_series']\n",
        "CUT_3": "\"\"\"Return True if variable is a Series\"\"\"\nreturn self.var_properties[name]['is_series']\n",
        "CUT_4": "\"\"\"Return True if variable is a DataFrame\"\"\"\ntry:\n    from pandas import DataFrame\n    return isinstance(var, DataFrame)\nexcept:\n    return False\n",
        "CUT_5": "\"\"\"Return type string of an object.\"\"\"\nif isinstance(item, DataFrame):\n    return 'DataFrame'\nif isinstance(item, Index):\n    return type(item).__name__\nif isinstance(item, Series):\n    return 'Series'\nfound = re.findall(\"<(?:type|class) '(\\\\S*)'>\", to_text_string(type(item)))\nif found:\n    if found[0] == 'type':\n        return 'class'\n    return found[0]\nelse:\n    return None\n"
    },
    {
        "functionName": "test_sort_and_fetch_collectionsmodel_with_many_rows",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "coll = list(range(2 * LARGE_NROWS))\ncm = CollectionsModel(MockParent(), coll)\nassert cm.rowCount() == cm.rows_loaded == ROWS_TO_LOAD\nassert cm.columnCount() == 4\ncm.sort(1)\ncm.fetchMore()\nassert cm.rowCount() == 2 * ROWS_TO_LOAD\nfor _ in range(3):\n    cm.fetchMore()\nassert cm.rowCount() == len(coll)\n",
        "CUT_1": "\"\"\"Get the item count in the list widget.\"\"\"\nreturn self.proxy.rowCount()\n",
        "CUT_2": "\"\"\"Get the item count in the list widget.\"\"\"\nreturn self.proxy.rowCount()\n",
        "CUT_3": "\"\"\"Load all the data.\"\"\"\nself.fetchMore(number_to_fetch=self.total_rows)\n",
        "CUT_4": "\"\"\"Load all the data.\"\"\"\nself.fetchMore(number_to_fetch=self.total_rows)\n",
        "CUT_5": "\"\"\"Update the column and row numbering in the headers.\"\"\"\nrows = self.rowCount()\ncols = self.columnCount()\nfor r in range(rows):\n    self.setVerticalHeaderItem(r, QTableWidgetItem(str(r)))\nfor c in range(cols):\n    self.setHorizontalHeaderItem(c, QTableWidgetItem(str(c)))\n    self.setColumnWidth(c, 40)\n"
    },
    {
        "functionName": "test_rename_and_duplicate_item_in_collection_editor",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "collections = {'list': ([1, 2, 3], False, True), 'tuple': ((1, 2, 3), False,\n    False), 'dict': ({'a': 1, 'b': 2}, True, True)}\nfor coll, rename_enabled, duplicate_enabled in collections.values():\n    coll_copy = copy.copy(coll)\n    editor = CollectionsEditorTableView(None, coll)\n    assert editor.rename_action.isEnabled()\n    assert editor.duplicate_action.isEnabled()\n    editor.setCurrentIndex(editor.model.index(0, 0))\n    editor.refresh_menu()\n    assert editor.rename_action.isEnabled() == rename_enabled\n    assert editor.duplicate_action.isEnabled() == duplicate_enabled\n    if isinstance(coll, list):\n        editor.duplicate_item()\n        assert editor.source_model.get_data() == coll_copy + [coll_copy[0]]\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "self.editor.copy()\n",
        "CUT_4": "self.editor.copy()\n",
        "CUT_5": "\"\"\"Create the local shortcuts for the CodeEditor.\"\"\"\nshortcut_context_name_callbacks = ('editor', 'code completion', self.\n    do_completion), ('editor', 'duplicate line down', self.duplicate_line_down\n    ), ('editor', 'duplicate line up', self.duplicate_line_up), ('editor',\n    'delete line', self.delete_line), ('editor', 'move line up', self.\n    move_line_up), ('editor', 'move line down', self.move_line_down), ('editor'\n    , 'go to new line', self.go_to_new_line), ('editor', 'go to definition',\n    self.go_to_definition_from_cursor), ('editor', 'toggle comment', self.\n    toggle_comment), ('editor', 'blockcomment', self.blockcomment), ('editor',\n    'unblockcomment', self.unblockcomment), ('editor',\n    'transform to uppercase', self.transform_to_uppercase), ('editor',\n    'transform to lowercase', self.transform_to_lowercase), ('editor',\n    'indent', lambda : self.indent(force=True)), ('editor', 'unindent', lambda\n    : self.unindent(force=True)), ('editor', 'start of line', self.\n    create_cursor_callback('StartOfLine')), ('editor', 'end of line', self.\n    create_cursor_callback('EndOfLine')), ('editor', 'previous line', self.\n    create_cursor_callback('Up')), ('editor', 'next line', self.\n    create_cursor_callback('Down')), ('editor', 'previous char', self.\n    create_cursor_callback('Left')), ('editor', 'next char', self.\n    create_cursor_callback('Right')), ('editor', 'previous word', self.\n    create_cursor_callback('PreviousWord')), ('editor', 'next word', self.\n    create_cursor_callback('NextWord')), ('editor', 'kill to line end',\n    self.kill_line_end), ('editor', 'kill to line start', self.kill_line_start\n    ), ('editor', 'yank', self._kill_ring.yank), ('editor',\n    'rotate kill ring', self._kill_ring.rotate), ('editor',\n    'kill previous word', self.kill_prev_word), ('editor', 'kill next word',\n    self.kill_next_word), ('editor', 'start of document', self.\n    create_cursor_callback('Start')), ('editor', 'end of document', self.\n    create_cursor_callback('End')), ('editor', 'undo', self.undo), ('editor',\n    'redo', self.redo), ('editor', 'cut', self.cut), ('editor', 'copy',\n    self.copy), ('editor', 'paste', self.paste), ('editor', 'delete', self.\n    delete), ('editor', 'select all', self.selectAll), ('editor',\n    'docstring', self.writer_docstring.write_docstring_for_shortcut), ('editor'\n    , 'autoformatting', self.format_document_or_range), ('array_builder',\n    'enter array inline', self.enter_array_inline), ('array_builder',\n    'enter array table', self.enter_array_table)\nshortcuts = []\nfor context, name, callback in shortcut_context_name_callbacks:\n    shortcuts.append(CONF.config_shortcut(callback, context=context, name=\n        name, parent=self))\nreturn shortcuts\n"
    },
    {
        "functionName": "test_edit_datetime",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test datetimes are editable and NaT values are correctly handled.\n\n    Regression test for spyder-ide/spyder#13557 and spyder-ide/spyder#8329\n    \"\"\"\nvariables = [pandas.NaT, datetime.date.today()]\neditor_list = CollectionsEditorTableView(None, variables)\neditor_list_value = editor_list.delegate.createEditor(None, None,\n    editor_list.model.index(0, 3))\nassert editor_list_value is None\neditor_list_value = editor_list.delegate.createEditor(None, None,\n    editor_list.model.index(1, 3))\nassert isinstance(editor_list_value, QDateEdit)\n",
        "CUT_1": "\"\"\"View item with the Object Explorer\"\"\"\nindex = self.currentIndex()\nif not index.isValid():\n    return\nindex = index.child(index.row(), 3)\nself.delegate.createEditor(self, None, index, object_explorer=True)\nSlot()",
        "CUT_2": "\"\"\"View item with the Object Explorer\"\"\"\nindex = self.currentIndex()\nif not index.isValid():\n    return\nindex = index.child(index.row(), 3)\nself.delegate.createEditor(self, None, index, object_explorer=True)\nSlot()",
        "CUT_3": "QTableView.__init__(self, parent)\nself.array_filename = None\nself.menu = None\nself.empty_ws_menu = None\nself.paste_action = None\nself.copy_action = None\nself.edit_action = None\nself.plot_action = None\nself.hist_action = None\nself.imshow_action = None\nself.save_array_action = None\nself.insert_action = None\nself.insert_action_above = None\nself.insert_action_below = None\nself.remove_action = None\nself.minmax_action = None\nself.rename_action = None\nself.duplicate_action = None\nself.last_regex = ''\nself.view_action = None\nself.delegate = None\nself.proxy_model = None\nself.source_model = None\nself.setAcceptDrops(True)\nself.automatic_column_width = True\nself.setHorizontalHeader(BaseHeaderView(parent=self))\nself.horizontalHeader().sig_user_resized_section.connect(self.\n    user_resize_columns)\n",
        "CUT_4": "QTableView.__init__(self, parent)\nself.array_filename = None\nself.menu = None\nself.empty_ws_menu = None\nself.paste_action = None\nself.copy_action = None\nself.edit_action = None\nself.plot_action = None\nself.hist_action = None\nself.imshow_action = None\nself.save_array_action = None\nself.insert_action = None\nself.insert_action_above = None\nself.insert_action_below = None\nself.remove_action = None\nself.minmax_action = None\nself.rename_action = None\nself.duplicate_action = None\nself.last_regex = ''\nself.view_action = None\nself.delegate = None\nself.proxy_model = None\nself.source_model = None\nself.setAcceptDrops(True)\nself.automatic_column_width = True\nself.setHorizontalHeader(BaseHeaderView(parent=self))\nself.horizontalHeader().sig_user_resized_section.connect(self.\n    user_resize_columns)\n",
        "CUT_5": "self.args = None\nself.args_enabled = None\nself.wdir = None\nself.wdir_enabled = None\nself.current = None\nself.systerm = None\nself.interact = None\nself.post_mortem = None\nself.python_args = None\nself.python_args_enabled = None\nself.clear_namespace = None\nself.console_namespace = None\nself.file_dir = None\nself.cw_dir = None\nself.fixed_dir = None\nself.dir = None\nself.set(CONF.get('run', 'defaultconfiguration', default={}))\n"
    },
    {
        "functionName": "test_edit_mutable_and_immutable_types",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that mutable objs/vals are editable in VarExp; immutable ones aren't.\n\n    Regression test for spyder-ide/spyder#5991.\n    \"\"\"\nMockQLineEdit = Mock()\nattr_to_patch_qlineedit = ('spyder.plugins.variableexplorer.widgets.' +\n    'collectionsdelegate.QLineEdit')\nmonkeypatch.setattr(attr_to_patch_qlineedit, MockQLineEdit)\nMockTextEditor = Mock()\nattr_to_patch_textedit = ('spyder.plugins.variableexplorer.widgets.' +\n    'collectionsdelegate.TextEditor')\nmonkeypatch.setattr(attr_to_patch_textedit, MockTextEditor)\nMockQDateTimeEdit = Mock()\nattr_to_patch_qdatetimeedit = ('spyder.plugins.variableexplorer.widgets.' +\n    'collectionsdelegate.QDateTimeEdit')\nmonkeypatch.setattr(attr_to_patch_qdatetimeedit, MockQDateTimeEdit)\nMockCollectionsEditor = Mock()\nmockCollectionsEditor_instance = MockCollectionsEditor()\nattr_to_patch_coledit = ('spyder.widgets.' +\n    'collectionseditor.CollectionsEditor')\nmonkeypatch.setattr(attr_to_patch_coledit, MockCollectionsEditor)\nlist_test = [1, '012345678901234567901234567890123456789012', datetime.\n    datetime(2017, 12, 24, 7, 9), [1, 2, 3], (2, 'eggs')]\ntup_test = tuple(list_test)\neditor_list = CollectionsEditorTableView(None, list_test)\neditor_list_value = editor_list.delegate.createEditor(None, None,\n    editor_list.model.index(0, 3))\nassert editor_list_value is not None\nassert MockQLineEdit.call_count == 1\neditor_list.delegate.createEditor(None, None, editor_list.model.index(1, 3))\nassert MockTextEditor.call_count == 2\nassert not MockTextEditor.call_args[1]['readonly']\neditor_list_datetime = editor_list.delegate.createEditor(None, None,\n    editor_list.model.index(2, 3))\nassert editor_list_datetime is not None\nassert MockQDateTimeEdit.call_count == 1\neditor_list.delegate.createEditor(None, None, editor_list.model.index(3, 3))\nassert mockCollectionsEditor_instance.show.call_count == 1\nassert not mockCollectionsEditor_instance.setup.call_args[1]['readonly']\neditor_list.delegate.createEditor(None, None, editor_list.model.index(4, 3))\nassert mockCollectionsEditor_instance.show.call_count == 2\nassert mockCollectionsEditor_instance.setup.call_args[1]['readonly']\neditor_tup = CollectionsEditorTableView(None, tup_test)\neditor_tup_value = editor_tup.delegate.createEditor(None, None, editor_tup.\n    model.index(0, 3))\nassert editor_tup_value is None\nassert MockQLineEdit.call_count == 1\neditor_tup.delegate.createEditor(None, None, editor_tup.model.index(1, 3))\nassert MockTextEditor.call_count == 4\nassert MockTextEditor.call_args[1]['readonly']\neditor_tup_datetime = editor_tup.delegate.createEditor(None, None,\n    editor_tup.model.index(2, 3))\nassert editor_tup_datetime is None\nassert MockQDateTimeEdit.call_count == 1\neditor_tup.delegate.createEditor(None, None, editor_tup.model.index(3, 3))\nassert mockCollectionsEditor_instance.show.call_count == 3\nassert mockCollectionsEditor_instance.setup.call_args[1]['readonly']\neditor_tup.delegate.createEditor(None, None, editor_tup.model.index(4, 3))\nassert mockCollectionsEditor_instance.show.call_count == 4\nassert mockCollectionsEditor_instance.setup.call_args[1]['readonly']\n",
        "CUT_1": "\"\"\"View item with the Object Explorer\"\"\"\nindex = self.currentIndex()\nif not index.isValid():\n    return\nindex = index.child(index.row(), 3)\nself.delegate.createEditor(self, None, index, object_explorer=True)\nSlot()",
        "CUT_2": "\"\"\"View item with the Object Explorer\"\"\"\nindex = self.currentIndex()\nif not index.isValid():\n    return\nindex = index.child(index.row(), 3)\nself.delegate.createEditor(self, None, index, object_explorer=True)\nSlot()",
        "CUT_3": "\"\"\"Overriding method createEditor\"\"\"\nval_type = index.sibling(index.row(), 1).data()\nself.sig_open_editor.emit()\nif index.column() < 3:\n    return None\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    if value is None:\n        return None\nexcept ImportError as msg:\n    self.sig_editor_shown.emit()\n    module = str(msg).split(\"'\")[1]\n    if module in ['pandas', 'numpy']:\n        if module == 'numpy':\n            val_type = 'array'\n        else:\n            val_type = 'dataframe, series'\n        message = _(\n            \"Spyder is unable to show the {val_type} or object you're trying to view because <tt>{module}</tt> is not installed. \"\n            )\n        if running_in_mac_app():\n            message += _(\n                'Please consider using the full version of the Spyder MacOS application.<br>'\n                )\n        else:\n            message += _(\n                'Please install this package in your Spyder environment.<br>')\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            val_type=val_type, module=module))\n        return\n    else:\n        message = _(\n            \"Spyder is unable to show the variable you're trying to view because the module <tt>{module}</tt> is not \"\n            )\n        if running_in_mac_app():\n            message += _('supported in the Spyder MacOS application.<br>')\n        else:\n            message += _(\n                'found in your Spyder environment. Please install this package in your Spyder environment.<br>'\n                )\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            module=module))\n        return\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br>%s'\n        ) % to_text_string(msg))\n    return\nkey = index.model().get_key(index)\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)) and not object_explorer:\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)\n    ) and ndarray is not FakeObject and not object_explorer:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject and not object_explorer:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject and not object_explorer:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n            try:\n                value.time()\n            except ValueError:\n                self.sig_editor_shown.emit()\n                return None\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        self.sig_editor_shown.emit()\n        return editor\nelif is_text_string(value) and len(value) > 40 and not object_explorer:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        self.sig_editor_shown.emit()\n        return editor\nelse:\n    show_callable_attributes = index.model().show_callable_attributes\n    show_special_attributes = index.model().show_special_attributes\n    dataframe_format = index.model().dataframe_format\n    if show_callable_attributes is None:\n        show_callable_attributes = False\n    if show_special_attributes is None:\n        show_special_attributes = False\n    from spyder.plugins.variableexplorer.widgets.objectexplorer import ObjectExplorer\n    editor = ObjectExplorer(value, name=key, parent=parent,\n        show_callable_attributes=show_callable_attributes,\n        show_special_attributes=show_special_attributes, dataframe_format=\n        dataframe_format, readonly=readonly)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\n",
        "CUT_4": "\"\"\"Overriding method createEditor\"\"\"\nval_type = index.sibling(index.row(), 1).data()\nself.sig_open_editor.emit()\nif index.column() < 3:\n    return None\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    if value is None:\n        return None\nexcept ImportError as msg:\n    self.sig_editor_shown.emit()\n    module = str(msg).split(\"'\")[1]\n    if module in ['pandas', 'numpy']:\n        if module == 'numpy':\n            val_type = 'array'\n        else:\n            val_type = 'dataframe, series'\n        message = _(\n            \"Spyder is unable to show the {val_type} or object you're trying to view because <tt>{module}</tt> is not installed. \"\n            )\n        if running_in_mac_app():\n            message += _(\n                'Please consider using the full version of the Spyder MacOS application.<br>'\n                )\n        else:\n            message += _(\n                'Please install this package in your Spyder environment.<br>')\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            val_type=val_type, module=module))\n        return\n    else:\n        message = _(\n            \"Spyder is unable to show the variable you're trying to view because the module <tt>{module}</tt> is not \"\n            )\n        if running_in_mac_app():\n            message += _('supported in the Spyder MacOS application.<br>')\n        else:\n            message += _(\n                'found in your Spyder environment. Please install this package in your Spyder environment.<br>'\n                )\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            module=module))\n        return\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br>%s'\n        ) % to_text_string(msg))\n    return\nkey = index.model().get_key(index)\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)) and not object_explorer:\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)\n    ) and ndarray is not FakeObject and not object_explorer:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject and not object_explorer:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject and not object_explorer:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n            try:\n                value.time()\n            except ValueError:\n                self.sig_editor_shown.emit()\n                return None\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        self.sig_editor_shown.emit()\n        return editor\nelif is_text_string(value) and len(value) > 40 and not object_explorer:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        self.sig_editor_shown.emit()\n        return editor\nelse:\n    show_callable_attributes = index.model().show_callable_attributes\n    show_special_attributes = index.model().show_special_attributes\n    dataframe_format = index.model().dataframe_format\n    if show_callable_attributes is None:\n        show_callable_attributes = False\n    if show_special_attributes is None:\n        show_special_attributes = False\n    from spyder.plugins.variableexplorer.widgets.objectexplorer import ObjectExplorer\n    editor = ObjectExplorer(value, name=key, parent=parent,\n        show_callable_attributes=show_callable_attributes,\n        show_special_attributes=show_special_attributes, dataframe_format=\n        dataframe_format, readonly=readonly)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\n",
        "CUT_5": "QTableView.__init__(self, parent)\nself.array_filename = None\nself.menu = None\nself.empty_ws_menu = None\nself.paste_action = None\nself.copy_action = None\nself.edit_action = None\nself.plot_action = None\nself.hist_action = None\nself.imshow_action = None\nself.save_array_action = None\nself.insert_action = None\nself.insert_action_above = None\nself.insert_action_below = None\nself.remove_action = None\nself.minmax_action = None\nself.rename_action = None\nself.duplicate_action = None\nself.last_regex = ''\nself.view_action = None\nself.delegate = None\nself.proxy_model = None\nself.source_model = None\nself.setAcceptDrops(True)\nself.automatic_column_width = True\nself.setHorizontalHeader(BaseHeaderView(parent=self))\nself.horizontalHeader().sig_user_resized_section.connect(self.\n    user_resize_columns)\n"
    },
    {
        "functionName": "test_view_module_in_coledit",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that modules don't produce an error when opening in Variable Explorer.\n\n    Also check that they are set as readonly. Regression test for\n    spyder-ide/spyder#6080.\n    \"\"\"\neditor = CollectionsEditor()\neditor.setup(os, 'module_test', readonly=False)\nassert editor.widget.editor.readonly\n",
        "CUT_1": "\"\"\"Overriding method createEditor\"\"\"\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    try:\n        self.old_obj = value.copy()\n    except AttributeError:\n        self.old_obj = copy.deepcopy(value)\n    if value is None:\n        return None\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br><i>%s</i>'\n        ) % to_text_string(msg))\n    return\nself.current_index = index\nkey = index.model().get_key(index).obj_name\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)):\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)) and ndarray is not FakeObject:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date):\n    if readonly:\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        return editor\nelif is_text_string(value) and len(value) > 40:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value):\n    if readonly:\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        return editor\nelse:\n    return None\n",
        "CUT_2": "\"\"\"Overriding method createEditor\"\"\"\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    try:\n        self.old_obj = value.copy()\n    except AttributeError:\n        self.old_obj = copy.deepcopy(value)\n    if value is None:\n        return None\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br><i>%s</i>'\n        ) % to_text_string(msg))\n    return\nself.current_index = index\nkey = index.model().get_key(index).obj_name\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)):\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)) and ndarray is not FakeObject:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date):\n    if readonly:\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        return editor\nelif is_text_string(value) and len(value) > 40:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value):\n    if readonly:\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        return editor\nelse:\n    return None\n",
        "CUT_3": "\"\"\"Overriding method createEditor\"\"\"\nval_type = index.sibling(index.row(), 1).data()\nself.sig_open_editor.emit()\nif index.column() < 3:\n    return None\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    if value is None:\n        return None\nexcept ImportError as msg:\n    self.sig_editor_shown.emit()\n    module = str(msg).split(\"'\")[1]\n    if module in ['pandas', 'numpy']:\n        if module == 'numpy':\n            val_type = 'array'\n        else:\n            val_type = 'dataframe, series'\n        message = _(\n            \"Spyder is unable to show the {val_type} or object you're trying to view because <tt>{module}</tt> is not installed. \"\n            )\n        if running_in_mac_app():\n            message += _(\n                'Please consider using the full version of the Spyder MacOS application.<br>'\n                )\n        else:\n            message += _(\n                'Please install this package in your Spyder environment.<br>')\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            val_type=val_type, module=module))\n        return\n    else:\n        message = _(\n            \"Spyder is unable to show the variable you're trying to view because the module <tt>{module}</tt> is not \"\n            )\n        if running_in_mac_app():\n            message += _('supported in the Spyder MacOS application.<br>')\n        else:\n            message += _(\n                'found in your Spyder environment. Please install this package in your Spyder environment.<br>'\n                )\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            module=module))\n        return\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br>%s'\n        ) % to_text_string(msg))\n    return\nkey = index.model().get_key(index)\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)) and not object_explorer:\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)\n    ) and ndarray is not FakeObject and not object_explorer:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject and not object_explorer:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject and not object_explorer:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n            try:\n                value.time()\n            except ValueError:\n                self.sig_editor_shown.emit()\n                return None\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        self.sig_editor_shown.emit()\n        return editor\nelif is_text_string(value) and len(value) > 40 and not object_explorer:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        self.sig_editor_shown.emit()\n        return editor\nelse:\n    show_callable_attributes = index.model().show_callable_attributes\n    show_special_attributes = index.model().show_special_attributes\n    dataframe_format = index.model().dataframe_format\n    if show_callable_attributes is None:\n        show_callable_attributes = False\n    if show_special_attributes is None:\n        show_special_attributes = False\n    from spyder.plugins.variableexplorer.widgets.objectexplorer import ObjectExplorer\n    editor = ObjectExplorer(value, name=key, parent=parent,\n        show_callable_attributes=show_callable_attributes,\n        show_special_attributes=show_special_attributes, dataframe_format=\n        dataframe_format, readonly=readonly)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\n",
        "CUT_4": "\"\"\"Overriding method createEditor\"\"\"\nval_type = index.sibling(index.row(), 1).data()\nself.sig_open_editor.emit()\nif index.column() < 3:\n    return None\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    if value is None:\n        return None\nexcept ImportError as msg:\n    self.sig_editor_shown.emit()\n    module = str(msg).split(\"'\")[1]\n    if module in ['pandas', 'numpy']:\n        if module == 'numpy':\n            val_type = 'array'\n        else:\n            val_type = 'dataframe, series'\n        message = _(\n            \"Spyder is unable to show the {val_type} or object you're trying to view because <tt>{module}</tt> is not installed. \"\n            )\n        if running_in_mac_app():\n            message += _(\n                'Please consider using the full version of the Spyder MacOS application.<br>'\n                )\n        else:\n            message += _(\n                'Please install this package in your Spyder environment.<br>')\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            val_type=val_type, module=module))\n        return\n    else:\n        message = _(\n            \"Spyder is unable to show the variable you're trying to view because the module <tt>{module}</tt> is not \"\n            )\n        if running_in_mac_app():\n            message += _('supported in the Spyder MacOS application.<br>')\n        else:\n            message += _(\n                'found in your Spyder environment. Please install this package in your Spyder environment.<br>'\n                )\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            module=module))\n        return\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br>%s'\n        ) % to_text_string(msg))\n    return\nkey = index.model().get_key(index)\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)) and not object_explorer:\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)\n    ) and ndarray is not FakeObject and not object_explorer:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject and not object_explorer:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject and not object_explorer:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n            try:\n                value.time()\n            except ValueError:\n                self.sig_editor_shown.emit()\n                return None\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        self.sig_editor_shown.emit()\n        return editor\nelif is_text_string(value) and len(value) > 40 and not object_explorer:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        self.sig_editor_shown.emit()\n        return editor\nelse:\n    show_callable_attributes = index.model().show_callable_attributes\n    show_special_attributes = index.model().show_special_attributes\n    dataframe_format = index.model().dataframe_format\n    if show_callable_attributes is None:\n        show_callable_attributes = False\n    if show_special_attributes is None:\n        show_special_attributes = False\n    from spyder.plugins.variableexplorer.widgets.objectexplorer import ObjectExplorer\n    editor = ObjectExplorer(value, name=key, parent=parent,\n        show_callable_attributes=show_callable_attributes,\n        show_special_attributes=show_special_attributes, dataframe_format=\n        dataframe_format, readonly=readonly)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\n",
        "CUT_5": "QWidget.__init__(self, parent)\nif remote:\n    self.editor = RemoteCollectionsEditorTableView(self, data, readonly)\nelse:\n    self.editor = CollectionsEditorTableView(self, data, readonly, title)\nlayout = QVBoxLayout()\nlayout.addWidget(self.editor)\nself.setLayout(layout)\n"
    },
    {
        "functionName": "test_notimplementederror_multiindex",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the NotImplementedError when scrolling a MultiIndex is handled.\n\n    Regression test for spyder-ide/spyder#6284.\n    \"\"\"\ntime_deltas = [pandas.Timedelta(minutes=minute) for minute in range(5, 35, 5)]\ntime_delta_multiindex = pandas.MultiIndex.from_product([[0, 1, 2, 3, 4],\n    time_deltas])\ncol_model = CollectionsModel(MockParent(), time_delta_multiindex)\nassert col_model.rowCount() == col_model.rows_loaded == ROWS_TO_LOAD\nassert col_model.columnCount() == 4\ncol_model.fetchMore()\nassert col_model.rowCount() == 2 * ROWS_TO_LOAD\nfor _ in range(3):\n    col_model.fetchMore()\nassert col_model.rowCount() == 5 * ROWS_TO_LOAD\n",
        "CUT_1": "\"\"\"Get the item count in the list widget.\"\"\"\nreturn self.proxy.rowCount()\n",
        "CUT_2": "\"\"\"Get the item count in the list widget.\"\"\"\nreturn self.proxy.rowCount()\n",
        "CUT_3": "\"\"\"Load all the data.\"\"\"\nself.fetchMore(number_to_fetch=self.total_rows)\n",
        "CUT_4": "\"\"\"Load all the data.\"\"\"\nself.fetchMore(number_to_fetch=self.total_rows)\n",
        "CUT_5": "for i in range(3):\n    print(i)\n"
    },
    {
        "functionName": "test_editor_parent_set",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that editors have their parent set so they close with Spyder.\n\n    Regression test for spyder-ide/spyder#5696.\n    \"\"\"\ntest_parent = QWidget()\nMockCollectionsEditor = Mock()\nattr_to_patch_coledit = ('spyder.widgets.' +\n    'collectionseditor.CollectionsEditor')\nmonkeypatch.setattr(attr_to_patch_coledit, MockCollectionsEditor)\nMockArrayEditor = Mock()\nattr_to_patch_arredit = ('spyder.plugins.variableexplorer.widgets.' +\n    'collectionsdelegate.ArrayEditor')\nmonkeypatch.setattr(attr_to_patch_arredit, MockArrayEditor)\nMockDataFrameEditor = Mock()\nattr_to_patch_dfedit = ('spyder.plugins.variableexplorer.widgets.' +\n    'collectionsdelegate.DataFrameEditor')\nmonkeypatch.setattr(attr_to_patch_dfedit, MockDataFrameEditor)\nMockTextEditor = Mock()\nattr_to_patch_textedit = ('spyder.plugins.variableexplorer.widgets.' +\n    'collectionsdelegate.TextEditor')\nmonkeypatch.setattr(attr_to_patch_textedit, MockTextEditor)\nMockObjectExplorer = Mock()\nattr_to_patch_objectexplorer = ('spyder.plugins.variableexplorer.widgets.' +\n    'objectexplorer.ObjectExplorer')\nmonkeypatch.setattr(attr_to_patch_objectexplorer, MockObjectExplorer)\neditor_data = [[0, 1, 2, 3, 4], numpy.array([1.0, 42.0, 1337.0]), pandas.\n    DataFrame([[1, 2, 3], [20, 30, 40]]), os,\n    '012345678901234567890123456789012345678901234567890123456']\ncol_editor = CollectionsEditorTableView(test_parent, editor_data)\nassert col_editor.parent() is test_parent\nfor idx, mock_class in enumerate([MockCollectionsEditor, MockArrayEditor,\n    MockDataFrameEditor, MockObjectExplorer, MockTextEditor]):\n    col_editor.delegate.createEditor(col_editor.parent(), None, col_editor.\n        model.index(idx, 3))\n    assert mock_class.call_count == 1 + idx // 4\n    assert mock_class.call_args[1]['parent'] is test_parent\n",
        "CUT_1": "\"\"\"Mock the RecoveryDialog in the editor plugin.\"\"\"\nmock = MagicMock()\nmonkeypatch.setattr('spyder.plugins.editor.utils.autosave.RecoveryDialog', mock\n    )\nreturn mock\npytest.fixture",
        "CUT_2": "return Mock()\n",
        "CUT_3": "\"\"\"Set up the Editor plugin.\"\"\"\nmonkeypatch.setattr('spyder.plugins.editor.plugin.add_actions', Mock())\nclass MainMock(QMainWindow):\n\n    def __getattr__(self, attr):\n        if attr.endswith('actions'):\n            return []\n        elif attr == 'projects':\n            projects = Mock()\n            projects.get_active_project.return_value = None\n            return projects\n        elif attr == 'ipyconsole':\n            ipyconsole = Mock()\n            ipyconsole.get_pdb_state.return_value = False\n            return ipyconsole\n        else:\n            return Mock()\n\n    def get_spyder_pythonpath(*args):\n        return []\nwindow = MainMock()\neditor = Editor(window)\nwindow.setCentralWidget(editor)\nwindow.resize(640, 480)\nqtbot.addWidget(window)\nwindow.show()\nyield editor\neditor.close()\nCONF.remove_option('editor', 'autosave_mapping')\npytest.fixture",
        "CUT_4": "CollectionsDelegate.__init__(self, parent)\n",
        "CUT_5": "CollectionsDelegate.__init__(self, parent)\n"
    },
    {
        "functionName": "test_xml_dom_element_view",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that XML DOM ``Element``s are able to be viewied in CollectionsEditor.\n\n    Regression test for spyder-ide/spyder#5642.\n    \"\"\"\nxml_path = path.join(LOCATION, 'dom_element_test.xml')\nwith open(xml_path) as xml_file:\n    xml_data = xml_file.read()\nxml_content = parseString(xml_data)\nxml_element = xml_content.getElementsByTagName('note')[0]\ncol_editor = CollectionsEditor(None)\ncol_editor.setup(xml_element)\ncol_editor.show()\nassert col_editor.get_value()\ncol_editor.accept()\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "\"\"\"Test Collections editor.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\ndialog = CollectionsEditor()\ndialog.setup(get_test_data())\ndialog.show()\napp.exec_()\n",
        "CUT_4": "\"\"\"Test Collections editor.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\ndialog = CollectionsEditor()\ndialog.setup(get_test_data())\ndialog.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n"
    },
    {
        "functionName": "test_pandas_dateoffset_view",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that pandas ``DateOffset`` objs can be viewied in CollectionsEditor.\n\n    Regression test for spyder-ide/spyder#6729.\n    \"\"\"\ntest_dateoffset = pandas.DateOffset()\ncol_editor = CollectionsEditor(None)\ncol_editor.setup(test_dateoffset)\ncol_editor.show()\nassert col_editor.get_value()\ncol_editor.accept()\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "\"\"\"Test Collections editor.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\ndialog = CollectionsEditor()\ndialog.setup(get_test_data())\ndialog.show()\napp.exec_()\n",
        "CUT_4": "\"\"\"Test Collections editor.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\ndialog = CollectionsEditor()\ndialog.setup(get_test_data())\ndialog.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n"
    },
    {
        "functionName": "test_set_nonsettable_objects",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that errors trying to set attributes in ColEdit are handled properly.\n\n    Unit regression test for issues spyder-ide/spyder#6727 and\n    spyder-ide/spyder#6728.\n    \"\"\"\nfor test_obj, expected_obj, keys in nonsettable_objects_data:\n    col_model = CollectionsModel(None, test_obj)\n    indicies = [col_model.get_index_from_key(key) for key in keys]\n    for idx in indicies:\n        assert not col_model.set_value(idx, '2')\n        assert all([(key == '_typ' or getattr(col_model.get_data().__obj__,\n            key) == getattr(expected_obj, key)) for key in keys])\n",
        "CUT_1": "for key in set(a.keys()).union(b.keys()):\n    if key in a and key in b:\n        if isinstance(a[key], dict) and isinstance(b[key], dict):\n            yield key, dict(_merge_dicts_(a[key], b[key]))\n        elif b[key] is not None:\n            yield key, b[key]\n        else:\n            yield key, a[key]\n    elif key in a:\n        yield key, a[key]\n    elif b[key] is not None:\n        yield key, b[key]\n",
        "CUT_2": "\"\"\"Recursively merge dictionary b into dictionary a.\n\n    If override_nones is True, then\n    \"\"\"\ndef _merge_dicts_(a, b):\n    for key in set(a.keys()).union(b.keys()):\n        if key in a and key in b:\n            if isinstance(a[key], dict) and isinstance(b[key], dict):\n                yield key, dict(_merge_dicts_(a[key], b[key]))\n            elif b[key] is not None:\n                yield key, b[key]\n            else:\n                yield key, a[key]\n        elif key in a:\n            yield key, a[key]\n        elif b[key] is not None:\n            yield key, b[key]\nreturn dict(_merge_dicts_(dict_a, dict_b))\n",
        "CUT_3": "if running_python_3:\n    if isinstance(key, str):\n        key = key.encode('utf-8')\n    else:\n        key = str(key).encode('utf-8')\nelif isinstance(key, unicode):\n    key = key.encode('utf-8')\nelse:\n    key = str(key)\ni = 0\nfor salt in salts:\n    h = salt.copy()\n    h.update(key)\n    for uint in unpack(fmt, h.digest()):\n        yield uint % num_bits\n        i += 1\n        if i >= num_slices:\n            return\n",
        "CUT_4": "if running_python_3:\n    if isinstance(key, str):\n        key = key.encode('utf-8')\n    else:\n        key = str(key).encode('utf-8')\nelif isinstance(key, unicode):\n    key = key.encode('utf-8')\nelse:\n    key = str(key)\ni = 0\nfor salt in salts:\n    h = salt.copy()\n    h.update(key)\n    for uint in unpack(fmt, h.digest()):\n        yield uint % num_bits\n        i += 1\n        if i >= num_slices:\n            return\n",
        "CUT_5": "\"\"\"\n        Set model data.\n\n        Parameters\n        ----------\n        data: dict\n            Breakpoint data to use.\n        \"\"\"\nself._data = data\nself.breakpoints = []\nfiles = []\nfor key in data:\n    if data[key] and key not in files:\n        files.append(key)\nfor key in files:\n    for item in data[key]:\n        self.breakpoints.append((disambiguate_fname(files, key), item[0],\n            item[1], '', key))\nself.reset()\n"
    },
    {
        "functionName": "test_edit_nonsettable_objects",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that errors trying to edit attributes in ColEdit are handled properly.\n\n    Integration regression test for issues spyder-ide/spyder#6727 and\n    spyder-ide/spyder#6728.\n    \"\"\"\nfor test_obj, expected_obj, keys in nonsettable_objects_data:\n    col_editor = CollectionsEditor(None)\n    col_editor.setup(test_obj)\n    col_editor.show()\n    qtbot.waitForWindowShown(col_editor)\n    view = col_editor.widget.editor\n    indicies = [view.source_model.get_index_from_key(key) for key in keys]\n    for _ in range(3):\n        qtbot.keyClick(view, Qt.Key_Right)\n    last_row = -1\n    rows_to_test = [index.row() for index in indicies]\n    for row in rows_to_test:\n        for _ in range(row - last_row - 1):\n            qtbot.keyClick(view, Qt.Key_Down)\n        qtbot.keyClick(view, Qt.Key_Space)\n        qtbot.keyClick(view.focusWidget(), Qt.Key_Backspace)\n        qtbot.keyClicks(view.focusWidget(), '2')\n        qtbot.keyClick(view.focusWidget(), Qt.Key_Down)\n        last_row = row\n    qtbot.wait(100)\n    assert all([(key == '_typ' or getattr(col_editor.get_value(), key) ==\n        getattr(expected_obj, key)) for key in keys])\n    col_editor.accept()\n    qtbot.wait(200)\n    assert all([(key == '_typ' or getattr(col_editor.get_value(), key) ==\n        getattr(expected_obj, key)) for key in keys])\n    if getattr(test_obj, '_typ', None) is None:\n        keys.remove('_typ')\n    assert all([(getattr(test_obj, key) == getattr(expected_obj, key)) for\n        key in keys])\npytest.mark.no_xvfb",
        "CUT_1": "for key in set(a.keys()).union(b.keys()):\n    if key in a and key in b:\n        if isinstance(a[key], dict) and isinstance(b[key], dict):\n            yield key, dict(_merge_dicts_(a[key], b[key]))\n        elif b[key] is not None:\n            yield key, b[key]\n        else:\n            yield key, a[key]\n    elif key in a:\n        yield key, a[key]\n    elif b[key] is not None:\n        yield key, b[key]\n",
        "CUT_2": "\"\"\"Recursively merge dictionary b into dictionary a.\n\n    If override_nones is True, then\n    \"\"\"\ndef _merge_dicts_(a, b):\n    for key in set(a.keys()).union(b.keys()):\n        if key in a and key in b:\n            if isinstance(a[key], dict) and isinstance(b[key], dict):\n                yield key, dict(_merge_dicts_(a[key], b[key]))\n            elif b[key] is not None:\n                yield key, b[key]\n            else:\n                yield key, a[key]\n        elif key in a:\n            yield key, a[key]\n        elif b[key] is not None:\n            yield key, b[key]\nreturn dict(_merge_dicts_(dict_a, dict_b))\n",
        "CUT_3": "\"\"\"Return current key\"\"\"\nreturn self.keys[index.row()]\n",
        "CUT_4": "\"\"\"Return current key\"\"\"\nreturn self.keys[index.row()]\n",
        "CUT_5": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')"
    },
    {
        "functionName": "test_collectionseditor_with_class_having_buggy_copy",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that editor for object whose .copy() returns a different type is\n    readonly; cf. spyder-ide/spyder#6936.\n    \"\"\"\nclass MyDictWithBuggyCopy(dict):\n    pass\nmd = MyDictWithBuggyCopy({(1): 2})\neditor = CollectionsEditor()\neditor.setup(md)\nassert editor.widget.editor.readonly\n",
        "CUT_1": "\"\"\"Overriding method createEditor\"\"\"\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    try:\n        self.old_obj = value.copy()\n    except AttributeError:\n        self.old_obj = copy.deepcopy(value)\n    if value is None:\n        return None\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br><i>%s</i>'\n        ) % to_text_string(msg))\n    return\nself.current_index = index\nkey = index.model().get_key(index).obj_name\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)):\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)) and ndarray is not FakeObject:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date):\n    if readonly:\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        return editor\nelif is_text_string(value) and len(value) > 40:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value):\n    if readonly:\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        return editor\nelse:\n    return None\n",
        "CUT_2": "\"\"\"Overriding method createEditor\"\"\"\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    try:\n        self.old_obj = value.copy()\n    except AttributeError:\n        self.old_obj = copy.deepcopy(value)\n    if value is None:\n        return None\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br><i>%s</i>'\n        ) % to_text_string(msg))\n    return\nself.current_index = index\nkey = index.model().get_key(index).obj_name\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)):\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)) and ndarray is not FakeObject:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date):\n    if readonly:\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        return editor\nelif is_text_string(value) and len(value) > 40:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value):\n    if readonly:\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        return editor\nelse:\n    return None\n",
        "CUT_3": "return _('Editor')\n",
        "CUT_4": "return _('Editor')\n",
        "CUT_5": "\"\"\"Overriding method createEditor\"\"\"\nval_type = index.sibling(index.row(), 1).data()\nself.sig_open_editor.emit()\nif index.column() < 3:\n    return None\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    if value is None:\n        return None\nexcept ImportError as msg:\n    self.sig_editor_shown.emit()\n    module = str(msg).split(\"'\")[1]\n    if module in ['pandas', 'numpy']:\n        if module == 'numpy':\n            val_type = 'array'\n        else:\n            val_type = 'dataframe, series'\n        message = _(\n            \"Spyder is unable to show the {val_type} or object you're trying to view because <tt>{module}</tt> is not installed. \"\n            )\n        if running_in_mac_app():\n            message += _(\n                'Please consider using the full version of the Spyder MacOS application.<br>'\n                )\n        else:\n            message += _(\n                'Please install this package in your Spyder environment.<br>')\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            val_type=val_type, module=module))\n        return\n    else:\n        message = _(\n            \"Spyder is unable to show the variable you're trying to view because the module <tt>{module}</tt> is not \"\n            )\n        if running_in_mac_app():\n            message += _('supported in the Spyder MacOS application.<br>')\n        else:\n            message += _(\n                'found in your Spyder environment. Please install this package in your Spyder environment.<br>'\n                )\n        QMessageBox.critical(self.parent(), _('Error'), message.format(\n            module=module))\n        return\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br>%s'\n        ) % to_text_string(msg))\n    return\nkey = index.model().get_key(index)\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)) and not object_explorer:\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)\n    ) and ndarray is not FakeObject and not object_explorer:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject and not object_explorer:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject and not object_explorer:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n            try:\n                value.time()\n            except ValueError:\n                self.sig_editor_shown.emit()\n                return None\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        self.sig_editor_shown.emit()\n        return editor\nelif is_text_string(value) and len(value) > 40 and not object_explorer:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value) and not object_explorer:\n    if readonly:\n        self.sig_editor_shown.emit()\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        self.sig_editor_shown.emit()\n        return editor\nelse:\n    show_callable_attributes = index.model().show_callable_attributes\n    show_special_attributes = index.model().show_special_attributes\n    dataframe_format = index.model().dataframe_format\n    if show_callable_attributes is None:\n        show_callable_attributes = False\n    if show_special_attributes is None:\n        show_special_attributes = False\n    from spyder.plugins.variableexplorer.widgets.objectexplorer import ObjectExplorer\n    editor = ObjectExplorer(value, name=key, parent=parent,\n        show_callable_attributes=show_callable_attributes,\n        show_special_attributes=show_special_attributes, dataframe_format=\n        dataframe_format, readonly=readonly)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\n"
    },
    {
        "functionName": "test_collectionseditor_with_class_having_correct_copy",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that editor for object whose .copy() returns the same type is not\n    readonly; cf. spyder-ide/spyder#6936.\n    \"\"\"\nclass MyDictWithCorrectCopy(dict):\n\n    def copy(self):\n        return MyDictWithCorrectCopy(self)\nmd = MyDictWithCorrectCopy({(1): 2})\neditor = CollectionsEditor()\neditor.setup(md)\nassert not editor.widget.editor.readonly\n",
        "CUT_1": "self.editor.copy()\n",
        "CUT_2": "self.editor.copy()\n",
        "CUT_3": "\"\"\"Overriding method createEditor\"\"\"\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    try:\n        self.old_obj = value.copy()\n    except AttributeError:\n        self.old_obj = copy.deepcopy(value)\n    if value is None:\n        return None\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br><i>%s</i>'\n        ) % to_text_string(msg))\n    return\nself.current_index = index\nkey = index.model().get_key(index).obj_name\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)):\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)) and ndarray is not FakeObject:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date):\n    if readonly:\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        return editor\nelif is_text_string(value) and len(value) > 40:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value):\n    if readonly:\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        return editor\nelse:\n    return None\n",
        "CUT_4": "\"\"\"Overriding method createEditor\"\"\"\nif self.show_warning(index):\n    answer = QMessageBox.warning(self.parent(), _('Warning'), _(\n        \"\"\"Opening this variable can be slow\n\nDo you want to continue anyway?\"\"\"\n        ), QMessageBox.Yes | QMessageBox.No)\n    if answer == QMessageBox.No:\n        return None\ntry:\n    value = self.get_value(index)\n    try:\n        self.old_obj = value.copy()\n    except AttributeError:\n        self.old_obj = copy.deepcopy(value)\n    if value is None:\n        return None\nexcept Exception as msg:\n    QMessageBox.critical(self.parent(), _('Error'), _(\n        'Spyder was unable to retrieve the value of this variable from the console.<br><br>The error message was:<br><i>%s</i>'\n        ) % to_text_string(msg))\n    return\nself.current_index = index\nkey = index.model().get_key(index).obj_name\nreadonly = isinstance(value, (tuple, set)) or self.parent(\n    ).readonly or not is_known_type(value)\nif isinstance(value, (list, set, tuple, dict)):\n    from spyder.widgets.collectionseditor import CollectionsEditor\n    editor = CollectionsEditor(parent=parent)\n    editor.setup(value, key, icon=self.parent().windowIcon(), readonly=readonly\n        )\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, (ndarray, MaskedArray)) and ndarray is not FakeObject:\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key, readonly=readonly):\n        return\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, Image\n    ) and ndarray is not FakeObject and Image is not FakeObject:\n    arr = array(value)\n    editor = ArrayEditor(parent=parent)\n    if not editor.setup_and_check(arr, title=key, readonly=readonly):\n        return\n    conv_func = lambda arr: Image.fromarray(arr, mode=value.mode)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly, conv=conv_func))\n    return None\nelif isinstance(value, (DataFrame, Index, Series)\n    ) and DataFrame is not FakeObject:\n    editor = DataFrameEditor(parent=parent)\n    if not editor.setup_and_check(value, title=key):\n        return\n    editor.dataModel.set_format(index.model().dataframe_format)\n    editor.sig_option_changed.connect(self.change_option)\n    self.create_dialog(editor, dict(model=index.model(), editor=editor, key\n        =key, readonly=readonly))\n    return None\nelif isinstance(value, datetime.date):\n    if readonly:\n        return None\n    else:\n        if isinstance(value, datetime.datetime):\n            editor = QDateTimeEdit(value, parent=parent)\n        else:\n            editor = QDateEdit(value, parent=parent)\n        editor.setCalendarPopup(True)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        return editor\nelif is_text_string(value) and len(value) > 40:\n    te = TextEditor(None, parent=parent)\n    if te.setup_and_check(value):\n        editor = TextEditor(value, key, readonly=readonly, parent=parent)\n        self.create_dialog(editor, dict(model=index.model(), editor=editor,\n            key=key, readonly=readonly))\n    return None\nelif is_editable_type(value):\n    if readonly:\n        return None\n    else:\n        editor = QLineEdit(parent=parent)\n        editor.setFont(get_font(font_size_delta=DEFAULT_SMALL_DELTA))\n        editor.setAlignment(Qt.AlignLeft)\n        return editor\nelse:\n    return None\n",
        "CUT_5": "return _('Editor')\n"
    },
    {
        "functionName": "copy",
        "className": "MyDictWithCorrectCopy",
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return MyDictWithCorrectCopy(self)\n",
        "CUT_1": "return (a > b) - (a < b)\n",
        "CUT_2": "return 2\n",
        "CUT_3": "return 2\n",
        "CUT_4": "return 2\n",
        "CUT_5": "return 2\n"
    },
    {
        "functionName": "test_collectionseditor_when_clicking_on_header_and_large_rows",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that sorting works when clicking in its header and there's a\n    large number of rows.\n    \"\"\"\nli = [1] * 10000\neditor = CollectionsEditor()\neditor.setup(li)\nview = editor.widget.editor\nheader = view.horizontalHeader()\nwith qtbot.waitSignal(header.sectionClicked, timeout=200):\n    qtbot.mouseClick(header.viewport(), Qt.LeftButton, pos=QPoint(1, 1))\nassert data(view.model, 0, 0) == 9999\n",
        "CUT_1": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_2": "\"\"\"Get the information to put in the header.\"\"\"\nif role == Qt.TextAlignmentRole:\n    if orientation == Qt.Horizontal:\n        return Qt.AlignCenter | Qt.AlignBottom\n    else:\n        return Qt.AlignRight | Qt.AlignVCenter\nif role != Qt.DisplayRole and role != Qt.ToolTipRole:\n    return None\nif self.axis == 1 and self._shape[1] <= 1:\n    return None\norient_axis = 0 if orientation == Qt.Horizontal else 1\nif self.model.header_shape[orient_axis] > 1:\n    header = section\nelse:\n    header = self.model.header(self.axis, section)\n    if not is_type_text_string(header):\n        header = to_text_string(header)\nreturn header\n",
        "CUT_3": "\"\"\"\n        Get the data for the header.\n\n        This is used when a header has levels.\n        \"\"\"\nif not index.isValid() or index.row() >= self._shape[0] or index.column(\n    ) >= self._shape[1]:\n    return None\nrow, col = (index.row(), index.column()) if self.axis == 0 else (index.\n    column(), index.row())\nif role != Qt.DisplayRole:\n    return None\nif self.axis == 0 and self._shape[0] <= 1:\n    return None\nheader = self.model.header(self.axis, col, row)\nif not is_type_text_string(header):\n    header = to_text_string(header)\nreturn header\n",
        "CUT_4": "\"\"\"\n        Get the data for the header.\n\n        This is used when a header has levels.\n        \"\"\"\nif not index.isValid() or index.row() >= self._shape[0] or index.column(\n    ) >= self._shape[1]:\n    return None\nrow, col = (index.row(), index.column()) if self.axis == 0 else (index.\n    column(), index.row())\nif role != Qt.DisplayRole:\n    return None\nif self.axis == 0 and self._shape[0] <= 1:\n    return None\nheader = self.model.header(self.axis, col, row)\nif not is_type_text_string(header):\n    header = to_text_string(header)\nreturn header\n",
        "CUT_5": "\"\"\"\n        Returns the horizontal header (of type QHeaderView).\n\n        Override this if the horizontalHeader() function does not exist.\n        \"\"\"\nreturn self.header()\n"
    },
    {
        "functionName": "test_dicts_with_mixed_types_as_key",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that we can show dictionaries with mixed data types as keys.\n\n    This is a regression for spyder-ide/spyder#13481.\n    \"\"\"\ncolors = {(1): 'red', 'Y': 'yellow'}\neditor = CollectionsEditor()\neditor.setup(colors)\nassert editor.widget.editor.source_model.keys == [1, 'Y']\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "base_format = QTextCharFormat()\nif font is not None:\n    self.font = font\nif self.font is not None:\n    base_format.setFont(self.font)\nself.formats = {}\ncolors = self.color_scheme.copy()\nself.background_color = colors.pop('background')\nself.currentline_color = colors.pop('currentline')\nself.currentcell_color = colors.pop('currentcell')\nself.occurrence_color = colors.pop('occurrence')\nself.ctrlclick_color = colors.pop('ctrlclick')\nself.sideareas_color = colors.pop('sideareas')\nself.matched_p_color = colors.pop('matched_p')\nself.unmatched_p_color = colors.pop('unmatched_p')\nfor name, (color, bold, italic) in list(colors.items()):\n    format = QTextCharFormat(base_format)\n    format.setForeground(QColor(color))\n    if bold:\n        format.setFontWeight(QFont.Bold)\n    format.setFontItalic(italic)\n    self.formats[name] = format\n",
        "CUT_4": "base_format = QTextCharFormat()\nif font is not None:\n    self.font = font\nif self.font is not None:\n    base_format.setFont(self.font)\nself.formats = {}\ncolors = self.color_scheme.copy()\nself.background_color = colors.pop('background')\nself.currentline_color = colors.pop('currentline')\nself.currentcell_color = colors.pop('currentcell')\nself.occurrence_color = colors.pop('occurrence')\nself.ctrlclick_color = colors.pop('ctrlclick')\nself.sideareas_color = colors.pop('sideareas')\nself.matched_p_color = colors.pop('matched_p')\nself.unmatched_p_color = colors.pop('unmatched_p')\nfor name, (color, bold, italic) in list(colors.items()):\n    format = QTextCharFormat(base_format)\n    format.setForeground(QColor(color))\n    if bold:\n        format.setFontWeight(QFont.Bold)\n    format.setFontItalic(italic)\n    self.formats[name] = format\n",
        "CUT_5": "\"\"\"Set data.\"\"\"\nif data != self.editor.source_model.get_data():\n    self.editor.set_data(data)\n    self.editor.adjust_columns()\n"
    },
    {
        "functionName": "test_dicts_natural_sorting",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that natural sorting actually does what it should do\n    \"\"\"\nimport random\nnumbers = list(range(100))\nrandom.shuffle(numbers)\ndictionary = {'test{}'.format(i): None for i in numbers}\ndata_sorted = sorted(list(dictionary.keys()), key=natsort)\nexpected = ['test{}'.format(i) for i in list(range(100))]\neditor = CollectionsEditor()\neditor.setup(dictionary)\neditor.widget.editor.source_model.sort(0)\nassert data_sorted == expected, 'Function failed'\nassert editor.widget.editor.source_model.keys == expected, 'GUI sorting fail'\n",
        "CUT_1": "return _('Editor')\n",
        "CUT_2": "return _('Editor')\n",
        "CUT_3": "self.history = list()\nself.id_list = list()\nself.editor = editor\n",
        "CUT_4": "self.history = list()\nself.id_list = list()\nself.editor = editor\n",
        "CUT_5": "return {k: v for dictionary in list_of_dicts for k, v in dictionary.items()}\n"
    },
    {
        "functionName": "test_dicts_natural_sorting_mixed_types",
        "className": null,
        "fileName": "/spyder/widgets/tests/test_collectioneditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that natural sorting actually does what it should do.\n    testing for issue 13733, as mixed types were sorted incorrectly.\n\n    Sorting for other columns will be tested as well.\n    \"\"\"\nimport pandas as pd\ndictionary = {'DSeries': pd.Series(dtype=int), 'aStr': 'algName', 'kDict':\n    {(2): 'asd', (3): 2}}\nstr_size = get_size(dictionary['aStr'])\neditor = CollectionsEditor()\neditor.setup(dictionary)\ncm = editor.widget.editor.source_model\ncm.sort(0)\nkeys = cm.keys\ntypes = cm.types\nsizes = cm.sizes\nassert keys == ['aStr', 'DSeries', 'kDict']\nassert types == ['str', 'Series', 'dict']\nassert sizes == [str_size, (0,), 2]\nassert data_table(cm, 3, 3) == [['aStr', 'DSeries', 'kDict'], ['str',\n    'Series', 'dict'], [str_size, '(0,)', 2]]\neditor.widget.editor.new_value('List', [1, 2, 3])\nassert data_table(cm, 4, 3) == [['aStr', 'DSeries', 'kDict', 'List'], [\n    'str', 'Series', 'dict', 'list'], [str_size, '(0,)', 2, 3]]\ncm.sort(0)\nassert data_table(cm, 4, 3) == [['aStr', 'DSeries', 'kDict', 'List'], [\n    'str', 'Series', 'dict', 'list'], [str_size, '(0,)', 2, 3]]\ncm.sort(1)\nassert data_table(cm, 4, 3) == [['DSeries', 'kDict', 'List', 'aStr'], [\n    'Series', 'dict', 'list', 'str'], ['(0,)', 2, 3, str_size]]\ncm.sort(2)\nassert data_table(cm, 4, 3) == [['DSeries', 'kDict', 'List', 'aStr'], [\n    'Series', 'dict', 'list', 'str'], ['(0,)', 2, 3, str_size]]\n",
        "CUT_1": "\"\"\"Return True if variable is a Series\"\"\"\ntry:\n    from pandas import Series\n    return isinstance(var, Series)\nexcept:\n    return False\n",
        "CUT_2": "return str(list(self))\n",
        "CUT_3": "return str(list(self))\n",
        "CUT_4": "self.history = list()\nself.id_list = list()\nself.editor = editor\n",
        "CUT_5": "self.history = list()\nself.id_list = list()\nself.editor = editor\n"
    },
    {
        "functionName": "github_dialog",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_login.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Set up error report dialog.\"\"\"\nwidget = DlgGitHubLogin(None, None)\nqtbot.addWidget(widget)\nreturn widget\npytest.fixture",
        "CUT_1": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_2": "\"\"\"Return page widget\"\"\"\nif index is None:\n    widget = self.pages_widget.currentWidget()\nelse:\n    widget = self.pages_widget.widget(index)\nif widget:\n    return widget.widget()\n",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n",
        "CUT_5": "widget = self.current_widget()\nif widget and widget.thumbnails_sb.current_thumbnail is not None:\n    if widget.figviewer.figcanvas.fig:\n        widget = widget.thumbnails_sb.scrollarea\nreturn widget\n"
    },
    {
        "functionName": "test_dialog",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_login.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that error report dialog UI behaves properly.\"\"\"\ndlg = github_dialog\nassert not dlg.bt_sign_in.isEnabled()\nqtbot.keyClicks(dlg.le_token, 'token')\nassert dlg.bt_sign_in.isEnabled()\n",
        "CUT_1": "mocker.patch.object(ima, 'icon', lambda x, icon_path=None: QIcon())\ndlg = ConfigDialogTester(request.param)\nqtbot.addWidget(dlg)\ndlg.show()\nreturn dlg\npytest.fixture",
        "CUT_2": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_3": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n"
    },
    {
        "functionName": "get_backend",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_backend.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "b = backend.GithubBackend(GH_OWNER, GH_REPO)\nb._show_msgbox = False\nreturn b\n",
        "CUT_1": "\"\"\"\n        :param gh_owner: Name of the owner of the github repository.\n        :param gh_repo: Name of the repository on github.\n        \"\"\"\nsuper(GithubBackend, self).__init__(formatter, 'Submit on github',\n    'Submit the issue on our issue tracker on github', None, parent_widget=\n    parent_widget)\nself.gh_owner = gh_owner\nself.gh_repo = gh_repo\nself._show_msgbox = True\n",
        "CUT_2": "\"\"\"\n        :param gh_owner: Name of the owner of the github repository.\n        :param gh_repo: Name of the repository on github.\n        \"\"\"\nsuper(GithubBackend, self).__init__(formatter, 'Submit on github',\n    'Submit the issue on our issue tracker on github', None, parent_widget=\n    parent_widget)\nself.gh_owner = gh_owner\nself.gh_repo = gh_repo\nself._show_msgbox = True\n",
        "CUT_3": "\"\"\"\n        Set a backend for Matplotlib.\n\n        backend: A parameter that can be passed to %matplotlib\n                 (e.g. 'inline' or 'tk').\n        \"\"\"\nimport traceback\nfrom IPython.core.getipython import get_ipython\ngeneric_error = ('\\n' + '=' * 73 +\n    \"\"\"\nNOTE: The following error appeared when setting your Matplotlib backend!!\n\"\"\"\n     + '=' * 73 + '\\n\\n{0}')\nmagic = 'pylab' if pylab else 'matplotlib'\nerror = None\ntry:\n    get_ipython().run_line_magic(magic, backend)\nexcept RuntimeError as err:\n    if 'GUI eventloops' in str(err):\n        import matplotlib\n        previous_backend = matplotlib.get_backend()\n        if not backend in previous_backend.lower():\n            error = (\n                \"\"\"\nNOTE: Spyder *can't* set your selected Matplotlib backend because there is a previous backend already in use.\n\nYour backend will be {0}\"\"\"\n                .format(previous_backend))\n        del matplotlib\n    else:\n        error = generic_error.format(traceback.format_exc())\nexcept Exception:\n    error = generic_error.format(traceback.format_exc())\nself._mpl_backend_error = error\n",
        "CUT_4": "_logger().debug(\"\"\"sending bug report on github\ntitle=%s\nbody=%s\"\"\", title,\n    body)\ncredentials = self.get_user_credentials()\ntoken = credentials['token']\nremember_token = credentials['remember_token']\nif token is None:\n    return False\n_logger().debug('got user credentials')\nif application_log:\n    url = self.upload_log_file(application_log)\n    body += '\\nApplication log: %s' % url\ntry:\n    gh = github.GitHub(access_token=token)\n    repo = gh.repos(self.gh_owner)(self.gh_repo)\n    ret = repo.issues.post(title=title, body=body)\nexcept github.ApiError as e:\n    _logger().warning('Failed to send bug report on Github. response=%r', e\n        .response)\n    if e.response.code == 401:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _('Invalid credentials'\n                ), _('Failed to create Github issue, invalid credentials...'))\n    elif self._show_msgbox:\n        QMessageBox.warning(self.parent_widget, _('Failed to create issue'),\n            _('Failed to create Github issue. Error %d') % e.response.code)\n    return False\nelse:\n    issue_nbr = ret['number']\n    if self._show_msgbox:\n        ret = QMessageBox.question(self.parent_widget, _(\n            'Issue created on Github'), _(\n            'Issue successfully created. Would you like to open the issue in your web browser?'\n            ))\n    if ret in [QMessageBox.Yes, QMessageBox.Ok]:\n        webbrowser.open('https://github.com/%s/%s/issues/%d' % (self.\n            gh_owner, self.gh_repo, issue_nbr))\n    return True\n",
        "CUT_5": "_logger().debug(\"\"\"sending bug report on github\ntitle=%s\nbody=%s\"\"\", title,\n    body)\ncredentials = self.get_user_credentials()\ntoken = credentials['token']\nremember_token = credentials['remember_token']\nif token is None:\n    return False\n_logger().debug('got user credentials')\nif application_log:\n    url = self.upload_log_file(application_log)\n    body += '\\nApplication log: %s' % url\ntry:\n    gh = github.GitHub(access_token=token)\n    repo = gh.repos(self.gh_owner)(self.gh_repo)\n    ret = repo.issues.post(title=title, body=body)\nexcept github.ApiError as e:\n    _logger().warning('Failed to send bug report on Github. response=%r', e\n        .response)\n    if e.response.code == 401:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _('Invalid credentials'\n                ), _('Failed to create Github issue, invalid credentials...'))\n    elif self._show_msgbox:\n        QMessageBox.warning(self.parent_widget, _('Failed to create issue'),\n            _('Failed to create Github issue. Error %d') % e.response.code)\n    return False\nelse:\n    issue_nbr = ret['number']\n    if self._show_msgbox:\n        ret = QMessageBox.question(self.parent_widget, _(\n            'Issue created on Github'), _(\n            'Issue successfully created. Would you like to open the issue in your web browser?'\n            ))\n    if ret in [QMessageBox.Yes, QMessageBox.Ok]:\n        webbrowser.open('https://github.com/%s/%s/issues/%d' % (self.\n            gh_owner, self.gh_repo, issue_nbr))\n    return True\n"
    },
    {
        "functionName": "get_backend_bad_repo",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_backend.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "b = backend.GithubBackend(GH_OWNER, GH_REPO + '1234')\nb._show_msgbox = False\nreturn b\n",
        "CUT_1": "\"\"\"\n        :param gh_owner: Name of the owner of the github repository.\n        :param gh_repo: Name of the repository on github.\n        \"\"\"\nsuper(GithubBackend, self).__init__(formatter, 'Submit on github',\n    'Submit the issue on our issue tracker on github', None, parent_widget=\n    parent_widget)\nself.gh_owner = gh_owner\nself.gh_repo = gh_repo\nself._show_msgbox = True\n",
        "CUT_2": "\"\"\"\n        :param gh_owner: Name of the owner of the github repository.\n        :param gh_repo: Name of the repository on github.\n        \"\"\"\nsuper(GithubBackend, self).__init__(formatter, 'Submit on github',\n    'Submit the issue on our issue tracker on github', None, parent_widget=\n    parent_widget)\nself.gh_owner = gh_owner\nself.gh_repo = gh_repo\nself._show_msgbox = True\n",
        "CUT_3": "\"\"\"\n        Set a backend for Matplotlib.\n\n        backend: A parameter that can be passed to %matplotlib\n                 (e.g. 'inline' or 'tk').\n        \"\"\"\nimport traceback\nfrom IPython.core.getipython import get_ipython\ngeneric_error = ('\\n' + '=' * 73 +\n    \"\"\"\nNOTE: The following error appeared when setting your Matplotlib backend!!\n\"\"\"\n     + '=' * 73 + '\\n\\n{0}')\nmagic = 'pylab' if pylab else 'matplotlib'\nerror = None\ntry:\n    get_ipython().run_line_magic(magic, backend)\nexcept RuntimeError as err:\n    if 'GUI eventloops' in str(err):\n        import matplotlib\n        previous_backend = matplotlib.get_backend()\n        if not backend in previous_backend.lower():\n            error = (\n                \"\"\"\nNOTE: Spyder *can't* set your selected Matplotlib backend because there is a previous backend already in use.\n\nYour backend will be {0}\"\"\"\n                .format(previous_backend))\n        del matplotlib\n    else:\n        error = generic_error.format(traceback.format_exc())\nexcept Exception:\n    error = generic_error.format(traceback.format_exc())\nself._mpl_backend_error = error\n",
        "CUT_4": "_logger().debug(\"\"\"sending bug report on github\ntitle=%s\nbody=%s\"\"\", title,\n    body)\ncredentials = self.get_user_credentials()\ntoken = credentials['token']\nremember_token = credentials['remember_token']\nif token is None:\n    return False\n_logger().debug('got user credentials')\nif application_log:\n    url = self.upload_log_file(application_log)\n    body += '\\nApplication log: %s' % url\ntry:\n    gh = github.GitHub(access_token=token)\n    repo = gh.repos(self.gh_owner)(self.gh_repo)\n    ret = repo.issues.post(title=title, body=body)\nexcept github.ApiError as e:\n    _logger().warning('Failed to send bug report on Github. response=%r', e\n        .response)\n    if e.response.code == 401:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _('Invalid credentials'\n                ), _('Failed to create Github issue, invalid credentials...'))\n    elif self._show_msgbox:\n        QMessageBox.warning(self.parent_widget, _('Failed to create issue'),\n            _('Failed to create Github issue. Error %d') % e.response.code)\n    return False\nelse:\n    issue_nbr = ret['number']\n    if self._show_msgbox:\n        ret = QMessageBox.question(self.parent_widget, _(\n            'Issue created on Github'), _(\n            'Issue successfully created. Would you like to open the issue in your web browser?'\n            ))\n    if ret in [QMessageBox.Yes, QMessageBox.Ok]:\n        webbrowser.open('https://github.com/%s/%s/issues/%d' % (self.\n            gh_owner, self.gh_repo, issue_nbr))\n    return True\n",
        "CUT_5": "_logger().debug(\"\"\"sending bug report on github\ntitle=%s\nbody=%s\"\"\", title,\n    body)\ncredentials = self.get_user_credentials()\ntoken = credentials['token']\nremember_token = credentials['remember_token']\nif token is None:\n    return False\n_logger().debug('got user credentials')\nif application_log:\n    url = self.upload_log_file(application_log)\n    body += '\\nApplication log: %s' % url\ntry:\n    gh = github.GitHub(access_token=token)\n    repo = gh.repos(self.gh_owner)(self.gh_repo)\n    ret = repo.issues.post(title=title, body=body)\nexcept github.ApiError as e:\n    _logger().warning('Failed to send bug report on Github. response=%r', e\n        .response)\n    if e.response.code == 401:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _('Invalid credentials'\n                ), _('Failed to create Github issue, invalid credentials...'))\n    elif self._show_msgbox:\n        QMessageBox.warning(self.parent_widget, _('Failed to create issue'),\n            _('Failed to create Github issue. Error %d') % e.response.code)\n    return False\nelse:\n    issue_nbr = ret['number']\n    if self._show_msgbox:\n        ret = QMessageBox.question(self.parent_widget, _(\n            'Issue created on Github'), _(\n            'Issue successfully created. Would you like to open the issue in your web browser?'\n            ))\n    if ret in [QMessageBox.Yes, QMessageBox.Ok]:\n        webbrowser.open('https://github.com/%s/%s/issues/%d' % (self.\n            gh_owner, self.gh_repo, issue_nbr))\n    return True\n"
    },
    {
        "functionName": "get_wrong_user_credentials",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_backend.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Monkeypatch GithubBackend.get_user_credentials to force the case where\n    invalid credentias were provided\n    \"\"\"\nreturn dict(token='invalid', remember_token=False)\n",
        "CUT_1": "dlg = DlgGitHubLogin(parent, token, remember_token)\nif dlg.exec_() == dlg.Accepted:\n    token = dlg.le_token.text()\n    if dlg.cb_remember_token:\n        remember_token = dlg.cb_remember_token.isChecked()\n    else:\n        remember_token = False\n    credentials = dict(token=token, remember_token=remember_token)\n    return credentials\nreturn dict(token=None, remember_token=False)\nclassmethod",
        "CUT_2": "dlg = DlgGitHubLogin(parent, token, remember_token)\nif dlg.exec_() == dlg.Accepted:\n    token = dlg.le_token.text()\n    if dlg.cb_remember_token:\n        remember_token = dlg.cb_remember_token.isChecked()\n    else:\n        remember_token = False\n    credentials = dict(token=token, remember_token=remember_token)\n    return credentials\nreturn dict(token=None, remember_token=False)\nclassmethod",
        "CUT_3": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n",
        "CUT_4": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n",
        "CUT_5": "\"\"\"Get the stored credentials if any.\"\"\"\nremember_token = CONF.get('main', 'report_error/remember_token')\nreturn remember_token\n"
    },
    {
        "functionName": "get_empty_user_credentials",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_backend.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Monkeypatch GithubBackend.get_user_credentials to force the case where\n    invalid credentias were provided\n    \"\"\"\nreturn dict(token='', remember_token=False)\n",
        "CUT_1": "dlg = DlgGitHubLogin(parent, token, remember_token)\nif dlg.exec_() == dlg.Accepted:\n    token = dlg.le_token.text()\n    if dlg.cb_remember_token:\n        remember_token = dlg.cb_remember_token.isChecked()\n    else:\n        remember_token = False\n    credentials = dict(token=token, remember_token=remember_token)\n    return credentials\nreturn dict(token=None, remember_token=False)\nclassmethod",
        "CUT_2": "dlg = DlgGitHubLogin(parent, token, remember_token)\nif dlg.exec_() == dlg.Accepted:\n    token = dlg.le_token.text()\n    if dlg.cb_remember_token:\n        remember_token = dlg.cb_remember_token.isChecked()\n    else:\n        remember_token = False\n    credentials = dict(token=token, remember_token=remember_token)\n    return credentials\nreturn dict(token=None, remember_token=False)\nclassmethod",
        "CUT_3": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n",
        "CUT_4": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n",
        "CUT_5": "\"\"\"Get the stored credentials if any.\"\"\"\nremember_token = CONF.get('main', 'report_error/remember_token')\nreturn remember_token\n"
    },
    {
        "functionName": "get_fake_user_credentials",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_backend.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Monkeypatch GithubBackend.get_user_credentials to force the case where\n    invalid credentias were provided\n    \"\"\"\nreturn dict(token=TOKEN, remember_token=False)\n",
        "CUT_1": "if not isinstance(y, Token):\n    return False\nreturn self.token == y.token\n",
        "CUT_2": "if not isinstance(y, Token):\n    return False\nreturn self.token == y.token\n",
        "CUT_3": "if not isinstance(y, Token):\n    return True\nreturn self.token != y.token\n",
        "CUT_4": "if not isinstance(y, Token):\n    return True\nreturn self.token != y.token\n",
        "CUT_5": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n"
    },
    {
        "functionName": "test_invalid_credentials",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_backend.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "b = get_backend()\nb.get_user_credentials = get_wrong_user_credentials\nret_value = b.send_report('Wrong credentials', 'Wrong credentials')\nassert ret_value is False\n",
        "CUT_1": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n",
        "CUT_2": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n",
        "CUT_3": "_logger().debug(\"\"\"sending bug report on github\ntitle=%s\nbody=%s\"\"\", title,\n    body)\ncredentials = self.get_user_credentials()\ntoken = credentials['token']\nremember_token = credentials['remember_token']\nif token is None:\n    return False\n_logger().debug('got user credentials')\nif application_log:\n    url = self.upload_log_file(application_log)\n    body += '\\nApplication log: %s' % url\ntry:\n    gh = github.GitHub(access_token=token)\n    repo = gh.repos(self.gh_owner)(self.gh_repo)\n    ret = repo.issues.post(title=title, body=body)\nexcept github.ApiError as e:\n    _logger().warning('Failed to send bug report on Github. response=%r', e\n        .response)\n    if e.response.code == 401:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _('Invalid credentials'\n                ), _('Failed to create Github issue, invalid credentials...'))\n    elif self._show_msgbox:\n        QMessageBox.warning(self.parent_widget, _('Failed to create issue'),\n            _('Failed to create Github issue. Error %d') % e.response.code)\n    return False\nelse:\n    issue_nbr = ret['number']\n    if self._show_msgbox:\n        ret = QMessageBox.question(self.parent_widget, _(\n            'Issue created on Github'), _(\n            'Issue successfully created. Would you like to open the issue in your web browser?'\n            ))\n    if ret in [QMessageBox.Yes, QMessageBox.Ok]:\n        webbrowser.open('https://github.com/%s/%s/issues/%d' % (self.\n            gh_owner, self.gh_repo, issue_nbr))\n    return True\n",
        "CUT_4": "_logger().debug(\"\"\"sending bug report on github\ntitle=%s\nbody=%s\"\"\", title,\n    body)\ncredentials = self.get_user_credentials()\ntoken = credentials['token']\nremember_token = credentials['remember_token']\nif token is None:\n    return False\n_logger().debug('got user credentials')\nif application_log:\n    url = self.upload_log_file(application_log)\n    body += '\\nApplication log: %s' % url\ntry:\n    gh = github.GitHub(access_token=token)\n    repo = gh.repos(self.gh_owner)(self.gh_repo)\n    ret = repo.issues.post(title=title, body=body)\nexcept github.ApiError as e:\n    _logger().warning('Failed to send bug report on Github. response=%r', e\n        .response)\n    if e.response.code == 401:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _('Invalid credentials'\n                ), _('Failed to create Github issue, invalid credentials...'))\n    elif self._show_msgbox:\n        QMessageBox.warning(self.parent_widget, _('Failed to create issue'),\n            _('Failed to create Github issue. Error %d') % e.response.code)\n    return False\nelse:\n    issue_nbr = ret['number']\n    if self._show_msgbox:\n        ret = QMessageBox.question(self.parent_widget, _(\n            'Issue created on Github'), _(\n            'Issue successfully created. Would you like to open the issue in your web browser?'\n            ))\n    if ret in [QMessageBox.Yes, QMessageBox.Ok]:\n        webbrowser.open('https://github.com/%s/%s/issues/%d' % (self.\n            gh_owner, self.gh_repo, issue_nbr))\n    return True\n",
        "CUT_5": "\"\"\"Get the stored credentials if any.\"\"\"\nremember_token = CONF.get('main', 'report_error/remember_token')\nreturn remember_token\n"
    },
    {
        "functionName": "test_empty_credentials",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_backend.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "b = get_backend()\nb.get_user_credentials = get_empty_user_credentials\nret_value = b.send_report('Empty credentials', 'Wrong credentials')\nassert ret_value is False\n",
        "CUT_1": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n",
        "CUT_2": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n",
        "CUT_3": "_logger().debug(\"\"\"sending bug report on github\ntitle=%s\nbody=%s\"\"\", title,\n    body)\ncredentials = self.get_user_credentials()\ntoken = credentials['token']\nremember_token = credentials['remember_token']\nif token is None:\n    return False\n_logger().debug('got user credentials')\nif application_log:\n    url = self.upload_log_file(application_log)\n    body += '\\nApplication log: %s' % url\ntry:\n    gh = github.GitHub(access_token=token)\n    repo = gh.repos(self.gh_owner)(self.gh_repo)\n    ret = repo.issues.post(title=title, body=body)\nexcept github.ApiError as e:\n    _logger().warning('Failed to send bug report on Github. response=%r', e\n        .response)\n    if e.response.code == 401:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _('Invalid credentials'\n                ), _('Failed to create Github issue, invalid credentials...'))\n    elif self._show_msgbox:\n        QMessageBox.warning(self.parent_widget, _('Failed to create issue'),\n            _('Failed to create Github issue. Error %d') % e.response.code)\n    return False\nelse:\n    issue_nbr = ret['number']\n    if self._show_msgbox:\n        ret = QMessageBox.question(self.parent_widget, _(\n            'Issue created on Github'), _(\n            'Issue successfully created. Would you like to open the issue in your web browser?'\n            ))\n    if ret in [QMessageBox.Yes, QMessageBox.Ok]:\n        webbrowser.open('https://github.com/%s/%s/issues/%d' % (self.\n            gh_owner, self.gh_repo, issue_nbr))\n    return True\n",
        "CUT_4": "_logger().debug(\"\"\"sending bug report on github\ntitle=%s\nbody=%s\"\"\", title,\n    body)\ncredentials = self.get_user_credentials()\ntoken = credentials['token']\nremember_token = credentials['remember_token']\nif token is None:\n    return False\n_logger().debug('got user credentials')\nif application_log:\n    url = self.upload_log_file(application_log)\n    body += '\\nApplication log: %s' % url\ntry:\n    gh = github.GitHub(access_token=token)\n    repo = gh.repos(self.gh_owner)(self.gh_repo)\n    ret = repo.issues.post(title=title, body=body)\nexcept github.ApiError as e:\n    _logger().warning('Failed to send bug report on Github. response=%r', e\n        .response)\n    if e.response.code == 401:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _('Invalid credentials'\n                ), _('Failed to create Github issue, invalid credentials...'))\n    elif self._show_msgbox:\n        QMessageBox.warning(self.parent_widget, _('Failed to create issue'),\n            _('Failed to create Github issue. Error %d') % e.response.code)\n    return False\nelse:\n    issue_nbr = ret['number']\n    if self._show_msgbox:\n        ret = QMessageBox.question(self.parent_widget, _(\n            'Issue created on Github'), _(\n            'Issue successfully created. Would you like to open the issue in your web browser?'\n            ))\n    if ret in [QMessageBox.Yes, QMessageBox.Ok]:\n        webbrowser.open('https://github.com/%s/%s/issues/%d' % (self.\n            gh_owner, self.gh_repo, issue_nbr))\n    return True\n",
        "CUT_5": "\"\"\"Get the stored credentials if any.\"\"\"\nremember_token = CONF.get('main', 'report_error/remember_token')\nreturn remember_token\n"
    },
    {
        "functionName": "test_fake_credentials_bad_repo",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_backend.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "b = get_backend_bad_repo()\nb.get_user_credentials = get_fake_user_credentials\nret_value = b.send_report('Test suite', 'Test fake credentials')\nassert ret_value is False\n",
        "CUT_1": "\"\"\"Fake!\"\"\"\npass\n",
        "CUT_2": "\"\"\"Fake!\"\"\"\npass\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n"
    },
    {
        "functionName": "test_get_credentials_from_settings",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_backend.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "b = get_backend()\nremember_token = b._get_credentials_from_settings()\nassert remember_token is False\nCONF.set('main', 'report_error/remember_token', True)\nremember_token = b._get_credentials_from_settings()\nassert remember_token is True\n",
        "CUT_1": "\"\"\"Get the stored credentials if any.\"\"\"\nremember_token = CONF.get('main', 'report_error/remember_token')\nreturn remember_token\n",
        "CUT_2": "\"\"\"Get the stored credentials if any.\"\"\"\nremember_token = CONF.get('main', 'report_error/remember_token')\nreturn remember_token\n",
        "CUT_3": "dlg = DlgGitHubLogin(parent, token, remember_token)\nif dlg.exec_() == dlg.Accepted:\n    token = dlg.le_token.text()\n    if dlg.cb_remember_token:\n        remember_token = dlg.cb_remember_token.isChecked()\n    else:\n        remember_token = False\n    credentials = dict(token=token, remember_token=remember_token)\n    return credentials\nreturn dict(token=None, remember_token=False)\nclassmethod",
        "CUT_4": "dlg = DlgGitHubLogin(parent, token, remember_token)\nif dlg.exec_() == dlg.Accepted:\n    token = dlg.le_token.text()\n    if dlg.cb_remember_token:\n        remember_token = dlg.cb_remember_token.isChecked()\n    else:\n        remember_token = False\n    credentials = dict(token=token, remember_token=remember_token)\n    return credentials\nreturn dict(token=None, remember_token=False)\nclassmethod",
        "CUT_5": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n"
    },
    {
        "functionName": "test_store_user_credentials",
        "className": null,
        "fileName": "/spyder/widgets/github/tests/test_github_backend.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "b = get_backend()\nb._store_token('token', True)\ncredentials = b.get_user_credentials()\nassert credentials['token'] == 'token'\nassert credentials['remember_token'] is True\npytest.mark.skipif(os.environ.get('CI', None) is not None and not sys.\n    platform == 'darwin', reason='Only work on macOS and our CIs')",
        "CUT_1": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n",
        "CUT_2": "\"\"\"Get user credentials with the login dialog.\"\"\"\ntoken = None\nremember_token = self._get_credentials_from_settings()\nvalid_py_os = not (PY2 and sys.platform.startswith('linux'))\nif remember_token and valid_py_os:\n    try:\n        token = keyring.get_password('github', 'token')\n    except Exception:\n        if self._show_msgbox:\n            QMessageBox.warning(self.parent_widget, _(\n                'Failed to retrieve token'), _(\n                'It was not possible to retrieve your token. Please introduce it again.'\n                ))\nif not running_under_pytest():\n    credentials = DlgGitHubLogin.login(self.parent_widget, token,\n        remember_token)\n    if credentials['token'] and valid_py_os:\n        self._store_token(credentials['token'], credentials['remember_token'])\n        CONF.set('main', 'report_error/remember_token', credentials[\n            'remember_token'])\nelse:\n    return dict(token=token, remember_token=remember_token)\nreturn credentials\n",
        "CUT_3": "if not isinstance(y, Token):\n    return True\nreturn self.token != y.token\n",
        "CUT_4": "if not isinstance(y, Token):\n    return True\nreturn self.token != y.token\n",
        "CUT_5": "dlg = DlgGitHubLogin(parent, token, remember_token)\nif dlg.exec_() == dlg.Accepted:\n    token = dlg.le_token.text()\n    if dlg.cb_remember_token:\n        remember_token = dlg.cb_remember_token.isChecked()\n    else:\n        remember_token = False\n    credentials = dict(token=token, remember_token=remember_token)\n    return credentials\nreturn dict(token=None, remember_token=False)\nclassmethod"
    },
    {
        "functionName": "test_edit",
        "className": null,
        "fileName": "/build/lib/spyder/plugins/variableexplorer/widgets/dataframeeditor.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test subroutine\"\"\"\napp = qapplication()\ndlg = DataFrameEditor(parent=parent)\nif dlg.setup_and_check(data, title=title):\n    dlg.exec_()\n    return dlg.get_value()\nelse:\n    import sys\n    sys.exit(1)\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = SpyderErrorDialog()\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ndlg = DlgGitHubLogin(None, None)\ndlg.show()\nsys.exit(dlg.exec_())\n",
        "CUT_5": "\"\"\"Reset shortcuts.\"\"\"\ndlg = ShortcutsSummaryDialog(None)\ndlg.exec_()\n"
    },
    {
        "functionName": "test_msgcheckbox",
        "className": null,
        "fileName": "/build/lib/spyder/widgets/helperwidgets.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nbox = MessageCheckBox()\nbox.setWindowTitle(_('Spyder updates'))\nbox.setText('Testing checkbox')\nbox.set_checkbox_text('Check for updates on startup?')\nbox.setStandardButtons(QMessageBox.Ok)\nbox.setDefaultButton(QMessageBox.Ok)\nbox.setIcon(QMessageBox.Information)\nbox.exec_()\n",
        "CUT_1": "\"\"\"\n        Create a textbox field.\n        \"\"\"\nif default is not None and len(default) > 30:\n    box = QtWidgets.QTextEdit(parent=self)\n    box.setText = box.setPlainText\n    box.text = box.toPlainText\nelse:\n    box = QtWidgets.QLineEdit(parent=self)\nbox.setting = setting\nif default is not None:\n    box.setText(default)\n    box.textChanged.connect(lambda x=None: self.render())\nbox.get_value = lambda : box.text()\nbox.set_value = lambda text: box.setText(text)\nreturn box\n",
        "CUT_2": "\"\"\"\n        Create a textbox field.\n        \"\"\"\nif default is not None and len(default) > 30:\n    box = QtWidgets.QTextEdit(parent=self)\n    box.setText = box.setPlainText\n    box.text = box.toPlainText\nelse:\n    box = QtWidgets.QLineEdit(parent=self)\nbox.setting = setting\nif default is not None:\n    box.setText(default)\n    box.textChanged.connect(lambda x=None: self.render())\nbox.get_value = lambda : box.text()\nbox.set_value = lambda text: box.setText(text)\nreturn box\n",
        "CUT_3": "\"\"\"Called by WorkerUpdates when ready\"\"\"\nfrom spyder.widgets.helperwidgets import MessageCheckBox\nfeedback = self.give_updates_feedback\nupdate_available = self.worker_updates.update_available\nlatest_release = self.worker_updates.latest_release\nerror_msg = self.worker_updates.error\nurl_r = __project_url__ + '/releases/tag/v{}'.format(latest_release)\nurl_i = 'https://docs.spyder-ide.org/installation.html'\nbox = MessageCheckBox(icon=QMessageBox.Information, parent=self)\nbox.setWindowTitle(_('New Spyder version'))\nbox.set_checkbox_text(_('Check for updates at startup'))\nbox.setStandardButtons(QMessageBox.Ok)\nbox.setDefaultButton(QMessageBox.Ok)\nsection, option = 'main', 'check_updates_on_startup'\ncheck_updates = CONF.get(section, option)\nbox.set_checked(check_updates)\nif error_msg is not None:\n    msg = error_msg\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nelif update_available:\n    header = _('<b>Spyder {} is available!</b><br><br>').format(latest_release)\n    footer = _(\n        'For more information visit our <a href=\"{}\">installation guide</a>.'\n        ).format(url_i)\n    if is_anaconda():\n        content = _(\n            \"<b>Important note:</b> Since you installed Spyder with Anaconda, please <b>don't</b> use <code>pip</code> to update it as that will break your installation.<br><br>Instead, run the following commands in a terminal:<br><code>conda update anaconda</code><br><code>conda install spyder={}</code><br><br>\"\n            ).format(latest_release)\n    else:\n        content = _(\n            'Please go to <a href=\"{}\">this page</a> to download it.<br><br>'\n            ).format(url_r)\n    msg = header + content + footer\n    box.setText(msg)\n    box.set_check_visible(True)\n    box.exec_()\n    check_updates = box.is_checked()\nelif feedback:\n    msg = _('Spyder is up to date.')\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nCONF.set(section, option, check_updates)\nself.check_updates_action.setDisabled(False)\nself.give_updates_feedback = True\n",
        "CUT_4": "\"\"\"Called by WorkerUpdates when ready\"\"\"\nfrom spyder.widgets.helperwidgets import MessageCheckBox\nfeedback = self.give_updates_feedback\nupdate_available = self.worker_updates.update_available\nlatest_release = self.worker_updates.latest_release\nerror_msg = self.worker_updates.error\nurl_r = __project_url__ + '/releases/tag/v{}'.format(latest_release)\nurl_i = 'https://docs.spyder-ide.org/installation.html'\nbox = MessageCheckBox(icon=QMessageBox.Information, parent=self)\nbox.setWindowTitle(_('New Spyder version'))\nbox.set_checkbox_text(_('Check for updates at startup'))\nbox.setStandardButtons(QMessageBox.Ok)\nbox.setDefaultButton(QMessageBox.Ok)\nsection, option = 'main', 'check_updates_on_startup'\ncheck_updates = CONF.get(section, option)\nbox.set_checked(check_updates)\nif error_msg is not None:\n    msg = error_msg\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nelif update_available:\n    header = _('<b>Spyder {} is available!</b><br><br>').format(latest_release)\n    footer = _(\n        'For more information visit our <a href=\"{}\">installation guide</a>.'\n        ).format(url_i)\n    if is_anaconda():\n        content = _(\n            \"<b>Important note:</b> Since you installed Spyder with Anaconda, please <b>don't</b> use <code>pip</code> to update it as that will break your installation.<br><br>Instead, run the following commands in a terminal:<br><code>conda update anaconda</code><br><code>conda install spyder={}</code><br><br>\"\n            ).format(latest_release)\n    else:\n        content = _(\n            'Please go to <a href=\"{}\">this page</a> to download it.<br><br>'\n            ).format(url_r)\n    msg = header + content + footer\n    box.setText(msg)\n    box.set_check_visible(True)\n    box.exec_()\n    check_updates = box.is_checked()\nelif feedback:\n    msg = _('Spyder is up to date.')\n    box.setText(msg)\n    box.set_check_visible(False)\n    box.exec_()\n    check_updates = box.is_checked()\nCONF.set(section, option, check_updates)\nself.check_updates_action.setDisabled(False)\nself.give_updates_feedback = True\n",
        "CUT_5": "\"\"\"\n        Report that either the transport layer or the LSP server are\n        down.\n        \"\"\"\nself.update_status(language, ClientStatus.DOWN)\nif not self.get_option('show_lsp_down_warning'):\n    return\nif os.name == 'nt':\n    os_message = (\n        'To try to fix this, please verify that your firewall or antivirus allows Python processes to open ports in your system, or restart Spyder.<br><br>'\n        )\nelse:\n    os_message = 'This problem could be fixed by restarting Spyder. '\nwarn_str = _(\n    'Completion and linting in the editor for {language} files will not work during the current session, or stopped working.<br><br>'\n    ).format(language=language.capitalize()) + os_message + _(\n    'Do you want to restart Spyder now?')\nbox = MessageCheckBox(icon=QMessageBox.Warning, parent=self.main)\nbox.setWindowTitle(_('Warning'))\nbox.set_checkbox_text(_(\"Don't show again\"))\nbox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\nbox.setDefaultButton(QMessageBox.No)\nbox.set_checked(False)\nbox.set_check_visible(True)\nbox.setText(warn_str)\nanswer = box.exec_()\nself.set_option('show_lsp_down_warning', not box.is_checked())\nif answer == QMessageBox.Yes:\n    self.main.restart()\nSlot(str)"
    },
    {
        "functionName": "get_kernel",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/test_utils.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Get an instance of a kernel with the kernel class given.\"\"\"\nlog = logging.getLogger('test')\nlog.setLevel(logging.DEBUG)\nfor hdlr in log.handlers:\n    log.removeHandler(hdlr)\nhdlr = logging.StreamHandler(StringIO())\nhdlr.setLevel(logging.DEBUG)\nlog.addHandler(hdlr)\ncontext = zmq.Context.instance()\niopub_socket = context.socket(zmq.PUB)\nkernel = kernel_class(session=ss.Session(), iopub_socket=iopub_socket, log=log)\nreturn kernel\n",
        "CUT_1": "\"\"\"\n    Initialize the logger for this thread.\n\n    Sets the log level to ERROR (0), WARNING (1), INFO (2), or DEBUG (3),\n    depending on the argument `level`.\n    \"\"\"\nlevellist = [logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG]\nhandler = logging.StreamHandler()\nfmt = (\n    '%(levelname) -10s %(asctime)s %(name) -30s %(funcName) -35s %(lineno) -5d: %(message)s'\n    )\nhandler.setFormatter(logging.Formatter(fmt))\nlogger = logging.root\nlogger.addHandler(handler)\nlogger.setLevel(levellist[level])\n",
        "CUT_2": "\"\"\"\n    Initialize the logger for this thread.\n\n    Sets the log level to ERROR (0), WARNING (1), INFO (2), or DEBUG (3),\n    depending on the argument `level`.\n    \"\"\"\nlevellist = [logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG]\nhandler = logging.StreamHandler()\nfmt = (\n    '%(levelname) -10s %(asctime)s %(name) -30s %(funcName) -35s %(lineno) -5d: %(message)s'\n    )\nhandler.setFormatter(logging.Formatter(fmt))\nlogger = logging.root\nlogger.addHandler(handler)\nlogger.setLevel(levellist[level])\n",
        "CUT_3": "return logging.getLogger(__name__)\n",
        "CUT_4": "return logging.getLogger(__name__)\n",
        "CUT_5": "root_logger = logging.root\nif log_config:\n    with open(log_config, 'r') as f:\n        logging.config.dictConfig(json.load(f))\nelse:\n    formatter = logging.Formatter(LOG_FORMAT)\n    if log_file:\n        log_handler = logging.handlers.RotatingFileHandler(log_file, mode=\n            'a', maxBytes=50 * 1024 * 1024, backupCount=10, encoding=None,\n            delay=0)\n    else:\n        log_handler = logging.StreamHandler()\n    log_handler.setFormatter(formatter)\n    root_logger.addHandler(log_handler)\nif verbose == 0:\n    level = logging.WARNING\nelif verbose == 1:\n    level = logging.INFO\nelif verbose >= 2:\n    level = logging.DEBUG\nroot_logger.setLevel(level)\n"
    },
    {
        "functionName": "get_log_text",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/test_utils.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Get the log of the given kernel.\"\"\"\nreturn kernel.log.handlers[0].stream.getvalue()\n",
        "CUT_1": "log = open(FILENAME, 'a')\nprefix = format_prefix(attr, self)\nlog.write('%s %s\\n' % (prefix, name))\nlog.close()\nresult = attr(*args, **kwargs)\nreturn result\n",
        "CUT_2": "log = open(FILENAME, 'a')\nprefix = format_prefix(attr, self)\nlog.write('%s %s\\n' % (prefix, name))\nlog.close()\nresult = attr(*args, **kwargs)\nreturn result\n",
        "CUT_3": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_4": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_5": "try:\n    sys.path.remove(osp.dirname(__file__))\nexcept ValueError:\n    pass\ntry:\n    locals().pop('__file__')\nexcept KeyError:\n    pass\n__doc__ = ''\n__name__ = '__main__'\nimport_spydercustomize()\nwhile '' in sys.path:\n    sys.path.remove('')\nfrom ipykernel.kernelapp import IPKernelApp\nfrom spyder_kernels.console.kernel import SpyderKernel\nclass SpyderKernelApp(IPKernelApp):\n\n    def init_pdb(self):\n        \"\"\"\n            This method was added in IPykernel 5.3.1 and it replaces\n            the debugger used by the kernel with a new class\n            introduced in IPython 7.15 during kernel's initialization.\n            Therefore, it doesn't allow us to use our debugger.\n            \"\"\"\n        pass\nkernel = SpyderKernelApp.instance()\nkernel.kernel_class = SpyderKernel\ntry:\n    kernel.config = kernel_config()\nexcept:\n    pass\nkernel.initialize()\nkernel.shell.register_magic_function(varexp)\nimport pdb\nkernel.shell.InteractiveTB.debugger_cls = pdb.Pdb\nkernel.start()\n"
    },
    {
        "functionName": "method",
        "className": "Test",
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_dochelpers.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "pass\n",
        "CUT_1": "pass\n",
        "CUT_2": "pass\n",
        "CUT_3": "pass\n",
        "CUT_4": "pass\n",
        "CUT_5": "pass\n"
    },
    {
        "functionName": "test_dochelpers",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_dochelpers.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test dochelpers.\"\"\"\nassert not getargtxt(Test.__init__)\nif PY2:\n    assert getargtxt(Test.method) == ['x, ', 'y=2']\n    assert getdoc(sorted) == {'note': 'Function of __builtin__ module',\n        'argspec': '(iterable, cmp=None, key=None, reverse=False)',\n        'docstring':\n        'sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list'\n        , 'name': 'sorted'}\n    assert getargtxt(sorted) == ['iterable, ', ' cmp=None, ', ' key=None, ',\n        ' reverse=False']\nelse:\n    assert not getargtxt(Test.method)\n    if os.name == 'nt':\n        assert getdoc(sorted) == {'note': 'Function of builtins module',\n            'argspec': '(...)', 'docstring':\n            \"\"\"Return a new list containing all items from the iterable in ascending order.\n\nA custom key function can be supplied to customise the sort order, and the\nreverse flag can be set to request the result in descending order.\"\"\"\n            , 'name': 'sorted'}\n    else:\n        assert getdoc(sorted) == {'note': 'Function of builtins module',\n            'argspec': '(...)', 'docstring':\n            \"\"\"Return a new list containing all items from the iterable in ascending order.\n\nA custom key function can be supplied to customize the sort order, and the\nreverse flag can be set to request the result in descending order.\"\"\"\n            , 'name': 'sorted'}\n    assert not getargtxt(sorted)\nassert isdefined('numpy.take', force_import=True)\nassert isdefined('__import__')\nassert not isdefined('.keys', force_import=True)\nassert getobj('globals') == 'globals'\nassert not getobj('globals().keys')\nassert getobj('+scipy.signal.') == 'scipy.signal'\nassert getobj('4.') == '4'\npytest.mark.skipif(not PY2, reason='It fails in Python 3')",
        "CUT_1": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"\n    Arrange items of list1 in the same order as sorted(list2).\n\n    In other words, apply to list1 the permutation which takes list2 \n    to sorted(list2, reverse).\n    \"\"\"\nif sort_key is None:\n    key = lambda x: x[0]\nelse:\n    key = lambda x: sort_key(x[0])\ntry:\n    return [item for _, item in sorted(zip(list2, list1), key=key, reverse=\n        reverse)]\nexcept:\n    return list1\n",
        "CUT_4": "\"\"\"Remove values from data\"\"\"\ndata = self.source_model.get_data()\nfor key in sorted(keys, reverse=True):\n    data.pop(key)\nself.set_data(data)\n",
        "CUT_5": "\"\"\"Remove values from data\"\"\"\ndata = self.source_model.get_data()\nfor key in sorted(keys, reverse=True):\n    data.pop(key)\nself.set_data(data)\n"
    },
    {
        "functionName": "generate_complex_object",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Taken from issue #4221.\"\"\"\nbug = defaultdict(list)\nfor i in range(50000):\n    a = {j: np.random.rand(10) for j in range(10)}\n    bug[i] = a\nreturn bug\n",
        "CUT_1": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n",
        "CUT_2": "\"\"\"Run object editor test\"\"\"\nimport datetime\nimport numpy as np\nfrom spyder.pil_patch import Image\ndata = np.random.randint(1, 256, size=(100, 100)).astype('uint8')\nimage = Image.fromarray(data)\nexample = {'str': 'kjkj kj k j j kj k jkj', 'list': [1, 3, 4, 'kjkj', None],\n    'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False}, 'dict': {'d': 1,\n    'a': np.random.rand(10, 10), 'b': [1, 2]}, 'float': 1.2233, 'array': np\n    .random.rand(10, 10), 'image': image, 'date': datetime.date(1945, 5, 8),\n    'datetime': datetime.datetime(1945, 5, 8)}\nimage = oedit(image)\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\nfoobar = Foobar()\nprint(oedit(foobar))\nprint(oedit(example))\nprint(oedit(np.random.rand(10, 10)))\nprint(oedit(oedit.__doc__))\nprint(example)\n",
        "CUT_3": "for i in range(3):\n    print(i)\n",
        "CUT_4": "for i in range(3):\n    print(i)\n",
        "CUT_5": "for i in range(3):\n    print(i)\n"
    },
    {
        "functionName": "test_get_size",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the size of all values is returned correctly\"\"\"\nclass RecursionClassNoLen:\n\n    def __getattr__(self, name):\n        if name == 'size':\n            return self.name\n        else:\n            return super(object, self).__getattribute__(name)\nlength = [list([1, 2, 3]), tuple([1, 2, 3]), set([1, 2, 3]), '123', {(1): 1,\n    (2): 2, (3): 3}]\nfor obj in length:\n    assert get_size(obj) == 3\ndf = pd.DataFrame([[1, 2, 3], [1, 2, 3]])\nassert get_size(df) == (2, 3)\ndf = pd.Series([1, 2, 3])\nassert get_size(df) == (3,)\ndf = pd.Index([1, 2, 3])\nassert get_size(df) == (3,)\narr = np.array([[1, 2, 3], [1, 2, 3]], dtype=np.complex)\nassert get_size(arr) == (2, 3)\nimg = PIL.Image.new('RGB', (256, 256))\nassert get_size(img) == (256, 256)\nobj = RecursionClassNoLen()\nassert get_size(obj) == 1\n",
        "CUT_1": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_2": "\"\"\"Return data\"\"\"\nreturn self.df\n",
        "CUT_3": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_4": "\"\"\"Return modified Dataframe -- this is *not* a copy\"\"\"\ndf = self.dataModel.get_data()\nif self.is_series:\n    return df.iloc[:, (0)]\nelse:\n    return df\n",
        "CUT_5": "\"\"\"Return the value of the DataFrame.\"\"\"\ntry:\n    value = self.df.iat[row, column]\nexcept OutOfBoundsDatetime:\n    value = self.df.iloc[:, (column)].astype(str).iat[row]\nexcept:\n    value = self.df.iloc[row, column]\nreturn value\n"
    },
    {
        "functionName": "__getattr__",
        "className": "RecursionClassNoLen",
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if name == 'size':\n    return self.name\nelse:\n    return super(object, self).__getattribute__(name)\n",
        "CUT_1": "self.name = name\n",
        "CUT_2": "self.name = name\n",
        "CUT_3": "\"\"\"Returns a code cell name from a code cell comment.\"\"\"\nname = text.strip().lstrip('#% ')\nif name.startswith('<codecell>'):\n    name = name[10:].lstrip()\nelif name.startswith('In['):\n    name = name[2:]\n    if name.endswith(']:'):\n        name = name[:-1]\n    name = name.strip()\nreturn name\n",
        "CUT_4": "\"\"\"Returns a code cell name from a code cell comment.\"\"\"\nname = text.strip().lstrip('#% ')\nif name.startswith('<codecell>'):\n    name = name[10:].lstrip()\nelif name.startswith('In['):\n    name = name[2:]\n    if name.endswith(']:'):\n        name = name[:-1]\n    name = name.strip()\nreturn name\n",
        "CUT_5": "\"\"\"Configuration page name\"\"\"\nreturn self.NAME\n"
    },
    {
        "functionName": "test_sort_against",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "lista = [5, 6, 7]\nlistb = [2, 3, 1]\nres = sort_against(lista, listb)\nassert res == [7, 5, 6]\n",
        "CUT_1": "\"\"\"Removes duplicates from lista neglecting its initial ordering\"\"\"\nreturn list(set(lista))\n",
        "CUT_2": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_3": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_4": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_5": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n"
    },
    {
        "functionName": "test_sort_against_is_stable",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "lista = [3, 0, 1]\nlistb = [1, 1, 1]\nres = sort_against(lista, listb)\nassert res == lista\n",
        "CUT_1": "\"\"\"Removes duplicates from lista neglecting its initial ordering\"\"\"\nreturn list(set(lista))\n",
        "CUT_2": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_3": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_4": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_5": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n"
    },
    {
        "functionName": "test_none_values_are_supported",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests that None values are displayed by default\"\"\"\nsupported_types = get_supported_types()\nmode = 'editable'\nnone_var = None\nnone_list = [2, None, 3, None]\nnone_dict = {'a': None, 'b': 4}\nnone_tuple = None, [3, None, 4], 'eggs'\nassert is_supported(none_var, filters=tuple(supported_types[mode]))\nassert is_supported(none_list, filters=tuple(supported_types[mode]))\nassert is_supported(none_dict, filters=tuple(supported_types[mode]))\nassert is_supported(none_tuple, filters=tuple(supported_types[mode]))\n",
        "CUT_1": "\"\"\"\n    Return globals according to filter described in *settings*:\n        * data: data to be filtered (dictionary)\n        * settings: variable explorer settings (dictionary)\n        * mode (string): 'editable' or 'picklable'\n        * more_excluded_names: additional excluded names (list)\n    \"\"\"\nsupported_types = get_supported_types()\nassert mode in list(supported_types.keys())\nexcluded_names = settings['excluded_names']\nif more_excluded_names is not None:\n    excluded_names += more_excluded_names\nreturn globalsfilter(data, check_all=settings['check_all'], filters=tuple(\n    supported_types[mode]), exclude_private=settings['exclude_private'],\n    exclude_uppercase=settings['exclude_uppercase'], exclude_capitalized=\n    settings['exclude_capitalized'], exclude_unsupported=settings[\n    'exclude_unsupported'], exclude_callables_and_modules=settings[\n    'exclude_callables_and_modules'], excluded_names=excluded_names)\n",
        "CUT_2": "\"\"\"Return True if value is supported, False otherwise.\"\"\"\nassert filters is not None\nif value is None:\n    return True\nif is_callable_or_module(value):\n    return True\nelif not is_editable_type(value):\n    return False\nelif not isinstance(value, filters):\n    return False\nelif iterate:\n    if isinstance(value, (list, tuple, set)):\n        valid_count = 0\n        for val in value:\n            if is_supported(val, filters=filters, iterate=check_all):\n                valid_count += 1\n            if not check_all:\n                break\n        return valid_count > 0\n    elif isinstance(value, dict):\n        for key, val in list(value.items()):\n            if not is_supported(key, filters=filters, iterate=check_all\n                ) or not is_supported(val, filters=filters, iterate=check_all):\n                return False\n            if not check_all:\n                break\nreturn True\n",
        "CUT_3": "\"\"\"Clear all the filters.\"\"\"\nself.filters = {}\nself.invalidateFilter()\n",
        "CUT_4": "\"\"\"Clear all the filters.\"\"\"\nself.filters = {}\nself.invalidateFilter()\n",
        "CUT_5": "filters = []\nfor title, ftypes in filetypes:\n    filters.append(_create_filter(title, ftypes))\nfilters.append(ALL_FILTER)\nreturn ';;'.join(filters)\n"
    },
    {
        "functionName": "test_str_subclass_display",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test for value_to_display of subclasses of str/basestring.\"\"\"\nclass Test(str):\n\n    def __repr__(self):\n        return 'test'\nvalue = Test()\nvalue_display = value_to_display(value)\nassert 'Test object' in value_display\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "\"\"\"Run layout test widget test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nnames = ['test', 'tester', '20', '30', '40']\norder = ['test', 'tester', '20', '30', '40']\nactive = ['test', 'tester']\nwidget_1 = LayoutSettingsDialog(None, names, order, active)\nwidget_2 = LayoutSaveDialog(None, order)\nwidget_1.show()\nwidget_2.show()\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "__repr__",
        "className": "Test",
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return 'test'\n",
        "CUT_1": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_2": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\nif file_explorer:\n    test = FileExplorerTest()\nelse:\n    test = ProjectExplorerTest()\ntest.resize(640, 480)\ntest.show()\napp.exec_()\n",
        "CUT_3": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_4": "from spyder.utils.qthelpers import qapplication\napp = qapplication()\ntest = ProjectExplorerTest()\ntest.resize(250, 480)\ntest.show()\napp.exec_()\n",
        "CUT_5": "\"\"\"Run layout test widget test\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nnames = ['test', 'tester', '20', '30', '40']\norder = ['test', 'tester', '20', '30', '40']\nactive = ['test', 'tester']\nwidget_1 = LayoutSettingsDialog(None, names, order, active)\nwidget_2 = LayoutSaveDialog(None, order)\nwidget_1.show()\nwidget_2.show()\nsys.exit(app.exec_())\n"
    },
    {
        "functionName": "test_default_display",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for default_display.\"\"\"\nassert value_to_display(COMPLEX_OBJECT\n    ) == 'defaultdict object of collections module'\nassert value_to_display(np.array(COMPLEX_OBJECT)\n    ) == 'ndarray object of numpy module'\nassert value_to_display(DATASET\n    ) == 'Dataset object of xarray.core.dataset module'\n",
        "CUT_1": "\"\"\"Make a link for a class.\"\"\"\nname, module = object.__name__, sys.modules.get(object.__module__)\nif hasattr(module, name) and getattr(module, name) is object:\n    return '<a href=\"%s.html#%s\">%s</a>' % (module.__name__, name,\n        classname(object, modname))\nreturn classname(object, modname)\n",
        "CUT_2": "\"\"\"Make a link for a class.\"\"\"\nname, module = object.__name__, sys.modules.get(object.__module__)\nif hasattr(module, name) and getattr(module, name) is object:\n    return '<a href=\"%s.html#%s\">%s</a>' % (module.__name__, name,\n        classname(object, modname))\nreturn classname(object, modname)\n",
        "CUT_3": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_4": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_5": "\"\"\"Make a link for a module.\"\"\"\nreturn '<a href=\"%s.html\">%s</a>' % (object.__name__, object.__name__)\n"
    },
    {
        "functionName": "test_list_display",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for display of lists.\"\"\"\nlong_list = list(range(100))\nassert value_to_display([1, 2, 3]) == '[1, 2, 3]'\nassert value_to_display(long_list) == '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...]'\nassert value_to_display([long_list] * 3\n    ) == '[[0, 1, 2, 3, 4, ...], [0, 1, 2, 3, 4, ...], [0, 1, 2, 3, 4, ...]]'\nresult = '[' + ''.join('[0, 1, 2, 3, 4, ...], ' * 10)[:-2] + ']'\nassert value_to_display([long_list] * 10) == result[:70] + ' ...'\nassert value_to_display([[1, 2, 3, [4], 5]] + long_list\n    ) == '[[1, 2, 3, [...], 5], 0, 1, 2, 3, 4, 5, 6, 7, 8, ...]'\nassert value_to_display([1, 2, [DF]]) == '[1, 2, [Dataframe]]'\nassert value_to_display([1, 2, [[DF], DATASET]]) == '[1, 2, [[...], Dataset]]'\nassert value_to_display([COMPLEX_OBJECT]) == '[defaultdict]'\nli = [COMPLEX_OBJECT, DATASET, 1, {(1): 2, (3): 4}, DF]\nresult = '[defaultdict, Dataset, 1, {1:2, 3:4}, Dataframe]'\nassert value_to_display(li) == result\nsupported_types = tuple(get_supported_types()['editable'])\nli = [len, 1]\nassert value_to_display(li) == '[builtin_function_or_method, 1]'\nassert is_supported(li, filters=supported_types)\n",
        "CUT_1": "\"\"\"Create input extension dialog and save it to for reuse.\"\"\"\nself._dlg_input = InputTextDialog(self, title=_('File association'), label=\n    _(\n    'Enter new file extension. You can add several values separated by commas.<br>Examples include:'\n    ) + '<ul><li><code>*.txt</code></li>' +\n    '<li><code>*.json,*.csv</code></li>' +\n    '<li><code>*.json,README.md</code></li></ul>')\nself._dlg_input.set_regex_validation(self._EXTENSIONS_LIST_REGEX)\n",
        "CUT_2": "\"\"\"Create input extension dialog and save it to for reuse.\"\"\"\nself._dlg_input = InputTextDialog(self, title=_('File association'), label=\n    _(\n    'Enter new file extension. You can add several values separated by commas.<br>Examples include:'\n    ) + '<ul><li><code>*.txt</code></li>' +\n    '<li><code>*.json,*.csv</code></li>' +\n    '<li><code>*.json,README.md</code></li></ul>')\nself._dlg_input.set_regex_validation(self._EXTENSIONS_LIST_REGEX)\n",
        "CUT_3": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_4": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_5": "\"\"\"Display for collections (i.e. list, set, tuple and dict).\"\"\"\nis_dict = isinstance(value, dict)\nis_set = isinstance(value, set)\nif is_dict:\n    elements = iteritems(value)\nelse:\n    elements = value\ntruncate = False\nif level == 1 and len(value) > 10:\n    elements = islice(elements, 10) if is_dict or is_set else value[:10]\n    truncate = True\nelif level == 2 and len(value) > 5:\n    elements = islice(elements, 5) if is_dict or is_set else value[:5]\n    truncate = True\nif level <= 2:\n    if is_dict:\n        displays = [(value_to_display(k, level=level) + ':' +\n            value_to_display(v, level=level)) for k, v in list(elements)]\n    else:\n        displays = [value_to_display(e, level=level) for e in elements]\n    if truncate:\n        displays.append('...')\n    display = ', '.join(displays)\nelse:\n    display = '...'\nif is_dict:\n    display = '{' + display + '}'\nelif isinstance(value, list):\n    display = '[' + display + ']'\nelif isinstance(value, set):\n    display = '{' + display + '}'\nelse:\n    display = '(' + display + ')'\nreturn display\n"
    },
    {
        "functionName": "test_dict_display",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for display of dicts.\"\"\"\nlong_list = list(range(100))\nlong_dict = dict(zip(list(range(100)), list(range(100))))\nassert value_to_display({(0): 0, 'a': 'b'}) == \"{0:0, 'a':'b'}\"\nassert value_to_display(long_dict\n    ) == '{0:0, 1:1, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8, 9:9, ...}'\nassert value_to_display({(1): long_dict, (2): long_dict}\n    ) == '{1:{0:0, 1:1, 2:2, 3:3, 4:4, ...}, 2:{0:0, 1:1, 2:2, 3:3, 4:4, ...}}'\nresult = (\n    '{(0, 0, 0, 0, 0, ...):[0, 1, 2, 3, 4, ...], (1, 1, 1, 1, 1, ...):[0, 1, 2, 3, 4, ...]}'\n    )\nassert value_to_display({((0,) * 100): long_list, ((1,) * 100): long_list}\n    ) == result[:70] + ' ...'\nassert value_to_display({(0): {(1): 1, (2): 2, (3): 3, (4): {(0): 0}, (5): \n    5}, (1): 1}) == '{0:{1:1, 2:2, 3:3, 4:{...}, 5:5}, 1:1}'\nassert value_to_display({(0): 0, (1): 1, (2): 2, (3): DF}\n    ) == '{0:0, 1:1, 2:2, 3:Dataframe}'\nassert value_to_display({(0): 0, (1): 1, (2): [[DF], DATASET]}\n    ) == '{0:0, 1:1, 2:[[...], Dataset]}'\nassert value_to_display({(0): COMPLEX_OBJECT}) == '{0:defaultdict}'\nli = {(0): COMPLEX_OBJECT, (1): DATASET, (2): 2, (3): {(0): 0, (1): 1}, (4): DF\n    }\nresult = '{0:defaultdict, 1:Dataset, 2:2, 3:{0:0, 1:1}, 4:Dataframe}'\nassert value_to_display(li) == result\nsupported_types = tuple(get_supported_types()['editable'])\ndi = {max: len, (1): 1}\nassert value_to_display(di) in (\n    '{builtin_function_or_method:builtin_function_or_method, 1:1}',\n    '{1:1, builtin_function_or_method:builtin_function_or_method}')\nassert is_supported(di, filters=supported_types)\n",
        "CUT_1": "\"\"\"Format a list of items into a multi-column list.\"\"\"\nresult = ''\nrows = (len(list) + cols - 1) // cols\nfor col in range(cols):\n    result = result + '<td style=\"width:%d%%;vertical-align:text-top\">' % (\n        100 // cols)\n    for i in range(rows * col, rows * col + rows):\n        if i < len(list):\n            result = result + format(list[i]) + '<br>\\n'\n    result = result + '</td>'\nreturn '<table style=\"width:100%%\"><tr>%s</tr></table>' % result\n",
        "CUT_2": "\"\"\"Format a list of items into a multi-column list.\"\"\"\nresult = ''\nrows = (len(list) + cols - 1) // cols\nfor col in range(cols):\n    result = result + '<td style=\"width:%d%%;vertical-align:text-top\">' % (\n        100 // cols)\n    for i in range(rows * col, rows * col + rows):\n        if i < len(list):\n            result = result + format(list[i]) + '<br>\\n'\n    result = result + '</td>'\nreturn '<table style=\"width:100%%\"><tr>%s</tr></table>' % result\n",
        "CUT_3": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_4": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_5": "if isinstance(result, list):\n    if len(result) > 0:\n        result = result[0]\n        result['file'] = process_uri(result['uri'])\n    else:\n        result = None\nelif isinstance(result, dict):\n    result['file'] = process_uri(result['uri'])\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_DEFINITION, {'params':\n        result})\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)"
    },
    {
        "functionName": "test_set_display",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests for display of sets.\"\"\"\nlong_set = {i for i in range(100)}\nassert value_to_display({1, 2, 3}) == '{1, 2, 3}'\ndisp = '{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...}'\nassert value_to_display(long_set) == disp\ndisp = '[{0, 1, 2, 3, 4, ...}, {0, 1, 2, 3, 4, ...}, {0, 1, 2, 3, 4, ...}]'\nassert value_to_display([long_set] * 3) == disp\ndisp = '[' + ''.join('{0, 1, 2, 3, 4, ...}, ' * 10)[:-2] + ']'\nassert value_to_display([long_set] * 10) == disp[:70] + ' ...'\n",
        "CUT_1": "\"\"\"Display for collections (i.e. list, set, tuple and dict).\"\"\"\nis_dict = isinstance(value, dict)\nis_set = isinstance(value, set)\nif is_dict:\n    elements = iteritems(value)\nelse:\n    elements = value\ntruncate = False\nif level == 1 and len(value) > 10:\n    elements = islice(elements, 10) if is_dict or is_set else value[:10]\n    truncate = True\nelif level == 2 and len(value) > 5:\n    elements = islice(elements, 5) if is_dict or is_set else value[:5]\n    truncate = True\nif level <= 2:\n    if is_dict:\n        displays = [(value_to_display(k, level=level) + ':' +\n            value_to_display(v, level=level)) for k, v in list(elements)]\n    else:\n        displays = [value_to_display(e, level=level) for e in elements]\n    if truncate:\n        displays.append('...')\n    display = ', '.join(displays)\nelse:\n    display = '...'\nif is_dict:\n    display = '{' + display + '}'\nelif isinstance(value, list):\n    display = '[' + display + ']'\nelif isinstance(value, set):\n    display = '{' + display + '}'\nelse:\n    display = '(' + display + ')'\nreturn display\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_4": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n",
        "CUT_5": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n"
    },
    {
        "functionName": "test_datetime_display",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Simple tests that dates, datetimes and timedeltas display correctly.\"\"\"\ntest_date = datetime.date(2017, 12, 18)\ntest_date_2 = datetime.date(2017, 2, 2)\ntest_datetime = datetime.datetime(2017, 12, 18, 13, 43, 2)\ntest_datetime_2 = datetime.datetime(2017, 8, 18, 0, 41, 27)\ntest_timedelta = datetime.timedelta(-1, 2000)\ntest_timedelta_2 = datetime.timedelta(0, 3600)\nassert value_to_display(test_date) == '2017-12-18'\nassert value_to_display(test_datetime) == '2017-12-18 13:43:02'\nassert value_to_display(test_timedelta) == '-1 day, 0:33:20'\nassert value_to_display([test_date, test_date_2]) == '[2017-12-18, 2017-02-02]'\nassert value_to_display([test_datetime, test_datetime_2]\n    ) == '[2017-12-18 13:43:02, 2017-08-18 00:41:27]'\nassert value_to_display([test_timedelta, test_timedelta_2]\n    ) == '[-1 day, 0:33:20, 1:00:00]'\nassert value_to_display((test_date, test_datetime, test_timedelta)\n    ) == '(2017-12-18, 2017-12-18 13:43:02, -1 day, 0:33:20)'\nassert value_to_display({(0): test_date, (1): test_datetime, (2):\n    test_timedelta_2}) == '{0:2017-12-18, 1:2017-12-18 13:43:02, 2:1:00:00}'\n",
        "CUT_1": "QToolButton.__init__(self, parent)\nself.setFixedSize(20, 20)\nself.setIconSize(QSize(12, 12))\nself.clicked.connect(self.choose_color)\nself._color = QColor()\n",
        "CUT_2": "QToolButton.__init__(self, parent)\nself.setFixedSize(20, 20)\nself.setIconSize(QSize(12, 12))\nself.clicked.connect(self.choose_color)\nself._color = QColor()\n",
        "CUT_3": "\"\"\"Just for 'year, month, day' strings\"\"\"\nreturn datetime.datetime(*list(map(int, datestr.split(','))))\n",
        "CUT_4": "\"\"\"Convert a string to a datetime.timedelta value.\n\n    The following strings are accepted:\n\n        - 'datetime.timedelta(1, 5, 12345)'\n        - 'timedelta(1, 5, 12345)'\n        - '(1, 5, 12345)'\n        - '1, 5, 12345'\n        - '1'\n\n    if there are less then three parameters, the missing parameters are\n    assumed to be 0. Variations in the spacing of the parameters are allowed.\n\n    Raises:\n        ValueError for strings not matching the above criterion.\n\n    \"\"\"\nm = re.match('^(?:(?:datetime\\\\.)?timedelta)?\\\\(?([^)]*)\\\\)?$', value)\nif not m:\n    raise ValueError('Invalid string for datetime.timedelta')\nargs = [int(a.strip()) for a in m.group(1).split(',')]\nreturn datetime.timedelta(*args)\n",
        "CUT_5": "\"\"\"Just for 'day/month/year' strings\"\"\"\n_a, _b, _c = list(map(int, datestr.split('/')))\nif dayfirst:\n    return datetime.datetime(_c, _b, _a)\nreturn datetime.datetime(_c, _a, _b)\n"
    },
    {
        "functionName": "test_str_in_container_display",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that strings are displayed correctly inside lists or dicts.\"\"\"\nassert value_to_display([b'a', 'b']) == \"['a', 'b']\"\nif PY2:\n    assert value_to_display(['\u042d'.encode('cp1251')]) == \"['\u00dd']\"\n",
        "CUT_1": "return iter(d.lists(**kw))\n",
        "CUT_2": "return iter(d.lists(**kw))\n",
        "CUT_3": "return iter(d.lists(**kw))\n",
        "CUT_4": "return _('Search for strings of text in files.')\n",
        "CUT_5": "return _('Search for strings of text in files.')\n"
    },
    {
        "functionName": "test_ellipses",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_nsview.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that we're adding a binary ellipses when value_to_display of\n    a collection is too long and binary.\n\n    For issue 6942\n    \"\"\"\nfile = tmpdir.new(basename='bytes.txt')\nfile.write_binary(bytearray(list(range(255))))\nbuffer = file.read(mode='rb')\nassert b' ...' in value_to_display(buffer)\n",
        "CUT_1": "\"\"\"\n        Print the error to file or to sys.stderr if file is None.\n        \"\"\"\nif file is None:\n    file = sys.stderr\nfor line in self.format_error():\n    print(line, file=file)\n",
        "CUT_2": "buffer = b''\nheaders = b''\ncontinue_reading = True\nwhile continue_reading:\n    try:\n        buffer += self.read_num_bytes(1)\n        if b'\\r\\n\\r\\n' in buffer:\n            split = buffer.split(b'\\r\\n\\r\\n')\n            if len(split) == 2:\n                headers, buffer = split\n                continue_reading = False\n    except socket.error as e:\n        logger.error(e)\n        raise e\nheaders = self.parse_headers(headers)\nlogger.debug(headers)\ncontent_length = int(headers[b'Content-Length'])\npending_bytes = content_length - len(buffer)\nwhile pending_bytes > 0:\n    logger.debug('Pending bytes...' + str(pending_bytes))\n    recv = self.read_num_bytes(min(1024, pending_bytes))\n    buffer += recv\n    pending_bytes -= len(recv)\nreturn self.encode_body(buffer, headers)\n",
        "CUT_3": "buffer = b''\nheaders = b''\ncontinue_reading = True\nwhile continue_reading:\n    try:\n        buffer += self.read_num_bytes(1)\n        if b'\\r\\n\\r\\n' in buffer:\n            split = buffer.split(b'\\r\\n\\r\\n')\n            if len(split) == 2:\n                headers, buffer = split\n                continue_reading = False\n    except socket.error as e:\n        logger.error(e)\n        raise e\nheaders = self.parse_headers(headers)\nlogger.debug(headers)\ncontent_length = int(headers[b'Content-Length'])\npending_bytes = content_length - len(buffer)\nwhile pending_bytes > 0:\n    logger.debug('Pending bytes...' + str(pending_bytes))\n    recv = self.read_num_bytes(min(1024, pending_bytes))\n    buffer += recv\n    pending_bytes -= len(recv)\nreturn self.encode_body(buffer, headers)\n",
        "CUT_4": "\"\"\"Return True if `obj` is a binary string, False if it is anything else\"\"\"\nif PY2:\n    return isinstance(obj, str)\nelse:\n    return isinstance(obj, bytes)\n",
        "CUT_5": "\"\"\"Return True if `obj` is a binary string, False if it is anything else\"\"\"\nif PY2:\n    return isinstance(obj, str)\nelse:\n    return isinstance(obj, bytes)\n"
    },
    {
        "functionName": "are_namespaces_equal",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if actual is None and expected is None:\n    return True\nare_equal = True\nfor var in sorted(expected.keys()):\n    try:\n        are_equal = are_equal and bool(np.mean(expected[var] == actual[var]))\n    except ValueError:\n        are_equal = are_equal and all([np.all(obj1 == obj2) for obj1, obj2 in\n            zip(expected[var], actual[var])])\n    print(str(var) + ': ' + str(are_equal))\nreturn are_equal\n",
        "CUT_1": "\"\"\"Return array's shape\"\"\"\ntry:\n    if self._is_array(var):\n        return var.shape\n    else:\n        return None\nexcept:\n    return None\n",
        "CUT_2": "\"\"\"Return array's ndim\"\"\"\ntry:\n    if self._is_array(var):\n        return var.ndim\n    else:\n        return None\nexcept:\n    return None\n",
        "CUT_3": "\"\"\"Return sequence length\"\"\"\ntry:\n    return len(var)\nexcept:\n    return None\n",
        "CUT_4": "\"\"\"\n    Remove non-ascii entries from a dictionary of environments variables.\n\n    The values will be converted to strings or bytes (on Python 2). If an\n    exception is raised, an empty string will be used.\n    \"\"\"\nnew_env_vars = env_vars.copy()\nfor key, var in iteritems(env_vars):\n    if PY2:\n        try:\n            unicode_var = to_text_string(var)\n        except UnicodeDecodeError:\n            try:\n                unicode_var = to_unicode_from_fs(var)\n            except Exception:\n                unicode_var = ''\n        new_env_vars[key] = to_binary_string(unicode_var, encoding='utf-8')\n    else:\n        new_env_vars[key] = to_text_string(var)\nreturn new_env_vars\n",
        "CUT_5": "\"\"\"\n    Remove non-ascii entries from a dictionary of environments variables.\n\n    The values will be converted to strings or bytes (on Python 2). If an\n    exception is raised, an empty string will be used.\n    \"\"\"\nnew_env_vars = env_vars.copy()\nfor key, var in iteritems(env_vars):\n    if PY2:\n        try:\n            unicode_var = to_text_string(var)\n        except UnicodeDecodeError:\n            try:\n                unicode_var = to_unicode_from_fs(var)\n            except Exception:\n                unicode_var = ''\n        new_env_vars[key] = to_binary_string(unicode_var, encoding='utf-8')\n    else:\n        new_env_vars[key] = to_text_string(var)\nreturn new_env_vars\n"
    },
    {
        "functionName": "__init__",
        "className": "CustomObj",
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "self.data = None\nif data:\n    self.data = data\n",
        "CUT_1": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_2": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_3": "if self.data:\n    return self.data[self.get_stack_index()]\n",
        "CUT_4": "if self.data:\n    return self.data[self.get_stack_index()]\n",
        "CUT_5": "\"\"\"\n        Set breakpoint data on widget.\n\n        Parameters\n        ----------\n        data: dict, optional\n            Breakpoint data to use. If None, data from the configuration\n            will be loaded. Default is None.\n        \"\"\"\nif data is None:\n    data = self._load_data()\nself.get_widget().set_data(data)\n"
    },
    {
        "functionName": "__eq__",
        "className": "CustomObj",
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return self.__dict__ == other.__dict__\n",
        "CUT_1": "d = self.__dict__.copy()\ndel d['make_hashes']\nreturn d\n",
        "CUT_2": "d = self.__dict__.copy()\ndel d['make_hashes']\nreturn d\n",
        "CUT_3": "return list(self.__dict__.keys()) + [x for x in dir(self.__class__) if x[0] !=\n    '_']\n",
        "CUT_4": "return list(self.__dict__.keys()) + [x for x in dir(self.__class__) if x[0] !=\n    '_']\n",
        "CUT_5": "if self.language is not None:\n    state = CONF.get('lsp-server', self.language.lower())\n    self.__dict__.update(state)\n"
    },
    {
        "functionName": "__getstate__",
        "className": "UnDeepCopyableObj",
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "raise RuntimeError()\n",
        "CUT_1": "raise NotImplementedError\n",
        "CUT_2": "raise NotImplementedError\n",
        "CUT_3": "raise NotImplementedError\n",
        "CUT_4": "raise NotImplementedError\n",
        "CUT_5": "raise NotImplementedError\n"
    },
    {
        "functionName": "__deepcopy__",
        "className": "UnPickleableObj",
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "new_one = self.__class__.__new__(self.__class__)\nnew_one.__dict__.update(self.__dict__)\nreturn new_one\n",
        "CUT_1": "return list(self.__dict__.keys()) + [x for x in dir(self.__class__) if x[0] !=\n    '_']\n",
        "CUT_2": "return list(self.__dict__.keys()) + [x for x in dir(self.__class__) if x[0] !=\n    '_']\n",
        "CUT_3": "d = self.__dict__.copy()\ndel d['make_hashes']\nreturn d\n",
        "CUT_4": "d = self.__dict__.copy()\ndel d['make_hashes']\nreturn d\n",
        "CUT_5": "if self.language is not None:\n    state = CONF.get('lsp-server', self.language.lower())\n    self.__dict__.update(state)\n"
    },
    {
        "functionName": "spydata_values",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Define spydata file ground truth values.\n\n    The file export_data.spydata contains five variables to be loaded.\n    This fixture declares those variables in a static way.\n    \"\"\"\nA = 1\nB = 'ham'\nC = np.eye(3)\nD = {'a': True, 'b': np.eye(4, dtype=np.complex)}\nE = [np.eye(2, dtype=np.int64), 42.0, np.eye(3, dtype=np.bool_)]\nreturn {'A': A, 'B': B, 'C': C, 'D': D, 'E': E}\npytest.fixture",
        "CUT_1": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_2": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n",
        "CUT_3": "QAbstractTableModel.__init__(self)\nself.dialog = parent\nself.changes = {}\nself.xlabels = xlabels\nself.ylabels = ylabels\nself.readonly = readonly\nself.test_array = np.array([0], dtype=data.dtype)\nif data.dtype in (np.complex64, np.complex128):\n    self.color_func = np.abs\nelse:\n    self.color_func = np.real\nhuerange = [0.66, 0.99]\nself.sat = 0.7\nself.val = 1.0\nself.alp = 0.6\nself._data = data\nself._format = format\nself.total_rows = self._data.shape[0]\nself.total_cols = self._data.shape[1]\nsize = self.total_rows * self.total_cols\ntry:\n    self.vmin = np.nanmin(self.color_func(data))\n    self.vmax = np.nanmax(self.color_func(data))\n    if self.vmax == self.vmin:\n        self.vmin -= 1\n    self.hue0 = huerange[0]\n    self.dhue = huerange[1] - huerange[0]\n    self.bgcolor_enabled = True\nexcept (AttributeError, TypeError, ValueError):\n    self.vmin = None\n    self.vmax = None\n    self.hue0 = None\n    self.dhue = None\n    self.bgcolor_enabled = False\nself.has_inf = False\nif data.dtype.kind in ['f', 'c']:\n    self.has_inf = np.any(np.isinf(data))\nif self._data.dtype.name == 'object' or self.has_inf:\n    self.bgcolor_enabled = False\nif size > LARGE_SIZE:\n    self.rows_loaded = self.ROWS_TO_LOAD\n    self.cols_loaded = self.COLS_TO_LOAD\nelse:\n    if self.total_rows > LARGE_NROWS:\n        self.rows_loaded = self.ROWS_TO_LOAD\n    else:\n        self.rows_loaded = self.total_rows\n    if self.total_cols > LARGE_COLS:\n        self.cols_loaded = self.COLS_TO_LOAD\n    else:\n        self.cols_loaded = self.total_cols\n",
        "CUT_4": "QAbstractTableModel.__init__(self)\nself.dialog = parent\nself.changes = {}\nself.xlabels = xlabels\nself.ylabels = ylabels\nself.readonly = readonly\nself.test_array = np.array([0], dtype=data.dtype)\nif data.dtype in (np.complex64, np.complex128):\n    self.color_func = np.abs\nelse:\n    self.color_func = np.real\nhuerange = [0.66, 0.99]\nself.sat = 0.7\nself.val = 1.0\nself.alp = 0.6\nself._data = data\nself._format = format\nself.total_rows = self._data.shape[0]\nself.total_cols = self._data.shape[1]\nsize = self.total_rows * self.total_cols\ntry:\n    self.vmin = np.nanmin(self.color_func(data))\n    self.vmax = np.nanmax(self.color_func(data))\n    if self.vmax == self.vmin:\n        self.vmin -= 1\n    self.hue0 = huerange[0]\n    self.dhue = huerange[1] - huerange[0]\n    self.bgcolor_enabled = True\nexcept (AttributeError, TypeError, ValueError):\n    self.vmin = None\n    self.vmax = None\n    self.hue0 = None\n    self.dhue = None\n    self.bgcolor_enabled = False\nself.has_inf = False\nif data.dtype.kind in ['f', 'c']:\n    self.has_inf = np.any(np.isinf(data))\nif self._data.dtype.name == 'object' or self.has_inf:\n    self.bgcolor_enabled = False\nif size > LARGE_SIZE:\n    self.rows_loaded = self.ROWS_TO_LOAD\n    self.cols_loaded = self.COLS_TO_LOAD\nelse:\n    if self.total_rows > LARGE_NROWS:\n        self.rows_loaded = self.ROWS_TO_LOAD\n    else:\n        self.rows_loaded = self.total_rows\n    if self.total_cols > LARGE_COLS:\n        self.cols_loaded = self.COLS_TO_LOAD\n    else:\n        self.cols_loaded = self.total_cols\n",
        "CUT_5": "\"\"\"Return NumPy data type associated to obj\n    Return None if NumPy is not available\n    or if obj is not a NumPy array or scalar\"\"\"\nif ndarray is not FakeObject:\n    import numpy as np\n    if isinstance(obj, np.generic) or isinstance(obj, np.ndarray):\n        try:\n            return obj.dtype.type\n        except (AttributeError, RuntimeError):\n            return\n"
    },
    {
        "functionName": "real_values",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Load a Numpy pickled file.\n\n    The file numpy_data.npz contains six variables, each one represents the\n    expected test values after a manual conversion of the same variables\n    defined and evaluated in MATLAB. The manual type conversion was done\n    over several variable types, such as: Matrices/Vectors, Scalar and\n    Complex numbers, Structs, Strings and Cell Arrays. The set of variables\n    was defined to allow and test the deep conversion of a compound type,\n    i.e., a struct that contains other types that need to be converted,\n    like other structs, matrices and Cell Arrays.\n    \"\"\"\npath = os.path.join(LOCATION, 'numpy_data.npz')\nfile_s = np.load(path, allow_pickle=True)\nA = file_s['A'].item()\nB = file_s['B']\nC = file_s['C']\nD = file_s['D'].item()\nE = file_s['E']\nreturn {'A': A, 'B': B, 'C': C, 'D': D, 'E': E}\npytest.fixture",
        "CUT_1": "\"\"\"Return if data type conversion\"\"\"\nreturn self._as_data\n",
        "CUT_2": "\"\"\"Return if data type conversion\"\"\"\nreturn self._as_data\n",
        "CUT_3": "\"\"\"Return if code type conversion\"\"\"\nreturn self._as_code\n",
        "CUT_4": "\"\"\"Return if code type conversion\"\"\"\nreturn self._as_code\n",
        "CUT_5": "\"\"\"Return if numeric type conversion\"\"\"\nreturn self._as_num\n"
    },
    {
        "functionName": "namespace_objects_full",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Define a dictionary of objects of a variety of different types to be saved.\n\n    This fixture reprisents the state of the namespace before saving and\n    filtering out un-deep-copyable, un-pickleable, and uninteresting objects.\n    \"\"\"\nnamespace_dict = copy.deepcopy(spydata_values)\nnamespace_dict['expected_error_string'] = (\n    'Some objects could not be saved: undeepcopyable_instance, unpickleable_instance'\n    )\nnamespace_dict['module_obj'] = io\nnamespace_dict['class_obj'] = Exception\nnamespace_dict['function_obj'] = os.path.join\nnamespace_dict['unpickleable_instance'] = UnPickleableObj('spam')\nnamespace_dict['undeepcopyable_instance'] = UnDeepCopyableObj('ham')\nnamespace_dict['custom_instance'] = CustomObj('eggs')\nreturn namespace_dict\npytest.fixture",
        "CUT_1": "return 'spam'\nspam.eggs",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "\"\"\"\n        Set list of strings on object combo box.\n\n        Parameters\n        ----------\n        history: list\n            List of strings of objects.\n        \"\"\"\nself.object_combo.addItems(history)\n",
        "CUT_4": "\"\"\"\n        Set list of strings on object combo box.\n\n        Parameters\n        ----------\n        history: list\n            List of strings of objects.\n        \"\"\"\nself.object_combo.addItems(history)\n",
        "CUT_5": "\"\"\"\n        Constructor\n\n        :param show_callable_attributes: if True the callables objects,\n            i.e. objects (such as function) that  a __call__ method,\n            will be displayed (in brown). If False they are hidden.\n        :param show_special_attributes: if True the objects special attributes,\n            i.e. methods with a name that starts and ends with two underscores,\n            will be displayed (in italics). If False they are hidden.\n        :param dataframe_format: the dataframe format from config.\n        :param parent: the parent widget\n        \"\"\"\nsuper(TreeProxyModel, self).__init__(parent)\nself._show_callables = show_callable_attributes\nself._show_special_attributes = show_special_attributes\nself.dataframe_format = dataframe_format\n"
    },
    {
        "functionName": "namespace_objects_filtered",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Define a dictionary of the objects from the namespace that can be saved.\n\n    This fixture reprisents the state of the namespace after saving and\n    filtering out un-deep-copyable, un-pickleable, and uninteresting objects.\n    \"\"\"\nnamespace_dict = copy.deepcopy(spydata_values)\nnamespace_dict['custom_instance'] = CustomObj('eggs')\nreturn namespace_dict\npytest.fixture",
        "CUT_1": "self.namespace = namespace\n",
        "CUT_2": "self.namespace = namespace\n",
        "CUT_3": "\"\"\"\n        Add an object to the namespace dictionary of the internal console.\n        \"\"\"\nself.shell.interpreter.namespace[name] = item\n",
        "CUT_4": "\"\"\"\n        Add an object to the namespace dictionary of the internal console.\n        \"\"\"\nself.shell.interpreter.namespace[name] = item\n",
        "CUT_5": "return Document(DOC_URI, workspace, DOC)\npytest.fixture"
    },
    {
        "functionName": "namespace_objects_nocopyable",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Define a dictionary of that cannot be deepcopied.\n    \"\"\"\nnamespace_dict = {}\nnamespace_dict['expected_error_string'] = 'No supported objects to save'\nnamespace_dict['class_obj'] = Exception\nnamespace_dict['undeepcopyable_instance'] = UnDeepCopyableObj('ham')\nreturn namespace_dict\npytest.fixture",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"\n        Set plugin font option.\n\n        Note: All plugins in Spyder use a global font. To define a different\n        size, the plugin must define a 'FONT_SIZE_DELTA' class variable.\n        \"\"\"\nraise Exception(\n    'Plugins font is based on the general settings, and cannot be set directly on the plugin.This method is deprecated.'\n    )\n",
        "CUT_5": "\"\"\"\n        Set plugin font option.\n\n        Note: All plugins in Spyder use a global font. To define a different\n        size, the plugin must define a 'FONT_SIZE_DELTA' class variable.\n        \"\"\"\nraise Exception(\n    'Plugins font is based on the general settings, and cannot be set directly on the plugin.This method is deprecated.'\n    )\n"
    },
    {
        "functionName": "namespace_objects_nopickleable",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Define a dictionary of objects that cannot be pickled.\n    \"\"\"\nnamespace_dict = {}\nnamespace_dict['expected_error_string'] = 'No supported objects to save'\nnamespace_dict['function_obj'] = os.path.join\nnamespace_dict['unpickleable_instance'] = UnPickleableObj('spam')\nreturn namespace_dict\npytest.fixture",
        "CUT_1": "return 'spam'\nspam.eggs",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "\"\"\"\n        Constructor\n\n        :param show_callable_attributes: if True the callables objects,\n            i.e. objects (such as function) that  a __call__ method,\n            will be displayed (in brown). If False they are hidden.\n        :param show_special_attributes: if True the objects special attributes,\n            i.e. methods with a name that starts and ends with two underscores,\n            will be displayed (in italics). If False they are hidden.\n        :param dataframe_format: the dataframe format from config.\n        :param parent: the parent widget\n        \"\"\"\nsuper(TreeProxyModel, self).__init__(parent)\nself._show_callables = show_callable_attributes\nself._show_special_attributes = show_special_attributes\nself.dataframe_format = dataframe_format\n",
        "CUT_4": "\"\"\"\n        Constructor\n\n        :param show_callable_attributes: if True the callables objects,\n            i.e. objects (such as function) that  a __call__ method,\n            will be displayed (in brown). If False they are hidden.\n        :param show_special_attributes: if True the objects special attributes,\n            i.e. methods with a name that starts and ends with two underscores,\n            will be displayed (in italics). If False they are hidden.\n        :param dataframe_format: the dataframe format from config.\n        :param parent: the parent widget\n        \"\"\"\nsuper(TreeProxyModel, self).__init__(parent)\nself._show_callables = show_callable_attributes\nself._show_special_attributes = show_special_attributes\nself.dataframe_format = dataframe_format\n",
        "CUT_5": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture"
    },
    {
        "functionName": "input_namespace",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if request.param is None:\n    return None\nelse:\n    return request.getfixturevalue(request.param)\npytest.fixture",
        "CUT_1": "request['jsonrpc'] = '2.0'\nreturn request\n",
        "CUT_2": "request['jsonrpc'] = '2.0'\nreturn request\n",
        "CUT_3": "logger.debug('Perform request {0} for: {1}'.format(request, params['file']))\nself.main.completions.send_request(language, request, params)\n",
        "CUT_4": "logger.debug('Perform request {0} for: {1}'.format(request, params['file']))\nself.main.completions.send_request(language, request, params)\n",
        "CUT_5": "\"\"\"\n        Process completion/introspection request from Spyder.\n\n        Parameters\n        ----------\n        language: str\n            Programming language for the incoming request\n        req_type: str\n            Type of request, one of\n            :class:`spyder.plugins.completion.CompletionTypes`\n        req: dict\n            Request body\n            {\n                'filename': str,\n                **kwargs: request-specific parameters\n            }\n        req_id: int\n            Request identifier for response\n        \"\"\"\npass\n"
    },
    {
        "functionName": "expected_namespace",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "if request.param is None:\n    return None\nelse:\n    return request.getfixturevalue(request.param)\npytest.fixture",
        "CUT_1": "request['jsonrpc'] = '2.0'\nreturn request\n",
        "CUT_2": "request['jsonrpc'] = '2.0'\nreturn request\n",
        "CUT_3": "logger.debug('Perform request {0} for: {1}'.format(request, params['file']))\nself.main.completions.send_request(language, request, params)\n",
        "CUT_4": "logger.debug('Perform request {0} for: {1}'.format(request, params['file']))\nself.main.completions.send_request(language, request, params)\n",
        "CUT_5": "\"\"\"\n        Process completion/introspection request from Spyder.\n\n        Parameters\n        ----------\n        language: str\n            Programming language for the incoming request\n        req_type: str\n            Type of request, one of\n            :class:`spyder.plugins.completion.CompletionTypes`\n        req: dict\n            Request body\n            {\n                'filename': str,\n                **kwargs: request-specific parameters\n            }\n        req_id: int\n            Request identifier for response\n        \"\"\"\npass\n"
    },
    {
        "functionName": "test_npz_import",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the load of .npz files as dictionaries.\n    \"\"\"\nfilename = os.path.join(LOCATION, 'import_data.npz')\ndata = iofuncs.load_array(filename)\nassert isinstance(data, tuple)\nvariables, error = data\nassert variables['val1'] == np.array(1) and not error\n",
        "CUT_1": "try:\n    name = osp.splitext(osp.basename(filename))[0]\n    data = np.load(filename)\n    if isinstance(data, np.lib.npyio.NpzFile):\n        return dict(data), None\n    elif hasattr(data, 'keys'):\n        return data, None\n    else:\n        return {name: data}, None\nexcept Exception as error:\n    return None, str(error)\n",
        "CUT_2": "if self.data:\n    return self.data[self.get_stack_index()].filename\n",
        "CUT_3": "if self.data:\n    return self.data[self.get_stack_index()].filename\n",
        "CUT_4": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n",
        "CUT_5": "\"\"\"Copy value\"\"\"\ndata = self.source_model.get_data()\nif isinstance(data, list):\n    data.append(data[orig_key])\nif isinstance(data, set):\n    data.add(data[orig_key])\nelse:\n    data[new_key] = data[orig_key]\nself.set_data(data)\n"
    },
    {
        "functionName": "test_matlab_import",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the automatic conversion and import of variables from MATLAB.\n\n    This test loads a file stored in MATLAB, the variables defined are\n    equivalent to the manually converted values done over Numpy. This test\n    allows to evaluate the function which processes the conversion automa-\n    tically. i.e., The automatic conversion results should be equal to the\n    manual conversion of the variables.\n    \"\"\"\npath = os.path.join(LOCATION, 'data.mat')\ninf, _ = iofuncs.load_matlab(path)\nvalid = True\nfor var in sorted(real_values.keys()):\n    valid = valid and bool(np.mean(real_values[var] == inf[var]))\nassert valid\npytest.mark.skipif(iofuncs.load_matlab is None, reason='SciPy required')",
        "CUT_1": "\"\"\"Return if data type conversion\"\"\"\nreturn self._as_data\n",
        "CUT_2": "\"\"\"Return if data type conversion\"\"\"\nreturn self._as_data\n",
        "CUT_3": "\"\"\"Return if code type conversion\"\"\"\nreturn self._as_code\n",
        "CUT_4": "\"\"\"Return if code type conversion\"\"\"\nreturn self._as_code\n",
        "CUT_5": "\"\"\"Reimplemented to avoid formatting actions\"\"\"\nvalid = self.is_valid(qstr)\nif self.hasFocus() and valid is not None:\n    if editing and not valid:\n        self.show_tip(self.tips[valid])\n        self.valid.emit(False, False)\n    elif valid:\n        self.selected()\n        self.lineEdit().cursorWordForward(False)\n    else:\n        self.valid.emit(False, False)\n"
    },
    {
        "functionName": "test_spydata_import",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test spydata handling and variable importing.\n\n    This test loads all the variables contained inside a spydata tar\n    container and compares them against their static values.\n    It tests both a file with the original name, and one that has been renamed\n    in order to catch Issue #9 .\n    \"\"\"\npath = os.path.join(LOCATION, spydata_file_name)\ndata, error = iofuncs.load_dictionary(path)\nassert error is None\nassert are_namespaces_equal(data, spydata_values)\npytest.mark.parametrize('spydata_file_name', ['export_data.spydata',\n    'export_data_renamed.spydata'])",
        "CUT_1": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_2": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_3": "\"\"\"Normalize windows path and remove extra quotes.\"\"\"\npath = path.replace('\\\\', '/').lower()\nif path[0] == '\"' and path[-1] == '\"':\n    path = literal_eval(path)\nreturn path\n",
        "CUT_4": "\"\"\"Normalize windows path and remove extra quotes.\"\"\"\npath = path.replace('\\\\', '/').lower()\nif path[0] == '\"' and path[-1] == '\"':\n    path = literal_eval(path)\nreturn path\n",
        "CUT_5": "return path\n"
    },
    {
        "functionName": "test_spydata_import_witherror",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that import fails gracefully with a fn not present in the namespace.\n\n    Checks that the error is caught, the message is passed back,\n    and the current working directory is restored afterwards.\n    \"\"\"\noriginal_cwd = os.getcwd()\npath = os.path.join(LOCATION, 'export_data_withfunction.spydata')\ndata, error = iofuncs.load_dictionary(path)\nassert error and is_text_string(error)\nassert data is None\nassert os.getcwd() == original_cwd\n",
        "CUT_1": "\"\"\"Get current working directory.\"\"\"\nreturn os.getcwd()\n",
        "CUT_2": "\"\"\"Error handler for `shutil.rmtree`.\n\n    If the error is due to an access error (read-only file), it\n    attempts to add write permission and then retries.\n    If the error is for another reason, it re-raises the error.\n\n    Usage: `shutil.rmtree(path, onerror=onerror)\"\"\"\nif not os.access(path, os.W_OK):\n    os.chmod(path, stat.S_IWUSR)\n    function(path)\nelse:\n    raise\n",
        "CUT_3": "\"\"\"Error handler for `shutil.rmtree`.\n\n    If the error is due to an access error (read-only file), it\n    attempts to add write permission and then retries.\n    If the error is for another reason, it re-raises the error.\n\n    Usage: `shutil.rmtree(path, onerror=onerror)\"\"\"\nif not os.access(path, os.W_OK):\n    os.chmod(path, stat.S_IWUSR)\n    function(path)\nelse:\n    raise\n",
        "CUT_4": "\"\"\"Safe version of getcwd that will fallback to home user dir.\n\n    This will catch the error raised when the current working directory\n    was removed for an external program.\n    \"\"\"\ntry:\n    return getcwd()\nexcept OSError:\n    logger.debug(\n        'WARNING: Current working directory was deleted, falling back to home dirertory'\n        )\n    return get_home_dir()\n",
        "CUT_5": "\"\"\"Safe version of getcwd that will fallback to home user dir.\n\n    This will catch the error raised when the current working directory\n    was removed for an external program.\n    \"\"\"\ntry:\n    return getcwd()\nexcept OSError:\n    logger.debug(\n        'WARNING: Current working directory was deleted, falling back to home dirertory'\n        )\n    return get_home_dir()\n"
    },
    {
        "functionName": "test_spydata_import_missing_file",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that import fails properly when file is missing, and resets the cwd.\n    \"\"\"\noriginal_cwd = os.getcwd()\npath = os.path.join(LOCATION, 'non_existant_path_2019-01-23.spydata')\ntry:\n    iofuncs.load_dictionary(path)\nexcept IOError:\n    pass\nelse:\n    assert False\nassert os.getcwd() == original_cwd\n",
        "CUT_1": "\"\"\"Get current working directory.\"\"\"\nreturn os.getcwd()\n",
        "CUT_2": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_3": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_4": "\"\"\"Get the project root directory.\n\n    We require that all commands are run from the project root, i.e. the\n    directory that contains setup.py, setup.cfg, and versioneer.py .\n    \"\"\"\nroot = os.path.realpath(os.path.abspath(os.getcwd()))\nsetup_py = os.path.join(root, 'setup.py')\nversioneer_py = os.path.join(root, 'versioneer.py')\nif not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n    root = os.path.dirname(os.path.realpath(os.path.abspath(sys.argv[0])))\n    setup_py = os.path.join(root, 'setup.py')\n    versioneer_py = os.path.join(root, 'versioneer.py')\nif not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n    err = (\n        \"Versioneer was unable to run the project root directory. Versioneer requires setup.py to be executed from its immediate directory (like 'python setup.py COMMAND'), or in a way that lets it use sys.argv[0] to find the root (like 'python path/to/setup.py COMMAND').\"\n        )\n    raise VersioneerBadRootError(err)\ntry:\n    me = os.path.realpath(os.path.abspath(__file__))\n    me_dir = os.path.normcase(os.path.splitext(me)[0])\n    vsr_dir = os.path.normcase(os.path.splitext(versioneer_py)[0])\n    if me_dir != vsr_dir:\n        print('Warning: build in %s is using versioneer.py from %s' % (os.\n            path.dirname(me), versioneer_py))\nexcept NameError:\n    pass\nreturn root\n",
        "CUT_5": "\"\"\"Given a path to a module, derive its dot-separated full name.\"\"\"\ndirectory = os.path.dirname(path)\nmodule_name, _ = os.path.splitext(os.path.basename(path))\nfull_name = [module_name]\nwhile os.path.exists(os.path.join(directory, '__init__.py')):\n    this_directory = os.path.basename(directory)\n    directory = os.path.dirname(directory)\n    full_name = [this_directory] + full_name\nreturn '.'.join(full_name)\n"
    },
    {
        "functionName": "test_matlabstruct",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test support for matlab stlye struct.\"\"\"\na = iofuncs.MatlabStruct()\na.b = 'spam'\nassert a['b'] == 'spam'\na.c['d'] = 'eggs'\nassert a.c.d == 'eggs'\nassert a == {'c': {'d': 'eggs'}, 'b': 'spam'}\na['d'] = [1, 2, 3]\nbuf = io.BytesIO()\niofuncs.save_matlab(a, buf)\nbuf.seek(0)\ndata, error = iofuncs.load_matlab(buf)\nassert error is None\nassert data['b'] == 'spam'\nassert data['c'].d == 'eggs'\nassert data['d'].tolist() == [[1, 2, 3]]\npytest.mark.skipif(iofuncs.load_matlab is None, reason='SciPy required')",
        "CUT_1": "return 'spam'\nspam.eggs",
        "CUT_2": "\"\"\"\n        Return an unambigous textual representation of the node.\n\n        The representation lists any edge, with all properties. The\n        edge dictionary is sorted at every call, so that, even if\n        more expansive computationally, the function is guaranteed to be\n        idempotent in all implementations.\n\n        Please note that, as the return value includes information such as\n        edge weight, it cannot be used for minimization. For such purposes,\n        the potentially ambiguous ``.__str__()`` method must be used.\n\n.. code:: python\n        >>> from dafsa import DAFSANode, DAFSAEdge\n        >>> node = DAFSANode(0)\n        >>> node.final = True\n        >>> node.edges[\"x\"] = DAFSAEdge(DAFSANode(1), 1)\n        >>> repr(node)\n        '0(#1/0:<x>/1)'\n\n        Returns\n        -------\n        string : str\n            The unambiguous textual representation of the current node.\n        \"\"\"\nbuf = ';'.join(['|'.join([('#%i/%i:<%s>/%i' % (self.edges[label].node.\n    node_id, self.weight, label, self.edges[label].weight)) for label in\n    sorted(self.edges)])])\nif self.node_id == 0:\n    buf = '0(%s)' % buf\nelif self.final:\n    buf = 'F(%s)' % buf\nelse:\n    buf = 'n(%s)' % buf\nreturn buf\n",
        "CUT_3": "\"\"\"\n        Return an unambigous textual representation of the node.\n\n        The representation lists any edge, with all properties. The\n        edge dictionary is sorted at every call, so that, even if\n        more expansive computationally, the function is guaranteed to be\n        idempotent in all implementations.\n\n        Please note that, as the return value includes information such as\n        edge weight, it cannot be used for minimization. For such purposes,\n        the potentially ambiguous ``.__str__()`` method must be used.\n\n.. code:: python\n        >>> from dafsa import DAFSANode, DAFSAEdge\n        >>> node = DAFSANode(0)\n        >>> node.final = True\n        >>> node.edges[\"x\"] = DAFSAEdge(DAFSANode(1), 1)\n        >>> repr(node)\n        '0(#1/0:<x>/1)'\n\n        Returns\n        -------\n        string : str\n            The unambiguous textual representation of the current node.\n        \"\"\"\nbuf = ';'.join(['|'.join([('#%i/%i:<%s>/%i' % (self.edges[label].node.\n    node_id, self.weight, label, self.edges[label].weight)) for label in\n    sorted(self.edges)])])\nif self.node_id == 0:\n    buf = '0(%s)' % buf\nelif self.final:\n    buf = 'F(%s)' % buf\nelse:\n    buf = 'n(%s)' % buf\nreturn buf\n",
        "CUT_4": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_5": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n"
    },
    {
        "functionName": "test_spydata_export",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/utils/tests/test_iofuncs.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test spydata export and re-import.\n\n    This test saves the variables in ``spydata`` format and then\n    reloads and checks them to make sure they save/restore properly\n    and no errors occur during the process.\n    \"\"\"\npath = os.path.join(LOCATION, filename + '.spydata')\nexpected_error = None\nif 'expected_error_string' in input_namespace:\n    expected_error = input_namespace['expected_error_string']\n    del input_namespace['expected_error_string']\ncwd_original = os.getcwd()\ntry:\n    export_error = iofuncs.save_dictionary(input_namespace, path)\n    assert export_error == expected_error\n    if expected_namespace is None:\n        assert not os.path.isfile(path)\n    else:\n        data_actual, import_error = iofuncs.load_dictionary(path)\n        assert import_error is None\n        print(data_actual.keys())\n        print(expected_namespace.keys())\n        assert are_namespaces_equal(data_actual, expected_namespace)\n    assert cwd_original == os.getcwd()\nfinally:\n    if os.path.isfile(path):\n        try:\n            os.remove(path)\n        except (IOError, OSError, PermissionError):\n            pass\npytest.mark.parametrize('input_namespace,expected_namespace,filename', [(\n    'spydata_values', 'spydata_values', 'export_data_copy'), (\n    'namespace_objects_full', 'namespace_objects_filtered', 'export_data_2'\n    ), ('namespace_objects_nocopyable', None, 'export_data_none_1'), (\n    'namespace_objects_nopickleable', None, 'export_data_none_2')],\n    indirect=['input_namespace', 'expected_namespace'])",
        "CUT_1": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_2": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_3": "\"\"\"Normalize windows path and remove extra quotes.\"\"\"\npath = path.replace('\\\\', '/').lower()\nif path[0] == '\"' and path[-1] == '\"':\n    path = literal_eval(path)\nreturn path\n",
        "CUT_4": "\"\"\"Normalize windows path and remove extra quotes.\"\"\"\npath = path.replace('\\\\', '/').lower()\nif path[0] == '\"' and path[-1] == '\"':\n    path = literal_eval(path)\nreturn path\n",
        "CUT_5": "return path\n"
    },
    {
        "functionName": "setup_kernel",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"start an embedded kernel in a subprocess, and wait for it to be ready\n\n    This function was taken from the ipykernel project.\n    We plan to remove it when dropping support for python 2.\n\n    Returns\n    -------\n    kernel_manager: connected KernelManager instance\n    \"\"\"\nkernel = Popen([sys.executable, '-c', cmd], stdout=PIPE, stderr=PIPE)\ntry:\n    connection_file = os.path.join(paths.jupyter_runtime_dir(), \n        'kernel-%i.json' % kernel.pid)\n    tic = time.time()\n    while not os.path.exists(connection_file) and kernel.poll(\n        ) is None and time.time() < tic + SETUP_TIMEOUT:\n        time.sleep(0.1)\n    if kernel.poll() is not None:\n        o, e = kernel.communicate()\n        e = py3compat.cast_unicode(e)\n        raise IOError('Kernel failed to start:\\n%s' % e)\n    if not os.path.exists(connection_file):\n        if kernel.poll() is None:\n            kernel.terminate()\n        raise IOError('Connection file %r never arrived' % connection_file)\n    client = BlockingKernelClient(connection_file=connection_file)\n    client.load_connection_file()\n    client.start_channels()\n    client.wait_for_ready()\n    try:\n        yield client\n    finally:\n        client.stop_channels()\nfinally:\n    kernel.terminate()\ncontextmanager",
        "CUT_1": "try:\n    sys.path.remove(osp.dirname(__file__))\nexcept ValueError:\n    pass\ntry:\n    locals().pop('__file__')\nexcept KeyError:\n    pass\n__doc__ = ''\n__name__ = '__main__'\nimport_spydercustomize()\nwhile '' in sys.path:\n    sys.path.remove('')\nfrom ipykernel.kernelapp import IPKernelApp\nfrom spyder_kernels.console.kernel import SpyderKernel\nclass SpyderKernelApp(IPKernelApp):\n\n    def init_pdb(self):\n        \"\"\"\n            This method was added in IPykernel 5.3.1 and it replaces\n            the debugger used by the kernel with a new class\n            introduced in IPython 7.15 during kernel's initialization.\n            Therefore, it doesn't allow us to use our debugger.\n            \"\"\"\n        pass\nkernel = SpyderKernelApp.instance()\nkernel.kernel_class = SpyderKernel\ntry:\n    kernel.config = kernel_config()\nexcept:\n    pass\nkernel.initialize()\nkernel.shell.register_magic_function(varexp)\nimport pdb\nkernel.shell.InteractiveTB.debugger_cls = pdb.Pdb\nkernel.start()\n",
        "CUT_2": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_3": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_4": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_5": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n"
    },
    {
        "functionName": "kernel",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Console kernel fixture\"\"\"\nkernel = get_kernel()\nkernel.namespace_view_settings = {'check_all': False, 'exclude_private':\n    True, 'exclude_uppercase': True, 'exclude_capitalized': False,\n    'exclude_unsupported': False, 'exclude_callables_and_modules': True,\n    'excluded_names': ['nan', 'inf', 'infty', 'little_endian',\n    'colorbar_doc', 'typecodes', '__builtins__', '__main__', '__doc__',\n    'NaN', 'Inf', 'Infinity', 'sctypes', 'rcParams', 'rcParamsDefault',\n    'sctypeNA', 'typeNA', 'False_', 'True_'], 'minmax': False}\ndef reset_kernel():\n    kernel.do_execute('reset -f', True)\nrequest.addfinalizer(reset_kernel)\nreturn kernel\npytest.fixture",
        "CUT_1": "\"\"\"\n        Register Pdb session after reset.\n        \"\"\"\nsuper(SpyderPdb, self).reset()\nkernel = get_ipython().kernel\nkernel._register_pdb_session(self)\n",
        "CUT_2": "try:\n    sys.path.remove(osp.dirname(__file__))\nexcept ValueError:\n    pass\ntry:\n    locals().pop('__file__')\nexcept KeyError:\n    pass\n__doc__ = ''\n__name__ = '__main__'\nimport_spydercustomize()\nwhile '' in sys.path:\n    sys.path.remove('')\nfrom ipykernel.kernelapp import IPKernelApp\nfrom spyder_kernels.console.kernel import SpyderKernel\nclass SpyderKernelApp(IPKernelApp):\n\n    def init_pdb(self):\n        \"\"\"\n            This method was added in IPykernel 5.3.1 and it replaces\n            the debugger used by the kernel with a new class\n            introduced in IPython 7.15 during kernel's initialization.\n            Therefore, it doesn't allow us to use our debugger.\n            \"\"\"\n        pass\nkernel = SpyderKernelApp.instance()\nkernel.kernel_class = SpyderKernel\ntry:\n    kernel.config = kernel_config()\nexcept:\n    pass\nkernel.initialize()\nkernel.shell.register_magic_function(varexp)\nimport pdb\nkernel.shell.InteractiveTB.debugger_cls = pdb.Pdb\nkernel.start()\n",
        "CUT_3": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_4": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_5": "\"\"\"Determine if the kernel is from Spyder.\"\"\"\ncode = \"getattr(get_ipython().kernel, 'set_value', False)\"\nif self._reading:\n    return\nelse:\n    self.silent_exec_method(code)\n"
    },
    {
        "functionName": "reset_kernel",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "kernel.do_execute('reset -f', True)\n",
        "CUT_1": "\"\"\"\n        Register Pdb session after reset.\n        \"\"\"\nsuper(SpyderPdb, self).reset()\nkernel = get_ipython().kernel\nkernel._register_pdb_session(self)\n",
        "CUT_2": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_3": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n",
        "CUT_4": "try:\n    sys.path.remove(osp.dirname(__file__))\nexcept ValueError:\n    pass\ntry:\n    locals().pop('__file__')\nexcept KeyError:\n    pass\n__doc__ = ''\n__name__ = '__main__'\nimport_spydercustomize()\nwhile '' in sys.path:\n    sys.path.remove('')\nfrom ipykernel.kernelapp import IPKernelApp\nfrom spyder_kernels.console.kernel import SpyderKernel\nclass SpyderKernelApp(IPKernelApp):\n\n    def init_pdb(self):\n        \"\"\"\n            This method was added in IPykernel 5.3.1 and it replaces\n            the debugger used by the kernel with a new class\n            introduced in IPython 7.15 during kernel's initialization.\n            Therefore, it doesn't allow us to use our debugger.\n            \"\"\"\n        pass\nkernel = SpyderKernelApp.instance()\nkernel.kernel_class = SpyderKernel\ntry:\n    kernel.config = kernel_config()\nexcept:\n    pass\nkernel.initialize()\nkernel.shell.register_magic_function(varexp)\nimport pdb\nkernel.shell.InteractiveTB.debugger_cls = pdb.Pdb\nkernel.start()\n",
        "CUT_5": "\"\"\"Reset to default values of the shortcuts making a confirmation.\"\"\"\nif not force:\n    reset = QMessageBox.warning(self, _('Shortcuts reset'), _(\n        'Do you want to reset to default values?'), QMessageBox.Yes |\n        QMessageBox.No)\n    if reset == QMessageBox.No:\n        return\nself.plugin.reset_shortcuts()\nself.plugin.apply_shortcuts()\nself.table.load_shortcuts()\nself.load_from_conf()\nself.set_modified(False)\n"
    },
    {
        "functionName": "test_magics",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Check available magics in the kernel.\"\"\"\nline_magics = kernel.shell.magics_manager.magics['line']\ncell_magics = kernel.shell.magics_manager.magics['cell']\nfor magic in ['alias', 'alias_magic', 'autocall', 'automagic', 'autosave',\n    'bookmark', 'cd', 'clear', 'colors', 'config', 'connect_info', 'debug',\n    'dhist', 'dirs', 'doctest_mode', 'ed', 'edit', 'env', 'gui', 'hist',\n    'history', 'killbgscripts', 'ldir', 'less', 'load', 'load_ext',\n    'loadpy', 'logoff', 'logon', 'logstart', 'logstate', 'logstop', 'ls',\n    'lsmagic', 'macro', 'magic', 'matplotlib', 'mkdir', 'more', 'notebook',\n    'page', 'pastebin', 'pdb', 'pdef', 'pdoc', 'pfile', 'pinfo', 'pinfo2',\n    'popd', 'pprint', 'precision', 'prun', 'psearch', 'psource', 'pushd',\n    'pwd', 'pycat', 'pylab', 'qtconsole', 'quickref', 'recall', 'rehashx',\n    'reload_ext', 'rep', 'rerun', 'reset', 'reset_selective', 'rmdir',\n    'run', 'save', 'sc', 'set_env', 'sx', 'system', 'tb', 'time', 'timeit',\n    'unalias', 'unload_ext', 'who', 'who_ls', 'whos', 'xdel', 'xmode']:\n    msg = \"magic '%s' is not in line_magics\" % magic\n    assert magic in line_magics, msg\nfor magic in ['!', 'HTML', 'SVG', 'bash', 'capture', 'debug', 'file',\n    'html', 'javascript', 'js', 'latex', 'perl', 'prun', 'pypy', 'python',\n    'python2', 'python3', 'ruby', 'script', 'sh', 'svg', 'sx', 'system',\n    'time', 'timeit', 'writefile']:\n    assert magic in cell_magics\n",
        "CUT_1": "\"\"\"Handle %edit magic petitions.\"\"\"\nif encoding.is_text_file(filename):\n    self.edit_goto.emit(filename, 1, '')\nSlot(object, object)",
        "CUT_2": "\"\"\"Handle %edit magic petitions.\"\"\"\nif encoding.is_text_file(filename):\n    self.edit_goto.emit(filename, 1, '')\nSlot(object, object)",
        "CUT_3": "\"\"\"\n        Return current namespace\n\n        This is globals() if not debugging, or a dictionary containing\n        both locals() and globals() for current frame when debugging\n        \"\"\"\nns = {}\nif self._running_namespace is None:\n    ns.update(self._mglobals())\nelse:\n    running_globals, running_locals = self._running_namespace\n    ns.update(running_globals)\n    if running_locals is not None:\n        ns.update(running_locals)\nif self._pdb_frame is not None:\n    ns.update(self._pdb_locals)\nif with_magics:\n    line_magics = self.shell.magics_manager.magics['line']\n    cell_magics = self.shell.magics_manager.magics['cell']\n    ns.update(line_magics)\n    ns.update(cell_magics)\nreturn ns\n",
        "CUT_4": "\"\"\"Load file in external Spyder's editor, if available\n        This method is used only for embedded consoles\n        (could also be useful if we ever implement the magic %edit command)\"\"\"\nmatch = get_error_match(to_text_string(text))\nif match:\n    fname, lnb = match.groups()\n    builtins.open_in_spyder(fname, int(lnb))\n",
        "CUT_5": "\"\"\"Load file in external Spyder's editor, if available\n        This method is used only for embedded consoles\n        (could also be useful if we ever implement the magic %edit command)\"\"\"\nmatch = get_error_match(to_text_string(text))\nif match:\n    fname, lnb = match.groups()\n    builtins.open_in_spyder(fname, int(lnb))\n"
    },
    {
        "functionName": "test_get_namespace_view",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the namespace view of the kernel.\n    \"\"\"\nexecute = kernel.do_execute('a = 1', True)\nnsview = repr(kernel.get_namespace_view())\nassert \"'a':\" in nsview\nassert \"'type': 'int'\" in nsview or \"'type': u'int'\" in nsview\nassert \"'size': 1\" in nsview\nassert \"'color': '#0000ff'\" in nsview\nassert \"'view': '1'\" in nsview\n",
        "CUT_1": "\"\"\"\n        Return the namespace view\n\n        This is a dictionary with the following structure\n\n        {'a': {'color': '#800000', 'size': 1, 'type': 'str', 'view': '1'}}\n\n        Here:\n        * 'a' is the variable name\n        * 'color' is the color used to show it\n        * 'size' and 'type' are self-evident\n        * and'view' is its value or the text shown in the last column\n        \"\"\"\nfrom spyder_kernels.utils.nsview import make_remote_view\nsettings = self.namespace_view_settings\nif settings:\n    ns = self._get_current_namespace()\n    view = make_remote_view(ns, settings, EXCLUDED_NAMES)\n    return view\nelse:\n    return None\n",
        "CUT_2": "\"\"\"Save namespace into filename\"\"\"\nfrom spyder_kernels.utils.nsview import get_remote_data\nfrom spyder_kernels.utils.iofuncs import iofunctions\nns = self._get_current_namespace()\nsettings = self.namespace_view_settings\ndata = get_remote_data(ns, settings, mode='picklable', more_excluded_names=\n    EXCLUDED_NAMES).copy()\nreturn iofunctions.save(data, filename)\n",
        "CUT_3": "try:\n    sys.path.remove(osp.dirname(__file__))\nexcept ValueError:\n    pass\ntry:\n    locals().pop('__file__')\nexcept KeyError:\n    pass\n__doc__ = ''\n__name__ = '__main__'\nimport_spydercustomize()\nwhile '' in sys.path:\n    sys.path.remove('')\nfrom ipykernel.kernelapp import IPKernelApp\nfrom spyder_kernels.console.kernel import SpyderKernel\nclass SpyderKernelApp(IPKernelApp):\n\n    def init_pdb(self):\n        \"\"\"\n            This method was added in IPykernel 5.3.1 and it replaces\n            the debugger used by the kernel with a new class\n            introduced in IPython 7.15 during kernel's initialization.\n            Therefore, it doesn't allow us to use our debugger.\n            \"\"\"\n        pass\nkernel = SpyderKernelApp.instance()\nkernel.kernel_class = SpyderKernel\ntry:\n    kernel.config = kernel_config()\nexcept:\n    pass\nkernel.initialize()\nkernel.shell.register_magic_function(varexp)\nimport pdb\nkernel.shell.InteractiveTB.debugger_cls = pdb.Pdb\nkernel.start()\n",
        "CUT_4": "\"\"\"Test remote collections editor.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nfrom spyder.config.manager import CONF\nfrom spyder_kernels.utils.nsview import make_remote_view, REMOTE_SETTINGS\nsettings = {}\nfor name in REMOTE_SETTINGS:\n    settings[name] = CONF.get('variable_explorer', name)\nremote = make_remote_view(get_test_data(), settings)\ndialog = CollectionsEditor()\ndialog.setup(remote, remote=True)\ndialog.show()\napp.exec_()\n",
        "CUT_5": "\"\"\"Test remote collections editor.\"\"\"\nfrom spyder.utils.qthelpers import qapplication\napp = qapplication()\nfrom spyder.config.manager import CONF\nfrom spyder_kernels.utils.nsview import make_remote_view, REMOTE_SETTINGS\nsettings = {}\nfor name in REMOTE_SETTINGS:\n    settings[name] = CONF.get('variable_explorer', name)\nremote = make_remote_view(get_test_data(), settings)\ndialog = CollectionsEditor()\ndialog.setup(remote, remote=True)\ndialog.show()\napp.exec_()\n"
    },
    {
        "functionName": "test_get_var_properties",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test the properties fo the variables in the namespace.\n    \"\"\"\nexecute = kernel.do_execute('a = 1', True)\nvar_properties = repr(kernel.get_var_properties())\nassert \"'a'\" in var_properties\nassert \"'is_list': False\" in var_properties\nassert \"'is_dict': False\" in var_properties\nassert \"'len': None\" in var_properties\nassert \"'is_array': False\" in var_properties\nassert \"'is_image': False\" in var_properties\nassert \"'is_data_frame': False\" in var_properties\nassert \"'is_series': False\" in var_properties\nassert \"'array_shape': None\" in var_properties\nassert \"'array_ndim': None\" in var_properties\n",
        "CUT_1": "\"\"\"Return sequence length\"\"\"\nreturn self.var_properties[name]['len']\n",
        "CUT_2": "\"\"\"Return sequence length\"\"\"\nreturn self.var_properties[name]['len']\n",
        "CUT_3": "\"\"\"Return True if variable is a dictionary\"\"\"\nreturn self.var_properties[name]['is_dict']\n",
        "CUT_4": "\"\"\"Return True if variable is a dictionary\"\"\"\nreturn self.var_properties[name]['is_dict']\n",
        "CUT_5": "\"\"\"Return array's shape\"\"\"\nreturn self.var_properties[name]['array_shape']\n"
    },
    {
        "functionName": "test_get_value",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test getting the value of a variable.\"\"\"\nname = 'a'\nkernel.do_execute('a = 124', True)\nassert kernel.get_value(name) == 124\n",
        "CUT_1": "\"\"\"Get the value of a variable\"\"\"\nvalue = self.shellwidget.get_value(name)\nreturn value\n",
        "CUT_2": "\"\"\"Get the value of a variable\"\"\"\nvalue = self.shellwidget.get_value(name)\nreturn value\n",
        "CUT_3": "self.name = name\n",
        "CUT_4": "self.name = name\n",
        "CUT_5": "\"\"\"\n        Kill the running kernel.\n\n        Override private method to be able to correctly close kernel that was\n        started via a batch/bash script for correct conda env activation.\n        \"\"\"\nif self.has_kernel:\n    try:\n        if hasattr(signal, 'SIGKILL'):\n            self.signal_kernel(signal.SIGKILL)\n        else:\n            self.kill_proc_tree(self.kernel.pid)\n            self.kernel.kill()\n    except OSError as e:\n        if sys.platform == 'win32':\n            if e.winerror != 5:\n                raise\n        else:\n            from errno import ESRCH\n            if e.errno != ESRCH:\n                raise\n    self.kernel.wait()\n    self.kernel = None\nelse:\n    raise RuntimeError('Cannot kill kernel. No kernel is running!')\n"
    },
    {
        "functionName": "test_set_value",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test setting the value of a variable.\"\"\"\nname = 'a'\nexecute = kernel.do_execute('a = 0', True)\nvalue = 10\nkernel.set_value(name, value)\nlog_text = get_log_text(kernel)\nassert \"'__builtin__': <module \" in log_text\nassert \"'__builtins__': <module \" in log_text\nassert \"'_ih': ['']\" in log_text\nassert \"'_oh': {}\" in log_text\nassert \"'a': 10\" in log_text\n",
        "CUT_1": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_2": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_3": "\"\"\"Get the value of a variable\"\"\"\nvalue = self.shellwidget.get_value(name)\nreturn value\n",
        "CUT_4": "\"\"\"Get the value of a variable\"\"\"\nvalue = self.shellwidget.get_value(name)\nreturn value\n",
        "CUT_5": "self.value = value\n"
    },
    {
        "functionName": "test_remove_value",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the removal of a variable.\"\"\"\nname = 'a'\nexecute = kernel.do_execute('a = 1', True)\nvar_properties = repr(kernel.get_var_properties())\nassert \"'a'\" in var_properties\nassert \"'is_list': False\" in var_properties\nassert \"'is_dict': False\" in var_properties\nassert \"'len': None\" in var_properties\nassert \"'is_array': False\" in var_properties\nassert \"'is_image': False\" in var_properties\nassert \"'is_data_frame': False\" in var_properties\nassert \"'is_series': False\" in var_properties\nassert \"'array_shape': None\" in var_properties\nassert \"'array_ndim': None\" in var_properties\nkernel.remove_value(name)\nvar_properties = repr(kernel.get_var_properties())\nassert var_properties == '{}'\n",
        "CUT_1": "\"\"\"Return sequence length\"\"\"\nreturn self.var_properties[name]['len']\n",
        "CUT_2": "\"\"\"Return sequence length\"\"\"\nreturn self.var_properties[name]['len']\n",
        "CUT_3": "\"\"\"Return True if variable is a dictionary\"\"\"\nreturn self.var_properties[name]['is_dict']\n",
        "CUT_4": "\"\"\"Return True if variable is a dictionary\"\"\"\nreturn self.var_properties[name]['is_dict']\n",
        "CUT_5": "\"\"\"Return True if variable is a DataFrame\"\"\"\nreturn self.var_properties[name]['is_data_frame']\n"
    },
    {
        "functionName": "test_copy_value",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test the copy of a variable.\"\"\"\norig_name = 'a'\nnew_name = 'b'\nexecute = kernel.do_execute('a = 1', True)\nvar_properties = repr(kernel.get_var_properties())\nassert \"'a'\" in var_properties\nassert \"'is_list': False\" in var_properties\nassert \"'is_dict': False\" in var_properties\nassert \"'len': None\" in var_properties\nassert \"'is_array': False\" in var_properties\nassert \"'is_image': False\" in var_properties\nassert \"'is_data_frame': False\" in var_properties\nassert \"'is_series': False\" in var_properties\nassert \"'array_shape': None\" in var_properties\nassert \"'array_ndim': None\" in var_properties\nkernel.copy_value(orig_name, new_name)\nvar_properties = repr(kernel.get_var_properties())\nassert \"'a'\" in var_properties\nassert \"'b'\" in var_properties\nassert \"'is_list': False\" in var_properties\nassert \"'is_dict': False\" in var_properties\nassert \"'len': None\" in var_properties\nassert \"'is_array': False\" in var_properties\nassert \"'is_image': False\" in var_properties\nassert \"'is_data_frame': False\" in var_properties\nassert \"'is_series': False\" in var_properties\nassert \"'array_shape': None\" in var_properties\nassert \"'array_ndim': None\" in var_properties\n",
        "CUT_1": "\"\"\"Return sequence length\"\"\"\nreturn self.var_properties[name]['len']\n",
        "CUT_2": "\"\"\"Return sequence length\"\"\"\nreturn self.var_properties[name]['len']\n",
        "CUT_3": "\"\"\"Return True if variable is a dictionary\"\"\"\nreturn self.var_properties[name]['is_dict']\n",
        "CUT_4": "\"\"\"Return True if variable is a dictionary\"\"\"\nreturn self.var_properties[name]['is_dict']\n",
        "CUT_5": "\"\"\"Return True if variable is a DataFrame\"\"\"\nreturn self.var_properties[name]['is_data_frame']\n"
    },
    {
        "functionName": "test_load_npz_data",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test loading data from npz filename.\"\"\"\nnamespace_file = osp.join(FILES_PATH, 'load_data.npz')\nextention = '.npz'\noverwrite, execute, variables = load\nkernel.do_execute(execute, True)\nkernel.load_data(namespace_file, extention, overwrite=overwrite)\nfor var, value in variables.items():\n    assert value == kernel.get_value(var)\npytest.mark.parametrize('load', [(True, 'val1 = 0', {'val1': np.array(1)}),\n    (False, 'val1 = 0', {'val1': 0, 'val1_000': np.array(1)})])",
        "CUT_1": "\"\"\"Load data from a file.\"\"\"\noverwrite = False\nif self.namespacebrowser.editor.var_properties:\n    message = _(\n        'Do you want to overwrite old variables (if any) in the namespace when loading the data?'\n        )\n    buttons = QMessageBox.Yes | QMessageBox.No\n    result = QMessageBox.question(self, _('Data loading'), message, buttons)\n    overwrite = result == QMessageBox.Yes\ntry:\n    return self.call_kernel(interrupt=True, blocking=True, display_error=\n        True, timeout=CALL_KERNEL_TIMEOUT).load_data(filename, ext,\n        overwrite=overwrite)\nexcept ImportError as msg:\n    module = str(msg).split(\"'\")[1]\n    msg = _(\n        \"Spyder is unable to open the file you're trying to load because <tt>{module}</tt> is not installed. Please install this package in your working environment.<br>\"\n        ).format(module=module)\n    return msg\nexcept TimeoutError:\n    msg = _('Data is too big to be loaded')\n    return msg\nexcept (UnpicklingError, RuntimeError):\n    return None\n",
        "CUT_2": "\"\"\"Load data from a file.\"\"\"\noverwrite = False\nif self.namespacebrowser.editor.var_properties:\n    message = _(\n        'Do you want to overwrite old variables (if any) in the namespace when loading the data?'\n        )\n    buttons = QMessageBox.Yes | QMessageBox.No\n    result = QMessageBox.question(self, _('Data loading'), message, buttons)\n    overwrite = result == QMessageBox.Yes\ntry:\n    return self.call_kernel(interrupt=True, blocking=True, display_error=\n        True, timeout=CALL_KERNEL_TIMEOUT).load_data(filename, ext,\n        overwrite=overwrite)\nexcept ImportError as msg:\n    module = str(msg).split(\"'\")[1]\n    msg = _(\n        \"Spyder is unable to open the file you're trying to load because <tt>{module}</tt> is not installed. Please install this package in your working environment.<br>\"\n        ).format(module=module)\n    return msg\nexcept TimeoutError:\n    msg = _('Data is too big to be loaded')\n    return msg\nexcept (UnpicklingError, RuntimeError):\n    return None\n",
        "CUT_3": "\"\"\"\n        Load data from filename.\n\n        Use 'overwrite' to determine if conflicts between variable names need\n        to be handle or not.\n\n        For example, if a loaded variable is call 'var'\n        and there is already a variable 'var' in the namespace, having\n        'overwrite=True' will cause 'var' to be updated.\n        In the other hand, with 'overwrite=False', a new variable will be\n        created with a sufix starting with 000 i.e 'var000' (default behavior).\n        \"\"\"\nfrom spyder_kernels.utils.iofuncs import iofunctions\nfrom spyder_kernels.utils.misc import fix_reference_name\nglbs = self._mglobals()\nload_func = iofunctions.load_funcs[ext]\ndata, error_message = load_func(filename)\nif error_message:\n    return error_message\nif not overwrite:\n    for key in list(data.keys()):\n        new_key = fix_reference_name(key, blacklist=list(glbs.keys()))\n        if new_key != key:\n            data[new_key] = data.pop(key)\ntry:\n    glbs.update(data)\nexcept Exception as error:\n    return str(error)\nreturn None\n",
        "CUT_4": "\"\"\"Return array's shape\"\"\"\ntry:\n    if self._is_array(var):\n        return var.shape\n    else:\n        return None\nexcept:\n    return None\n",
        "CUT_5": "\"\"\"Create test data.\"\"\"\nimport numpy as np\nfrom spyder.pil_patch import Image\nimage = Image.fromarray(np.random.randint(256, size=(100, 100)), mode='P')\ntestdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}\ntestdate = datetime.date(1945, 5, 8)\ntest_timedelta = datetime.timedelta(days=-1, minutes=42, seconds=13)\ntry:\n    import pandas as pd\nexcept (ModuleNotFoundError, ImportError):\n    test_timestamp, test_pd_td, test_dtindex, test_series, test_df = None\nelse:\n    test_timestamp = pd.Timestamp('1945-05-08T23:01:00.12345')\n    test_pd_td = pd.Timedelta(days=2193, hours=12)\n    test_dtindex = pd.date_range(start='1939-09-01T', end='1939-10-06',\n        freq='12H')\n    test_series = pd.Series({'series_name': [0, 1, 2, 3, 4, 5]})\n    test_df = pd.DataFrame({'string_col': ['a', 'b', 'c', 'd'], 'int_col':\n        [0, 1, 2, 3], 'float_col': [1.1, 2.2, 3.3, 4.4], 'bool_col': [True,\n        False, False, True]})\nclass Foobar(object):\n\n    def __init__(self):\n        self.text = 'toto'\n        self.testdict = testdict\n        self.testdate = testdate\nfoobar = Foobar()\nreturn {'object': foobar, 'module': np, 'str': 'kjkj kj k j j kj k jkj',\n    'unicode': to_text_string('\u00e9\u00f9', 'utf-8'), 'list': [1, 3, [sorted, 5, 6],\n    'kjkj', None], 'set': {1, 2, 1, 3, None, 'A', 'B', 'C', True, False},\n    'tuple': ([1, testdate, testdict, test_timedelta], 'kjkj', None),\n    'dict': testdict, 'float': 1.2233, 'int': 223, 'bool': True, 'array':\n    np.random.rand(10, 10).astype(np.int64), 'masked_array': np.ma.array([[\n    1, 0], [1, 0]], mask=[[True, False], [False, False]]), '1D-array': np.\n    linspace(-10, 10).astype(np.float16), '3D-array': np.random.randint(2,\n    size=(5, 5, 5)).astype(np.bool_), 'empty_array': np.array([]), 'image':\n    image, 'date': testdate, 'datetime': datetime.datetime(1945, 5, 8, 23, \n    1, 0, int(150000.0)), 'timedelta': test_timedelta, 'complex': 2 + 1.0j,\n    'complex64': np.complex64(2 + 1.0j), 'complex128': np.complex128(9.0j),\n    'int8_scalar': np.int8(8), 'int16_scalar': np.int16(16), 'int32_scalar':\n    np.int32(32), 'int64_scalar': np.int64(64), 'float16_scalar': np.\n    float16(16), 'float32_scalar': np.float32(32), 'float64_scalar': np.\n    float64(64), 'bool_scalar': np.bool(8), 'bool__scalar': np.bool_(8),\n    'timestamp': test_timestamp, 'timedelta_pd': test_pd_td,\n    'datetimeindex': test_dtindex, 'series': test_series, 'ddataframe':\n    test_df, 'None': None, 'unsupported1': np.arccos, 'unsupported2': np.\n    cast, 'big_struct_array': np.zeros(1000, dtype=[('ID', 'f8'), ('param1',\n    'f8', 5000)])}\n"
    },
    {
        "functionName": "test_load_data",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test loading data from filename.\"\"\"\nnamespace_file = osp.join(FILES_PATH, 'load_data.spydata')\nextention = '.spydata'\nkernel.load_data(namespace_file, extention)\nvar_properties = repr(kernel.get_var_properties())\nassert \"'a'\" in var_properties\nassert \"'is_list': False\" in var_properties\nassert \"'is_dict': False\" in var_properties\nassert \"'len': None\" in var_properties\nassert \"'is_array': False\" in var_properties\nassert \"'is_image': False\" in var_properties\nassert \"'is_data_frame': False\" in var_properties\nassert \"'is_series': False\" in var_properties\nassert \"'array_shape': None\" in var_properties\nassert \"'array_ndim': None\" in var_properties\n",
        "CUT_1": "\"\"\"Return sequence length\"\"\"\nreturn self.var_properties[name]['len']\n",
        "CUT_2": "\"\"\"Return sequence length\"\"\"\nreturn self.var_properties[name]['len']\n",
        "CUT_3": "\"\"\"Return array's shape\"\"\"\nreturn self.var_properties[name]['array_shape']\n",
        "CUT_4": "\"\"\"Return array's shape\"\"\"\nreturn self.var_properties[name]['array_shape']\n",
        "CUT_5": "\"\"\"Return True if variable is a dictionary\"\"\"\nreturn self.var_properties[name]['is_dict']\n"
    },
    {
        "functionName": "test_save_namespace",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test saving the namespace into filename.\"\"\"\nnamespace_file = osp.join(FILES_PATH, 'save_data.spydata')\nexecute = kernel.do_execute('b = 1', True)\nkernel.save_namespace(namespace_file)\nassert osp.isfile(namespace_file)\nload_func = iofunctions.load_funcs['.spydata']\ndata, error_message = load_func(namespace_file)\nassert data == {'b': 1}\nassert not error_message\nos.remove(namespace_file)\nassert not osp.isfile(namespace_file)\n",
        "CUT_1": "\"\"\"Import data from text file.\"\"\"\ntitle = _('Import data')\nif filenames is None:\n    if self.filename is None:\n        basedir = getcwd_or_home()\n    else:\n        basedir = osp.dirname(self.filename)\n    filenames, _selfilter = getopenfilenames(self, title, basedir,\n        iofunctions.load_filters)\n    if not filenames:\n        return\nelif is_text_string(filenames):\n    filenames = [filenames]\nfor filename in filenames:\n    self.filename = to_text_string(filename)\n    if os.name == 'nt':\n        self.filename = remove_backslashes(self.filename)\n    ext = osp.splitext(self.filename)[1].lower()\n    if ext not in iofunctions.load_funcs:\n        buttons = QMessageBox.Yes | QMessageBox.Cancel\n        answer = QMessageBox.question(self, title, _(\n            \"<b>Unsupported file extension '%s'</b><br><br>Would you like to import it anyway (by selecting a known file format)?\"\n            ) % ext, buttons)\n        if answer == QMessageBox.Cancel:\n            return\n        formats = list(iofunctions.load_extensions.keys())\n        item, ok = QInputDialog.getItem(self, title, _('Open file as:'),\n            formats, 0, False)\n        if ok:\n            ext = iofunctions.load_extensions[to_text_string(item)]\n        else:\n            return\n    load_func = iofunctions.load_funcs[ext]\n    if is_text_string(load_func):\n        error_message = None\n        try:\n            text, _encoding = encoding.read(self.filename)\n            base_name = osp.basename(self.filename)\n            editor = ImportWizard(self, text, title=base_name, varname=\n                fix_reference_name(base_name))\n            if editor.exec_():\n                var_name, clip_data = editor.get_data()\n                self.editor.new_value(var_name, clip_data)\n        except Exception as error:\n            error_message = str(error)\n    else:\n        QApplication.setOverrideCursor(QCursor(Qt.WaitCursor))\n        QApplication.processEvents()\n        error_message = self.shellwidget.load_data(self.filename, ext)\n        QApplication.restoreOverrideCursor()\n        QApplication.processEvents()\n    if error_message is not None:\n        QMessageBox.critical(self, title, _(\n            \"<b>Unable to load '%s'</b><br><br>The error message was:<br>%s\"\n            ) % (self.filename, error_message))\n    self.refresh_table()\nSlot(bool)Slot(list)",
        "CUT_2": "\"\"\"Import data from text file.\"\"\"\ntitle = _('Import data')\nif filenames is None:\n    if self.filename is None:\n        basedir = getcwd_or_home()\n    else:\n        basedir = osp.dirname(self.filename)\n    filenames, _selfilter = getopenfilenames(self, title, basedir,\n        iofunctions.load_filters)\n    if not filenames:\n        return\nelif is_text_string(filenames):\n    filenames = [filenames]\nfor filename in filenames:\n    self.filename = to_text_string(filename)\n    if os.name == 'nt':\n        self.filename = remove_backslashes(self.filename)\n    ext = osp.splitext(self.filename)[1].lower()\n    if ext not in iofunctions.load_funcs:\n        buttons = QMessageBox.Yes | QMessageBox.Cancel\n        answer = QMessageBox.question(self, title, _(\n            \"<b>Unsupported file extension '%s'</b><br><br>Would you like to import it anyway (by selecting a known file format)?\"\n            ) % ext, buttons)\n        if answer == QMessageBox.Cancel:\n            return\n        formats = list(iofunctions.load_extensions.keys())\n        item, ok = QInputDialog.getItem(self, title, _('Open file as:'),\n            formats, 0, False)\n        if ok:\n            ext = iofunctions.load_extensions[to_text_string(item)]\n        else:\n            return\n    load_func = iofunctions.load_funcs[ext]\n    if is_text_string(load_func):\n        error_message = None\n        try:\n            text, _encoding = encoding.read(self.filename)\n            base_name = osp.basename(self.filename)\n            editor = ImportWizard(self, text, title=base_name, varname=\n                fix_reference_name(base_name))\n            if editor.exec_():\n                var_name, clip_data = editor.get_data()\n                self.editor.new_value(var_name, clip_data)\n        except Exception as error:\n            error_message = str(error)\n    else:\n        QApplication.setOverrideCursor(QCursor(Qt.WaitCursor))\n        QApplication.processEvents()\n        error_message = self.shellwidget.load_data(self.filename, ext)\n        QApplication.restoreOverrideCursor()\n        QApplication.processEvents()\n    if error_message is not None:\n        QMessageBox.critical(self, title, _(\n            \"<b>Unable to load '%s'</b><br><br>The error message was:<br>%s\"\n            ) % (self.filename, error_message))\n    self.refresh_table()\nSlot(bool)Slot(list)",
        "CUT_3": "\"\"\"\n        Load data from filename.\n\n        Use 'overwrite' to determine if conflicts between variable names need\n        to be handle or not.\n\n        For example, if a loaded variable is call 'var'\n        and there is already a variable 'var' in the namespace, having\n        'overwrite=True' will cause 'var' to be updated.\n        In the other hand, with 'overwrite=False', a new variable will be\n        created with a sufix starting with 000 i.e 'var000' (default behavior).\n        \"\"\"\nfrom spyder_kernels.utils.iofuncs import iofunctions\nfrom spyder_kernels.utils.misc import fix_reference_name\nglbs = self._mglobals()\nload_func = iofunctions.load_funcs[ext]\ndata, error_message = load_func(filename)\nif error_message:\n    return error_message\nif not overwrite:\n    for key in list(data.keys()):\n        new_key = fix_reference_name(key, blacklist=list(glbs.keys()))\n        if new_key != key:\n            data[new_key] = data.pop(key)\ntry:\n    glbs.update(data)\nexcept Exception as error:\n    return str(error)\nreturn None\n",
        "CUT_4": "\"\"\"Save data\"\"\"\nif filename is None:\n    filename = self.filename\n    if filename is None:\n        filename = getcwd_or_home()\n    filename, _selfilter = getsavefilename(self, _('Save data'), filename,\n        iofunctions.save_filters)\n    if filename:\n        self.filename = filename\n    else:\n        return False\nQApplication.setOverrideCursor(QCursor(Qt.WaitCursor))\nQApplication.processEvents()\nerror_message = self.shellwidget.save_namespace(self.filename)\nQApplication.restoreOverrideCursor()\nQApplication.processEvents()\nif error_message is not None:\n    if 'Some objects could not be saved:' in error_message:\n        save_data_message = _('<b>Some objects could not be saved:</b>'\n            ) + '<br><br><code>{obj_list}</code>'.format(obj_list=\n            error_message.split(': ')[1])\n    else:\n        save_data_message = _(\n            '<b>Unable to save current workspace</b><br><br>The error message was:<br>'\n            ) + error_message\n    QMessageBox.critical(self, _('Save data'), save_data_message)\nself.save_button.setEnabled(self.filename is not None)\nSlot()",
        "CUT_5": "\"\"\"Save data\"\"\"\nif filename is None:\n    filename = self.filename\n    if filename is None:\n        filename = getcwd_or_home()\n    filename, _selfilter = getsavefilename(self, _('Save data'), filename,\n        iofunctions.save_filters)\n    if filename:\n        self.filename = filename\n    else:\n        return False\nQApplication.setOverrideCursor(QCursor(Qt.WaitCursor))\nQApplication.processEvents()\nerror_message = self.shellwidget.save_namespace(self.filename)\nQApplication.restoreOverrideCursor()\nQApplication.processEvents()\nif error_message is not None:\n    if 'Some objects could not be saved:' in error_message:\n        save_data_message = _('<b>Some objects could not be saved:</b>'\n            ) + '<br><br><code>{obj_list}</code>'.format(obj_list=\n            error_message.split(': ')[1])\n    else:\n        save_data_message = _(\n            '<b>Unable to save current workspace</b><br><br>The error message was:<br>'\n            ) + error_message\n    QMessageBox.critical(self, _('Save data'), save_data_message)\nself.save_button.setEnabled(self.filename is not None)\nSlot()"
    },
    {
        "functionName": "test_is_defined",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test method to tell if object is defined.\"\"\"\nobj = 'debug'\nassert kernel.is_defined(obj)\n",
        "CUT_1": "if isinstance(obj, dict):\n    return obj\nd = dict()\nfor k in dir(obj):\n    if not k.startswith('_'):\n        d[k] = getattr(obj, k)\nreturn d\n",
        "CUT_2": "if isinstance(obj, dict):\n    return obj\nd = dict()\nfor k in dir(obj):\n    if not k.startswith('_'):\n        d[k] = getattr(obj, k)\nreturn d\n",
        "CUT_3": "\"\"\"Convert `obj` to (unicode) text string\"\"\"\nif PY2:\n    if isinstance(obj, unicode):\n        return obj\n    if encoding is None:\n        return unicode(obj)\n    else:\n        return unicode(obj, encoding)\nelif encoding is None:\n    return str(obj)\nelif isinstance(obj, str):\n    return obj\nelse:\n    return str(obj, encoding)\n",
        "CUT_4": "\"\"\"Convert `obj` to (unicode) text string\"\"\"\nif PY2:\n    if isinstance(obj, unicode):\n        return obj\n    if encoding is None:\n        return unicode(obj)\n    else:\n        return unicode(obj, encoding)\nelif encoding is None:\n    return str(obj)\nelif isinstance(obj, str):\n    return obj\nelse:\n    return str(obj, encoding)\n",
        "CUT_5": "\"\"\"\n    Encode object as json str.\n    \"\"\"\ndef _dump_obj(obj):\n    if isinstance(obj, dict):\n        return obj\n    d = dict()\n    for k in dir(obj):\n        if not k.startswith('_'):\n            d[k] = getattr(obj, k)\n    return d\nreturn json.dumps(obj, default=_dump_obj)\n"
    },
    {
        "functionName": "test_get_doc",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test to get object documentation dictionary.\"\"\"\nobjtxt = 'help'\nassert \"Define the builtin 'help'\" in kernel.get_doc(objtxt)['docstring'\n    ] or \"Define the built-in 'help'\" in kernel.get_doc(objtxt)['docstring']\n",
        "CUT_1": "\"\"\"Get object documentation dictionary\"\"\"\ntry:\n    return self.call_kernel(interrupt=True, blocking=True).get_doc(objtxt)\nexcept (TimeoutError, UnpicklingError, RuntimeError):\n    return None\n",
        "CUT_2": "\"\"\"Get object documentation dictionary\"\"\"\ntry:\n    return self.call_kernel(interrupt=True, blocking=True).get_doc(objtxt)\nexcept (TimeoutError, UnpicklingError, RuntimeError):\n    return None\n",
        "CUT_3": "return _('Help')\n",
        "CUT_4": "return _('Help')\n",
        "CUT_5": "return _('Help')\n"
    },
    {
        "functionName": "test_get_source",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test to get object source.\"\"\"\nobjtxt = 'help'\nassert 'class _Helper(object):' in kernel.get_source(objtxt)\n",
        "CUT_1": "\"\"\"Get object source\"\"\"\ntry:\n    return self.call_kernel(interrupt=True, blocking=True).get_source(objtxt)\nexcept (TimeoutError, UnpicklingError, RuntimeError):\n    return None\n",
        "CUT_2": "\"\"\"Get object source\"\"\"\ntry:\n    return self.call_kernel(interrupt=True, blocking=True).get_source(objtxt)\nexcept (TimeoutError, UnpicklingError, RuntimeError):\n    return None\n",
        "CUT_3": "\"\"\"Get object source\"\"\"\nobj, valid = self._eval(objtxt)\nif valid:\n    return getsource(obj)\n",
        "CUT_4": "\"\"\"Get object source\"\"\"\nobj, valid = self._eval(objtxt)\nif valid:\n    return getsource(obj)\n",
        "CUT_5": "\"\"\"Return True if object is defined\"\"\"\nreturn self.interpreter.is_defined(objtxt, force_import)\n"
    },
    {
        "functionName": "test_output_from_c_libraries",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the wurlitzer extension is working.\"\"\"\ncode = \"\"\"\nimport ctypes\nlibc = ctypes.CDLL(None)\nlibc.printf(('Hello from C\\\\n').encode('utf8'))\n\"\"\"\nkernel._load_wurlitzer()\nreply = kernel.do_execute(code, True)\ncaptured = capsys.readouterr()\nassert captured.out == 'Hello from C\\n'\npytest.mark.skipif(os.name == 'nt', reason=\"Doesn't work on Windows\")",
        "CUT_1": "\"\"\"Determine if the kernel is from Spyder.\"\"\"\ncode = \"getattr(get_ipython().kernel, 'set_value', False)\"\nif self._reading:\n    return\nelse:\n    self.silent_exec_method(code)\n",
        "CUT_2": "\"\"\"Determine if the kernel is from Spyder.\"\"\"\ncode = \"getattr(get_ipython().kernel, 'set_value', False)\"\nif self._reading:\n    return\nelse:\n    self.silent_exec_method(code)\n",
        "CUT_3": "\"\"\"Load wurlitzer extension.\"\"\"\nif not os.name == 'nt':\n    from IPython.core.getipython import get_ipython\n    try:\n        get_ipython().run_line_magic('reload_ext', 'wurlitzer')\n    except Exception:\n        pass\n",
        "CUT_4": "if self.isAlive():\n    ctypes.pythonapi.PyThreadState_SetAsyncExc(self.get_thread_id(), ctypes\n        .py_object(KeyboardInterrupt))\n    return True\nelse:\n    return False\n",
        "CUT_5": "if self.isAlive():\n    ctypes.pythonapi.PyThreadState_SetAsyncExc(self.get_thread_id(), ctypes\n        .py_object(KeyboardInterrupt))\n    return True\nelse:\n    return False\n"
    },
    {
        "functionName": "test_cwd_in_sys_path",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that cwd stays as the first element in sys.path after the\n    kernel has started.\n    \"\"\"\ncmd = 'from spyder_kernels.console import start; start.main()'\nwith setup_kernel(cmd) as client:\n    msg_id = client.execute('import sys; sys_path = sys.path',\n        user_expressions={'output': 'sys_path'})\n    reply = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    user_expressions = reply['content']['user_expressions']\n    str_value = user_expressions['output']['data']['text/plain']\n    value = ast.literal_eval(str_value)\n    assert '' in value\n",
        "CUT_1": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n",
        "CUT_2": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n",
        "CUT_3": "\"\"\"Silently execute a kernel method and save its reply\n\n        The methods passed here **don't** involve getting the value\n        of a variable but instead replies that can be handled by\n        ast.literal_eval.\n\n        To get a value see `get_value`\n\n        Parameters\n        ----------\n        code : string\n            Code that contains the kernel method as part of its\n            string\n\n        See Also\n        --------\n        handle_exec_method : Method that deals with the reply\n\n        Note\n        ----\n        This is based on the _silent_exec_callback method of\n        RichJupyterWidget. Therefore this is licensed BSD\n        \"\"\"\nlocal_uuid = to_text_string(uuid.uuid1())\ncode = to_text_string(code)\nif self.kernel_client is None:\n    return\nmsg_id = self.kernel_client.execute('', silent=True, user_expressions={\n    local_uuid: code})\nself._kernel_methods[local_uuid] = code\nself._request_info['execute'][msg_id] = self._ExecutionRequest(msg_id,\n    'silent_exec_method')\n",
        "CUT_4": "\"\"\"Silently execute a kernel method and save its reply\n\n        The methods passed here **don't** involve getting the value\n        of a variable but instead replies that can be handled by\n        ast.literal_eval.\n\n        To get a value see `get_value`\n\n        Parameters\n        ----------\n        code : string\n            Code that contains the kernel method as part of its\n            string\n\n        See Also\n        --------\n        handle_exec_method : Method that deals with the reply\n\n        Note\n        ----\n        This is based on the _silent_exec_callback method of\n        RichJupyterWidget. Therefore this is licensed BSD\n        \"\"\"\nlocal_uuid = to_text_string(uuid.uuid1())\ncode = to_text_string(code)\nif self.kernel_client is None:\n    return\nmsg_id = self.kernel_client.execute('', silent=True, user_expressions={\n    local_uuid: code})\nself._kernel_methods[local_uuid] = code\nself._request_info['execute'][msg_id] = self._ExecutionRequest(msg_id,\n    'silent_exec_method')\n",
        "CUT_5": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n"
    },
    {
        "functionName": "test_multiprocessing",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that multiprocessing works on Python 3.\n    \"\"\"\ncmd = 'from spyder_kernels.console import start; start.main()'\nwith setup_kernel(cmd) as client:\n    client.execute('%reset -f')\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    code = \"\"\"\nfrom multiprocessing import Pool\n\ndef f(x):\n    return x*x\n\nif __name__ == '__main__':\n    with Pool(5) as p:\n        result = p.map(f, [1, 2, 3])\n\"\"\"\n    p = tmpdir.join('mp-test.py')\n    p.write(code)\n    client.execute(\"runfile(r'{}')\".format(to_text_string(p)))\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    client.inspect('result')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']\n    assert content['found']\npytest.mark.skipif(not PY3, reason='Only meant for Python 3')",
        "CUT_1": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_2": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_3": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_4": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_5": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n"
    },
    {
        "functionName": "test_dask_multiprocessing",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that dask multiprocessing works on Python 3.\n    \"\"\"\ncmd = 'from spyder_kernels.console import start; start.main()'\nwith setup_kernel(cmd) as client:\n    client.execute('%reset -f')\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    code = \"\"\"\nfrom dask.distributed import Client\n\nif __name__=='__main__':\n    client = Client()\n    client.close()\n    x = 'hello'\n\"\"\"\n    p = tmpdir.join('mp-test.py')\n    p.write(code)\n    client.execute(\"runfile(r'{}')\".format(to_text_string(p)))\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    client.execute(\"runfile(r'{}')\".format(to_text_string(p)))\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    client.inspect('x')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']\n    assert content['found']\npytest.mark.skipif(not PY3, reason='Only meant for Python 3')",
        "CUT_1": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_2": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_3": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_4": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_5": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n"
    },
    {
        "functionName": "test_runfile",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"\n    Test that runfile uses the proper name space for execution.\n    \"\"\"\ncmd = 'from spyder_kernels.console import start; start.main()'\nwith setup_kernel(cmd) as client:\n    client.execute('%reset -f')\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    code = \"result = 'hello world'; error # make an error\"\n    d = tmpdir.join('defined-test.py')\n    d.write(code)\n    code = dedent(\n        \"\"\"\n        try:\n            result3 = result\n        except NameError:\n            result2 = 'hello world'\n        \"\"\"\n        )\n    u = tmpdir.join('undefined-test.py')\n    u.write(code)\n    client.execute(\"runfile(r'{}', current_namespace=False)\".format(\n        to_text_string(d)))\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    client.inspect('result')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']\n    assert content['found']\n    client.execute(\"runfile(r'{}', current_namespace=False)\".format(\n        to_text_string(u)))\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    client.inspect('result2')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']\n    assert content['found']\n    client.execute(\"runfile(r'{}', current_namespace=True)\".format(\n        to_text_string(u)))\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']\n    client.inspect('result3')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']\n    assert content['found']\n    client.inspect('__file__')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']\n    assert not content['found']\n",
        "CUT_1": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_2": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_3": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_4": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_5": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n"
    },
    {
        "functionName": "test_np_threshold",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that setting Numpy threshold doesn't make the Variable Explorer slow.\"\"\"\ncmd = 'from spyder_kernels.console import start; start.main()'\nwith setup_kernel(cmd) as client:\n    client.execute(\n        \"\"\"\nimport numpy as np;\nnp.set_printoptions(\n    threshold=np.inf,\n    suppress=True,\n    formatter={'float_kind':'{:0.2f}'.format})\n    \"\"\"\n        )\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    client.execute(\n        '\\nx = np.random.rand(75000,5);\\na = np.array([123412341234.123412341234])\\n'\n        )\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    client.execute(\n        \"\"\"\nt = np.get_printoptions()['threshold'];\ns = np.get_printoptions()['suppress'];\nf = np.get_printoptions()['formatter']\n\"\"\"\n        )\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    client.inspect('a')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']['data']['text/plain']\n    assert '123412341234.12' in content\n    client.inspect('t')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']['data']['text/plain']\n    assert 'inf' in content\n    client.inspect('s')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']['data']['text/plain']\n    assert 'True' in content\n    client.inspect('f')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']['data']['text/plain']\n    assert \"{'float_kind': <built-in method format of str object\" in content\n",
        "CUT_1": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_2": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_3": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_4": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_5": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n"
    },
    {
        "functionName": "test_turtle_launch",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test turtle scripts running in the same kernel.\"\"\"\ncmd = 'from spyder_kernels.console import start; start.main()'\nwith setup_kernel(cmd) as client:\n    client.execute('%reset -f')\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    code = \"\"\"\nimport turtle\nwn=turtle.Screen()\nwn.bgcolor(\"lightgreen\")\ntess = turtle.Turtle() # Create tess and set some attributes\ntess.color(\"hotpink\")\ntess.pensize(5)\n\ntess.forward(80) # Make tess draw equilateral triangle\ntess.left(120)\ntess.forward(80)\ntess.left(120)\ntess.forward(80)\ntess.left(120) # Complete the triangle\n\nturtle.bye()\n\"\"\"\n    p = tmpdir.join('turtle-test.py')\n    p.write(code)\n    client.execute(\"runfile(r'{}')\".format(to_text_string(p)))\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    client.inspect('tess')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']\n    assert content['found']\n    code = code + 'a = 10'\n    p = tmpdir.join('turtle-test1.py')\n    p.write(code)\n    client.execute(\"runfile(r'{}')\".format(to_text_string(p)))\n    client.get_shell_msg(block=True, timeout=TIMEOUT)\n    client.inspect('a')\n    msg = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    content = msg['content']\n    assert content['found']\npytest.mark.skipif(not TKINTER_INSTALLED, reason=\n    \"Doesn't work on Python installations without Tk\")",
        "CUT_1": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_2": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_3": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_4": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n",
        "CUT_5": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n"
    },
    {
        "functionName": "test_matplotlib_inline",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "\"\"\"Test that the default backend for our kernels is 'inline'.\"\"\"\ncmd = 'from spyder_kernels.console import start; start.main()'\nwith setup_kernel(cmd) as client:\n    code = 'import matplotlib; backend = matplotlib.get_backend()'\n    client.execute(code, user_expressions={'output': 'backend'})\n    reply = client.get_shell_msg(block=True, timeout=TIMEOUT)\n    user_expressions = reply['content']['user_expressions']\n    str_value = user_expressions['output']['data']['text/plain']\n    value = ast.literal_eval(str_value)\n    assert 'inline' in value\n",
        "CUT_1": "\"\"\"\n        Set a backend for Matplotlib.\n\n        backend: A parameter that can be passed to %matplotlib\n                 (e.g. 'inline' or 'tk').\n        \"\"\"\nimport traceback\nfrom IPython.core.getipython import get_ipython\ngeneric_error = ('\\n' + '=' * 73 +\n    \"\"\"\nNOTE: The following error appeared when setting your Matplotlib backend!!\n\"\"\"\n     + '=' * 73 + '\\n\\n{0}')\nmagic = 'pylab' if pylab else 'matplotlib'\nerror = None\ntry:\n    get_ipython().run_line_magic(magic, backend)\nexcept RuntimeError as err:\n    if 'GUI eventloops' in str(err):\n        import matplotlib\n        previous_backend = matplotlib.get_backend()\n        if not backend in previous_backend.lower():\n            error = (\n                \"\"\"\nNOTE: Spyder *can't* set your selected Matplotlib backend because there is a previous backend already in use.\n\nYour backend will be {0}\"\"\"\n                .format(previous_backend))\n        del matplotlib\n    else:\n        error = generic_error.format(traceback.format_exc())\nexcept Exception:\n    error = generic_error.format(traceback.format_exc())\nself._mpl_backend_error = error\n",
        "CUT_2": "\"\"\"Silently execute a kernel method and save its reply\n\n        The methods passed here **don't** involve getting the value\n        of a variable but instead replies that can be handled by\n        ast.literal_eval.\n\n        To get a value see `get_value`\n\n        Parameters\n        ----------\n        code : string\n            Code that contains the kernel method as part of its\n            string\n\n        See Also\n        --------\n        handle_exec_method : Method that deals with the reply\n\n        Note\n        ----\n        This is based on the _silent_exec_callback method of\n        RichJupyterWidget. Therefore this is licensed BSD\n        \"\"\"\nlocal_uuid = to_text_string(uuid.uuid1())\ncode = to_text_string(code)\nif self.kernel_client is None:\n    return\nmsg_id = self.kernel_client.execute('', silent=True, user_expressions={\n    local_uuid: code})\nself._kernel_methods[local_uuid] = code\nself._request_info['execute'][msg_id] = self._ExecutionRequest(msg_id,\n    'silent_exec_method')\n",
        "CUT_3": "\"\"\"Silently execute a kernel method and save its reply\n\n        The methods passed here **don't** involve getting the value\n        of a variable but instead replies that can be handled by\n        ast.literal_eval.\n\n        To get a value see `get_value`\n\n        Parameters\n        ----------\n        code : string\n            Code that contains the kernel method as part of its\n            string\n\n        See Also\n        --------\n        handle_exec_method : Method that deals with the reply\n\n        Note\n        ----\n        This is based on the _silent_exec_callback method of\n        RichJupyterWidget. Therefore this is licensed BSD\n        \"\"\"\nlocal_uuid = to_text_string(uuid.uuid1())\ncode = to_text_string(code)\nif self.kernel_client is None:\n    return\nmsg_id = self.kernel_client.execute('', silent=True, user_expressions={\n    local_uuid: code})\nself._kernel_methods[local_uuid] = code\nself._request_info['execute'][msg_id] = self._ExecutionRequest(msg_id,\n    'silent_exec_method')\n",
        "CUT_4": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_5": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n"
    },
    {
        "functionName": "test_do_complete",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Check do complete works in normal and debugging mode.\n    \"\"\"\nkernel.do_execute('abba = 1', True)\nassert kernel.get_value('abba') == 1\nmatch = kernel.do_complete('ab', 2)\nassert 'abba' in match['matches']\npdb_obj = SpyderPdb()\npdb_obj.curframe = inspect.currentframe()\npdb_obj.completenames = lambda *ignore: ['baba']\nkernel._pdb_obj = pdb_obj\nmatch = kernel.do_complete('ba', 2)\nassert 'baba' in match['matches']\n",
        "CUT_1": "self.pdb_obj = pdb_obj\n",
        "CUT_2": "\"\"\"Register Pdb session to use it later\"\"\"\nself._pdb_obj = pdb_obj\n",
        "CUT_3": "\"\"\"\n        Register Pdb session after reset.\n        \"\"\"\nsuper(SpyderPdb, self).reset()\nkernel = get_ipython().kernel\nkernel._register_pdb_session(self)\n",
        "CUT_4": "match = re.match('[\\\\ ]*%s ([a-zA-Z0-9_]*)[\\\\ ]*[\\\\(|\\\\:]' % statmt, text)\nif match is not None:\n    return match.group(1)\n",
        "CUT_5": "match = re.match('[\\\\ ]*%s ([a-zA-Z0-9_]*)[\\\\ ]*[\\\\(|\\\\:]' % statmt, text)\nif match is not None:\n    return match.group(1)\n"
    },
    {
        "functionName": "test_callables_and_modules",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Tests that callables and modules are in the namespace view only\n    when the right options are passed to the kernel.\n    \"\"\"\nkernel.do_execute('import numpy', True)\nkernel.do_execute('a = 10', True)\nkernel.do_execute('def f(x): return x', True)\nsettings = kernel.namespace_view_settings\nsettings['exclude_callables_and_modules'] = exclude_callables_and_modules\nsettings['exclude_unsupported'] = exclude_unsupported\nnsview = kernel.get_namespace_view()\nif not exclude_callables_and_modules:\n    assert 'numpy' in nsview.keys()\n    assert 'f' in nsview.keys()\nelse:\n    assert 'numpy' not in nsview.keys()\n    assert 'f' not in nsview.keys()\nassert 'a' in nsview.keys()\nsettings['exclude_callables_and_modules'] = True\nsettings['exclude_unsupported'] = False\npytest.mark.parametrize('exclude_callables_and_modules', [True, False])pytest.mark.parametrize('exclude_unsupported', [True, False])",
        "CUT_1": "\"\"\"\n    Return globals according to filter described in *settings*:\n        * data: data to be filtered (dictionary)\n        * settings: variable explorer settings (dictionary)\n        * mode (string): 'editable' or 'picklable'\n        * more_excluded_names: additional excluded names (list)\n    \"\"\"\nsupported_types = get_supported_types()\nassert mode in list(supported_types.keys())\nexcluded_names = settings['excluded_names']\nif more_excluded_names is not None:\n    excluded_names += more_excluded_names\nreturn globalsfilter(data, check_all=settings['check_all'], filters=tuple(\n    supported_types[mode]), exclude_private=settings['exclude_private'],\n    exclude_uppercase=settings['exclude_uppercase'], exclude_capitalized=\n    settings['exclude_capitalized'], exclude_unsupported=settings[\n    'exclude_unsupported'], exclude_callables_and_modules=settings[\n    'exclude_callables_and_modules'], excluded_names=excluded_names)\n",
        "CUT_2": "\"\"\"\n        Retrieve all Variable Explorer configuration settings.\n        \n        Specifically, return the settings in CONF_SECTION with keys in \n        REMOTE_SETTINGS, and the setting 'dataframe_format'.\n        \n        Returns:\n            dict: settings\n        \"\"\"\nsettings = {}\nfor name in REMOTE_SETTINGS:\n    settings[name] = self.get_option(name)\nname = 'dataframe_format'\nsettings[name] = '%{0}'.format(self.get_option(name))\nreturn settings\n",
        "CUT_3": "\"\"\"\n        Retrieve all Variable Explorer configuration settings.\n        \n        Specifically, return the settings in CONF_SECTION with keys in \n        REMOTE_SETTINGS, and the setting 'dataframe_format'.\n        \n        Returns:\n            dict: settings\n        \"\"\"\nsettings = {}\nfor name in REMOTE_SETTINGS:\n    settings[name] = self.get_option(name)\nname = 'dataframe_format'\nsettings[name] = '%{0}'.format(self.get_option(name))\nreturn settings\n",
        "CUT_4": "\"\"\"Return dict editor view settings\"\"\"\nsettings = {}\nfor name in REMOTE_SETTINGS:\n    settings[name] = getattr(self, name)\nreturn settings\n",
        "CUT_5": "\"\"\"Return dict editor view settings\"\"\"\nsettings = {}\nfor name in REMOTE_SETTINGS:\n    settings[name] = getattr(self, name)\nreturn settings\n"
    },
    {
        "functionName": "test_comprehensions_with_locals_in_pdb",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/console/tests/test_console_kernel.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that evaluating comprehensions with locals works in Pdb.\n\n    Also test that we use the right frame globals, in case the user\n    wants to work with them.\n\n    This is a regression test for spyder-ide/spyder#13909.\n    \"\"\"\npdb_obj = SpyderPdb()\npdb_obj.curframe = inspect.currentframe()\npdb_obj.curframe_locals = pdb_obj.curframe.f_locals\nkernel._pdb_obj = pdb_obj\nkernel._pdb_obj.default('zz = 10')\nassert kernel.get_value('zz') == 10\nkernel._pdb_obj.default('compr = [zz * i for i in [1, 2, 3]]')\nassert kernel.get_value('compr') == [10, 20, 30]\nkernel._pdb_obj.default(\"in_globals = 'zz' in globals()\")\nassert kernel.get_value('in_globals') == False\n",
        "CUT_1": "self.pdb_obj = pdb_obj\n",
        "CUT_2": "\"\"\"Register Pdb session to use it later\"\"\"\nself._pdb_obj = pdb_obj\n",
        "CUT_3": "\"\"\"Return current Pdb frame if there is any\"\"\"\nif self._pdb_obj is not None and self._pdb_obj.curframe is not None:\n    return self._pdb_obj.curframe\nproperty",
        "CUT_4": "\"\"\"\n        Register Pdb session after reset.\n        \"\"\"\nsuper(SpyderPdb, self).reset()\nkernel = get_ipython().kernel\nkernel._register_pdb_session(self)\n",
        "CUT_5": "try:\n    sys.path.remove(osp.dirname(__file__))\nexcept ValueError:\n    pass\ntry:\n    locals().pop('__file__')\nexcept KeyError:\n    pass\n__doc__ = ''\n__name__ = '__main__'\nimport_spydercustomize()\nwhile '' in sys.path:\n    sys.path.remove('')\nfrom ipykernel.kernelapp import IPKernelApp\nfrom spyder_kernels.console.kernel import SpyderKernel\nclass SpyderKernelApp(IPKernelApp):\n\n    def init_pdb(self):\n        \"\"\"\n            This method was added in IPykernel 5.3.1 and it replaces\n            the debugger used by the kernel with a new class\n            introduced in IPython 7.15 during kernel's initialization.\n            Therefore, it doesn't allow us to use our debugger.\n            \"\"\"\n        pass\nkernel = SpyderKernelApp.instance()\nkernel.kernel_class = SpyderKernel\ntry:\n    kernel.config = kernel_config()\nexcept:\n    pass\nkernel.initialize()\nkernel.shell.register_magic_function(varexp)\nimport pdb\nkernel.shell.InteractiveTB.debugger_cls = pdb.Pdb\nkernel.start()\n"
    },
    {
        "functionName": "test_user_sitepackages_in_pathlist",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/customize/tests/test_utils.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that we include user site-packages in pathlist.\"\"\"\nif sys.platform.startswith('linux'):\n    user_path = 'local'\nelif sys.platform == 'darwin':\n    user_path = os.path.expanduser('~/.local')\nelse:\n    user_path = 'Roaming'\nassert any([(user_path in path) for path in create_pathlist()])\n",
        "CUT_1": "\"\"\"\n    Create list of Python library paths to be skipped from module\n    reloading and Pdb steps.\n    \"\"\"\ntry:\n    paths = sysconfig.get_paths()\n    standard_paths = [paths['stdlib'], paths['purelib'], paths['scripts'],\n        paths['data']]\nexcept Exception:\n    standard_paths = []\ntry:\n    import site\n    if getattr(site, 'getusersitepackages', False):\n        user_path = [site.getusersitepackages()]\n    elif getattr(site, 'USER_SITE', False):\n        user_path = [site.USER_SITE]\n    else:\n        user_path = []\nexcept Exception:\n    user_path = []\nreturn standard_paths + user_path\n",
        "CUT_2": "\"\"\"Detect if kite is installed and return the installation path.\"\"\"\npath = ''\nif os.name == 'nt':\n    path = 'C:\\\\Program Files\\\\Kite\\\\kited.exe'\nelif sys.platform.startswith('linux'):\n    path = osp.expanduser('~/.local/share/kite/kited')\nelif sys.platform == 'darwin':\n    path = locate_kite_darwin()\nreturn osp.exists(osp.realpath(path)), path\n",
        "CUT_3": "\"\"\"Detect if kite is installed and return the installation path.\"\"\"\npath = ''\nif os.name == 'nt':\n    path = 'C:\\\\Program Files\\\\Kite\\\\kited.exe'\nelif sys.platform.startswith('linux'):\n    path = osp.expanduser('~/.local/share/kite/kited')\nelif sys.platform == 'darwin':\n    path = locate_kite_darwin()\nreturn osp.exists(osp.realpath(path)), path\n",
        "CUT_4": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n",
        "CUT_5": "\"\"\"\n        Return the `sys.path`.\n        \"\"\"\nreturn sys.path\n"
    },
    {
        "functionName": "user_module",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/customize/tests/test_umr.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Create a simple module in tmpdir as an example of a user module.\"\"\"\nif to_text_string(tmpdir) not in sys.path:\n    sys.path.append(to_text_string(tmpdir))\ndef create_module(modname):\n    modfile = tmpdir.mkdir(modname).join('bar.py')\n    code = '\\ndef square(x):\\n    return x**2\\n        '\n    modfile.write(code)\n    init_file = tmpdir.join(modname).join('__init__.py')\n    init_file.write('#')\nreturn create_module\npytest.fixture",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_3": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_4": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n",
        "CUT_5": "\"\"\"Return module *modname* base path\"\"\"\nreturn osp.abspath(osp.dirname(sys.modules[modname].__file__))\n"
    },
    {
        "functionName": "create_module",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/customize/tests/test_umr.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "modfile = tmpdir.mkdir(modname).join('bar.py')\ncode = \"\"\"\ndef square(x):\n    return x**2\n        \"\"\"\nmodfile.write(code)\ninit_file = tmpdir.join(modname).join('__init__.py')\ninit_file.write('#')\n",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "if modname[-9:] == '.__init__':\n    modname = modname[:-9] + ' (package)'\nsearch_result.append((modname, desc and '- ' + desc))\n",
        "CUT_3": "if modname[-9:] == '.__init__':\n    modname = modname[:-9] + ' (package)'\nsearch_result.append((modname, desc and '- ' + desc))\n",
        "CUT_4": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_5": "\"\"\"Return module *modname* base path\"\"\"\nreturn osp.abspath(osp.dirname(sys.modules[modname].__file__))\n"
    },
    {
        "functionName": "test_umr_skip_cython",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/customize/tests/test_umr.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"\n    Test that the UMR doesn't try to reload modules when Cython\n    support is active.\n    \"\"\"\nuser_module('foo')\nos.environ['SPY_RUN_CYTHON'] = 'True'\numr = UserModuleReloader()\nimport foo\nassert umr.is_module_reloadable(foo, 'foo') == False\nos.environ['SPY_RUN_CYTHON'] = 'False'\n",
        "CUT_1": "\"\"\"\n        Check if optional dependencies are available for special consoles.\n        \"\"\"\ntry:\n    if os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True':\n        import matplotlib\n    elif os.environ.get('SPY_SYMPY_O') == 'True':\n        import sympy\n    elif os.environ.get('SPY_RUN_CYTHON') == 'True':\n        import cython\nexcept Exception:\n    if os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True':\n        return 'matplotlib'\n    elif os.environ.get('SPY_SYMPY_O') == 'True':\n        return 'sympy'\n    elif os.environ.get('SPY_RUN_CYTHON') == 'True':\n        return 'cython'\nreturn None\n",
        "CUT_2": "\"\"\"\n        Activate Cython support.\n\n        We need to run this here because if the support is\n        active, we don't to run the UMR at all.\n        \"\"\"\nrun_cython = os.environ.get('SPY_RUN_CYTHON') == 'True'\nif run_cython:\n    try:\n        __import__('Cython')\n        self.has_cython = True\n    except Exception:\n        pass\n    if self.has_cython:\n        import pyximport\n        pyx_setup_args = {}\n        try:\n            import numpy\n            pyx_setup_args['include_dirs'] = numpy.get_include()\n        except Exception:\n            pass\n        pyximport.install(setup_args=pyx_setup_args, reload_support=True)\n",
        "CUT_3": "newcb = self.create_checkbox\npyexec_group = QGroupBox(_('Python interpreter'))\npyexec_bg = QButtonGroup(pyexec_group)\npyexec_label = QLabel(_(\n    'Select the Python interpreter for all Spyder consoles'))\nself.def_exec_radio = self.create_radiobutton(_(\n    \"Default (i.e. the same as Spyder's)\"), 'default', button_group=pyexec_bg)\nself.cus_exec_radio = self.create_radiobutton(_(\n    'Use the following Python interpreter:'), 'custom', button_group=pyexec_bg)\nif os.name == 'nt':\n    filters = _('Executables') + ' (*.exe)'\nelse:\n    filters = None\npyexec_layout = QVBoxLayout()\npyexec_layout.addWidget(pyexec_label)\npyexec_layout.addWidget(self.def_exec_radio)\npyexec_layout.addWidget(self.cus_exec_radio)\nself.validate_custom_interpreters_list()\nself.cus_exec_combo = self.create_file_combobox(_(\n    'Recent custom interpreters'), self.get_option(\n    'custom_interpreters_list'), 'custom_interpreter', filters=filters,\n    default_line_edit=True, adjust_to_contents=True, validate_callback=\n    programs.is_python_interpreter)\nself.def_exec_radio.toggled.connect(self.cus_exec_combo.setDisabled)\nself.cus_exec_radio.toggled.connect(self.cus_exec_combo.setEnabled)\npyexec_layout.addWidget(self.cus_exec_combo)\npyexec_group.setLayout(pyexec_layout)\nself.pyexec_edit = self.cus_exec_combo.combobox.lineEdit()\numr_group = QGroupBox(_('User Module Reloader (UMR)'))\numr_label = QLabel(_(\n    'UMR forces Python to reload modules which were imported when executing a file in a Python or IPython console with the <i>runfile</i> function.'\n    ))\numr_label.setWordWrap(True)\numr_enabled_box = newcb(_('Enable UMR'), 'umr/enabled', msg_if_enabled=True,\n    msg_warning=_(\n    \"This option will enable the User Module Reloader (UMR) in Python/IPython consoles. UMR forces Python to reload deeply modules during import when running a Python script using the Spyder's builtin function <b>runfile</b>.<br><br><b>1.</b> UMR may require to restart the console in which it will be called (otherwise only newly imported modules will be reloaded when executing files).<br><br><b>2.</b> If errors occur when re-running a PyQt-based program, please check that the Qt objects are properly destroyed (e.g. you may have to use the attribute <b>Qt.WA_DeleteOnClose</b> on your main window, using the <b>setAttribute</b> method)\"\n    ))\numr_verbose_box = newcb(_('Show reloaded modules list'), 'umr/verbose',\n    msg_info=_(\n    'Please note that these changes will be applied only to new consoles'))\numr_namelist_btn = QPushButton(_('Set UMR excluded (not reloaded) modules'))\numr_namelist_btn.clicked.connect(self.set_umr_namelist)\numr_layout = QVBoxLayout()\numr_layout.addWidget(umr_label)\numr_layout.addWidget(umr_enabled_box)\numr_layout.addWidget(umr_verbose_box)\numr_layout.addWidget(umr_namelist_btn)\numr_group.setLayout(umr_layout)\nvlayout = QVBoxLayout()\nvlayout.addWidget(pyexec_group)\nvlayout.addWidget(umr_group)\nvlayout.addStretch(1)\nself.setLayout(vlayout)\n",
        "CUT_4": "newcb = self.create_checkbox\npyexec_group = QGroupBox(_('Python interpreter'))\npyexec_bg = QButtonGroup(pyexec_group)\npyexec_label = QLabel(_(\n    'Select the Python interpreter for all Spyder consoles'))\nself.def_exec_radio = self.create_radiobutton(_(\n    \"Default (i.e. the same as Spyder's)\"), 'default', button_group=pyexec_bg)\nself.cus_exec_radio = self.create_radiobutton(_(\n    'Use the following Python interpreter:'), 'custom', button_group=pyexec_bg)\nif os.name == 'nt':\n    filters = _('Executables') + ' (*.exe)'\nelse:\n    filters = None\npyexec_layout = QVBoxLayout()\npyexec_layout.addWidget(pyexec_label)\npyexec_layout.addWidget(self.def_exec_radio)\npyexec_layout.addWidget(self.cus_exec_radio)\nself.validate_custom_interpreters_list()\nself.cus_exec_combo = self.create_file_combobox(_(\n    'Recent custom interpreters'), self.get_option(\n    'custom_interpreters_list'), 'custom_interpreter', filters=filters,\n    default_line_edit=True, adjust_to_contents=True, validate_callback=\n    programs.is_python_interpreter)\nself.def_exec_radio.toggled.connect(self.cus_exec_combo.setDisabled)\nself.cus_exec_radio.toggled.connect(self.cus_exec_combo.setEnabled)\npyexec_layout.addWidget(self.cus_exec_combo)\npyexec_group.setLayout(pyexec_layout)\nself.pyexec_edit = self.cus_exec_combo.combobox.lineEdit()\numr_group = QGroupBox(_('User Module Reloader (UMR)'))\numr_label = QLabel(_(\n    'UMR forces Python to reload modules which were imported when executing a file in a Python or IPython console with the <i>runfile</i> function.'\n    ))\numr_label.setWordWrap(True)\numr_enabled_box = newcb(_('Enable UMR'), 'umr/enabled', msg_if_enabled=True,\n    msg_warning=_(\n    \"This option will enable the User Module Reloader (UMR) in Python/IPython consoles. UMR forces Python to reload deeply modules during import when running a Python script using the Spyder's builtin function <b>runfile</b>.<br><br><b>1.</b> UMR may require to restart the console in which it will be called (otherwise only newly imported modules will be reloaded when executing files).<br><br><b>2.</b> If errors occur when re-running a PyQt-based program, please check that the Qt objects are properly destroyed (e.g. you may have to use the attribute <b>Qt.WA_DeleteOnClose</b> on your main window, using the <b>setAttribute</b> method)\"\n    ))\numr_verbose_box = newcb(_('Show reloaded modules list'), 'umr/verbose',\n    msg_info=_(\n    'Please note that these changes will be applied only to new consoles'))\numr_namelist_btn = QPushButton(_('Set UMR excluded (not reloaded) modules'))\numr_namelist_btn.clicked.connect(self.set_umr_namelist)\numr_layout = QVBoxLayout()\numr_layout.addWidget(umr_label)\numr_layout.addWidget(umr_enabled_box)\numr_layout.addWidget(umr_verbose_box)\numr_layout.addWidget(umr_namelist_btn)\numr_group.setLayout(umr_layout)\nvlayout = QVBoxLayout()\nvlayout.addWidget(pyexec_group)\nvlayout.addWidget(umr_group)\nvlayout.addStretch(1)\nself.setLayout(vlayout)\n",
        "CUT_5": "\"\"\"Set UMR excluded modules name list\"\"\"\narguments, valid = QInputDialog.getText(self, _('UMR'), _(\n    'Set the list of excluded modules as this: <i>numpy, scipy</i>'),\n    QLineEdit.Normal, ', '.join(self.get_option('umr/namelist')))\nif valid:\n    arguments = to_text_string(arguments)\n    if arguments:\n        namelist = arguments.replace(' ', '').split(',')\n        fixed_namelist = []\n        non_ascii_namelist = []\n        for module_name in namelist:\n            if PY2:\n                if all(ord(c) < 128 for c in module_name):\n                    if programs.is_module_installed(module_name):\n                        fixed_namelist.append(module_name)\n                else:\n                    QMessageBox.warning(self, _('Warning'), _(\n                        'You are working with Python 2, this means that you can not import a module that contains non-ascii characters.'\n                        ), QMessageBox.Ok)\n                    non_ascii_namelist.append(module_name)\n            elif programs.is_module_installed(module_name):\n                fixed_namelist.append(module_name)\n        invalid = ', '.join(set(namelist) - set(fixed_namelist) - set(\n            non_ascii_namelist))\n        if invalid:\n            QMessageBox.warning(self, _('UMR'), _(\n                \"\"\"The following modules are not installed on your machine:\n%s\"\"\"\n                ) % invalid, QMessageBox.Ok)\n        QMessageBox.information(self, _('UMR'), _(\n            'Please note that these changes will be applied only to new Python/IPython consoles'\n            ), QMessageBox.Ok)\n    else:\n        fixed_namelist = []\n    self.set_option('umr/namelist', fixed_namelist)\n"
    },
    {
        "functionName": "test_umr_run",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/customize/tests/test_umr.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that UMR's run method is working correctly.\"\"\"\nuser_module('foo1')\nos.environ['SPY_UMR_VERBOSE'] = 'True'\numr = UserModuleReloader()\nfrom foo1.bar import square\numr.run()\numr.modnames_to_reload == ['foo', 'foo.bar']\n",
        "CUT_1": "\"\"\"Set UMR excluded modules name list\"\"\"\narguments, valid = QInputDialog.getText(self, _('UMR'), _(\n    'Set the list of excluded modules as this: <i>numpy, scipy</i>'),\n    QLineEdit.Normal, ', '.join(self.get_option('umr/namelist')))\nif valid:\n    arguments = to_text_string(arguments)\n    if arguments:\n        namelist = arguments.replace(' ', '').split(',')\n        fixed_namelist = []\n        non_ascii_namelist = []\n        for module_name in namelist:\n            if PY2:\n                if all(ord(c) < 128 for c in module_name):\n                    if programs.is_module_installed(module_name):\n                        fixed_namelist.append(module_name)\n                else:\n                    QMessageBox.warning(self, _('Warning'), _(\n                        'You are working with Python 2, this means that you can not import a module that contains non-ascii characters.'\n                        ), QMessageBox.Ok)\n                    non_ascii_namelist.append(module_name)\n            elif programs.is_module_installed(module_name):\n                fixed_namelist.append(module_name)\n        invalid = ', '.join(set(namelist) - set(fixed_namelist) - set(\n            non_ascii_namelist))\n        if invalid:\n            QMessageBox.warning(self, _('UMR'), _(\n                \"\"\"The following modules are not installed on your machine:\n%s\"\"\"\n                ) % invalid, QMessageBox.Ok)\n        QMessageBox.information(self, _('UMR'), _(\n            'Please note that these changes will be applied only to new Python/IPython consoles'\n            ), QMessageBox.Ok)\n    else:\n        fixed_namelist = []\n    self.set_option('umr/namelist', fixed_namelist)\n",
        "CUT_2": "\"\"\"Set UMR excluded modules name list\"\"\"\narguments, valid = QInputDialog.getText(self, _('UMR'), _(\n    'Set the list of excluded modules as this: <i>numpy, scipy</i>'),\n    QLineEdit.Normal, ', '.join(self.get_option('umr/namelist')))\nif valid:\n    arguments = to_text_string(arguments)\n    if arguments:\n        namelist = arguments.replace(' ', '').split(',')\n        fixed_namelist = []\n        non_ascii_namelist = []\n        for module_name in namelist:\n            if PY2:\n                if all(ord(c) < 128 for c in module_name):\n                    if programs.is_module_installed(module_name):\n                        fixed_namelist.append(module_name)\n                else:\n                    QMessageBox.warning(self, _('Warning'), _(\n                        'You are working with Python 2, this means that you can not import a module that contains non-ascii characters.'\n                        ), QMessageBox.Ok)\n                    non_ascii_namelist.append(module_name)\n            elif programs.is_module_installed(module_name):\n                fixed_namelist.append(module_name)\n        invalid = ', '.join(set(namelist) - set(fixed_namelist) - set(\n            non_ascii_namelist))\n        if invalid:\n            QMessageBox.warning(self, _('UMR'), _(\n                \"\"\"The following modules are not installed on your machine:\n%s\"\"\"\n                ) % invalid, QMessageBox.Ok)\n        QMessageBox.information(self, _('UMR'), _(\n            'Please note that these changes will be applied only to new Python/IPython consoles'\n            ), QMessageBox.Ok)\n    else:\n        fixed_namelist = []\n    self.set_option('umr/namelist', fixed_namelist)\n",
        "CUT_3": "newcb = self.create_checkbox\npyexec_group = QGroupBox(_('Python interpreter'))\npyexec_bg = QButtonGroup(pyexec_group)\npyexec_label = QLabel(_(\n    'Select the Python interpreter for all Spyder consoles'))\nself.def_exec_radio = self.create_radiobutton(_(\n    \"Default (i.e. the same as Spyder's)\"), 'default', button_group=pyexec_bg)\nself.cus_exec_radio = self.create_radiobutton(_(\n    'Use the following Python interpreter:'), 'custom', button_group=pyexec_bg)\nif os.name == 'nt':\n    filters = _('Executables') + ' (*.exe)'\nelse:\n    filters = None\npyexec_layout = QVBoxLayout()\npyexec_layout.addWidget(pyexec_label)\npyexec_layout.addWidget(self.def_exec_radio)\npyexec_layout.addWidget(self.cus_exec_radio)\nself.validate_custom_interpreters_list()\nself.cus_exec_combo = self.create_file_combobox(_(\n    'Recent custom interpreters'), self.get_option(\n    'custom_interpreters_list'), 'custom_interpreter', filters=filters,\n    default_line_edit=True, adjust_to_contents=True, validate_callback=\n    programs.is_python_interpreter)\nself.def_exec_radio.toggled.connect(self.cus_exec_combo.setDisabled)\nself.cus_exec_radio.toggled.connect(self.cus_exec_combo.setEnabled)\npyexec_layout.addWidget(self.cus_exec_combo)\npyexec_group.setLayout(pyexec_layout)\nself.pyexec_edit = self.cus_exec_combo.combobox.lineEdit()\numr_group = QGroupBox(_('User Module Reloader (UMR)'))\numr_label = QLabel(_(\n    'UMR forces Python to reload modules which were imported when executing a file in a Python or IPython console with the <i>runfile</i> function.'\n    ))\numr_label.setWordWrap(True)\numr_enabled_box = newcb(_('Enable UMR'), 'umr/enabled', msg_if_enabled=True,\n    msg_warning=_(\n    \"This option will enable the User Module Reloader (UMR) in Python/IPython consoles. UMR forces Python to reload deeply modules during import when running a Python script using the Spyder's builtin function <b>runfile</b>.<br><br><b>1.</b> UMR may require to restart the console in which it will be called (otherwise only newly imported modules will be reloaded when executing files).<br><br><b>2.</b> If errors occur when re-running a PyQt-based program, please check that the Qt objects are properly destroyed (e.g. you may have to use the attribute <b>Qt.WA_DeleteOnClose</b> on your main window, using the <b>setAttribute</b> method)\"\n    ))\numr_verbose_box = newcb(_('Show reloaded modules list'), 'umr/verbose',\n    msg_info=_(\n    'Please note that these changes will be applied only to new consoles'))\numr_namelist_btn = QPushButton(_('Set UMR excluded (not reloaded) modules'))\numr_namelist_btn.clicked.connect(self.set_umr_namelist)\numr_layout = QVBoxLayout()\numr_layout.addWidget(umr_label)\numr_layout.addWidget(umr_enabled_box)\numr_layout.addWidget(umr_verbose_box)\numr_layout.addWidget(umr_namelist_btn)\numr_group.setLayout(umr_layout)\nvlayout = QVBoxLayout()\nvlayout.addWidget(pyexec_group)\nvlayout.addWidget(umr_group)\nvlayout.addStretch(1)\nself.setLayout(vlayout)\n",
        "CUT_4": "newcb = self.create_checkbox\npyexec_group = QGroupBox(_('Python interpreter'))\npyexec_bg = QButtonGroup(pyexec_group)\npyexec_label = QLabel(_(\n    'Select the Python interpreter for all Spyder consoles'))\nself.def_exec_radio = self.create_radiobutton(_(\n    \"Default (i.e. the same as Spyder's)\"), 'default', button_group=pyexec_bg)\nself.cus_exec_radio = self.create_radiobutton(_(\n    'Use the following Python interpreter:'), 'custom', button_group=pyexec_bg)\nif os.name == 'nt':\n    filters = _('Executables') + ' (*.exe)'\nelse:\n    filters = None\npyexec_layout = QVBoxLayout()\npyexec_layout.addWidget(pyexec_label)\npyexec_layout.addWidget(self.def_exec_radio)\npyexec_layout.addWidget(self.cus_exec_radio)\nself.validate_custom_interpreters_list()\nself.cus_exec_combo = self.create_file_combobox(_(\n    'Recent custom interpreters'), self.get_option(\n    'custom_interpreters_list'), 'custom_interpreter', filters=filters,\n    default_line_edit=True, adjust_to_contents=True, validate_callback=\n    programs.is_python_interpreter)\nself.def_exec_radio.toggled.connect(self.cus_exec_combo.setDisabled)\nself.cus_exec_radio.toggled.connect(self.cus_exec_combo.setEnabled)\npyexec_layout.addWidget(self.cus_exec_combo)\npyexec_group.setLayout(pyexec_layout)\nself.pyexec_edit = self.cus_exec_combo.combobox.lineEdit()\numr_group = QGroupBox(_('User Module Reloader (UMR)'))\numr_label = QLabel(_(\n    'UMR forces Python to reload modules which were imported when executing a file in a Python or IPython console with the <i>runfile</i> function.'\n    ))\numr_label.setWordWrap(True)\numr_enabled_box = newcb(_('Enable UMR'), 'umr/enabled', msg_if_enabled=True,\n    msg_warning=_(\n    \"This option will enable the User Module Reloader (UMR) in Python/IPython consoles. UMR forces Python to reload deeply modules during import when running a Python script using the Spyder's builtin function <b>runfile</b>.<br><br><b>1.</b> UMR may require to restart the console in which it will be called (otherwise only newly imported modules will be reloaded when executing files).<br><br><b>2.</b> If errors occur when re-running a PyQt-based program, please check that the Qt objects are properly destroyed (e.g. you may have to use the attribute <b>Qt.WA_DeleteOnClose</b> on your main window, using the <b>setAttribute</b> method)\"\n    ))\numr_verbose_box = newcb(_('Show reloaded modules list'), 'umr/verbose',\n    msg_info=_(\n    'Please note that these changes will be applied only to new consoles'))\numr_namelist_btn = QPushButton(_('Set UMR excluded (not reloaded) modules'))\numr_namelist_btn.clicked.connect(self.set_umr_namelist)\numr_layout = QVBoxLayout()\numr_layout.addWidget(umr_label)\numr_layout.addWidget(umr_enabled_box)\numr_layout.addWidget(umr_verbose_box)\numr_layout.addWidget(umr_namelist_btn)\numr_group.setLayout(umr_layout)\nvlayout = QVBoxLayout()\nvlayout.addWidget(pyexec_group)\nvlayout.addWidget(umr_group)\nvlayout.addStretch(1)\nself.setLayout(vlayout)\n",
        "CUT_5": "return _('Run')\n"
    },
    {
        "functionName": "test_umr_previous_modules",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/customize/tests/test_umr.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that UMR's previos_modules is working as expected.\"\"\"\nuser_module('foo2')\numr = UserModuleReloader()\nimport foo2\nassert 'IPython' in umr.previous_modules\nassert 'foo2' not in umr.previous_modules\n",
        "CUT_1": "\"\"\"Set UMR excluded modules name list\"\"\"\narguments, valid = QInputDialog.getText(self, _('UMR'), _(\n    'Set the list of excluded modules as this: <i>numpy, scipy</i>'),\n    QLineEdit.Normal, ', '.join(self.get_option('umr/namelist')))\nif valid:\n    arguments = to_text_string(arguments)\n    if arguments:\n        namelist = arguments.replace(' ', '').split(',')\n        fixed_namelist = []\n        non_ascii_namelist = []\n        for module_name in namelist:\n            if PY2:\n                if all(ord(c) < 128 for c in module_name):\n                    if programs.is_module_installed(module_name):\n                        fixed_namelist.append(module_name)\n                else:\n                    QMessageBox.warning(self, _('Warning'), _(\n                        'You are working with Python 2, this means that you can not import a module that contains non-ascii characters.'\n                        ), QMessageBox.Ok)\n                    non_ascii_namelist.append(module_name)\n            elif programs.is_module_installed(module_name):\n                fixed_namelist.append(module_name)\n        invalid = ', '.join(set(namelist) - set(fixed_namelist) - set(\n            non_ascii_namelist))\n        if invalid:\n            QMessageBox.warning(self, _('UMR'), _(\n                \"\"\"The following modules are not installed on your machine:\n%s\"\"\"\n                ) % invalid, QMessageBox.Ok)\n        QMessageBox.information(self, _('UMR'), _(\n            'Please note that these changes will be applied only to new Python/IPython consoles'\n            ), QMessageBox.Ok)\n    else:\n        fixed_namelist = []\n    self.set_option('umr/namelist', fixed_namelist)\n",
        "CUT_2": "\"\"\"Set UMR excluded modules name list\"\"\"\narguments, valid = QInputDialog.getText(self, _('UMR'), _(\n    'Set the list of excluded modules as this: <i>numpy, scipy</i>'),\n    QLineEdit.Normal, ', '.join(self.get_option('umr/namelist')))\nif valid:\n    arguments = to_text_string(arguments)\n    if arguments:\n        namelist = arguments.replace(' ', '').split(',')\n        fixed_namelist = []\n        non_ascii_namelist = []\n        for module_name in namelist:\n            if PY2:\n                if all(ord(c) < 128 for c in module_name):\n                    if programs.is_module_installed(module_name):\n                        fixed_namelist.append(module_name)\n                else:\n                    QMessageBox.warning(self, _('Warning'), _(\n                        'You are working with Python 2, this means that you can not import a module that contains non-ascii characters.'\n                        ), QMessageBox.Ok)\n                    non_ascii_namelist.append(module_name)\n            elif programs.is_module_installed(module_name):\n                fixed_namelist.append(module_name)\n        invalid = ', '.join(set(namelist) - set(fixed_namelist) - set(\n            non_ascii_namelist))\n        if invalid:\n            QMessageBox.warning(self, _('UMR'), _(\n                \"\"\"The following modules are not installed on your machine:\n%s\"\"\"\n                ) % invalid, QMessageBox.Ok)\n        QMessageBox.information(self, _('UMR'), _(\n            'Please note that these changes will be applied only to new Python/IPython consoles'\n            ), QMessageBox.Ok)\n    else:\n        fixed_namelist = []\n    self.set_option('umr/namelist', fixed_namelist)\n",
        "CUT_3": "newcb = self.create_checkbox\npyexec_group = QGroupBox(_('Python interpreter'))\npyexec_bg = QButtonGroup(pyexec_group)\npyexec_label = QLabel(_(\n    'Select the Python interpreter for all Spyder consoles'))\nself.def_exec_radio = self.create_radiobutton(_(\n    \"Default (i.e. the same as Spyder's)\"), 'default', button_group=pyexec_bg)\nself.cus_exec_radio = self.create_radiobutton(_(\n    'Use the following Python interpreter:'), 'custom', button_group=pyexec_bg)\nif os.name == 'nt':\n    filters = _('Executables') + ' (*.exe)'\nelse:\n    filters = None\npyexec_layout = QVBoxLayout()\npyexec_layout.addWidget(pyexec_label)\npyexec_layout.addWidget(self.def_exec_radio)\npyexec_layout.addWidget(self.cus_exec_radio)\nself.validate_custom_interpreters_list()\nself.cus_exec_combo = self.create_file_combobox(_(\n    'Recent custom interpreters'), self.get_option(\n    'custom_interpreters_list'), 'custom_interpreter', filters=filters,\n    default_line_edit=True, adjust_to_contents=True, validate_callback=\n    programs.is_python_interpreter)\nself.def_exec_radio.toggled.connect(self.cus_exec_combo.setDisabled)\nself.cus_exec_radio.toggled.connect(self.cus_exec_combo.setEnabled)\npyexec_layout.addWidget(self.cus_exec_combo)\npyexec_group.setLayout(pyexec_layout)\nself.pyexec_edit = self.cus_exec_combo.combobox.lineEdit()\numr_group = QGroupBox(_('User Module Reloader (UMR)'))\numr_label = QLabel(_(\n    'UMR forces Python to reload modules which were imported when executing a file in a Python or IPython console with the <i>runfile</i> function.'\n    ))\numr_label.setWordWrap(True)\numr_enabled_box = newcb(_('Enable UMR'), 'umr/enabled', msg_if_enabled=True,\n    msg_warning=_(\n    \"This option will enable the User Module Reloader (UMR) in Python/IPython consoles. UMR forces Python to reload deeply modules during import when running a Python script using the Spyder's builtin function <b>runfile</b>.<br><br><b>1.</b> UMR may require to restart the console in which it will be called (otherwise only newly imported modules will be reloaded when executing files).<br><br><b>2.</b> If errors occur when re-running a PyQt-based program, please check that the Qt objects are properly destroyed (e.g. you may have to use the attribute <b>Qt.WA_DeleteOnClose</b> on your main window, using the <b>setAttribute</b> method)\"\n    ))\numr_verbose_box = newcb(_('Show reloaded modules list'), 'umr/verbose',\n    msg_info=_(\n    'Please note that these changes will be applied only to new consoles'))\numr_namelist_btn = QPushButton(_('Set UMR excluded (not reloaded) modules'))\numr_namelist_btn.clicked.connect(self.set_umr_namelist)\numr_layout = QVBoxLayout()\numr_layout.addWidget(umr_label)\numr_layout.addWidget(umr_enabled_box)\numr_layout.addWidget(umr_verbose_box)\numr_layout.addWidget(umr_namelist_btn)\numr_group.setLayout(umr_layout)\nvlayout = QVBoxLayout()\nvlayout.addWidget(pyexec_group)\nvlayout.addWidget(umr_group)\nvlayout.addStretch(1)\nself.setLayout(vlayout)\n",
        "CUT_4": "newcb = self.create_checkbox\npyexec_group = QGroupBox(_('Python interpreter'))\npyexec_bg = QButtonGroup(pyexec_group)\npyexec_label = QLabel(_(\n    'Select the Python interpreter for all Spyder consoles'))\nself.def_exec_radio = self.create_radiobutton(_(\n    \"Default (i.e. the same as Spyder's)\"), 'default', button_group=pyexec_bg)\nself.cus_exec_radio = self.create_radiobutton(_(\n    'Use the following Python interpreter:'), 'custom', button_group=pyexec_bg)\nif os.name == 'nt':\n    filters = _('Executables') + ' (*.exe)'\nelse:\n    filters = None\npyexec_layout = QVBoxLayout()\npyexec_layout.addWidget(pyexec_label)\npyexec_layout.addWidget(self.def_exec_radio)\npyexec_layout.addWidget(self.cus_exec_radio)\nself.validate_custom_interpreters_list()\nself.cus_exec_combo = self.create_file_combobox(_(\n    'Recent custom interpreters'), self.get_option(\n    'custom_interpreters_list'), 'custom_interpreter', filters=filters,\n    default_line_edit=True, adjust_to_contents=True, validate_callback=\n    programs.is_python_interpreter)\nself.def_exec_radio.toggled.connect(self.cus_exec_combo.setDisabled)\nself.cus_exec_radio.toggled.connect(self.cus_exec_combo.setEnabled)\npyexec_layout.addWidget(self.cus_exec_combo)\npyexec_group.setLayout(pyexec_layout)\nself.pyexec_edit = self.cus_exec_combo.combobox.lineEdit()\numr_group = QGroupBox(_('User Module Reloader (UMR)'))\numr_label = QLabel(_(\n    'UMR forces Python to reload modules which were imported when executing a file in a Python or IPython console with the <i>runfile</i> function.'\n    ))\numr_label.setWordWrap(True)\numr_enabled_box = newcb(_('Enable UMR'), 'umr/enabled', msg_if_enabled=True,\n    msg_warning=_(\n    \"This option will enable the User Module Reloader (UMR) in Python/IPython consoles. UMR forces Python to reload deeply modules during import when running a Python script using the Spyder's builtin function <b>runfile</b>.<br><br><b>1.</b> UMR may require to restart the console in which it will be called (otherwise only newly imported modules will be reloaded when executing files).<br><br><b>2.</b> If errors occur when re-running a PyQt-based program, please check that the Qt objects are properly destroyed (e.g. you may have to use the attribute <b>Qt.WA_DeleteOnClose</b> on your main window, using the <b>setAttribute</b> method)\"\n    ))\numr_verbose_box = newcb(_('Show reloaded modules list'), 'umr/verbose',\n    msg_info=_(\n    'Please note that these changes will be applied only to new consoles'))\numr_namelist_btn = QPushButton(_('Set UMR excluded (not reloaded) modules'))\numr_namelist_btn.clicked.connect(self.set_umr_namelist)\numr_layout = QVBoxLayout()\numr_layout.addWidget(umr_label)\numr_layout.addWidget(umr_enabled_box)\numr_layout.addWidget(umr_verbose_box)\numr_layout.addWidget(umr_namelist_btn)\numr_group.setLayout(umr_layout)\nvlayout = QVBoxLayout()\nvlayout.addWidget(pyexec_group)\nvlayout.addWidget(umr_group)\nvlayout.addStretch(1)\nself.setLayout(vlayout)\n",
        "CUT_5": "\"\"\"\n        Activate Cython support.\n\n        We need to run this here because if the support is\n        active, we don't to run the UMR at all.\n        \"\"\"\nrun_cython = os.environ.get('SPY_RUN_CYTHON') == 'True'\nif run_cython:\n    try:\n        __import__('Cython')\n        self.has_cython = True\n    except Exception:\n        pass\n    if self.has_cython:\n        import pyximport\n        pyx_setup_args = {}\n        try:\n            import numpy\n            pyx_setup_args['include_dirs'] = numpy.get_include()\n        except Exception:\n            pass\n        pyximport.install(setup_args=pyx_setup_args, reload_support=True)\n"
    },
    {
        "functionName": "test_umr_namelist",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/customize/tests/test_umr.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the UMR skips modules according to its name.\"\"\"\numr = UserModuleReloader()\nassert umr.is_module_in_namelist('tensorflow')\nassert umr.is_module_in_namelist('pytorch')\nassert umr.is_module_in_namelist('spyder_kernels')\nassert not umr.is_module_in_namelist('foo')\n",
        "CUT_1": "\"\"\"Set UMR excluded modules name list\"\"\"\narguments, valid = QInputDialog.getText(self, _('UMR'), _(\n    'Set the list of excluded modules as this: <i>numpy, scipy</i>'),\n    QLineEdit.Normal, ', '.join(self.get_option('umr/namelist')))\nif valid:\n    arguments = to_text_string(arguments)\n    if arguments:\n        namelist = arguments.replace(' ', '').split(',')\n        fixed_namelist = []\n        non_ascii_namelist = []\n        for module_name in namelist:\n            if PY2:\n                if all(ord(c) < 128 for c in module_name):\n                    if programs.is_module_installed(module_name):\n                        fixed_namelist.append(module_name)\n                else:\n                    QMessageBox.warning(self, _('Warning'), _(\n                        'You are working with Python 2, this means that you can not import a module that contains non-ascii characters.'\n                        ), QMessageBox.Ok)\n                    non_ascii_namelist.append(module_name)\n            elif programs.is_module_installed(module_name):\n                fixed_namelist.append(module_name)\n        invalid = ', '.join(set(namelist) - set(fixed_namelist) - set(\n            non_ascii_namelist))\n        if invalid:\n            QMessageBox.warning(self, _('UMR'), _(\n                \"\"\"The following modules are not installed on your machine:\n%s\"\"\"\n                ) % invalid, QMessageBox.Ok)\n        QMessageBox.information(self, _('UMR'), _(\n            'Please note that these changes will be applied only to new Python/IPython consoles'\n            ), QMessageBox.Ok)\n    else:\n        fixed_namelist = []\n    self.set_option('umr/namelist', fixed_namelist)\n",
        "CUT_2": "\"\"\"Set UMR excluded modules name list\"\"\"\narguments, valid = QInputDialog.getText(self, _('UMR'), _(\n    'Set the list of excluded modules as this: <i>numpy, scipy</i>'),\n    QLineEdit.Normal, ', '.join(self.get_option('umr/namelist')))\nif valid:\n    arguments = to_text_string(arguments)\n    if arguments:\n        namelist = arguments.replace(' ', '').split(',')\n        fixed_namelist = []\n        non_ascii_namelist = []\n        for module_name in namelist:\n            if PY2:\n                if all(ord(c) < 128 for c in module_name):\n                    if programs.is_module_installed(module_name):\n                        fixed_namelist.append(module_name)\n                else:\n                    QMessageBox.warning(self, _('Warning'), _(\n                        'You are working with Python 2, this means that you can not import a module that contains non-ascii characters.'\n                        ), QMessageBox.Ok)\n                    non_ascii_namelist.append(module_name)\n            elif programs.is_module_installed(module_name):\n                fixed_namelist.append(module_name)\n        invalid = ', '.join(set(namelist) - set(fixed_namelist) - set(\n            non_ascii_namelist))\n        if invalid:\n            QMessageBox.warning(self, _('UMR'), _(\n                \"\"\"The following modules are not installed on your machine:\n%s\"\"\"\n                ) % invalid, QMessageBox.Ok)\n        QMessageBox.information(self, _('UMR'), _(\n            'Please note that these changes will be applied only to new Python/IPython consoles'\n            ), QMessageBox.Ok)\n    else:\n        fixed_namelist = []\n    self.set_option('umr/namelist', fixed_namelist)\n",
        "CUT_3": "newcb = self.create_checkbox\npyexec_group = QGroupBox(_('Python interpreter'))\npyexec_bg = QButtonGroup(pyexec_group)\npyexec_label = QLabel(_(\n    'Select the Python interpreter for all Spyder consoles'))\nself.def_exec_radio = self.create_radiobutton(_(\n    \"Default (i.e. the same as Spyder's)\"), 'default', button_group=pyexec_bg)\nself.cus_exec_radio = self.create_radiobutton(_(\n    'Use the following Python interpreter:'), 'custom', button_group=pyexec_bg)\nif os.name == 'nt':\n    filters = _('Executables') + ' (*.exe)'\nelse:\n    filters = None\npyexec_layout = QVBoxLayout()\npyexec_layout.addWidget(pyexec_label)\npyexec_layout.addWidget(self.def_exec_radio)\npyexec_layout.addWidget(self.cus_exec_radio)\nself.validate_custom_interpreters_list()\nself.cus_exec_combo = self.create_file_combobox(_(\n    'Recent custom interpreters'), self.get_option(\n    'custom_interpreters_list'), 'custom_interpreter', filters=filters,\n    default_line_edit=True, adjust_to_contents=True, validate_callback=\n    programs.is_python_interpreter)\nself.def_exec_radio.toggled.connect(self.cus_exec_combo.setDisabled)\nself.cus_exec_radio.toggled.connect(self.cus_exec_combo.setEnabled)\npyexec_layout.addWidget(self.cus_exec_combo)\npyexec_group.setLayout(pyexec_layout)\nself.pyexec_edit = self.cus_exec_combo.combobox.lineEdit()\numr_group = QGroupBox(_('User Module Reloader (UMR)'))\numr_label = QLabel(_(\n    'UMR forces Python to reload modules which were imported when executing a file in a Python or IPython console with the <i>runfile</i> function.'\n    ))\numr_label.setWordWrap(True)\numr_enabled_box = newcb(_('Enable UMR'), 'umr/enabled', msg_if_enabled=True,\n    msg_warning=_(\n    \"This option will enable the User Module Reloader (UMR) in Python/IPython consoles. UMR forces Python to reload deeply modules during import when running a Python script using the Spyder's builtin function <b>runfile</b>.<br><br><b>1.</b> UMR may require to restart the console in which it will be called (otherwise only newly imported modules will be reloaded when executing files).<br><br><b>2.</b> If errors occur when re-running a PyQt-based program, please check that the Qt objects are properly destroyed (e.g. you may have to use the attribute <b>Qt.WA_DeleteOnClose</b> on your main window, using the <b>setAttribute</b> method)\"\n    ))\numr_verbose_box = newcb(_('Show reloaded modules list'), 'umr/verbose',\n    msg_info=_(\n    'Please note that these changes will be applied only to new consoles'))\numr_namelist_btn = QPushButton(_('Set UMR excluded (not reloaded) modules'))\numr_namelist_btn.clicked.connect(self.set_umr_namelist)\numr_layout = QVBoxLayout()\numr_layout.addWidget(umr_label)\numr_layout.addWidget(umr_enabled_box)\numr_layout.addWidget(umr_verbose_box)\numr_layout.addWidget(umr_namelist_btn)\numr_group.setLayout(umr_layout)\nvlayout = QVBoxLayout()\nvlayout.addWidget(pyexec_group)\nvlayout.addWidget(umr_group)\nvlayout.addStretch(1)\nself.setLayout(vlayout)\n",
        "CUT_4": "newcb = self.create_checkbox\npyexec_group = QGroupBox(_('Python interpreter'))\npyexec_bg = QButtonGroup(pyexec_group)\npyexec_label = QLabel(_(\n    'Select the Python interpreter for all Spyder consoles'))\nself.def_exec_radio = self.create_radiobutton(_(\n    \"Default (i.e. the same as Spyder's)\"), 'default', button_group=pyexec_bg)\nself.cus_exec_radio = self.create_radiobutton(_(\n    'Use the following Python interpreter:'), 'custom', button_group=pyexec_bg)\nif os.name == 'nt':\n    filters = _('Executables') + ' (*.exe)'\nelse:\n    filters = None\npyexec_layout = QVBoxLayout()\npyexec_layout.addWidget(pyexec_label)\npyexec_layout.addWidget(self.def_exec_radio)\npyexec_layout.addWidget(self.cus_exec_radio)\nself.validate_custom_interpreters_list()\nself.cus_exec_combo = self.create_file_combobox(_(\n    'Recent custom interpreters'), self.get_option(\n    'custom_interpreters_list'), 'custom_interpreter', filters=filters,\n    default_line_edit=True, adjust_to_contents=True, validate_callback=\n    programs.is_python_interpreter)\nself.def_exec_radio.toggled.connect(self.cus_exec_combo.setDisabled)\nself.cus_exec_radio.toggled.connect(self.cus_exec_combo.setEnabled)\npyexec_layout.addWidget(self.cus_exec_combo)\npyexec_group.setLayout(pyexec_layout)\nself.pyexec_edit = self.cus_exec_combo.combobox.lineEdit()\numr_group = QGroupBox(_('User Module Reloader (UMR)'))\numr_label = QLabel(_(\n    'UMR forces Python to reload modules which were imported when executing a file in a Python or IPython console with the <i>runfile</i> function.'\n    ))\numr_label.setWordWrap(True)\numr_enabled_box = newcb(_('Enable UMR'), 'umr/enabled', msg_if_enabled=True,\n    msg_warning=_(\n    \"This option will enable the User Module Reloader (UMR) in Python/IPython consoles. UMR forces Python to reload deeply modules during import when running a Python script using the Spyder's builtin function <b>runfile</b>.<br><br><b>1.</b> UMR may require to restart the console in which it will be called (otherwise only newly imported modules will be reloaded when executing files).<br><br><b>2.</b> If errors occur when re-running a PyQt-based program, please check that the Qt objects are properly destroyed (e.g. you may have to use the attribute <b>Qt.WA_DeleteOnClose</b> on your main window, using the <b>setAttribute</b> method)\"\n    ))\numr_verbose_box = newcb(_('Show reloaded modules list'), 'umr/verbose',\n    msg_info=_(\n    'Please note that these changes will be applied only to new consoles'))\numr_namelist_btn = QPushButton(_('Set UMR excluded (not reloaded) modules'))\numr_namelist_btn.clicked.connect(self.set_umr_namelist)\numr_layout = QVBoxLayout()\numr_layout.addWidget(umr_label)\numr_layout.addWidget(umr_enabled_box)\numr_layout.addWidget(umr_verbose_box)\numr_layout.addWidget(umr_namelist_btn)\numr_group.setLayout(umr_layout)\nvlayout = QVBoxLayout()\nvlayout.addWidget(pyexec_group)\nvlayout.addWidget(umr_group)\nvlayout.addStretch(1)\nself.setLayout(vlayout)\n",
        "CUT_5": "\"\"\"Decide if a module is reloadable or not.\"\"\"\nif self.has_cython:\n    return False\nelif path_is_library(getattr(module, '__file__', None), self.pathlist\n    ) or self.is_module_in_namelist(modname):\n    return False\nelse:\n    return True\n"
    },
    {
        "functionName": "test_umr_reload_modules",
        "className": null,
        "fileName": "/external-deps/spyder-kernels/spyder_kernels/customize/tests/test_umr.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that the UMR only tries to reload user modules.\"\"\"\nuser_module('foo3')\numr = UserModuleReloader()\nimport xml\nassert not umr.is_module_reloadable(xml, 'xml')\nimport numpy\nassert not umr.is_module_reloadable(numpy, 'numpy')\nimport foo3\nassert umr.is_module_reloadable(foo3, 'foo3')\n",
        "CUT_1": "\"\"\"Set UMR excluded modules name list\"\"\"\narguments, valid = QInputDialog.getText(self, _('UMR'), _(\n    'Set the list of excluded modules as this: <i>numpy, scipy</i>'),\n    QLineEdit.Normal, ', '.join(self.get_option('umr/namelist')))\nif valid:\n    arguments = to_text_string(arguments)\n    if arguments:\n        namelist = arguments.replace(' ', '').split(',')\n        fixed_namelist = []\n        non_ascii_namelist = []\n        for module_name in namelist:\n            if PY2:\n                if all(ord(c) < 128 for c in module_name):\n                    if programs.is_module_installed(module_name):\n                        fixed_namelist.append(module_name)\n                else:\n                    QMessageBox.warning(self, _('Warning'), _(\n                        'You are working with Python 2, this means that you can not import a module that contains non-ascii characters.'\n                        ), QMessageBox.Ok)\n                    non_ascii_namelist.append(module_name)\n            elif programs.is_module_installed(module_name):\n                fixed_namelist.append(module_name)\n        invalid = ', '.join(set(namelist) - set(fixed_namelist) - set(\n            non_ascii_namelist))\n        if invalid:\n            QMessageBox.warning(self, _('UMR'), _(\n                \"\"\"The following modules are not installed on your machine:\n%s\"\"\"\n                ) % invalid, QMessageBox.Ok)\n        QMessageBox.information(self, _('UMR'), _(\n            'Please note that these changes will be applied only to new Python/IPython consoles'\n            ), QMessageBox.Ok)\n    else:\n        fixed_namelist = []\n    self.set_option('umr/namelist', fixed_namelist)\n",
        "CUT_2": "\"\"\"Set UMR excluded modules name list\"\"\"\narguments, valid = QInputDialog.getText(self, _('UMR'), _(\n    'Set the list of excluded modules as this: <i>numpy, scipy</i>'),\n    QLineEdit.Normal, ', '.join(self.get_option('umr/namelist')))\nif valid:\n    arguments = to_text_string(arguments)\n    if arguments:\n        namelist = arguments.replace(' ', '').split(',')\n        fixed_namelist = []\n        non_ascii_namelist = []\n        for module_name in namelist:\n            if PY2:\n                if all(ord(c) < 128 for c in module_name):\n                    if programs.is_module_installed(module_name):\n                        fixed_namelist.append(module_name)\n                else:\n                    QMessageBox.warning(self, _('Warning'), _(\n                        'You are working with Python 2, this means that you can not import a module that contains non-ascii characters.'\n                        ), QMessageBox.Ok)\n                    non_ascii_namelist.append(module_name)\n            elif programs.is_module_installed(module_name):\n                fixed_namelist.append(module_name)\n        invalid = ', '.join(set(namelist) - set(fixed_namelist) - set(\n            non_ascii_namelist))\n        if invalid:\n            QMessageBox.warning(self, _('UMR'), _(\n                \"\"\"The following modules are not installed on your machine:\n%s\"\"\"\n                ) % invalid, QMessageBox.Ok)\n        QMessageBox.information(self, _('UMR'), _(\n            'Please note that these changes will be applied only to new Python/IPython consoles'\n            ), QMessageBox.Ok)\n    else:\n        fixed_namelist = []\n    self.set_option('umr/namelist', fixed_namelist)\n",
        "CUT_3": "newcb = self.create_checkbox\npyexec_group = QGroupBox(_('Python interpreter'))\npyexec_bg = QButtonGroup(pyexec_group)\npyexec_label = QLabel(_(\n    'Select the Python interpreter for all Spyder consoles'))\nself.def_exec_radio = self.create_radiobutton(_(\n    \"Default (i.e. the same as Spyder's)\"), 'default', button_group=pyexec_bg)\nself.cus_exec_radio = self.create_radiobutton(_(\n    'Use the following Python interpreter:'), 'custom', button_group=pyexec_bg)\nif os.name == 'nt':\n    filters = _('Executables') + ' (*.exe)'\nelse:\n    filters = None\npyexec_layout = QVBoxLayout()\npyexec_layout.addWidget(pyexec_label)\npyexec_layout.addWidget(self.def_exec_radio)\npyexec_layout.addWidget(self.cus_exec_radio)\nself.validate_custom_interpreters_list()\nself.cus_exec_combo = self.create_file_combobox(_(\n    'Recent custom interpreters'), self.get_option(\n    'custom_interpreters_list'), 'custom_interpreter', filters=filters,\n    default_line_edit=True, adjust_to_contents=True, validate_callback=\n    programs.is_python_interpreter)\nself.def_exec_radio.toggled.connect(self.cus_exec_combo.setDisabled)\nself.cus_exec_radio.toggled.connect(self.cus_exec_combo.setEnabled)\npyexec_layout.addWidget(self.cus_exec_combo)\npyexec_group.setLayout(pyexec_layout)\nself.pyexec_edit = self.cus_exec_combo.combobox.lineEdit()\numr_group = QGroupBox(_('User Module Reloader (UMR)'))\numr_label = QLabel(_(\n    'UMR forces Python to reload modules which were imported when executing a file in a Python or IPython console with the <i>runfile</i> function.'\n    ))\numr_label.setWordWrap(True)\numr_enabled_box = newcb(_('Enable UMR'), 'umr/enabled', msg_if_enabled=True,\n    msg_warning=_(\n    \"This option will enable the User Module Reloader (UMR) in Python/IPython consoles. UMR forces Python to reload deeply modules during import when running a Python script using the Spyder's builtin function <b>runfile</b>.<br><br><b>1.</b> UMR may require to restart the console in which it will be called (otherwise only newly imported modules will be reloaded when executing files).<br><br><b>2.</b> If errors occur when re-running a PyQt-based program, please check that the Qt objects are properly destroyed (e.g. you may have to use the attribute <b>Qt.WA_DeleteOnClose</b> on your main window, using the <b>setAttribute</b> method)\"\n    ))\numr_verbose_box = newcb(_('Show reloaded modules list'), 'umr/verbose',\n    msg_info=_(\n    'Please note that these changes will be applied only to new consoles'))\numr_namelist_btn = QPushButton(_('Set UMR excluded (not reloaded) modules'))\numr_namelist_btn.clicked.connect(self.set_umr_namelist)\numr_layout = QVBoxLayout()\numr_layout.addWidget(umr_label)\numr_layout.addWidget(umr_enabled_box)\numr_layout.addWidget(umr_verbose_box)\numr_layout.addWidget(umr_namelist_btn)\numr_group.setLayout(umr_layout)\nvlayout = QVBoxLayout()\nvlayout.addWidget(pyexec_group)\nvlayout.addWidget(umr_group)\nvlayout.addStretch(1)\nself.setLayout(vlayout)\n",
        "CUT_4": "newcb = self.create_checkbox\npyexec_group = QGroupBox(_('Python interpreter'))\npyexec_bg = QButtonGroup(pyexec_group)\npyexec_label = QLabel(_(\n    'Select the Python interpreter for all Spyder consoles'))\nself.def_exec_radio = self.create_radiobutton(_(\n    \"Default (i.e. the same as Spyder's)\"), 'default', button_group=pyexec_bg)\nself.cus_exec_radio = self.create_radiobutton(_(\n    'Use the following Python interpreter:'), 'custom', button_group=pyexec_bg)\nif os.name == 'nt':\n    filters = _('Executables') + ' (*.exe)'\nelse:\n    filters = None\npyexec_layout = QVBoxLayout()\npyexec_layout.addWidget(pyexec_label)\npyexec_layout.addWidget(self.def_exec_radio)\npyexec_layout.addWidget(self.cus_exec_radio)\nself.validate_custom_interpreters_list()\nself.cus_exec_combo = self.create_file_combobox(_(\n    'Recent custom interpreters'), self.get_option(\n    'custom_interpreters_list'), 'custom_interpreter', filters=filters,\n    default_line_edit=True, adjust_to_contents=True, validate_callback=\n    programs.is_python_interpreter)\nself.def_exec_radio.toggled.connect(self.cus_exec_combo.setDisabled)\nself.cus_exec_radio.toggled.connect(self.cus_exec_combo.setEnabled)\npyexec_layout.addWidget(self.cus_exec_combo)\npyexec_group.setLayout(pyexec_layout)\nself.pyexec_edit = self.cus_exec_combo.combobox.lineEdit()\numr_group = QGroupBox(_('User Module Reloader (UMR)'))\numr_label = QLabel(_(\n    'UMR forces Python to reload modules which were imported when executing a file in a Python or IPython console with the <i>runfile</i> function.'\n    ))\numr_label.setWordWrap(True)\numr_enabled_box = newcb(_('Enable UMR'), 'umr/enabled', msg_if_enabled=True,\n    msg_warning=_(\n    \"This option will enable the User Module Reloader (UMR) in Python/IPython consoles. UMR forces Python to reload deeply modules during import when running a Python script using the Spyder's builtin function <b>runfile</b>.<br><br><b>1.</b> UMR may require to restart the console in which it will be called (otherwise only newly imported modules will be reloaded when executing files).<br><br><b>2.</b> If errors occur when re-running a PyQt-based program, please check that the Qt objects are properly destroyed (e.g. you may have to use the attribute <b>Qt.WA_DeleteOnClose</b> on your main window, using the <b>setAttribute</b> method)\"\n    ))\numr_verbose_box = newcb(_('Show reloaded modules list'), 'umr/verbose',\n    msg_info=_(\n    'Please note that these changes will be applied only to new consoles'))\numr_namelist_btn = QPushButton(_('Set UMR excluded (not reloaded) modules'))\numr_namelist_btn.clicked.connect(self.set_umr_namelist)\numr_layout = QVBoxLayout()\numr_layout.addWidget(umr_label)\numr_layout.addWidget(umr_enabled_box)\numr_layout.addWidget(umr_verbose_box)\numr_layout.addWidget(umr_namelist_btn)\numr_group.setLayout(umr_layout)\nvlayout = QVBoxLayout()\nvlayout.addWidget(pyexec_group)\nvlayout.addWidget(umr_group)\nvlayout.addStretch(1)\nself.setLayout(vlayout)\n",
        "CUT_5": "\"\"\"Return True if variable is a NumPy array\"\"\"\ntry:\n    import numpy\n    return isinstance(var, numpy.ndarray)\nexcept:\n    return False\n"
    },
    {
        "functionName": "test_debounce",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_utils.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "interval = 0.1\nobj = mock.Mock()\n@_utils.debounce(0.1)\ndef call_m():\n    obj()\nassert not obj.mock_calls\ncall_m()\ncall_m()\ncall_m()\nassert not obj.mock_calls\ntime.sleep(interval * 2)\nassert len(obj.mock_calls) == 1\ncall_m()\ntime.sleep(interval * 2)\nassert len(obj.mock_calls) == 2\n",
        "CUT_1": "if isinstance(obj, dict):\n    return obj\nd = dict()\nfor k in dir(obj):\n    if not k.startswith('_'):\n        d[k] = getattr(obj, k)\nreturn d\n",
        "CUT_2": "if isinstance(obj, dict):\n    return obj\nd = dict()\nfor k in dir(obj):\n    if not k.startswith('_'):\n        d[k] = getattr(obj, k)\nreturn d\n",
        "CUT_3": "\"\"\"Convert `obj` to (unicode) text string\"\"\"\nif PY2:\n    if isinstance(obj, unicode):\n        return obj\n    if encoding is None:\n        return unicode(obj)\n    else:\n        return unicode(obj, encoding)\nelif encoding is None:\n    return str(obj)\nelif isinstance(obj, str):\n    return obj\nelse:\n    return str(obj, encoding)\n",
        "CUT_4": "\"\"\"Convert `obj` to (unicode) text string\"\"\"\nif PY2:\n    if isinstance(obj, unicode):\n        return obj\n    if encoding is None:\n        return unicode(obj)\n    else:\n        return unicode(obj, encoding)\nelif encoding is None:\n    return str(obj)\nelif isinstance(obj, str):\n    return obj\nelse:\n    return str(obj, encoding)\n",
        "CUT_5": "\"\"\"\n    Encode object as json str.\n    \"\"\"\ndef _dump_obj(obj):\n    if isinstance(obj, dict):\n        return obj\n    d = dict()\n    for k in dir(obj):\n        if not k.startswith('_'):\n            d[k] = getattr(obj, k)\n    return d\nreturn json.dumps(obj, default=_dump_obj)\n"
    },
    {
        "functionName": "call_m",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_utils.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "obj()\n_utils.debounce(0.1)",
        "CUT_1": "if isinstance(obj, dict):\n    return obj\nd = dict()\nfor k in dir(obj):\n    if not k.startswith('_'):\n        d[k] = getattr(obj, k)\nreturn d\n",
        "CUT_2": "if isinstance(obj, dict):\n    return obj\nd = dict()\nfor k in dir(obj):\n    if not k.startswith('_'):\n        d[k] = getattr(obj, k)\nreturn d\n",
        "CUT_3": "\"\"\"Convert `obj` to (unicode) text string\"\"\"\nif PY2:\n    if isinstance(obj, unicode):\n        return obj\n    if encoding is None:\n        return unicode(obj)\n    else:\n        return unicode(obj, encoding)\nelif encoding is None:\n    return str(obj)\nelif isinstance(obj, str):\n    return obj\nelse:\n    return str(obj, encoding)\n",
        "CUT_4": "\"\"\"Convert `obj` to (unicode) text string\"\"\"\nif PY2:\n    if isinstance(obj, unicode):\n        return obj\n    if encoding is None:\n        return unicode(obj)\n    else:\n        return unicode(obj, encoding)\nelif encoding is None:\n    return str(obj)\nelif isinstance(obj, str):\n    return obj\nelse:\n    return str(obj, encoding)\n",
        "CUT_5": "\"\"\"Qt/Python2/3 compatibility helper.\"\"\"\nif isinstance(obj, QByteArray):\n    obj = obj.data()\nreturn to_text_string(obj, encoding=encoding)\n"
    },
    {
        "functionName": "test_debounce_keyed_by",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_utils.py",
        "projectName": "spyder",
        "Label": 1,
        "isTest": true,
        "Body": "interval = 0.1\nobj = mock.Mock()\n@_utils.debounce(0.1, keyed_by='key')\ndef call_m(key):\n    obj(key)\nassert not obj.mock_calls\ncall_m(1)\ncall_m(2)\ncall_m(3)\nassert not obj.mock_calls\ntime.sleep(interval * 2)\nobj.assert_has_calls([mock.call(1), mock.call(2), mock.call(3)], any_order=True\n    )\nassert len(obj.mock_calls) == 3\ncall_m(1)\ncall_m(1)\ncall_m(1)\ntime.sleep(interval * 2)\nassert len(obj.mock_calls) == 4\n",
        "CUT_1": "return Mock()\n",
        "CUT_2": "if isinstance(obj, dict):\n    return obj\nd = dict()\nfor k in dir(obj):\n    if not k.startswith('_'):\n        d[k] = getattr(obj, k)\nreturn d\n",
        "CUT_3": "if isinstance(obj, dict):\n    return obj\nd = dict()\nfor k in dir(obj):\n    if not k.startswith('_'):\n        d[k] = getattr(obj, k)\nreturn d\n",
        "CUT_4": "\"\"\"Convert `obj` to (unicode) text string\"\"\"\nif PY2:\n    if isinstance(obj, unicode):\n        return obj\n    if encoding is None:\n        return unicode(obj)\n    else:\n        return unicode(obj, encoding)\nelif encoding is None:\n    return str(obj)\nelif isinstance(obj, str):\n    return obj\nelse:\n    return str(obj, encoding)\n",
        "CUT_5": "\"\"\"Convert `obj` to (unicode) text string\"\"\"\nif PY2:\n    if isinstance(obj, unicode):\n        return obj\n    if encoding is None:\n        return unicode(obj)\n    else:\n        return unicode(obj, encoding)\nelif encoding is None:\n    return str(obj)\nelif isinstance(obj, str):\n    return obj\nelse:\n    return str(obj, encoding)\n"
    },
    {
        "functionName": "test_list_to_string",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_utils.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert _utils.list_to_string('string') == 'string'\nassert _utils.list_to_string(['a', 'r', 'r', 'a', 'y']) == 'a,r,r,a,y'\n",
        "CUT_1": "return str(string)\n",
        "CUT_2": "return str(string)\n",
        "CUT_3": "\"\"\"\n    Return a unicode version of string decoded using the file system encoding.\n    \"\"\"\nif not is_string(string):\n    string = to_text_string(string.toUtf8(), 'utf-8')\nelif is_binary_string(string):\n    try:\n        unic = string.decode(FS_ENCODING)\n    except (UnicodeError, TypeError):\n        pass\n    else:\n        return unic\nreturn string\n",
        "CUT_4": "\"\"\"\n    Return a unicode version of string decoded using the file system encoding.\n    \"\"\"\nif not is_string(string):\n    string = to_text_string(string.toUtf8(), 'utf-8')\nelif is_binary_string(string):\n    try:\n        unic = string.decode(FS_ENCODING)\n    except (UnicodeError, TypeError):\n        pass\n    else:\n        return unic\nreturn string\n",
        "CUT_5": "root_path = uris.to_fs_path(self._root_uri)\nreturn _utils.find_parents(root_path, path, names)\n"
    },
    {
        "functionName": "test_find_parents",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_utils.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "subsubdir = tmpdir.ensure_dir('subdir', 'subsubdir')\npath = subsubdir.ensure('path.py')\ntest_cfg = tmpdir.ensure('test.cfg')\nassert _utils.find_parents(tmpdir.strpath, path.strpath, ['test.cfg']) == [\n    test_cfg.strpath]\n",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\ncfg = VersioneerConfig()\ncfg.VCS = 'git'\ncfg.style = 'pep440'\ncfg.tag_prefix = ''\ncfg.parentdir_prefix = ''\ncfg.versionfile_source = 'pyls/_version.py'\ncfg.verbose = False\nreturn cfg\n",
        "CUT_3": "ini_contents = \"\"\"[main]\nversion = 50.0.0\n\n\"\"\"\nif PY2:\n    ini_contents += \"[section]\\noption = 'value'\"\nelse:\n    ini_contents += '[section]\\noption = value'\nname = 'spyder'\npath = str(tmpdir)\ndef temp(*args, **kwargs):\n    return path\nmocker.patch('spyder.config.base', 'get_conf_path')\ninifile = tmpdir.join('{}.ini'.format(name))\nos.makedirs(str(tmpdir.join('app', 'config')))\ninifile2 = tmpdir.join('app', 'config', '{}.ini'.format(name))\ninifile.write(ini_contents + '\\n\\n')\ninifile2.write(ini_contents + '\\n\\n')\nreturn SpyderUserConfig(name=name, path=path, defaults={}, load=True,\n    version='50.0.0', backup=False, raw_mode=True, remove_obsolete=False)\npytest.fixture",
        "CUT_4": "return path\n",
        "CUT_5": "\"\"\"\n        Remove stderr files left by previous Spyder instances.\n\n        This is only required on Windows because we can't\n        clean up stderr files while Spyder is running on it.\n        \"\"\"\nif os.name == 'nt':\n    tmpdir = get_temp_dir()\n    for fname in os.listdir(tmpdir):\n        if osp.splitext(fname)[1] == '.stderr':\n            try:\n                os.remove(osp.join(tmpdir, fname))\n            except Exception:\n                pass\n"
    },
    {
        "functionName": "test_merge_dicts",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_utils.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert _utils.merge_dicts({'a': True, 'b': {'x': 123, 'y': {'hello':\n    'world'}}}, {'a': False, 'b': {'y': [], 'z': 987}}) == {'a': False, 'b':\n    {'x': 123, 'y': [], 'z': 987}}\n",
        "CUT_1": "\"\"\"Init Pdb.\"\"\"\nself.curframe_locals = None\nself.continue_if_has_breakpoints = False\nself.pdb_ignore_lib = False\nself.pdb_execute_events = False\nself.pdb_use_exclamation_mark = False\nself._exclamation_warning_printed = False\nself.pdb_stop_first_line = True\nself._disable_next_stack_entry = False\nsuper(SpyderPdb, self).__init__()\nself._pdb_breaking = False\nself._frontend_notified = False\n",
        "CUT_2": "\"\"\"Settings are constructed from a few sources:\n\n            1. User settings, found in user's home directory\n            2. Plugin settings, reported by PyLS plugins\n            3. LSP settings, given to us from didChangeConfiguration\n            4. Project settings, found in config files in the current project.\n\n        Since this function is nondeterministic, it is important to call\n        settings.cache_clear() when the config is updated\n        \"\"\"\nsettings = {}\nsources = self._settings.get('configurationSources', DEFAULT_CONFIG_SOURCES)\nsettings = _utils.merge_dicts(settings, self._plugin_settings)\nsettings = _utils.merge_dicts(settings, self._settings)\nfor source_name in reversed(sources):\n    source = self._config_sources.get(source_name)\n    if not source:\n        continue\n    source_conf = source.user_config()\n    log.debug('Got user config from %s: %s', source.__class__.__name__,\n        source_conf)\n    settings = _utils.merge_dicts(settings, source_conf)\nfor source_name in reversed(sources):\n    source = self._config_sources.get(source_name)\n    if not source:\n        continue\n    source_conf = source.project_config(document_path or self._root_path)\n    log.debug('Got project config from %s: %s', source.__class__.__name__,\n        source_conf)\n    settings = _utils.merge_dicts(settings, source_conf)\nlog.debug('With configuration: %s', settings)\nreturn settings\nlru_cache(maxsize=32)",
        "CUT_3": "return False\nproperty",
        "CUT_4": "return False\nproperty",
        "CUT_5": "\"\"\"Find previous occurrence\"\"\"\nstate = self.find(changed=False, forward=False, rehighlight=False,\n    multiline_replace_check=False)\nif set_focus:\n    self.editor.setFocus()\nreturn state\nSlot()"
    },
    {
        "functionName": "test_clip_column",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_utils.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert _utils.clip_column(0, [], 0) == 0\nassert _utils.clip_column(2, ['123'], 0) == 2\nassert _utils.clip_column(3, ['123'], 0) == 3\nassert _utils.clip_column(5, ['123'], 0) == 3\nassert _utils.clip_column(0, ['\\n', '123'], 0) == 0\nassert _utils.clip_column(1, ['\\n', '123'], 0) == 0\nassert _utils.clip_column(2, ['123\\n', '123'], 0) == 2\nassert _utils.clip_column(3, ['123\\n', '123'], 0) == 3\nassert _utils.clip_column(4, ['123\\n', '123'], 1) == 3\n",
        "CUT_1": "root_path = uris.to_fs_path(self._root_uri)\nreturn _utils.find_parents(root_path, path, names)\n",
        "CUT_2": "workspace_uri = _utils.match_uri_to_workspace(uri, self.workspaces)\nreturn self.workspaces.get(workspace_uri, self.workspace)\n",
        "CUT_3": "\"\"\"\n    Convert the LSP format 'line', 'character' to Jedi's 'line', 'column'\n\n    https://microsoft.github.io/language-server-protocol/specification#position\n    \"\"\"\ncode_position = {}\nif position:\n    code_position = {'line': position['line'] + 1, 'column': clip_column(\n        position['character'], document.lines, position['line'])}\nreturn code_position\n",
        "CUT_4": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n",
        "CUT_5": "\"\"\"\n    Run Python script in a separate process\n    package=None -> module is in sys.path (standard library modules)\n    \"\"\"\nassert module is not None\nassert isinstance(args, (tuple, list)) and isinstance(p_args, (tuple, list))\npath = python_script_exists(package, module)\nrun_program(sys.executable, p_args + [path] + args)\n"
    },
    {
        "functionName": "path_as_uri",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return pathlib.Path(os.path.abspath(path)).as_uri()\n",
        "CUT_1": "return path\n",
        "CUT_2": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_3": "if path.startswith('file://'):\n    if os.name == 'nt':\n        if path.startswith('file:///'):\n            path = path[8:]\n        else:\n            path = path[5:]\n    else:\n        path = path[7:]\npath = path.replace('\\\\', os.sep)\nif osp.exists(path):\n    if extlist is None or osp.splitext(path)[1] in extlist:\n        return path\n",
        "CUT_4": "netloc = ''\nif IS_WIN:\n    path = path.replace('\\\\', '/')\nif path[:2] == '//':\n    idx = path.index('/', 2)\n    if idx == -1:\n        netloc = path[2:]\n    else:\n        netloc = path[2:idx]\n        path = path[idx:]\nelse:\n    path = path\nif not path.startswith('/'):\n    path = '/' + path\nif RE_DRIVE_LETTER_PATH.match(path):\n    path = path[0] + path[1].lower() + path[2:]\nreturn path, netloc\n",
        "CUT_5": "\"\"\"Normalize windows path and remove extra quotes.\"\"\"\npath = path.replace('\\\\', '/').lower()\nif path[0] == '\"' and path[-1] == '\"':\n    path = literal_eval(path)\nreturn path\n"
    },
    {
        "functionName": "test_local",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\" Since the workspace points to the test directory \"\"\"\nassert pyls.workspace.is_local()\n",
        "CUT_1": "\"\"\"Return project-level (i.e. workspace directory) configuration.\"\"\"\nraise NotImplementedError()\n",
        "CUT_2": "self.config.update((settings or {}).get('pyls', {}))\nfor workspace_uri in self.workspaces:\n    workspace = self.workspaces[workspace_uri]\n    workspace.update_config(settings)\n    for doc_uri in workspace.documents:\n        self.lint(doc_uri, is_saved=False)\n",
        "CUT_3": "workspace = self._match_uri_to_workspace(textDocument['uri'])\nworkspace.rm_document(textDocument['uri'])\n",
        "CUT_4": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_5": "\"\"\"Disable LSP workspace functionality.\"\"\"\nself.completions_available = False\n"
    },
    {
        "functionName": "test_put_document",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "pyls.workspace.put_document(DOC_URI, 'content')\nassert DOC_URI in pyls.workspace._docs\n",
        "CUT_1": "workspace = self._match_uri_to_workspace(doc_uri)\nif doc_uri in workspace.documents:\n    workspace.publish_diagnostics(doc_uri, flatten(self._hook('pyls_lint',\n        doc_uri, is_saved=is_saved)))\n_utils.debounce(LINT_DEBOUNCE_S, keyed_by='doc_uri')",
        "CUT_2": "return self._docs.get(doc_uri)\n",
        "CUT_3": "self._docs.pop(doc_uri)\n",
        "CUT_4": "self.config.update((settings or {}).get('pyls', {}))\nfor workspace_uri in self.workspaces:\n    workspace = self.workspaces[workspace_uri]\n    workspace.update_config(settings)\n    for doc_uri in workspace.documents:\n        self.lint(doc_uri, is_saved=False)\n",
        "CUT_5": "self._docs[doc_uri].apply_change(change)\nself._docs[doc_uri].version = version\n"
    },
    {
        "functionName": "test_get_document",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "pyls.workspace.put_document(DOC_URI, 'TEXT')\nassert pyls.workspace.get_document(DOC_URI).source == 'TEXT'\n",
        "CUT_1": "workspace = self._match_uri_to_workspace(doc_uri)\nif doc_uri in workspace.documents:\n    workspace.publish_diagnostics(doc_uri, flatten(self._hook('pyls_lint',\n        doc_uri, is_saved=is_saved)))\n_utils.debounce(LINT_DEBOUNCE_S, keyed_by='doc_uri')",
        "CUT_2": "self._config.update((settings or {}).get('pyls', {}))\nfor doc_uri in self.documents:\n    self.get_document(doc_uri).update_config(settings)\n",
        "CUT_3": "self.config.update((settings or {}).get('pyls', {}))\nfor workspace_uri in self.workspaces:\n    workspace = self.workspaces[workspace_uri]\n    workspace.update_config(settings)\n    for doc_uri in workspace.documents:\n        self.lint(doc_uri, is_saved=False)\n",
        "CUT_4": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_5": "return Document(DOC_URI, workspace, DOC)\npytest.fixture"
    },
    {
        "functionName": "test_get_missing_document",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "source = 'TEXT'\ndoc_path = tmpdir.join('test_document.py')\ndoc_path.write(source)\ndoc_uri = uris.from_fs_path(str(doc_path))\nassert pyls.workspace.get_document(doc_uri).source == 'TEXT'\n",
        "CUT_1": "\"\"\"\n    Return Python documentation path\n    (Windows: return the PythonXX.chm path if available)\n    \"\"\"\nif os.name == 'nt':\n    doc_path = osp.join(sys.prefix, 'Doc')\n    if not osp.isdir(doc_path):\n        return\n    python_chm = [path for path in os.listdir(doc_path) if re.match(\n        '(?i)Python[0-9]{3,6}.chm', path)]\n    if python_chm:\n        return file_uri(osp.join(doc_path, python_chm[0]))\nelse:\n    vinf = sys.version_info\n    doc_path = '/usr/share/doc/python%d.%d/html' % (vinf[0], vinf[1])\npython_doc = osp.join(doc_path, 'index.html')\nif osp.isfile(python_doc):\n    return file_uri(python_doc)\n",
        "CUT_2": "\"\"\"\n    Return Python documentation path\n    (Windows: return the PythonXX.chm path if available)\n    \"\"\"\nif os.name == 'nt':\n    doc_path = osp.join(sys.prefix, 'Doc')\n    if not osp.isdir(doc_path):\n        return\n    python_chm = [path for path in os.listdir(doc_path) if re.match(\n        '(?i)Python[0-9]{3,6}.chm', path)]\n    if python_chm:\n        return file_uri(osp.join(doc_path, python_chm[0]))\nelse:\n    vinf = sys.version_info\n    doc_path = '/usr/share/doc/python%d.%d/html' % (vinf[0], vinf[1])\npython_doc = osp.join(doc_path, 'index.html')\nif osp.isfile(python_doc):\n    return file_uri(python_doc)\n",
        "CUT_3": "self._docs[doc_uri] = self._create_document(doc_uri, source=source, version\n    =version)\n",
        "CUT_4": "path = uris.to_fs_path(doc_uri)\nreturn Document(doc_uri, self, source=source, version=version,\n    extra_sys_path=self.source_roots(path), rope_project_builder=self.\n    _rope_project_builder)\n",
        "CUT_5": "self._config.update((settings or {}).get('pyls', {}))\nfor doc_uri in self.documents:\n    self.get_document(doc_uri).update_config(settings)\n"
    },
    {
        "functionName": "test_rm_document",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "pyls.workspace.put_document(DOC_URI, 'TEXT')\nassert pyls.workspace.get_document(DOC_URI).source == 'TEXT'\npyls.workspace.rm_document(DOC_URI)\nassert pyls.workspace.get_document(DOC_URI)._source is None\n",
        "CUT_1": "workspace = self._match_uri_to_workspace(doc_uri)\nif doc_uri in workspace.documents:\n    workspace.publish_diagnostics(doc_uri, flatten(self._hook('pyls_lint',\n        doc_uri, is_saved=is_saved)))\n_utils.debounce(LINT_DEBOUNCE_S, keyed_by='doc_uri')",
        "CUT_2": "self._config.update((settings or {}).get('pyls', {}))\nfor doc_uri in self.documents:\n    self.get_document(doc_uri).update_config(settings)\n",
        "CUT_3": "self.config.update((settings or {}).get('pyls', {}))\nfor workspace_uri in self.workspaces:\n    workspace = self.workspaces[workspace_uri]\n    workspace.update_config(settings)\n    for doc_uri in workspace.documents:\n        self.lint(doc_uri, is_saved=False)\n",
        "CUT_4": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_5": "return Document(DOC_URI, workspace, DOC)\npytest.fixture"
    },
    {
        "functionName": "test_non_root_project",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "repo_root = os.path.join(pyls.workspace.root_path, 'repo-root')\nos.mkdir(repo_root)\nproject_root = os.path.join(repo_root, 'project-root')\nos.mkdir(project_root)\nfor metafile in metafiles:\n    with open(os.path.join(project_root, metafile), 'w+') as f:\n        f.write('# ' + metafile)\ntest_uri = uris.from_fs_path(os.path.join(project_root, 'hello/test.py'))\npyls.workspace.put_document(test_uri, 'assert True')\ntest_doc = pyls.workspace.get_document(test_uri)\nassert project_root in test_doc.sys_path()\npytest.mark.parametrize('metafiles', [('setup.py',), ('pyproject.toml',), (\n    'setup.py', 'pyproject.toml')])",
        "CUT_1": "\"\"\"Return the project configuration path.\"\"\"\npath = osp.join(project_root, '.spyproj', 'config')\nif not osp.isdir(path):\n    os.makedirs(path)\n",
        "CUT_2": "\"\"\"Return the project configuration path.\"\"\"\npath = osp.join(project_root, '.spyproj', 'config')\nif not osp.isdir(path):\n    os.makedirs(path)\n",
        "CUT_3": "\"\"\"Get the project root directory.\n\n    We require that all commands are run from the project root, i.e. the\n    directory that contains setup.py, setup.cfg, and versioneer.py .\n    \"\"\"\nroot = os.path.realpath(os.path.abspath(os.getcwd()))\nsetup_py = os.path.join(root, 'setup.py')\nversioneer_py = os.path.join(root, 'versioneer.py')\nif not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n    root = os.path.dirname(os.path.realpath(os.path.abspath(sys.argv[0])))\n    setup_py = os.path.join(root, 'setup.py')\n    versioneer_py = os.path.join(root, 'versioneer.py')\nif not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n    err = (\n        \"Versioneer was unable to run the project root directory. Versioneer requires setup.py to be executed from its immediate directory (like 'python setup.py COMMAND'), or in a way that lets it use sys.argv[0] to find the root (like 'python path/to/setup.py COMMAND').\"\n        )\n    raise VersioneerBadRootError(err)\ntry:\n    me = os.path.realpath(os.path.abspath(__file__))\n    me_dir = os.path.normcase(os.path.splitext(me)[0])\n    vsr_dir = os.path.normcase(os.path.splitext(versioneer_py)[0])\n    if me_dir != vsr_dir:\n        print('Warning: build in %s is using versioneer.py from %s' % (os.\n            path.dirname(me), versioneer_py))\nexcept NameError:\n    pass\nreturn root\n",
        "CUT_4": "\"\"\"List directory 'root' appending the path separator to subdirs.\"\"\"\nres = []\nroot = os.path.expanduser(root)\ntry:\n    for name in os.listdir(root):\n        path = os.path.join(root, name)\n        if os.path.isdir(path):\n            name += os.sep\n        res.append(name)\nexcept:\n    pass\nreturn res\n",
        "CUT_5": "\"\"\"List directory 'root' appending the path separator to subdirs.\"\"\"\nres = []\nroot = os.path.expanduser(root)\ntry:\n    for name in os.listdir(root):\n        path = os.path.join(root, name)\n        if os.path.isdir(path):\n            name += os.sep\n        res.append(name)\nexcept:\n    pass\nreturn res\n"
    },
    {
        "functionName": "test_root_project_with_no_setup_py",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Default to workspace root.\"\"\"\nworkspace_root = pyls.workspace.root_path\ntest_uri = uris.from_fs_path(os.path.join(workspace_root, 'hello/test.py'))\npyls.workspace.put_document(test_uri, 'assert True')\ntest_doc = pyls.workspace.get_document(test_uri)\nassert workspace_root in test_doc.sys_path()\n",
        "CUT_1": "fn = os.path.join(workspace.root_path, name)\nwith open(fn, 'w') as f:\n    f.write(content)\nworkspace.put_document(uris.from_fs_path(fn), content)\n",
        "CUT_2": "self.config.update((settings or {}).get('pyls', {}))\nfor workspace_uri in self.workspaces:\n    workspace = self.workspaces[workspace_uri]\n    workspace.update_config(settings)\n    for doc_uri in workspace.documents:\n        self.lint(doc_uri, is_saved=False)\n",
        "CUT_3": "def create_file(name, content):\n    fn = os.path.join(workspace.root_path, name)\n    with open(fn, 'w') as f:\n        f.write(content)\n    workspace.put_document(uris.from_fs_path(fn), content)\nfor name, content in files.items():\n    create_file(name, content)\nreturn workspace\n",
        "CUT_4": "\"\"\"\n    Returns a function that creates a temporary workspace from the files dict.\n    The dict is in the format {\"file_name\": \"file_contents\"}\n    \"\"\"\ndef fn(files):\n\n    def create_file(name, content):\n        fn = os.path.join(workspace.root_path, name)\n        with open(fn, 'w') as f:\n            f.write(content)\n        workspace.put_document(uris.from_fs_path(fn), content)\n    for name, content in files.items():\n        create_file(name, content)\n    return workspace\nreturn fn\npytest.fixture",
        "CUT_5": "workspace = self._match_uri_to_workspace(textDocument['uri'])\nworkspace.rm_document(textDocument['uri'])\n"
    },
    {
        "functionName": "test_multiple_workspaces",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "workspace1_dir = tmpdir.mkdir('workspace1')\nworkspace2_dir = tmpdir.mkdir('workspace2')\nfile1 = workspace1_dir.join('file1.py')\nfile2 = workspace2_dir.join('file1.py')\nfile1.write('import os')\nfile2.write('import sys')\nmsg = {'uri': path_as_uri(str(file1)), 'version': 1, 'text': 'import os'}\npyls.m_text_document__did_open(textDocument=msg)\nassert msg['uri'] in pyls.workspace._docs\nadded_workspaces = [{'uri': path_as_uri(str(x))} for x in (workspace1_dir,\n    workspace2_dir)]\nevent = {'added': added_workspaces, 'removed': []}\npyls.m_workspace__did_change_workspace_folders(event)\nfor workspace in added_workspaces:\n    assert workspace['uri'] in pyls.workspaces\nworkspace1_uri = added_workspaces[0]['uri']\nassert msg['uri'] not in pyls.workspace._docs\nassert msg['uri'] in pyls.workspaces[workspace1_uri]._docs\nmsg = {'uri': path_as_uri(str(file2)), 'version': 1, 'text': 'import sys'}\npyls.m_text_document__did_open(textDocument=msg)\nworkspace2_uri = added_workspaces[1]['uri']\nassert msg['uri'] in pyls.workspaces[workspace2_uri]._docs\nevent = {'added': [], 'removed': [added_workspaces[0]]}\npyls.m_workspace__did_change_workspace_folders(event)\nassert workspace1_uri not in pyls.workspaces\n",
        "CUT_1": "return str(self.uri)\n",
        "CUT_2": "if event is None:\n    return\nadded = event.get('added', [])\nremoved = event.get('removed', [])\nfor removed_info in removed:\n    if 'uri' in removed_info:\n        removed_uri = removed_info['uri']\n        self.workspaces.pop(removed_uri, None)\nfor added_info in added:\n    if 'uri' in added_info:\n        added_uri = added_info['uri']\n        workspace_config = config.Config(added_uri, self.config._init_opts,\n            self.config._process_id, self.config._capabilities)\n        workspace_config.update(self.config._settings)\n        self.workspaces[added_uri] = Workspace(added_uri, self._endpoint,\n            workspace_config)\nroot_workspace_removed = any(removed_info['uri'] == self.root_uri for\n    removed_info in removed)\nworkspace_added = len(added) > 0 and 'uri' in added[0]\nif root_workspace_removed and workspace_added:\n    added_uri = added[0]['uri']\n    self.root_uri = added_uri\n    new_root_workspace = self.workspaces[added_uri]\n    self.config = new_root_workspace._config\n    self.workspace = new_root_workspace\nelif root_workspace_removed:\n    if self.workspaces:\n        log.debug('Root workspace deleted!')\n        available_workspaces = sorted(self.workspaces)\n        first_workspace = available_workspaces[0]\n        new_root_workspace = self.workspaces[first_workspace]\n        self.root_uri = first_workspace\n        self.config = new_root_workspace._config\n        self.workspace = new_root_workspace\ndoc_uris = list(self.workspace._docs.keys())\nfor uri in doc_uris:\n    doc = self.workspace._docs.pop(uri)\n    new_workspace = self._match_uri_to_workspace(uri)\n    new_workspace._docs[uri] = doc\n",
        "CUT_3": "workspace = self._match_uri_to_workspace(textDocument['uri'])\nworkspace.rm_document(textDocument['uri'])\n",
        "CUT_4": "workspace = self._match_uri_to_workspace(textDocument['uri'])\nworkspace.put_document(textDocument['uri'], textDocument['text'], version=\n    textDocument.get('version'))\nself._hook('pyls_document_did_open', textDocument['uri'])\nself.lint(textDocument['uri'], is_saved=True)\n",
        "CUT_5": "workspace = self._match_uri_to_workspace(textDocument['uri'])\nfor change in contentChanges:\n    workspace.update_document(textDocument['uri'], change, version=\n        textDocument.get('version'))\nself.lint(textDocument['uri'], is_saved=False)\n"
    },
    {
        "functionName": "test_multiple_workspaces_wrong_removed_uri",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "workspace = {'uri': str(tmpdir.mkdir('Test123'))}\nevent = {'added': [], 'removed': [workspace]}\npyls.m_workspace__did_change_workspace_folders(event)\nassert workspace['uri'] not in pyls.workspaces\n",
        "CUT_1": "workspace = self._match_uri_to_workspace(textDocument['uri'])\nworkspace.rm_document(textDocument['uri'])\n",
        "CUT_2": "self.config.update((settings or {}).get('pyls', {}))\nfor workspace_uri in self.workspaces:\n    workspace = self.workspaces[workspace_uri]\n    workspace.update_config(settings)\n    for doc_uri in workspace.documents:\n        self.lint(doc_uri, is_saved=False)\n",
        "CUT_3": "if event is None:\n    return\nadded = event.get('added', [])\nremoved = event.get('removed', [])\nfor removed_info in removed:\n    if 'uri' in removed_info:\n        removed_uri = removed_info['uri']\n        self.workspaces.pop(removed_uri, None)\nfor added_info in added:\n    if 'uri' in added_info:\n        added_uri = added_info['uri']\n        workspace_config = config.Config(added_uri, self.config._init_opts,\n            self.config._process_id, self.config._capabilities)\n        workspace_config.update(self.config._settings)\n        self.workspaces[added_uri] = Workspace(added_uri, self._endpoint,\n            workspace_config)\nroot_workspace_removed = any(removed_info['uri'] == self.root_uri for\n    removed_info in removed)\nworkspace_added = len(added) > 0 and 'uri' in added[0]\nif root_workspace_removed and workspace_added:\n    added_uri = added[0]['uri']\n    self.root_uri = added_uri\n    new_root_workspace = self.workspaces[added_uri]\n    self.config = new_root_workspace._config\n    self.workspace = new_root_workspace\nelif root_workspace_removed:\n    if self.workspaces:\n        log.debug('Root workspace deleted!')\n        available_workspaces = sorted(self.workspaces)\n        first_workspace = available_workspaces[0]\n        new_root_workspace = self.workspaces[first_workspace]\n        self.root_uri = first_workspace\n        self.config = new_root_workspace._config\n        self.workspace = new_root_workspace\ndoc_uris = list(self.workspace._docs.keys())\nfor uri in doc_uris:\n    doc = self.workspace._docs.pop(uri)\n    new_workspace = self._match_uri_to_workspace(uri)\n    new_workspace._docs[uri] = doc\n",
        "CUT_4": "return str(self.uri)\n",
        "CUT_5": "workspace_uri = _utils.match_uri_to_workspace(uri, self.workspaces)\nreturn self.workspaces.get(workspace_uri, self.workspace)\n"
    },
    {
        "functionName": "test_root_workspace_changed",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "test_uri = str(tmpdir.mkdir('Test123'))\npyls.root_uri = test_uri\npyls.workspace._root_uri = test_uri\nworkspace1 = {'uri': test_uri}\nworkspace2 = {'uri': str(tmpdir.mkdir('NewTest456'))}\nevent = {'added': [workspace2], 'removed': [workspace1]}\npyls.m_workspace__did_change_workspace_folders(event)\nassert workspace2['uri'] == pyls.workspace._root_uri\nassert workspace2['uri'] == pyls.root_uri\n",
        "CUT_1": "return str(self.uri)\n",
        "CUT_2": "self._config.update((settings or {}).get('pyls', {}))\n",
        "CUT_3": "workspace = self._match_uri_to_workspace(textDocument['uri'])\nworkspace.rm_document(textDocument['uri'])\n",
        "CUT_4": "if event is None:\n    return\nadded = event.get('added', [])\nremoved = event.get('removed', [])\nfor removed_info in removed:\n    if 'uri' in removed_info:\n        removed_uri = removed_info['uri']\n        self.workspaces.pop(removed_uri, None)\nfor added_info in added:\n    if 'uri' in added_info:\n        added_uri = added_info['uri']\n        workspace_config = config.Config(added_uri, self.config._init_opts,\n            self.config._process_id, self.config._capabilities)\n        workspace_config.update(self.config._settings)\n        self.workspaces[added_uri] = Workspace(added_uri, self._endpoint,\n            workspace_config)\nroot_workspace_removed = any(removed_info['uri'] == self.root_uri for\n    removed_info in removed)\nworkspace_added = len(added) > 0 and 'uri' in added[0]\nif root_workspace_removed and workspace_added:\n    added_uri = added[0]['uri']\n    self.root_uri = added_uri\n    new_root_workspace = self.workspaces[added_uri]\n    self.config = new_root_workspace._config\n    self.workspace = new_root_workspace\nelif root_workspace_removed:\n    if self.workspaces:\n        log.debug('Root workspace deleted!')\n        available_workspaces = sorted(self.workspaces)\n        first_workspace = available_workspaces[0]\n        new_root_workspace = self.workspaces[first_workspace]\n        self.root_uri = first_workspace\n        self.config = new_root_workspace._config\n        self.workspace = new_root_workspace\ndoc_uris = list(self.workspace._docs.keys())\nfor uri in doc_uris:\n    doc = self.workspace._docs.pop(uri)\n    new_workspace = self._match_uri_to_workspace(uri)\n    new_workspace._docs[uri] = doc\n",
        "CUT_5": "\"\"\"Return a workspace with a root_path other than tmpdir.\"\"\"\nws_path = str(tmpdir.mkdir('test123').mkdir('test456'))\nws = Workspace(uris.from_fs_path(ws_path), Mock())\nws._config = Config(ws.root_uri, {}, 0, {})\nreturn ws\npytest.fixture"
    },
    {
        "functionName": "test_root_workspace_not_changed",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "test_uri_1 = str(tmpdir.mkdir('Test12'))\npyls.root_uri = test_uri_1\npyls.workspace._root_uri = test_uri_1\nworkspace1 = {'uri': str(tmpdir.mkdir('Test1234'))}\nworkspace2 = {'uri': str(tmpdir.mkdir('NewTest456'))}\nevent = {'added': [workspace2], 'removed': [workspace1]}\npyls.m_workspace__did_change_workspace_folders(event)\nassert test_uri_1 == pyls.workspace._root_uri\nassert test_uri_1 == pyls.root_uri\ntest_uri_2 = str(tmpdir.mkdir('Test123'))\nnew_root_uri = workspace2['uri']\npyls.root_uri = test_uri_2\npyls.workspace._root_uri = test_uri_2\nworkspace1 = {'uri': test_uri_2}\nevent = {'added': [], 'removed': [workspace1]}\npyls.m_workspace__did_change_workspace_folders(event)\nassert new_root_uri == pyls.workspace._root_uri\nassert new_root_uri == pyls.root_uri\nevent = {'added': [workspace1], 'removed': []}\npyls.m_workspace__did_change_workspace_folders(event)\nassert new_root_uri == pyls.workspace._root_uri\nassert new_root_uri == pyls.root_uri\nworkspace2 = {'TESTuri': 'Test1234'}\nevent = {'added': [workspace2], 'removed': [workspace1]}\npyls.m_workspace__did_change_workspace_folders(event)\nassert new_root_uri == pyls.workspace._root_uri\nassert new_root_uri == pyls.root_uri\n",
        "CUT_1": "self._config.update((settings or {}).get('pyls', {}))\n",
        "CUT_2": "self._root_path = uris.to_fs_path(root_uri)\nself._root_uri = root_uri\nself._init_opts = init_opts\nself._process_id = process_id\nself._capabilities = capabilities\nself._settings = {}\nself._plugin_settings = {}\nself._config_sources = {}\ntry:\n    from .flake8_conf import Flake8Config\n    self._config_sources['flake8'] = Flake8Config(self._root_path)\nexcept ImportError:\n    pass\ntry:\n    from .pycodestyle_conf import PyCodeStyleConfig\n    self._config_sources['pycodestyle'] = PyCodeStyleConfig(self._root_path)\nexcept ImportError:\n    pass\nself._pm = pluggy.PluginManager(PYLS)\nself._pm.trace.root.setwriter(log.debug)\nself._pm.enable_tracing()\nself._pm.add_hookspecs(hookspecs)\nfor entry_point in pkg_resources.iter_entry_points(PYLS):\n    try:\n        entry_point.load()\n    except ImportError as e:\n        log.warning(\"Failed to load %s entry point '%s': %s\", PYLS,\n            entry_point.name, e)\n        self._pm.set_blocked(entry_point.name)\nself._pm.load_setuptools_entrypoints(PYLS)\nfor name, plugin in self._pm.list_name_plugin():\n    if plugin is not None:\n        log.info('Loaded pyls plugin %s from %s', name, plugin)\nfor plugin_conf in self._pm.hook.pyls_settings(config=self):\n    self._plugin_settings = _utils.merge_dicts(self._plugin_settings,\n        plugin_conf)\nself._update_disabled_plugins()\n",
        "CUT_3": "return self._root_uri\nproperty",
        "CUT_4": "return self._root_uri\nproperty",
        "CUT_5": "self.config.update((settings or {}).get('pyls', {}))\nfor workspace_uri in self.workspaces:\n    workspace = self.workspaces[workspace_uri]\n    workspace.update_config(settings)\n    for doc_uri in workspace.documents:\n        self.lint(doc_uri, is_saved=False)\n"
    },
    {
        "functionName": "test_root_workspace_removed",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "workspace1_dir = tmpdir.mkdir('workspace1')\nworkspace2_dir = tmpdir.mkdir('workspace2')\nroot_uri = pyls.root_uri\nadded_workspaces = [{'uri': path_as_uri(str(x))} for x in (workspace1_dir,\n    workspace2_dir)]\nevent = {'added': added_workspaces, 'removed': []}\npyls.m_workspace__did_change_workspace_folders(event)\nremoved_workspaces = [{'uri': root_uri}]\nevent = {'added': [], 'removed': removed_workspaces}\npyls.m_workspace__did_change_workspace_folders(event)\nassert pyls.root_uri == path_as_uri(str(workspace1_dir))\nassert pyls.workspace._root_uri == path_as_uri(str(workspace1_dir))\n",
        "CUT_1": "self._config.update((settings or {}).get('pyls', {}))\n",
        "CUT_2": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture",
        "CUT_3": "if event is None:\n    return\nadded = event.get('added', [])\nremoved = event.get('removed', [])\nfor removed_info in removed:\n    if 'uri' in removed_info:\n        removed_uri = removed_info['uri']\n        self.workspaces.pop(removed_uri, None)\nfor added_info in added:\n    if 'uri' in added_info:\n        added_uri = added_info['uri']\n        workspace_config = config.Config(added_uri, self.config._init_opts,\n            self.config._process_id, self.config._capabilities)\n        workspace_config.update(self.config._settings)\n        self.workspaces[added_uri] = Workspace(added_uri, self._endpoint,\n            workspace_config)\nroot_workspace_removed = any(removed_info['uri'] == self.root_uri for\n    removed_info in removed)\nworkspace_added = len(added) > 0 and 'uri' in added[0]\nif root_workspace_removed and workspace_added:\n    added_uri = added[0]['uri']\n    self.root_uri = added_uri\n    new_root_workspace = self.workspaces[added_uri]\n    self.config = new_root_workspace._config\n    self.workspace = new_root_workspace\nelif root_workspace_removed:\n    if self.workspaces:\n        log.debug('Root workspace deleted!')\n        available_workspaces = sorted(self.workspaces)\n        first_workspace = available_workspaces[0]\n        new_root_workspace = self.workspaces[first_workspace]\n        self.root_uri = first_workspace\n        self.config = new_root_workspace._config\n        self.workspace = new_root_workspace\ndoc_uris = list(self.workspace._docs.keys())\nfor uri in doc_uris:\n    doc = self.workspace._docs.pop(uri)\n    new_workspace = self._match_uri_to_workspace(uri)\n    new_workspace._docs[uri] = doc\n",
        "CUT_4": "return str(self.uri)\n",
        "CUT_5": "self._root_path = uris.to_fs_path(root_uri)\nself._root_uri = root_uri\nself._init_opts = init_opts\nself._process_id = process_id\nself._capabilities = capabilities\nself._settings = {}\nself._plugin_settings = {}\nself._config_sources = {}\ntry:\n    from .flake8_conf import Flake8Config\n    self._config_sources['flake8'] = Flake8Config(self._root_path)\nexcept ImportError:\n    pass\ntry:\n    from .pycodestyle_conf import PyCodeStyleConfig\n    self._config_sources['pycodestyle'] = PyCodeStyleConfig(self._root_path)\nexcept ImportError:\n    pass\nself._pm = pluggy.PluginManager(PYLS)\nself._pm.trace.root.setwriter(log.debug)\nself._pm.enable_tracing()\nself._pm.add_hookspecs(hookspecs)\nfor entry_point in pkg_resources.iter_entry_points(PYLS):\n    try:\n        entry_point.load()\n    except ImportError as e:\n        log.warning(\"Failed to load %s entry point '%s': %s\", PYLS,\n            entry_point.name, e)\n        self._pm.set_blocked(entry_point.name)\nself._pm.load_setuptools_entrypoints(PYLS)\nfor name, plugin in self._pm.list_name_plugin():\n    if plugin is not None:\n        log.info('Loaded pyls plugin %s from %s', name, plugin)\nfor plugin_conf in self._pm.hook.pyls_settings(config=self):\n    self._plugin_settings = _utils.merge_dicts(self._plugin_settings,\n        plugin_conf)\nself._update_disabled_plugins()\n"
    },
    {
        "functionName": "test_workspace_loads_pycodestyle_config",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "workspace1_dir = tmpdir.mkdir('Test123')\npyls.root_uri = str(workspace1_dir)\npyls.workspace._root_uri = str(workspace1_dir)\nworkspace2_dir = tmpdir.mkdir('NewTest456')\ncfg = workspace2_dir.join('pycodestyle.cfg')\ncfg.write(\"\"\"[pycodestyle]\nmax-line-length = 1000\"\"\")\nworkspace1 = {'uri': str(workspace1_dir)}\nworkspace2 = {'uri': str(workspace2_dir)}\nevent = {'added': [workspace2], 'removed': [workspace1]}\npyls.m_workspace__did_change_workspace_folders(event)\nseetings = pyls.workspaces[str(workspace2_dir)]._config.settings()\nassert seetings['plugins']['pycodestyle']['maxLineLength'] == 1000\nserver_settings = {'pyls': {'plugins': {'pycodestyle': {'maxLineLength': 10}}}}\npyls.m_workspace__did_change_configuration(server_settings)\nassert seetings['plugins']['pycodestyle']['maxLineLength'] == 1000\nworkspace3_dir = tmpdir.mkdir('NewTest789')\ncfg1 = workspace3_dir.join('pycodestyle.cfg')\ncfg1.write(\"\"\"[pycodestyle]\nmax-line-length = 20\"\"\")\nworkspace3 = {'uri': str(workspace3_dir)}\nevent = {'added': [workspace3], 'removed': [workspace2]}\npyls.m_workspace__did_change_workspace_folders(event)\nseetings = pyls.workspaces[str(workspace3_dir)]._config.settings()\nassert seetings['plugins']['pycodestyle']['maxLineLength'] == 20\npytest.mark.skipif(os.name == 'nt', reason='Fails on Windows')",
        "CUT_1": "self._config.update((settings or {}).get('pyls', {}))\n",
        "CUT_2": "\"\"\"Create, populate and return the VersioneerConfig() object.\"\"\"\ncfg = VersioneerConfig()\ncfg.VCS = 'git'\ncfg.style = 'pep440'\ncfg.tag_prefix = ''\ncfg.parentdir_prefix = ''\ncfg.versionfile_source = 'pyls/_version.py'\ncfg.verbose = False\nreturn cfg\n",
        "CUT_3": "options = _autopep8_config(config, document)\nif line_range:\n    options['line_range'] = list(line_range)\ndel pycodestyle._checks['logical_line'][pycodestyle.continued_indentation]\npycodestyle.register_check(autopep8_c_i)\nnew_source = fix_code(document.source, options=options)\ndel pycodestyle._checks['logical_line'][autopep8_c_i]\npycodestyle.register_check(pycodestyle.continued_indentation)\nif new_source == document.source:\n    return []\nreturn [{'range': {'start': {'line': 0, 'character': 0}, 'end': {'line':\n    len(document.lines), 'character': 0}}, 'newText': new_source}]\n",
        "CUT_4": "config = workspace._config\nsettings = config.plugin_settings('pycodestyle', document_path=document.path)\nlog.debug('Got pycodestyle settings: %s', settings)\nopts = {'exclude': settings.get('exclude'), 'filename': settings.get(\n    'filename'), 'hang_closing': settings.get('hangClosing'), 'ignore':\n    settings.get('ignore'), 'max_line_length': settings.get('maxLineLength'\n    ), 'select': settings.get('select')}\nkwargs = {k: v for k, v in opts.items() if v}\nstyleguide = pycodestyle.StyleGuide(kwargs)\nc = pycodestyle.Checker(filename=document.uri, lines=document.lines,\n    options=styleguide.options, report=PyCodeStyleDiagnosticReport(\n    styleguide.options))\nc.check_all()\ndiagnostics = c.report.diagnostics\nreturn diagnostics\nhookimpl",
        "CUT_5": "return str(self.uri)\n"
    },
    {
        "functionName": "test_settings_of_added_workspace",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_workspace.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "test_uri = str(tmpdir.mkdir('Test123'))\npyls.root_uri = test_uri\npyls.workspace._root_uri = test_uri\nserver_settings = {'pyls': {'plugins': {'jedi': {'environment':\n    '/usr/bin/python3'}}}}\npyls.m_workspace__did_change_configuration(server_settings)\nworkspace1 = {'uri': str(tmpdir.mkdir('NewTest456'))}\nevent = {'added': [workspace1]}\npyls.m_workspace__did_change_workspace_folders(event)\nworkspace1_object = pyls.workspaces[workspace1['uri']]\nworkspace1_jedi_settings = workspace1_object._config.plugin_settings('jedi')\nassert workspace1_jedi_settings == server_settings['pyls']['plugins']['jedi']\n",
        "CUT_1": "self._config.update((settings or {}).get('pyls', {}))\n",
        "CUT_2": "self._config.update((settings or {}).get('pyls', {}))\nfor doc_uri in self.documents:\n    self.get_document(doc_uri).update_config(settings)\n",
        "CUT_3": "self._root_path = uris.to_fs_path(root_uri)\nself._root_uri = root_uri\nself._init_opts = init_opts\nself._process_id = process_id\nself._capabilities = capabilities\nself._settings = {}\nself._plugin_settings = {}\nself._config_sources = {}\ntry:\n    from .flake8_conf import Flake8Config\n    self._config_sources['flake8'] = Flake8Config(self._root_path)\nexcept ImportError:\n    pass\ntry:\n    from .pycodestyle_conf import PyCodeStyleConfig\n    self._config_sources['pycodestyle'] = PyCodeStyleConfig(self._root_path)\nexcept ImportError:\n    pass\nself._pm = pluggy.PluginManager(PYLS)\nself._pm.trace.root.setwriter(log.debug)\nself._pm.enable_tracing()\nself._pm.add_hookspecs(hookspecs)\nfor entry_point in pkg_resources.iter_entry_points(PYLS):\n    try:\n        entry_point.load()\n    except ImportError as e:\n        log.warning(\"Failed to load %s entry point '%s': %s\", PYLS,\n            entry_point.name, e)\n        self._pm.set_blocked(entry_point.name)\nself._pm.load_setuptools_entrypoints(PYLS)\nfor name, plugin in self._pm.list_name_plugin():\n    if plugin is not None:\n        log.info('Loaded pyls plugin %s from %s', name, plugin)\nfor plugin_conf in self._pm.hook.pyls_settings(config=self):\n    self._plugin_settings = _utils.merge_dicts(self._plugin_settings,\n        plugin_conf)\nself._update_disabled_plugins()\n",
        "CUT_4": "QObject.__init__(self)\nself.manager = parent\nself.zmq_in_socket = None\nself.zmq_out_socket = None\nself.zmq_in_port = None\nself.zmq_out_port = None\nself.transport = None\nself.server = None\nself.stdio_pid = None\nself.notifier = None\nself.language = language\nself.initialized = False\nself.ready_to_close = False\nself.request_seq = 1\nself.req_status = {}\nself.watched_files = {}\nself.watched_folders = {}\nself.req_reply = {}\nself.server_unresponsive = False\nself.transport_unresponsive = False\nif not server_settings['external']:\n    self.server_port = select_port(default_port=server_settings['port'])\nelse:\n    self.server_port = server_settings['port']\nself.server_host = server_settings['host']\nself.external_server = server_settings.get('external', False)\nself.stdio = server_settings.get('stdio', False)\nif self.stdio and self.external_server:\n    error = (\n        'If server is set to use stdio communication, then it cannot be an external server'\n        )\n    logger.error(error)\n    raise AssertionError(error)\nself.folder = folder\nself.configurations = server_settings.get('configurations', {})\nself.client_capabilites = CLIENT_CAPABILITES\nself.server_capabilites = SERVER_CAPABILITES\nself.context = zmq.Context()\nself._server_args = server_settings.get('args', '')\nself._server_cmd = server_settings['cmd']\nself._requests = []\n",
        "CUT_5": "QObject.__init__(self)\nself.manager = parent\nself.zmq_in_socket = None\nself.zmq_out_socket = None\nself.zmq_in_port = None\nself.zmq_out_port = None\nself.transport = None\nself.server = None\nself.stdio_pid = None\nself.notifier = None\nself.language = language\nself.initialized = False\nself.ready_to_close = False\nself.request_seq = 1\nself.req_status = {}\nself.watched_files = {}\nself.watched_folders = {}\nself.req_reply = {}\nself.server_unresponsive = False\nself.transport_unresponsive = False\nif not server_settings['external']:\n    self.server_port = select_port(default_port=server_settings['port'])\nelse:\n    self.server_port = server_settings['port']\nself.server_host = server_settings['host']\nself.external_server = server_settings.get('external', False)\nself.stdio = server_settings.get('stdio', False)\nif self.stdio and self.external_server:\n    error = (\n        'If server is set to use stdio communication, then it cannot be an external server'\n        )\n    logger.error(error)\n    raise AssertionError(error)\nself.folder = folder\nself.configurations = server_settings.get('configurations', {})\nself.client_capabilites = CLIENT_CAPABILITES\nself.server_capabilites = SERVER_CAPABILITES\nself.context = zmq.Context()\nself._server_args = server_settings.get('args', '')\nself._server_cmd = server_settings['cmd']\nself._requests = []\n"
    },
    {
        "functionName": "start_client",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_language_server.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "client.start()\n",
        "CUT_1": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_2": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_3": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_4": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_5": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n"
    },
    {
        "functionName": "__init__",
        "className": "_ClientServer",
        "fileName": "/external-deps/python-language-server/test/test_language_server.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "csr, csw = os.pipe()\nscr, scw = os.pipe()\nif os.name == 'nt':\n    ParallelKind = Thread\nelif sys.version_info[:2] >= (3, 8):\n    ParallelKind = multiprocessing.get_context('fork').Process\nelse:\n    ParallelKind = multiprocessing.Process\nself.process = ParallelKind(target=start_io_lang_server, args=(os.fdopen(\n    csr, 'rb'), os.fdopen(scw, 'wb'), check_parent_process,\n    PythonLanguageServer))\nself.process.start()\nself.client = PythonLanguageServer(os.fdopen(scr, 'rb'), os.fdopen(csw,\n    'wb'), start_io_lang_server)\nself.client_thread = Thread(target=start_client, args=[self.client])\nself.client_thread.daemon = True\nself.client_thread.start()\n",
        "CUT_1": "if self.process is not None:\n    if self.process.state() == QProcess.Running:\n        self.process.kill()\n        self.process.waitForFinished()\n",
        "CUT_2": "if self.process is not None:\n    if self.process.state() == QProcess.Running:\n        self.process.kill()\n        self.process.waitForFinished()\n",
        "CUT_3": "\"\"\"Check whether the process with the given pid is still alive.\n\n        Running `os.kill()` on Windows always exits the process, so it can't be used to check for an alive process.\n        see: https://docs.python.org/3/library/os.html?highlight=os%20kill#os.kill\n\n        Hence ctypes is used to check for the process directly via windows API avoiding any other 3rd-party dependency.\n\n        Args:\n            pid (int): process ID\n\n        Returns:\n            bool: False if the process is not alive or don't have permission to check, True otherwise.\n        \"\"\"\nprocess = kernel32.OpenProcess(PROCESS_QUERY_INFROMATION, 0, pid)\nif process != 0:\n    kernel32.CloseHandle(process)\n    return True\nreturn False\n",
        "CUT_4": "os.remove(os.path.join(filename, 'symlink'))\nos.rmdir(filename)\n",
        "CUT_5": "os.remove(os.path.join(filename, 'symlink'))\nos.rmdir(filename)\n"
    },
    {
        "functionName": "client_server",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_language_server.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\" A fixture that sets up a client/server pair and shuts down the server\n    This client/server pair does not support checking parent process aliveness\n    \"\"\"\nclient_server_pair = _ClientServer()\nyield client_server_pair.client\nshutdown_response = client_server_pair.client._endpoint.request('shutdown'\n    ).result(timeout=CALL_TIMEOUT)\nassert shutdown_response is None\nclient_server_pair.client._endpoint.notify('exit')\npytest.fixture",
        "CUT_1": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_2": "\"\"\"Return the currently selected client\"\"\"\nclient = self.tabwidget.currentWidget()\nif client is not None:\n    return client\n",
        "CUT_3": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_4": "\"\"\"Return the shellwidget of the current client\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    return client.shellwidget\n",
        "CUT_5": "\"\"\"Reset kernel of current client.\"\"\"\nclient = self.get_current_client()\nif client is not None:\n    self.switch_to_plugin()\n    client.reset_namespace()\n"
    },
    {
        "functionName": "client_exited_server",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_language_server.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\" A fixture that sets up a client/server pair that support checking parent process aliveness\n    and assert the server has already exited\n    \"\"\"\nclient_server_pair = _ClientServer(True)\nyield client_server_pair\nassert client_server_pair.process.is_alive() is False\npytest.fixture",
        "CUT_1": "\"\"\"Return True if pydoc server is already running.\"\"\"\nreturn self.server is not None\n",
        "CUT_2": "\"\"\"Return True if pydoc server is already running.\"\"\"\nreturn self.server is not None\n",
        "CUT_3": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_4": "if self.process is not None:\n    if self.process.state() == QProcess.Running:\n        self.process.kill()\n        self.process.waitForFinished()\n",
        "CUT_5": "if self.process is not None:\n    if self.process.state() == QProcess.Running:\n        self.process.kill()\n        self.process.waitForFinished()\n"
    },
    {
        "functionName": "test_initialize",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_language_server.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "response = client_server._endpoint.request('initialize', {'rootPath': os.\n    path.dirname(__file__), 'initializationOptions': {}}).result(timeout=\n    CALL_TIMEOUT)\nassert 'capabilities' in response\n",
        "CUT_1": "\"\"\"\n        Send response for server request.\n\n        Parameters\n        ----------\n        response: dict\n            Response body for server\n            {\n                **kwargs: response-specific keys\n            }\n        resp_id: int\n            Request identifier for response\n        \"\"\"\npass\n",
        "CUT_2": "\"\"\"\n        Send response for server request.\n\n        Parameters\n        ----------\n        response: dict\n            Response body for server\n            {\n                **kwargs: response-specific keys\n            }\n        resp_id: int\n            Request identifier for response\n        \"\"\"\npass\n",
        "CUT_3": "super(ApiError, self).__init__(url)\nself.request = request\nself.response = response\n",
        "CUT_4": "super(ApiError, self).__init__(url)\nself.request = request\nself.response = response\n",
        "CUT_5": "if len(response['signatures']) > 0:\n    response['signatures'] = response['signatures'][response['activeSignature']\n        ]\n    response['provider'] = LSP_COMPLETION\nelse:\n    response = None\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_SIGNATURE, {'params':\n        response})\nhandles(LSPRequestTypes.DOCUMENT_SIGNATURE)"
    },
    {
        "functionName": "test_exit_with_parent_process_died",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_language_server.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "lsp_server, mock_process = (client_exited_server.client,\n    client_exited_server.process)\nlsp_server._endpoint.request('initialize', {'processId': mock_process.pid,\n    'rootPath': os.path.dirname(__file__), 'initializationOptions': {}}\n    ).result(timeout=CALL_TIMEOUT)\nmock_process.terminate()\ntime.sleep(CALL_TIMEOUT)\nassert not client_exited_server.client_thread.is_alive()\npytest.mark.skipif(os.name == 'nt' or sys.platform.startswith('linux') and\n    PY3, reason='Skipped on win and fails on linux >=3.6')",
        "CUT_1": "\"\"\"Check if a process is running based on the pid.\"\"\"\nif os.name == 'nt':\n    return _is_pid_running_on_windows(pid)\nelse:\n    return _is_pid_running_on_unix(pid)\n",
        "CUT_2": "\"\"\"Check if a process is running based on the pid.\"\"\"\nif os.name == 'nt':\n    return _is_pid_running_on_windows(pid)\nelse:\n    return _is_pid_running_on_unix(pid)\n",
        "CUT_3": "\"\"\"\n        Exit when the given pid is not alive.\n\n        Code taken from the Python Language Server project.\n        \"\"\"\nglobal is_alive\nif not psutil.pid_exists(pid):\n    logger.info('parent process %s is not alive, exiting!', pid)\n    is_alive = False\nif is_alive:\n    threading.Timer(PARENT_PROCESS_WATCH_INTERVAL, watch_parent_process,\n        args=[pid]).start()\n",
        "CUT_4": "\"\"\"\n        Exit when the given pid is not alive.\n\n        Code taken from the Python Language Server project.\n        \"\"\"\nglobal is_alive\nif not psutil.pid_exists(pid):\n    logger.info('parent process %s is not alive, exiting!', pid)\n    is_alive = False\nif is_alive:\n    threading.Timer(PARENT_PROCESS_WATCH_INTERVAL, watch_parent_process,\n        args=[pid]).start()\n",
        "CUT_5": "\"\"\"Check if a process is running on unix systems based on the pid.\"\"\"\ntry:\n    os.kill(pid, 0)\nexcept OSError:\n    return False\nelse:\n    return True\n"
    },
    {
        "functionName": "test_not_exit_without_check_parent_process_flag",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_language_server.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "response = client_server._endpoint.request('initialize', {'processId': 1234,\n    'rootPath': os.path.dirname(__file__), 'initializationOptions': {}}\n    ).result(timeout=CALL_TIMEOUT)\nassert 'capabilities' in response\npytest.mark.skipif(sys.platform.startswith('linux') and PY3, reason=\n    'Fails on linux and py3')",
        "CUT_1": "\"\"\"\n        Send response for server request.\n\n        Parameters\n        ----------\n        response: dict\n            Response body for server\n            {\n                **kwargs: response-specific keys\n            }\n        resp_id: int\n            Request identifier for response\n        \"\"\"\npass\n",
        "CUT_2": "\"\"\"\n        Send response for server request.\n\n        Parameters\n        ----------\n        response: dict\n            Response body for server\n            {\n                **kwargs: response-specific keys\n            }\n        resp_id: int\n            Request identifier for response\n        \"\"\"\npass\n",
        "CUT_3": "super(ApiError, self).__init__(url)\nself.request = request\nself.response = response\n",
        "CUT_4": "super(ApiError, self).__init__(url)\nself.request = request\nself.response = response\n",
        "CUT_5": "if not PY3 and is_unicode(x):\n    x = x.encode('utf-8')\ny = lgettext(x)\nif is_text_string(y) and PY3:\n    return y\nelse:\n    return to_text_string(y, 'utf-8')\n"
    },
    {
        "functionName": "test_missing_message",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_language_server.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "with pytest.raises(JsonRpcMethodNotFound):\n    client_server._endpoint.request('unknown_method').result(timeout=\n        CALL_TIMEOUT)\npytest.mark.skipif(bool(os.environ.get('CI')), reason=\n    'This test is hanging on CI')",
        "CUT_1": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_2": "\"\"\"Run pytest tests for Spyder.\"\"\"\npytest_args = ['-vv', '-rw', '--durations=10', '--ignore=./external-deps']\nif CI:\n    pytest_args += ['-x', '--cov=spyder', '--no-cov-on-fail']\n    if os.environ.get('AZURE', None) is not None:\n        pytest_args += ['--cache-clear', '--junitxml=result.xml']\nif run_slow or RUN_SLOW:\n    pytest_args += ['--run-slow']\nif extra_args:\n    pytest_args += extra_args\nprint('Pytest Arguments: ' + str(pytest_args))\nerrno = pytest.main(pytest_args)\nif errno != 0:\n    raise SystemExit(errno)\n",
        "CUT_3": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_4": "\"\"\"\n        Check if optional dependencies are available for special consoles.\n        \"\"\"\ntry:\n    if os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True':\n        import matplotlib\n    elif os.environ.get('SPY_SYMPY_O') == 'True':\n        import sympy\n    elif os.environ.get('SPY_RUN_CYTHON') == 'True':\n        import cython\nexcept Exception:\n    if os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True':\n        return 'matplotlib'\n    elif os.environ.get('SPY_SYMPY_O') == 'True':\n        return 'sympy'\n    elif os.environ.get('SPY_RUN_CYTHON') == 'True':\n        return 'cython'\nreturn None\n",
        "CUT_5": "return self._endpoint.request(self.M_APPLY_EDIT, {'edit': edit})\n"
    },
    {
        "functionName": "test_to_fs_path",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_uris.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert uris.to_fs_path(uri) == path\nunix_onlypytest.mark.parametrize('uri,path', [('file:///foo/bar#frag', '/foo/bar'),\n    ('file:/foo/bar#frag', '/foo/bar'), ('file:/foo/space%20%3Fbar#frag',\n    '/foo/space ?bar')])",
        "CUT_1": "\"\"\"\n    Try to get the formatted argspec of a callable from the first block of its\n    docstring\n    \n    This will return something like\n    '(foo, bar, k=1)'\n    \"\"\"\nblocks = text.split('\\n\\n')\nfirst_block = blocks[0].strip()\nreturn getsignaturefromtext(first_block, '')\n",
        "CUT_2": "\"\"\"\n        Update the color scheme of the preview editor and adds text.\n\n        Note\n        ----\n        'index' is needed, because this is triggered by a signal that sends\n        the selected index.\n        \"\"\"\ntext = \"\"\"\"\"\\\"A string\"\"\\\"\n\n# A comment\n\nclass Foo(object):\n    def __init__(self):\n        bar = 42\n        print(bar)\n\"\"\"\nif scheme_name is None:\n    scheme_name = self.current_scheme\nself.preview_editor.setup_editor(font=get_font(), color_scheme=scheme_name,\n    show_blanks=False, scroll_past_end=False)\nself.preview_editor.set_language('Python')\nself.preview_editor.set_text(text)\n",
        "CUT_3": "\"\"\"\n        Update the color scheme of the preview editor and adds text.\n\n        Note\n        ----\n        'index' is needed, because this is triggered by a signal that sends\n        the selected index.\n        \"\"\"\ntext = \"\"\"\"\"\\\"A string\"\"\\\"\n\n# A comment\n\nclass Foo(object):\n    def __init__(self):\n        bar = 42\n        print(bar)\n\"\"\"\nif scheme_name is None:\n    scheme_name = self.current_scheme\nself.preview_editor.setup_editor(font=get_font(), color_scheme=scheme_name,\n    show_blanks=False, scroll_past_end=False)\nself.preview_editor.set_language('Python')\nself.preview_editor.set_text(text)\n",
        "CUT_4": "\"\"\"Set custom title bar.\"\"\"\nself.setTitleBarWidget(self.titlebar)\n",
        "CUT_5": "\"\"\"Set custom title bar.\"\"\"\nself.setTitleBarWidget(self.titlebar)\n"
    },
    {
        "functionName": "test_win_to_fs_path",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_uris.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert uris.to_fs_path(uri) == path\nwindows_onlypytest.mark.parametrize('uri,path', [('file:///c:/far/boo', 'c:\\\\far\\\\boo'),\n    ('file:///C:/far/boo', 'c:\\\\far\\\\boo'), (\n    'file:///C:/far/space%20%3Fboo', 'c:\\\\far\\\\space ?boo')])",
        "CUT_1": "return 'Boo'\nstaticmethod",
        "CUT_2": "return 'Boo'\nstaticmethod",
        "CUT_3": "return str(self.uri)\n",
        "CUT_4": "\"\"\"\n        Set path as current file path.\n\n        Parameters\n        ----------\n        path: str\n            File path string.\n        \"\"\"\nself.path_selection_combo.file_path = path\n",
        "CUT_5": "\"\"\"\n        Set path as current file path.\n\n        Parameters\n        ----------\n        path: str\n            File path string.\n        \"\"\"\nself.path_selection_combo.file_path = path\n"
    },
    {
        "functionName": "test_from_fs_path",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_uris.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert uris.from_fs_path(path) == uri\nunix_onlypytest.mark.parametrize('path,uri', [('/foo/bar', 'file:///foo/bar'), (\n    '/foo/space ?bar', 'file:///foo/space%20%3Fbar')])",
        "CUT_1": "\"\"\"\n    Try to get the formatted argspec of a callable from the first block of its\n    docstring\n    \n    This will return something like\n    '(foo, bar, k=1)'\n    \"\"\"\nblocks = text.split('\\n\\n')\nfirst_block = blocks[0].strip()\nreturn getsignaturefromtext(first_block, '')\n",
        "CUT_2": "return str(self.uri)\n",
        "CUT_3": "\"\"\"\n        Update the color scheme of the preview editor and adds text.\n\n        Note\n        ----\n        'index' is needed, because this is triggered by a signal that sends\n        the selected index.\n        \"\"\"\ntext = \"\"\"\"\"\\\"A string\"\"\\\"\n\n# A comment\n\nclass Foo(object):\n    def __init__(self):\n        bar = 42\n        print(bar)\n\"\"\"\nif scheme_name is None:\n    scheme_name = self.current_scheme\nself.preview_editor.setup_editor(font=get_font(), color_scheme=scheme_name,\n    show_blanks=False, scroll_past_end=False)\nself.preview_editor.set_language('Python')\nself.preview_editor.set_text(text)\n",
        "CUT_4": "\"\"\"\n        Update the color scheme of the preview editor and adds text.\n\n        Note\n        ----\n        'index' is needed, because this is triggered by a signal that sends\n        the selected index.\n        \"\"\"\ntext = \"\"\"\"\"\\\"A string\"\"\\\"\n\n# A comment\n\nclass Foo(object):\n    def __init__(self):\n        bar = 42\n        print(bar)\n\"\"\"\nif scheme_name is None:\n    scheme_name = self.current_scheme\nself.preview_editor.setup_editor(font=get_font(), color_scheme=scheme_name,\n    show_blanks=False, scroll_past_end=False)\nself.preview_editor.set_language('Python')\nself.preview_editor.set_text(text)\n",
        "CUT_5": "\"\"\"Action for Ctrl+Space\"\"\"\npass\n"
    },
    {
        "functionName": "test_win_from_fs_path",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_uris.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert uris.from_fs_path(path) == uri\nwindows_onlypytest.mark.parametrize('path,uri', [('c:\\\\far\\\\boo', 'file:///c:/far/boo'),\n    ('C:\\\\far\\\\space ?boo', 'file:///c:/far/space%20%3Fboo')])",
        "CUT_1": "return 'Boo'\nstaticmethod",
        "CUT_2": "return 'Boo'\nstaticmethod",
        "CUT_3": "return str(self.uri)\n",
        "CUT_4": "\"\"\"Action for Ctrl+Space\"\"\"\npass\n",
        "CUT_5": "\"\"\"Action for Ctrl+Space\"\"\"\npass\n"
    },
    {
        "functionName": "test_uri_with",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_uris.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert uris.uri_with(uri, **kwargs) == new_uri\npytest.mark.parametrize('uri,kwargs,new_uri', [('file:///foo/bar', {'path':\n    '/baz/boo'}, 'file:///baz/boo'), ('file:///D:/hello%20world.py', {\n    'path': 'D:/hello universe.py'}, 'file:///d:/hello%20universe.py')])",
        "CUT_1": "return 'Boo'\nstaticmethod",
        "CUT_2": "return 'Boo'\nstaticmethod",
        "CUT_3": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_4": "\"\"\"\n        Set path as current file path.\n\n        Parameters\n        ----------\n        path: str\n            File path string.\n        \"\"\"\nself.path_selection_combo.file_path = path\n",
        "CUT_5": "\"\"\"\n        Set path as current file path.\n\n        Parameters\n        ----------\n        path: str\n            File path string.\n        \"\"\"\nself.path_selection_combo.file_path = path\n"
    },
    {
        "functionName": "test_document_props",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_document.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert doc.uri == DOC_URI\nassert doc.source == DOC\n",
        "CUT_1": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n"
    },
    {
        "functionName": "test_document_lines",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_document.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert len(doc.lines) == 4\nassert doc.lines[0] == 'import sys\\n'\n",
        "CUT_1": "self.lines = lines\nself.diagnostics = []\n",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_document_source_unicode",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_document.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "document_mem = Document(DOC_URI, workspace, 'my source')\ndocument_disk = Document(DOC_URI, workspace)\nassert isinstance(document_mem.source, type(document_disk.source))\n",
        "CUT_1": "self._docs[doc_uri] = self._create_document(doc_uri, source=source, version\n    =version)\n",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "workspace = self._match_uri_to_workspace(doc_uri)\nif doc_uri in workspace.documents:\n    workspace.publish_diagnostics(doc_uri, flatten(self._hook('pyls_lint',\n        doc_uri, is_saved=is_saved)))\n_utils.debounce(LINT_DEBOUNCE_S, keyed_by='doc_uri')",
        "CUT_4": "path = uris.to_fs_path(doc_uri)\nreturn Document(doc_uri, self, source=source, version=version,\n    extra_sys_path=self.source_roots(path), rope_project_builder=self.\n    _rope_project_builder)\n",
        "CUT_5": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n"
    },
    {
        "functionName": "test_offset_at_position",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_document.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert doc.offset_at_position({'line': 0, 'character': 8}) == 8\nassert doc.offset_at_position({'line': 1, 'character': 5}) == 16\nassert doc.offset_at_position({'line': 2, 'character': 0}) == 12\nassert doc.offset_at_position({'line': 2, 'character': 4}) == 16\nassert doc.offset_at_position({'line': 4, 'character': 0}) == 51\n",
        "CUT_1": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n"
    },
    {
        "functionName": "test_word_at_position",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_document.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\" Return the position under the cursor (or last in line if past the end) \"\"\"\nassert doc.word_at_position({'line': 0, 'character': 8}) == 'sys'\nassert doc.word_at_position({'line': 0, 'character': 1000}) == 'sys'\nassert doc.word_at_position({'line': 1, 'character': 5}) == ''\nassert doc.word_at_position({'line': 2, 'character': 0}) == 'def'\nassert doc.word_at_position({'line': 4, 'character': 0}) == ''\n",
        "CUT_1": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n",
        "CUT_2": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_document_empty_edit",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_document.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document('file:///uri', workspace, '')\ndoc.apply_change({'range': {'start': {'line': 0, 'character': 0}, 'end': {\n    'line': 0, 'character': 0}}, 'text': 'f'})\nassert doc.source == 'f'\n",
        "CUT_1": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_2": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_3": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n",
        "CUT_4": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_document_line_edit",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_document.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document('file:///uri', workspace, 'itshelloworld')\ndoc.apply_change({'text': 'goodbye', 'range': {'start': {'line': 0,\n    'character': 3}, 'end': {'line': 0, 'character': 8}}})\nassert doc.source == 'itsgoodbyeworld'\n",
        "CUT_1": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_2": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_3": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n",
        "CUT_4": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_document_multiline_edit",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_document.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "old = ['def hello(a, b):\\n', '    print a\\n', '    print b\\n']\ndoc = Document('file:///uri', workspace, ''.join(old))\ndoc.apply_change({'text': 'print a, b', 'range': {'start': {'line': 1,\n    'character': 4}, 'end': {'line': 2, 'character': 11}}})\nassert doc.lines == ['def hello(a, b):\\n', '    print a, b\\n']\n",
        "CUT_1": "for i in range(3):\n    print(i)\n",
        "CUT_2": "for i in range(3):\n    print(i)\n",
        "CUT_3": "for i in range(3):\n    print(i)\n",
        "CUT_4": "for i in range(3):\n    print(i)\n",
        "CUT_5": "for i in range(3):\n    print(i)\n"
    },
    {
        "functionName": "test_document_end_of_file_edit",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/test_document.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "old = [\"print 'a'\\n\", \"print 'b'\\n\"]\ndoc = Document('file:///uri', workspace, ''.join(old))\ndoc.apply_change({'text': 'o', 'range': {'start': {'line': 2, 'character': \n    0}, 'end': {'line': 2, 'character': 0}}})\nassert doc.lines == [\"print 'a'\\n\", \"print 'b'\\n\", 'o']\n",
        "CUT_1": "for i in range(3):\n    print(i)\n",
        "CUT_2": "for i in range(3):\n    print(i)\n",
        "CUT_3": "for i in range(3):\n    print(i)\n",
        "CUT_4": "for i in range(3):\n    print(i)\n",
        "CUT_5": "for i in range(3):\n    print(i)\n"
    },
    {
        "functionName": "test_pyflakes",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pyflakes_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\ndiags = pyflakes_lint.pyls_lint(doc)\nmsg = \"'sys' imported but unused\"\nunused_import = [d for d in diags if d['message'] == msg][0]\nassert unused_import['range']['start'] == {'line': 0, 'character': 0}\nassert unused_import['severity'] == lsp.DiagnosticSeverity.Warning\n",
        "CUT_1": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_syntax_error_pyflakes",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pyflakes_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC_SYNTAX_ERR)\ndiag = pyflakes_lint.pyls_lint(doc)[0]\nassert diag['message'] == 'invalid syntax'\nassert diag['range']['start'] == {'line': 0, 'character': 12}\nassert diag['severity'] == lsp.DiagnosticSeverity.Error\n",
        "CUT_1": "\"\"\"Plugin interface to pyls linter.\n\n        Args:\n            document: The document to be linted.\n            is_saved: Whether or not the file has been saved to disk.\n            flags: Additional flags to pass to pylint. Not exposed to\n                pyls_lint, but used for testing.\n\n        Returns:\n            A list of dicts with the following format:\n\n                {\n                    'source': 'pylint',\n                    'range': {\n                        'start': {\n                            'line': start_line,\n                            'character': start_column,\n                        },\n                        'end': {\n                            'line': end_line,\n                            'character': end_column,\n                        },\n                    }\n                    'message': msg,\n                    'severity': lsp.DiagnosticSeverity.*,\n                }\n        \"\"\"\nif not is_saved:\n    return cls.last_diags[document.path]\npath = document.path\nif sys.platform.startswith('win'):\n    path = path.replace('\\\\', '/')\npylint_call = '{} -f json {}'.format(path, flags)\nlog.debug(\"Calling pylint with '%s'\", pylint_call)\njson_out, err = py_run(pylint_call, return_std=True)\njson_out = json_out.getvalue()\nerr = err.getvalue()\nif err != '':\n    log.error(\"Error calling pylint: '%s'\", err)\nif not json_out.strip():\n    cls.last_diags[document.path] = []\n    return []\ndiagnostics = []\nfor diag in json.loads(json_out):\n    line = diag['line'] - 1\n    err_range = {'start': {'line': line, 'character': diag['column']},\n        'end': {'line': line, 'character': len(document.lines[line]) if\n        document.lines else 0}}\n    if diag['type'] == 'convention':\n        severity = lsp.DiagnosticSeverity.Information\n    elif diag['type'] == 'error':\n        severity = lsp.DiagnosticSeverity.Error\n    elif diag['type'] == 'fatal':\n        severity = lsp.DiagnosticSeverity.Error\n    elif diag['type'] == 'refactor':\n        severity = lsp.DiagnosticSeverity.Hint\n    elif diag['type'] == 'warning':\n        severity = lsp.DiagnosticSeverity.Warning\n    diagnostics.append({'source': 'pylint', 'range': err_range, 'message':\n        '[{}] {}'.format(diag['symbol'], diag['message']), 'severity':\n        severity, 'code': diag['message-id']})\ncls.last_diags[document.path] = diagnostics\nreturn diagnostics\nclassmethod",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_4": "\"\"\" Get message like <filename>:<lineno>: <msg> \"\"\"\nerr_range = {'start': {'line': message.lineno - 1, 'character': message.col\n    }, 'end': {'line': message.lineno - 1, 'character': len(self.lines[\n    message.lineno - 1])}}\nseverity = lsp.DiagnosticSeverity.Warning\nfor message_type in PYFLAKES_ERROR_MESSAGES:\n    if isinstance(message, message_type):\n        severity = lsp.DiagnosticSeverity.Error\n        break\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': message.message % message.message_args, 'severity': severity})\n",
        "CUT_5": "lineno = error.definition.start - 1\nline = document.lines[0] if document.lines else ''\nstart_character = len(line) - len(line.lstrip())\nend_character = len(line)\nreturn {'source': 'pydocstyle', 'code': error.code, 'message': error.\n    message, 'severity': lsp.DiagnosticSeverity.Warning, 'range': {'start':\n    {'line': lineno, 'character': start_character}, 'end': {'line': lineno,\n    'character': end_character}}}\n"
    },
    {
        "functionName": "test_undefined_name_pyflakes",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pyflakes_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC_UNDEFINED_NAME_ERR)\ndiag = pyflakes_lint.pyls_lint(doc)[0]\nassert diag['message'] == \"undefined name 'b'\"\nassert diag['range']['start'] == {'line': 0, 'character': 4}\nassert diag['severity'] == lsp.DiagnosticSeverity.Error\n",
        "CUT_1": "\"\"\"Plugin interface to pyls linter.\n\n        Args:\n            document: The document to be linted.\n            is_saved: Whether or not the file has been saved to disk.\n            flags: Additional flags to pass to pylint. Not exposed to\n                pyls_lint, but used for testing.\n\n        Returns:\n            A list of dicts with the following format:\n\n                {\n                    'source': 'pylint',\n                    'range': {\n                        'start': {\n                            'line': start_line,\n                            'character': start_column,\n                        },\n                        'end': {\n                            'line': end_line,\n                            'character': end_column,\n                        },\n                    }\n                    'message': msg,\n                    'severity': lsp.DiagnosticSeverity.*,\n                }\n        \"\"\"\nif not is_saved:\n    return cls.last_diags[document.path]\npath = document.path\nif sys.platform.startswith('win'):\n    path = path.replace('\\\\', '/')\npylint_call = '{} -f json {}'.format(path, flags)\nlog.debug(\"Calling pylint with '%s'\", pylint_call)\njson_out, err = py_run(pylint_call, return_std=True)\njson_out = json_out.getvalue()\nerr = err.getvalue()\nif err != '':\n    log.error(\"Error calling pylint: '%s'\", err)\nif not json_out.strip():\n    cls.last_diags[document.path] = []\n    return []\ndiagnostics = []\nfor diag in json.loads(json_out):\n    line = diag['line'] - 1\n    err_range = {'start': {'line': line, 'character': diag['column']},\n        'end': {'line': line, 'character': len(document.lines[line]) if\n        document.lines else 0}}\n    if diag['type'] == 'convention':\n        severity = lsp.DiagnosticSeverity.Information\n    elif diag['type'] == 'error':\n        severity = lsp.DiagnosticSeverity.Error\n    elif diag['type'] == 'fatal':\n        severity = lsp.DiagnosticSeverity.Error\n    elif diag['type'] == 'refactor':\n        severity = lsp.DiagnosticSeverity.Hint\n    elif diag['type'] == 'warning':\n        severity = lsp.DiagnosticSeverity.Warning\n    diagnostics.append({'source': 'pylint', 'range': err_range, 'message':\n        '[{}] {}'.format(diag['symbol'], diag['message']), 'severity':\n        severity, 'code': diag['message-id']})\ncls.last_diags[document.path] = diagnostics\nreturn diagnostics\nclassmethod",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_4": "\"\"\" Get message like <filename>:<lineno>: <msg> \"\"\"\nerr_range = {'start': {'line': message.lineno - 1, 'character': message.col\n    }, 'end': {'line': message.lineno - 1, 'character': len(self.lines[\n    message.lineno - 1])}}\nseverity = lsp.DiagnosticSeverity.Warning\nfor message_type in PYFLAKES_ERROR_MESSAGES:\n    if isinstance(message, message_type):\n        severity = lsp.DiagnosticSeverity.Error\n        break\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': message.message % message.message_args, 'severity': severity})\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_unicode_encoding",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pyflakes_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC_ENCODING)\ndiags = pyflakes_lint.pyls_lint(doc)\nassert len(diags) == 1\nassert diags[0]['message'] == \"'sys' imported but unused\"\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "workspace = self._match_uri_to_workspace(doc_uri)\nif doc_uri in workspace.documents:\n    workspace.publish_diagnostics(doc_uri, flatten(self._hook('pyls_lint',\n        doc_uri, is_saved=is_saved)))\n_utils.debounce(LINT_DEBOUNCE_S, keyed_by='doc_uri')",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n"
    },
    {
        "functionName": "temp_document",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_flake8_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False)\nname = temp_file.name\ntemp_file.write(doc_text)\ntemp_file.close()\ndoc = Document(uris.from_fs_path(name), workspace)\nreturn name, doc\n",
        "CUT_1": "self.name = name\n",
        "CUT_2": "self.name = name\n",
        "CUT_3": "\"\"\"Returns a code cell name from a code cell comment.\"\"\"\nname = text.strip().lstrip('#% ')\nif name.startswith('<codecell>'):\n    name = name[10:].lstrip()\nelif name.startswith('In['):\n    name = name[2:]\n    if name.endswith(']:'):\n        name = name[:-1]\n    name = name.strip()\nreturn name\n",
        "CUT_4": "\"\"\"Returns a code cell name from a code cell comment.\"\"\"\nname = text.strip().lstrip('#% ')\nif name.startswith('<codecell>'):\n    name = name[10:].lstrip()\nelif name.startswith('In['):\n    name = name[2:]\n    if name.endswith(']:'):\n        name = name[:-1]\n    name = name.strip()\nreturn name\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_flake8_unsaved",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_flake8_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document('', workspace, DOC)\ndiags = flake8_lint.pyls_lint(workspace, doc)\nmsg = \"local variable 'a' is assigned to but never used\"\nunused_var = [d for d in diags if d['message'] == msg][0]\nassert unused_var['source'] == 'flake8'\nassert unused_var['code'] == 'F841'\nassert unused_var['range']['start'] == {'line': 5, 'character': 1}\nassert unused_var['range']['end'] == {'line': 5, 'character': 11}\nassert unused_var['severity'] == lsp.DiagnosticSeverity.Warning\n",
        "CUT_1": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_2": "\"\"\"\n    Build a diagnostics from flake8's output, it should extract every result and format\n    it into a dict that looks like this:\n        {\n            'source': 'flake8',\n            'code': code, # 'E501'\n            'range': {\n                'start': {\n                    'line': start_line,\n                    'character': start_column,\n                },\n                'end': {\n                    'line': end_line,\n                    'character': end_column,\n                },\n            },\n            'message': msg,\n            'severity': lsp.DiagnosticSeverity.*,\n        }\n\n    Args:\n        document: The document to be linted.\n        stdout: output from flake8\n    Returns:\n        A list of dictionaries.\n    \"\"\"\ndiagnostics = []\nlines = stdout.splitlines()\nfor raw_line in lines:\n    parsed_line = re.match('(.*):(\\\\d*):(\\\\d*): (\\\\w*) (.*)', raw_line)\n    if not parsed_line:\n        log.debug(\"Flake8 output parser can't parse line '%s'\", raw_line)\n        continue\n    parsed_line = parsed_line.groups()\n    if len(parsed_line) != 5:\n        log.debug(\"Flake8 output parser can't parse line '%s'\", raw_line)\n        continue\n    _, line, character, code, msg = parsed_line\n    line = int(line) - 1\n    character = int(character) - 1\n    diagnostics.append({'source': 'flake8', 'code': code, 'range': {'start':\n        {'line': line, 'character': character}, 'end': {'line': line,\n        'character': len(document.lines[line])}}, 'message': msg,\n        'severity': lsp.DiagnosticSeverity.Warning})\nreturn diagnostics\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "range['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nlines = [(range['start']['line'] + 1, range['end']['line'] + 1)]\nreturn _format(document, lines=lines)\nhookimpl"
    },
    {
        "functionName": "test_flake8_lint",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_flake8_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "try:\n    name, doc = temp_document(DOC, workspace)\n    diags = flake8_lint.pyls_lint(workspace, doc)\n    msg = \"local variable 'a' is assigned to but never used\"\n    unused_var = [d for d in diags if d['message'] == msg][0]\n    assert unused_var['source'] == 'flake8'\n    assert unused_var['code'] == 'F841'\n    assert unused_var['range']['start'] == {'line': 5, 'character': 1}\n    assert unused_var['range']['end'] == {'line': 5, 'character': 11}\n    assert unused_var['severity'] == lsp.DiagnosticSeverity.Warning\nfinally:\n    os.remove(name)\n",
        "CUT_1": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_2": "\"\"\"\n    Build a diagnostics from flake8's output, it should extract every result and format\n    it into a dict that looks like this:\n        {\n            'source': 'flake8',\n            'code': code, # 'E501'\n            'range': {\n                'start': {\n                    'line': start_line,\n                    'character': start_column,\n                },\n                'end': {\n                    'line': end_line,\n                    'character': end_column,\n                },\n            },\n            'message': msg,\n            'severity': lsp.DiagnosticSeverity.*,\n        }\n\n    Args:\n        document: The document to be linted.\n        stdout: output from flake8\n    Returns:\n        A list of dictionaries.\n    \"\"\"\ndiagnostics = []\nlines = stdout.splitlines()\nfor raw_line in lines:\n    parsed_line = re.match('(.*):(\\\\d*):(\\\\d*): (\\\\w*) (.*)', raw_line)\n    if not parsed_line:\n        log.debug(\"Flake8 output parser can't parse line '%s'\", raw_line)\n        continue\n    parsed_line = parsed_line.groups()\n    if len(parsed_line) != 5:\n        log.debug(\"Flake8 output parser can't parse line '%s'\", raw_line)\n        continue\n    _, line, character, code, msg = parsed_line\n    line = int(line) - 1\n    character = int(character) - 1\n    diagnostics.append({'source': 'flake8', 'code': code, 'range': {'start':\n        {'line': line, 'character': character}, 'end': {'line': line,\n        'character': len(document.lines[line])}}, 'message': msg,\n        'severity': lsp.DiagnosticSeverity.Warning})\nreturn diagnostics\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "range['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nlines = [(range['start']['line'] + 1, range['end']['line'] + 1)]\nreturn _format(document, lines=lines)\nhookimpl"
    },
    {
        "functionName": "test_flake8_config_param",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_flake8_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "with patch('pyls.plugins.flake8_lint.Popen') as popen_mock:\n    mock_instance = popen_mock.return_value\n    mock_instance.communicate.return_value = [bytes(), bytes()]\n    flake8_conf = '/tmp/some.cfg'\n    workspace._config.update({'plugins': {'flake8': {'config': flake8_conf}}})\n    _name, doc = temp_document(DOC, workspace)\n    flake8_lint.pyls_lint(workspace, doc)\n    call_args = popen_mock.call_args.args[0]\n    assert 'flake8' in call_args\n    assert '--config={}'.format(flake8_conf) in call_args\n",
        "CUT_1": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "return {'plugins': {'flake8': {'enabled': False}}}\nhookimpl",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_flake8_executable_param",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_flake8_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "with patch('pyls.plugins.flake8_lint.Popen') as popen_mock:\n    mock_instance = popen_mock.return_value\n    mock_instance.communicate.return_value = [bytes(), bytes()]\n    flake8_executable = '/tmp/flake8'\n    workspace._config.update({'plugins': {'flake8': {'executable':\n        flake8_executable}}})\n    _name, doc = temp_document(DOC, workspace)\n    flake8_lint.pyls_lint(workspace, doc)\n    call_args = popen_mock.call_args.args[0]\n    assert flake8_executable in call_args\n",
        "CUT_1": "\"\"\"Run flake8 with the provided arguments, logs errors\n    from stderr if any.\n    \"\"\"\nargs = [(i if not i.startswith('--ignore=') else FIX_IGNORES_RE.sub('', i)) for\n    i in args if i is not None]\nif not os.path.isfile(flake8_executable) and os.sep in flake8_executable:\n    flake8_executable = os.path.abspath(os.path.expanduser(os.path.\n        expandvars(flake8_executable)))\nlog.debug(\"Calling %s with args: '%s'\", flake8_executable, args)\ntry:\n    cmd = [flake8_executable]\n    cmd.extend(args)\n    p = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)\nexcept IOError:\n    log.debug(\"Can't execute %s. Trying with 'python -m flake8'\",\n        flake8_executable)\n    cmd = ['python', '-m', 'flake8']\n    cmd.extend(args)\n    p = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)\nstdout, stderr = p.communicate(document.source.encode())\nif stderr:\n    log.error(\"Error while running flake8 '%s'\", stderr.decode())\nreturn stdout.decode()\n",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "return {'plugins': {'flake8': {'enabled': False}}}\nhookimpl",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_numpy_hover",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_hover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "no_hov_position = {'line': 1, 'character': 0}\nnumpy_hov_position_1 = {'line': 2, 'character': 8}\nnumpy_hov_position_2 = {'line': 2, 'character': 17}\nnumpy_hov_position_3 = {'line': 3, 'character': 1}\nnumpy_sin_hov_position = {'line': 3, 'character': 4}\ndoc = Document(DOC_URI, workspace, NUMPY_DOC)\ncontents = ''\nassert contents in pyls_hover(doc, no_hov_position)['contents']\ncontents = \"\"\"NumPy\n=====\n\nProvides\n\"\"\"\nassert contents in pyls_hover(doc, numpy_hov_position_1)['contents'][0]\ncontents = \"\"\"NumPy\n=====\n\nProvides\n\"\"\"\nassert contents in pyls_hover(doc, numpy_hov_position_2)['contents'][0]\ncontents = \"\"\"NumPy\n=====\n\nProvides\n\"\"\"\nassert contents in pyls_hover(doc, numpy_hov_position_3)['contents'][0]\ncontents = 'Trigonometric sine, element-wise.\\n\\n'\nassert contents in pyls_hover(doc, numpy_sin_hov_position)['contents'][0]\n",
        "CUT_1": "contents = result['contents']\nif isinstance(contents, dict):\n    if 'value' in contents:\n        contents = contents['value']\nelif isinstance(contents, list):\n    text = []\n    for entry in contents:\n        if isinstance(entry, dict):\n            text.append(entry['value'])\n        else:\n            text.append(entry)\n    contents = '\\n\\n'.join(text)\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_HOVER, {'params': contents}\n        )\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_2": "contents = result['contents']\nif isinstance(contents, dict):\n    if 'value' in contents:\n        contents = contents['value']\nelif isinstance(contents, list):\n    text = []\n    for entry in contents:\n        if isinstance(entry, dict):\n            text.append(entry['value'])\n        else:\n            text.append(entry)\n    contents = '\\n\\n'.join(text)\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_HOVER, {'params': contents}\n        )\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_3": "return self._hook('pyls_hover', doc_uri, position=position) or {'contents': ''}\n",
        "CUT_4": "code_position = _utils.position_to_jedi_linecolumn(document, position)\ndefinitions = document.jedi_script().infer(**code_position)\nword = document.word_at_position(position)\ndefinition = next((x for x in definitions if x.name == word), None)\nif len(definitions) == 1:\n    definition = definitions[0]\nif not definition:\n    return {'contents': ''}\ndoc = _utils.format_docstring(definition.docstring(raw=True))\nsignature = next((x.to_string() for x in definition.get_signatures() if x.\n    name == word), '')\ncontents = []\nif signature:\n    contents.append({'language': 'python', 'value': signature})\nif doc:\n    contents.append(doc)\nif not contents:\n    return {'contents': ''}\nreturn {'contents': contents}\nhookimpl",
        "CUT_5": "\"\"\"Python doc strings come in a number of formats, but LSP wants markdown.\n\n    Until we can find a fast enough way of discovering and parsing each format,\n    we can do a little better by at least preserving indentation.\n    \"\"\"\ncontents = contents.replace('\\t', '\\xa0' * 4)\ncontents = contents.replace('  ', '\\xa0' * 2)\nreturn contents\n"
    },
    {
        "functionName": "test_hover",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_hover.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "hov_position = {'line': 2, 'character': 6}\nno_hov_position = {'line': 1, 'character': 0}\ndoc = Document(DOC_URI, workspace, DOC)\ncontents = [{'language': 'python', 'value': 'main()'}, 'hello world']\nassert {'contents': contents} == pyls_hover(doc, hov_position)\nassert {'contents': ''} == pyls_hover(doc, no_hov_position)\n",
        "CUT_1": "return self._hook('pyls_hover', doc_uri, position=position) or {'contents': ''}\n",
        "CUT_2": "code_position = _utils.position_to_jedi_linecolumn(document, position)\ndefinitions = document.jedi_script().infer(**code_position)\nword = document.word_at_position(position)\ndefinition = next((x for x in definitions if x.name == word), None)\nif len(definitions) == 1:\n    definition = definitions[0]\nif not definition:\n    return {'contents': ''}\ndoc = _utils.format_docstring(definition.docstring(raw=True))\nsignature = next((x.to_string() for x in definition.get_signatures() if x.\n    name == word), '')\ncontents = []\nif signature:\n    contents.append({'language': 'python', 'value': signature})\nif doc:\n    contents.append(doc)\nif not contents:\n    return {'contents': ''}\nreturn {'contents': contents}\nhookimpl",
        "CUT_3": "contents = result['contents']\nif isinstance(contents, dict):\n    if 'value' in contents:\n        contents = contents['value']\nelif isinstance(contents, list):\n    text = []\n    for entry in contents:\n        if isinstance(entry, dict):\n            text.append(entry['value'])\n        else:\n            text.append(entry)\n    contents = '\\n\\n'.join(text)\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_HOVER, {'params': contents}\n        )\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_4": "contents = result['contents']\nif isinstance(contents, dict):\n    if 'value' in contents:\n        contents = contents['value']\nelif isinstance(contents, list):\n    text = []\n    for entry in contents:\n        if isinstance(entry, dict):\n            text.append(entry['value'])\n        else:\n            text.append(entry)\n    contents = '\\n\\n'.join(text)\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_HOVER, {'params': contents}\n        )\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "temp_document",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pylint_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "try:\n    temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False)\n    name = temp_file.name\n    temp_file.write(doc_text)\n    temp_file.close()\n    yield Document(uris.from_fs_path(name), workspace)\nfinally:\n    os.remove(name)\ncontextlib.contextmanager",
        "CUT_1": "self.name = name\n",
        "CUT_2": "self.name = name\n",
        "CUT_3": "\"\"\"Returns a code cell name from a code cell comment.\"\"\"\nname = text.strip().lstrip('#% ')\nif name.startswith('<codecell>'):\n    name = name[10:].lstrip()\nelif name.startswith('In['):\n    name = name[2:]\n    if name.endswith(']:'):\n        name = name[:-1]\n    name = name.strip()\nreturn name\n",
        "CUT_4": "\"\"\"Returns a code cell name from a code cell comment.\"\"\"\nname = text.strip().lstrip('#% ')\nif name.startswith('<codecell>'):\n    name = name[10:].lstrip()\nelif name.startswith('In['):\n    name = name[2:]\n    if name.endswith(']:'):\n        name = name[:-1]\n    name = name.strip()\nreturn name\n",
        "CUT_5": "\"\"\"\n        Set widget name (plugin.NAME).\n        \"\"\"\nself._name = name\n"
    },
    {
        "functionName": "write_temp_doc",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pylint_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "with open(document.path, 'w') as temp_file:\n    temp_file.write(contents)\n",
        "CUT_1": "\"\"\"Return sys.path contents.\"\"\"\nreturn sys.path[:]\n",
        "CUT_2": "\"\"\"Write the given version number to the given _version.py file.\"\"\"\nos.unlink(filename)\ncontents = json.dumps(versions, sort_keys=True, indent=1, separators=(',',\n    ': '))\nwith open(filename, 'w') as f:\n    f.write(SHORT_VERSION_PY % contents)\nprint(\"set %s to '%s'\" % (filename, versions['version']))\n",
        "CUT_3": "contents = result['contents']\nif isinstance(contents, dict):\n    if 'value' in contents:\n        contents = contents['value']\nelif isinstance(contents, list):\n    text = []\n    for entry in contents:\n        if isinstance(entry, dict):\n            text.append(entry['value'])\n        else:\n            text.append(entry)\n    contents = '\\n\\n'.join(text)\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_HOVER, {'params': contents}\n        )\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_4": "contents = result['contents']\nif isinstance(contents, dict):\n    if 'value' in contents:\n        contents = contents['value']\nelif isinstance(contents, list):\n    text = []\n    for entry in contents:\n        if isinstance(entry, dict):\n            text.append(entry['value'])\n        else:\n            text.append(entry)\n    contents = '\\n\\n'.join(text)\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_HOVER, {'params': contents}\n        )\nhandles(LSPRequestTypes.DOCUMENT_HOVER)",
        "CUT_5": "\"\"\"Save language setting to language config file\"\"\"\ntry:\n    with open(LANG_FILE, 'w') as f:\n        f.write(value)\nexcept EnvironmentError:\n    pass\n"
    },
    {
        "functionName": "test_pylint",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pylint_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "with temp_document(DOC, workspace) as doc:\n    diags = pylint_lint.pyls_lint(config, doc, True)\n    msg = '[unused-import] Unused import sys'\n    unused_import = [d for d in diags if d['message'] == msg][0]\n    assert unused_import['range']['start'] == {'line': 0, 'character': 0}\n    assert unused_import['severity'] == lsp.DiagnosticSeverity.Warning\n    if IS_PY3:\n        config.plugin_settings('pylint')['executable'] = 'pylint'\n        diags = pylint_lint.pyls_lint(config, doc, True)\n        msg = 'Unused import sys (unused-import)'\n        unused_import = [d for d in diags if d['message'] == msg][0]\n        assert unused_import['range']['start'] == {'line': 0, 'character': 0}\n        assert unused_import['severity'] == lsp.DiagnosticSeverity.Warning\n",
        "CUT_1": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_2": "\"\"\" Get message like <filename>:<lineno>: <msg> \"\"\"\nerr_range = {'start': {'line': message.lineno - 1, 'character': message.col\n    }, 'end': {'line': message.lineno - 1, 'character': len(self.lines[\n    message.lineno - 1])}}\nseverity = lsp.DiagnosticSeverity.Warning\nfor message_type in PYFLAKES_ERROR_MESSAGES:\n    if isinstance(message, message_type):\n        severity = lsp.DiagnosticSeverity.Error\n        break\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': message.message % message.message_args, 'severity': severity})\n",
        "CUT_3": "\"\"\"Parse pylint results.\n\n    :param document: document to run pylint on\n    :type document: pyls.workspace.Document\n    :param stdout: pylint results to parse\n    :type stdout: string\n\n    :return: linting diagnostics\n    :rtype: list\n    \"\"\"\ndiagnostics = []\nlines = stdout.splitlines()\nfor raw_line in lines:\n    parsed_line = re.match('(.*):(\\\\d*):(\\\\d*): (\\\\w*): (.*)', raw_line)\n    if not parsed_line:\n        log.debug(\"Pylint output parser can't parse line '%s'\", raw_line)\n        continue\n    parsed_line = parsed_line.groups()\n    if len(parsed_line) != 5:\n        log.debug(\"Pylint output parser can't parse line '%s'\", raw_line)\n        continue\n    _, line, character, code, msg = parsed_line\n    line = int(line) - 1\n    character = int(character)\n    severity_map = {'C': lsp.DiagnosticSeverity.Information, 'E': lsp.\n        DiagnosticSeverity.Error, 'F': lsp.DiagnosticSeverity.Error, 'R':\n        lsp.DiagnosticSeverity.Hint, 'W': lsp.DiagnosticSeverity.Warning}\n    severity = severity_map[code[0]]\n    diagnostics.append({'source': 'pylint', 'code': code, 'range': {'start':\n        {'line': line, 'character': character}, 'end': {'line': line,\n        'character': len(document.lines[line]) - 1}}, 'message': msg,\n        'severity': severity})\nreturn diagnostics\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_syntax_error_pylint_py3",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pylint_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "with temp_document(DOC_SYNTAX_ERR, workspace) as doc:\n    diag = pylint_lint.pyls_lint(config, doc, True)[0]\n    assert diag['message'].startswith('[syntax-error] invalid syntax')\n    assert diag['range']['start'] == {'line': 0, 'character': 12}\n    assert diag['severity'] == lsp.DiagnosticSeverity.Error\n    config.plugin_settings('pylint')['executable'] = 'pylint'\n    diag = pylint_lint.pyls_lint(config, doc, True)[0]\n    assert diag['message'].startswith('invalid syntax')\n    assert diag['range']['start'] == {'line': 0, 'character': 12}\n    assert diag['severity'] == lsp.DiagnosticSeverity.Error\npy3_only",
        "CUT_1": "\"\"\"Plugin interface to pyls linter.\n\n        Args:\n            document: The document to be linted.\n            is_saved: Whether or not the file has been saved to disk.\n            flags: Additional flags to pass to pylint. Not exposed to\n                pyls_lint, but used for testing.\n\n        Returns:\n            A list of dicts with the following format:\n\n                {\n                    'source': 'pylint',\n                    'range': {\n                        'start': {\n                            'line': start_line,\n                            'character': start_column,\n                        },\n                        'end': {\n                            'line': end_line,\n                            'character': end_column,\n                        },\n                    }\n                    'message': msg,\n                    'severity': lsp.DiagnosticSeverity.*,\n                }\n        \"\"\"\nif not is_saved:\n    return cls.last_diags[document.path]\npath = document.path\nif sys.platform.startswith('win'):\n    path = path.replace('\\\\', '/')\npylint_call = '{} -f json {}'.format(path, flags)\nlog.debug(\"Calling pylint with '%s'\", pylint_call)\njson_out, err = py_run(pylint_call, return_std=True)\njson_out = json_out.getvalue()\nerr = err.getvalue()\nif err != '':\n    log.error(\"Error calling pylint: '%s'\", err)\nif not json_out.strip():\n    cls.last_diags[document.path] = []\n    return []\ndiagnostics = []\nfor diag in json.loads(json_out):\n    line = diag['line'] - 1\n    err_range = {'start': {'line': line, 'character': diag['column']},\n        'end': {'line': line, 'character': len(document.lines[line]) if\n        document.lines else 0}}\n    if diag['type'] == 'convention':\n        severity = lsp.DiagnosticSeverity.Information\n    elif diag['type'] == 'error':\n        severity = lsp.DiagnosticSeverity.Error\n    elif diag['type'] == 'fatal':\n        severity = lsp.DiagnosticSeverity.Error\n    elif diag['type'] == 'refactor':\n        severity = lsp.DiagnosticSeverity.Hint\n    elif diag['type'] == 'warning':\n        severity = lsp.DiagnosticSeverity.Warning\n    diagnostics.append({'source': 'pylint', 'range': err_range, 'message':\n        '[{}] {}'.format(diag['symbol'], diag['message']), 'severity':\n        severity, 'code': diag['message-id']})\ncls.last_diags[document.path] = diagnostics\nreturn diagnostics\nclassmethod",
        "CUT_2": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_3": "\"\"\" Get message like <filename>:<lineno>: <msg> \"\"\"\nerr_range = {'start': {'line': message.lineno - 1, 'character': message.col\n    }, 'end': {'line': message.lineno - 1, 'character': len(self.lines[\n    message.lineno - 1])}}\nseverity = lsp.DiagnosticSeverity.Warning\nfor message_type in PYFLAKES_ERROR_MESSAGES:\n    if isinstance(message, message_type):\n        severity = lsp.DiagnosticSeverity.Error\n        break\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': message.message % message.message_args, 'severity': severity})\n",
        "CUT_4": "\"\"\"Parse pylint results.\n\n    :param document: document to run pylint on\n    :type document: pyls.workspace.Document\n    :param stdout: pylint results to parse\n    :type stdout: string\n\n    :return: linting diagnostics\n    :rtype: list\n    \"\"\"\ndiagnostics = []\nlines = stdout.splitlines()\nfor raw_line in lines:\n    parsed_line = re.match('(.*):(\\\\d*):(\\\\d*): (\\\\w*): (.*)', raw_line)\n    if not parsed_line:\n        log.debug(\"Pylint output parser can't parse line '%s'\", raw_line)\n        continue\n    parsed_line = parsed_line.groups()\n    if len(parsed_line) != 5:\n        log.debug(\"Pylint output parser can't parse line '%s'\", raw_line)\n        continue\n    _, line, character, code, msg = parsed_line\n    line = int(line) - 1\n    character = int(character)\n    severity_map = {'C': lsp.DiagnosticSeverity.Information, 'E': lsp.\n        DiagnosticSeverity.Error, 'F': lsp.DiagnosticSeverity.Error, 'R':\n        lsp.DiagnosticSeverity.Hint, 'W': lsp.DiagnosticSeverity.Warning}\n    severity = severity_map[code[0]]\n    diagnostics.append({'source': 'pylint', 'code': code, 'range': {'start':\n        {'line': line, 'character': character}, 'end': {'line': line,\n        'character': len(document.lines[line]) - 1}}, 'message': msg,\n        'severity': severity})\nreturn diagnostics\n",
        "CUT_5": "lineno = error.definition.start - 1\nline = document.lines[0] if document.lines else ''\nstart_character = len(line) - len(line.lstrip())\nend_character = len(line)\nreturn {'source': 'pydocstyle', 'code': error.code, 'message': error.\n    message, 'severity': lsp.DiagnosticSeverity.Warning, 'range': {'start':\n    {'line': lineno, 'character': start_character}, 'end': {'line': lineno,\n    'character': end_character}}}\n"
    },
    {
        "functionName": "test_syntax_error_pylint_py2",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pylint_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "with temp_document(DOC_SYNTAX_ERR, workspace) as doc:\n    diag = pylint_lint.pyls_lint(config, doc, True)[0]\n    assert diag['message'].startswith('[syntax-error] invalid syntax')\n    assert diag['range']['start'] == {'line': 0, 'character': 0}\n    assert diag['severity'] == lsp.DiagnosticSeverity.Error\npy2_only",
        "CUT_1": "\"\"\"Plugin interface to pyls linter.\n\n        Args:\n            document: The document to be linted.\n            is_saved: Whether or not the file has been saved to disk.\n            flags: Additional flags to pass to pylint. Not exposed to\n                pyls_lint, but used for testing.\n\n        Returns:\n            A list of dicts with the following format:\n\n                {\n                    'source': 'pylint',\n                    'range': {\n                        'start': {\n                            'line': start_line,\n                            'character': start_column,\n                        },\n                        'end': {\n                            'line': end_line,\n                            'character': end_column,\n                        },\n                    }\n                    'message': msg,\n                    'severity': lsp.DiagnosticSeverity.*,\n                }\n        \"\"\"\nif not is_saved:\n    return cls.last_diags[document.path]\npath = document.path\nif sys.platform.startswith('win'):\n    path = path.replace('\\\\', '/')\npylint_call = '{} -f json {}'.format(path, flags)\nlog.debug(\"Calling pylint with '%s'\", pylint_call)\njson_out, err = py_run(pylint_call, return_std=True)\njson_out = json_out.getvalue()\nerr = err.getvalue()\nif err != '':\n    log.error(\"Error calling pylint: '%s'\", err)\nif not json_out.strip():\n    cls.last_diags[document.path] = []\n    return []\ndiagnostics = []\nfor diag in json.loads(json_out):\n    line = diag['line'] - 1\n    err_range = {'start': {'line': line, 'character': diag['column']},\n        'end': {'line': line, 'character': len(document.lines[line]) if\n        document.lines else 0}}\n    if diag['type'] == 'convention':\n        severity = lsp.DiagnosticSeverity.Information\n    elif diag['type'] == 'error':\n        severity = lsp.DiagnosticSeverity.Error\n    elif diag['type'] == 'fatal':\n        severity = lsp.DiagnosticSeverity.Error\n    elif diag['type'] == 'refactor':\n        severity = lsp.DiagnosticSeverity.Hint\n    elif diag['type'] == 'warning':\n        severity = lsp.DiagnosticSeverity.Warning\n    diagnostics.append({'source': 'pylint', 'range': err_range, 'message':\n        '[{}] {}'.format(diag['symbol'], diag['message']), 'severity':\n        severity, 'code': diag['message-id']})\ncls.last_diags[document.path] = diagnostics\nreturn diagnostics\nclassmethod",
        "CUT_2": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_3": "\"\"\" Get message like <filename>:<lineno>: <msg> \"\"\"\nerr_range = {'start': {'line': message.lineno - 1, 'character': message.col\n    }, 'end': {'line': message.lineno - 1, 'character': len(self.lines[\n    message.lineno - 1])}}\nseverity = lsp.DiagnosticSeverity.Warning\nfor message_type in PYFLAKES_ERROR_MESSAGES:\n    if isinstance(message, message_type):\n        severity = lsp.DiagnosticSeverity.Error\n        break\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': message.message % message.message_args, 'severity': severity})\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_lint_free_pylint",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pylint_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert not pylint_lint.pyls_lint(config, Document(uris.from_fs_path(\n    __file__), workspace), True)\n",
        "CUT_1": "fn = os.path.join(workspace.root_path, name)\nwith open(fn, 'w') as f:\n    f.write(content)\nworkspace.put_document(uris.from_fs_path(fn), content)\n",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture",
        "CUT_4": "\"\"\"Return a workspace.\"\"\"\nws = Workspace(uris.from_fs_path(str(tmpdir)), Mock())\nws._config = Config(ws.root_uri, {}, 0, {})\nreturn ws\npytest.fixture",
        "CUT_5": "def create_file(name, content):\n    fn = os.path.join(workspace.root_path, name)\n    with open(fn, 'w') as f:\n        f.write(content)\n    workspace.put_document(uris.from_fs_path(fn), content)\nfor name, content in files.items():\n    create_file(name, content)\nreturn workspace\n"
    },
    {
        "functionName": "test_lint_caching",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pylint_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "flags = '--disable=invalid-name'\nwith temp_document(DOC, workspace) as doc:\n    diags = pylint_lint.PylintLinter.lint(doc, True, flags)\n    assert diags\n    write_temp_doc(doc, '')\n    assert pylint_lint.PylintLinter.lint(doc, False, flags) == diags\n    assert not pylint_lint.PylintLinter.lint(doc, True, flags)\n    assert not pylint_lint.PylintLinter.lint(doc, False, flags)\n",
        "CUT_1": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n"
    },
    {
        "functionName": "test_per_file_caching",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pylint_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "with temp_document(DOC, workspace) as doc:\n    assert pylint_lint.pyls_lint(config, doc, True)\nassert not pylint_lint.pyls_lint(config, Document(uris.from_fs_path(\n    __file__), workspace), False)\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_definitions",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_definitions.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "cursor_pos = {'line': 3, 'character': 6}\ndef_range = {'start': {'line': 0, 'character': 4}, 'end': {'line': 0,\n    'character': 5}}\ndoc = Document(DOC_URI, workspace, DOC)\nassert [{'uri': DOC_URI, 'range': def_range}] == pyls_definitions(config,\n    doc, cursor_pos)\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "range['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nlines = [(range['start']['line'] + 1, range['end']['line'] + 1)]\nreturn _format(document, lines=lines)\nhookimpl",
        "CUT_3": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_4": "\"\"\"Handle go to definition response.\"\"\"\ntry:\n    position = position['params']\n    if position is not None:\n        def_range = position['range']\n        start = def_range['start']\n        if self.filename == position['file']:\n            self.go_to_line(start['line'] + 1, start['character'], None,\n                word=None)\n        else:\n            self.go_to_definition.emit(position['file'], start['line'] + 1,\n                start['character'])\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing go to definition')\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_5": "\"\"\"Handle go to definition response.\"\"\"\ntry:\n    position = position['params']\n    if position is not None:\n        def_range = position['range']\n        start = def_range['start']\n        if self.filename == position['file']:\n            self.go_to_line(start['line'] + 1, start['character'], None,\n                word=None)\n        else:\n            self.go_to_definition.emit(position['file'], start['line'] + 1,\n                start['character'])\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing go to definition')\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)"
    },
    {
        "functionName": "test_builtin_definition",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_definitions.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "cursor_pos = {'line': 8, 'character': 24}\ndoc = Document(DOC_URI, workspace, DOC)\nassert not pyls_definitions(config, doc, cursor_pos)\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_assignment",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_definitions.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "cursor_pos = {'line': 11, 'character': 19}\ndef_range = {'start': {'line': 8, 'character': 13}, 'end': {'line': 8,\n    'character': 20}}\ndoc = Document(DOC_URI, workspace, DOC)\nassert [{'uri': DOC_URI, 'range': def_range}] == pyls_definitions(config,\n    doc, cursor_pos)\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "range['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nlines = [(range['start']['line'] + 1, range['end']['line'] + 1)]\nreturn _format(document, lines=lines)\nhookimpl",
        "CUT_3": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_4": "\"\"\"Handle go to definition response.\"\"\"\ntry:\n    position = position['params']\n    if position is not None:\n        def_range = position['range']\n        start = def_range['start']\n        if self.filename == position['file']:\n            self.go_to_line(start['line'] + 1, start['character'], None,\n                word=None)\n        else:\n            self.go_to_definition.emit(position['file'], start['line'] + 1,\n                start['character'])\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing go to definition')\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)",
        "CUT_5": "\"\"\"Handle go to definition response.\"\"\"\ntry:\n    position = position['params']\n    if position is not None:\n        def_range = position['range']\n        start = def_range['start']\n        if self.filename == position['file']:\n            self.go_to_line(start['line'] + 1, start['character'], None,\n                word=None)\n        else:\n            self.go_to_definition.emit(position['file'], start['line'] + 1,\n                start['character'])\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing go to definition')\nhandles(LSPRequestTypes.DOCUMENT_DEFINITION)"
    },
    {
        "functionName": "test_no_signature",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_signature.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "sig_position = {'line': 9, 'character': 0}\ndoc = Document(DOC_URI, workspace, DOC)\nsigs = signature.pyls_signature_help(doc, sig_position)['signatures']\nassert not sigs\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_signature",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_signature.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "sig_position = {'line': 10, 'character': 5}\ndoc = Document(DOC_URI, workspace, DOC)\nsig_info = signature.pyls_signature_help(doc, sig_position)\nsigs = sig_info['signatures']\nassert len(sigs) == 1\nassert sigs[0]['label'] == 'main(param1, param2)'\nassert sigs[0]['parameters'][0]['label'] == 'param1'\nassert sigs[0]['parameters'][0]['documentation'] == 'Docs for param1'\nassert sig_info['activeParameter'] == 0\n",
        "CUT_1": "code_position = _utils.position_to_jedi_linecolumn(document, position)\nsignatures = document.jedi_script().get_signatures(**code_position)\nif not signatures:\n    return {'signatures': []}\ns = signatures[0]\nfunction_sig_lines = (s.docstring().split('\\n\\n') or [''])[0].splitlines()\nfunction_sig = ' '.join([line.strip() for line in function_sig_lines])\nsig = {'label': function_sig, 'documentation': _utils.format_docstring(s.\n    docstring(raw=True))}\nif s.params:\n    sig['parameters'] = [{'label': p.name, 'documentation': _param_docs(s.\n        docstring(), p.name)} for p in s.params]\nsig_info = {'signatures': [sig], 'activeSignature': 0}\nif s.index is not None and s.params:\n    sig_info['activeParameter'] = s.index\nreturn sig_info\nhookimpl",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_multi_line_signature",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_signature.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "sig_position = {'line': 17, 'character': 5}\ndoc = Document(DOC_URI, workspace, MULTI_LINE_DOC)\nsig_info = signature.pyls_signature_help(doc, sig_position)\nsigs = sig_info['signatures']\nassert len(sigs) == 1\nassert sigs[0]['label'\n    ] == 'main(param1=None, param2=None, param3=None, param4=None, param5=None, param6=None, param7=None, param8=None)'\nassert sigs[0]['parameters'][0]['label'] == 'param1'\nassert sigs[0]['parameters'][0]['documentation'] == 'Docs for param1'\nassert sig_info['activeParameter'] == 0\n",
        "CUT_1": "code_position = _utils.position_to_jedi_linecolumn(document, position)\nsignatures = document.jedi_script().get_signatures(**code_position)\nif not signatures:\n    return {'signatures': []}\ns = signatures[0]\nfunction_sig_lines = (s.docstring().split('\\n\\n') or [''])[0].splitlines()\nfunction_sig = ' '.join([line.strip() for line in function_sig_lines])\nsig = {'label': function_sig, 'documentation': _utils.format_docstring(s.\n    docstring(raw=True))}\nif s.params:\n    sig['parameters'] = [{'label': p.name, 'documentation': _param_docs(s.\n        docstring(), p.name)} for p in s.params]\nsig_info = {'signatures': [sig], 'activeSignature': 0}\nif s.index is not None and s.params:\n    sig_info['activeParameter'] = s.index\nreturn sig_info\nhookimpl",
        "CUT_2": "self.args = None\nself.args_enabled = None\nself.wdir = None\nself.wdir_enabled = None\nself.current = None\nself.systerm = None\nself.interact = None\nself.post_mortem = None\nself.python_args = None\nself.python_args_enabled = None\nself.clear_namespace = None\nself.console_namespace = None\nself.file_dir = None\nself.cw_dir = None\nself.fixed_dir = None\nself.dir = None\nself.set(CONF.get('run', 'defaultconfiguration', default={}))\n",
        "CUT_3": "self.args = None\nself.args_enabled = None\nself.wdir = None\nself.wdir_enabled = None\nself.current = None\nself.systerm = None\nself.interact = None\nself.post_mortem = None\nself.python_args = None\nself.python_args_enabled = None\nself.clear_namespace = None\nself.console_namespace = None\nself.file_dir = None\nself.cw_dir = None\nself.fixed_dir = None\nself.dir = None\nself.set(CONF.get('run', 'defaultconfiguration', default={}))\n",
        "CUT_4": "QWidget.__init__(self, parent)\nself.shellwidget = None\nself.is_visible = True\nself.setup_in_progress = None\nself.check_all = None\nself.exclude_private = None\nself.exclude_uppercase = None\nself.exclude_capitalized = None\nself.exclude_unsupported = None\nself.exclude_callables_and_modules = None\nself.excluded_names = None\nself.minmax = None\nself.dataframe_format = None\nself.show_callable_attributes = None\nself.show_special_attributes = None\nself.editor = None\nself.exclude_private_action = None\nself.exclude_uppercase_action = None\nself.exclude_capitalized_action = None\nself.exclude_unsupported_action = None\nself.exclude_callables_and_modules_action = None\nself.finder = None\nself.options_button = options_button\nself.actions = None\nself.plugin_actions = plugin_actions\nself.filename = None\n",
        "CUT_5": "QWidget.__init__(self, parent)\nself.shellwidget = None\nself.is_visible = True\nself.setup_in_progress = None\nself.check_all = None\nself.exclude_private = None\nself.exclude_uppercase = None\nself.exclude_capitalized = None\nself.exclude_unsupported = None\nself.exclude_callables_and_modules = None\nself.excluded_names = None\nself.minmax = None\nself.dataframe_format = None\nself.show_callable_attributes = None\nself.show_special_attributes = None\nself.editor = None\nself.exclude_private_action = None\nself.exclude_uppercase_action = None\nself.exclude_capitalized_action = None\nself.exclude_unsupported_action = None\nself.exclude_callables_and_modules_action = None\nself.finder = None\nself.options_button = options_button\nself.actions = None\nself.plugin_actions = plugin_actions\nself.filename = None\n"
    },
    {
        "functionName": "test_docstring_params",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_signature.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "m = regex.match(doc)\nassert m.group('param') == 'test'\nassert m.group('doc') == 'parameter docstring'\npytest.mark.parametrize('regex,doc', [(signature.SPHINX,\n    '    :param test: parameter docstring'), (signature.EPYDOC,\n    '    @param test: parameter docstring'), (signature.GOOGLE,\n    '    test (str): parameter docstring')])",
        "CUT_1": "for line in docstring.splitlines():\n    for regex in DOC_REGEX:\n        m = regex.match(line)\n        if not m:\n            continue\n        if m.group('param') != param_name:\n            continue\n        return m.group('doc') or ''\n",
        "CUT_2": "\"\"\"\n            Handle substitution of active parameter template.\n\n            This ensures the correct highlight of the active parameter.\n            \"\"\"\nmatch = matchobj.group(0)\nnew = match.replace(parameter, active_parameter_template)\nreturn new\n",
        "CUT_3": "\"\"\"\n            Handle substitution of active parameter template.\n\n            This ensures the correct highlight of the active parameter.\n            \"\"\"\nmatch = matchobj.group(0)\nnew = match.replace(parameter, active_parameter_template)\nreturn new\n",
        "CUT_4": "\"\"\"\n    Return text documentation from an object. This comes in a form of\n    dictionary with four keys:\n\n    name:\n      The name of the inspected object\n    argspec:\n      It's argspec\n    note:\n      A phrase describing the type of object (function or method) we are\n      inspecting, and the module it belongs to.\n    docstring:\n      It's docstring\n    \"\"\"\ndocstring = inspect.getdoc(obj) or inspect.getcomments(obj) or ''\ntry:\n    docstring = to_text_string(docstring)\nexcept:\n    pass\ndoc = {'name': '', 'argspec': '', 'note': '', 'docstring': docstring}\nif callable(obj):\n    try:\n        name = obj.__name__\n    except AttributeError:\n        doc['docstring'] = docstring\n        return doc\n    if inspect.ismethod(obj):\n        imclass = get_meth_class(obj)\n        if get_meth_class_inst(obj) is not None:\n            doc['note'] = 'Method of %s instance' % get_meth_class_inst(obj\n                ).__class__.__name__\n        else:\n            doc['note'] = 'Unbound %s method' % imclass.__name__\n        obj = get_meth_func(obj)\n    elif hasattr(obj, '__module__'):\n        doc['note'] = 'Function of %s module' % obj.__module__\n    else:\n        doc['note'] = 'Function'\n    doc['name'] = obj.__name__\n    if inspect.isfunction(obj):\n        if PY2:\n            args, varargs, varkw, defaults = inspect.getargspec(obj)\n            doc['argspec'] = inspect.formatargspec(args, varargs, varkw,\n                defaults, formatvalue=lambda o: '=' + repr(o))\n        else:\n            (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults,\n                annotations) = inspect.getfullargspec(obj)\n            doc['argspec'] = inspect.formatargspec(args, varargs, varkw,\n                defaults, kwonlyargs, kwonlydefaults, annotations,\n                formatvalue=lambda o: '=' + repr(o))\n        if name == '<lambda>':\n            doc['name'] = name + ' lambda '\n            doc['argspec'] = doc['argspec'][1:-1]\n    else:\n        argspec = getargspecfromtext(doc['docstring'])\n        if argspec:\n            doc['argspec'] = argspec\n            signature = doc['name'] + doc['argspec']\n            docstring_blocks = doc['docstring'].split('\\n\\n')\n            first_block = docstring_blocks[0].strip()\n            if first_block == signature:\n                doc['docstring'] = doc['docstring'].replace(signature, '', 1\n                    ).lstrip()\n        else:\n            doc['argspec'] = '(...)'\n    argspec = doc['argspec']\n    doc['argspec'] = argspec.replace('(self)', '()').replace('(self, ', '(')\nreturn doc\n",
        "CUT_5": "\"\"\"\n        Create HTML template for signature.\n\n        This template will include indent after the method name, a highlight\n        color for the active parameter and highlights for special chars.\n\n        Special chars depend on the language.\n        \"\"\"\nlanguage = getattr(self, 'language', language).lower()\nactive_parameter_template = (\n    '<span style=\\'font-family:\"{font_family}\";font-size:{font_size}pt;color:{color}\\'><b>{parameter}</b></span>'\n    )\nchars_template = '<span style=\"color:{0};'.format(self._CHAR_HIGHLIGHT_COLOR\n    ) + 'font-weight:bold\">{char}</span>'\ndef handle_sub(matchobj):\n    \"\"\"\n            Handle substitution of active parameter template.\n\n            This ensures the correct highlight of the active parameter.\n            \"\"\"\n    match = matchobj.group(0)\n    new = match.replace(parameter, active_parameter_template)\n    return new\nif not isinstance(signatures, list):\n    signatures = [signatures]\nnew_signatures = []\nfor signature in signatures:\n    signature = ' '.join(signature.split())\n    signature = signature.replace('( ', '(')\n    if parameter and language == 'python':\n        escape_regex_chars = ['|', '.', '^', '$', '*', '+']\n        remove_regex_chars = ['(', ')', '{', '}', '[', ']']\n        regex_parameter = parameter\n        for regex_char in (escape_regex_chars + remove_regex_chars):\n            if regex_char in escape_regex_chars:\n                escape_char = '\\\\{char}'.format(char=regex_char)\n                regex_parameter = regex_parameter.replace(regex_char,\n                    escape_char)\n            else:\n                regex_parameter = regex_parameter.replace(regex_char, '')\n                parameter = parameter.replace(regex_char, '')\n        pattern = '[\\\\*|\\\\(|\\\\[|\\\\s](' + regex_parameter + ')[,|\\\\)|\\\\]|\\\\s|=]'\n    formatted_lines = []\n    name = signature.split('(')[0]\n    indent = ' ' * (len(name) + 1)\n    rows = textwrap.wrap(signature, width=max_width, subsequent_indent=indent)\n    for row in rows:\n        if parameter and language == 'python':\n            row = re.sub(pattern, handle_sub, row)\n        row = row.replace(' ', '&nbsp;')\n        row = row.replace('span&nbsp;', 'span ')\n        row = row.replace('{}', '{{}}')\n        if language and language == 'python':\n            for char in ['(', ')', ',', '*', '**']:\n                new_char = chars_template.format(char=char)\n                row = row.replace(char, new_char)\n        formatted_lines.append(row)\n    title_template = '<br>'.join(formatted_lines)\n    font = self.font()\n    font_size = font.pointSize()\n    font_family = font.family()\n    if parameter and language == 'python':\n        title = title_template.format(font_size=font_size, font_family=\n            font_family, color=parameter_color, parameter=parameter)\n    else:\n        title = title_template\n    new_signatures.append(title)\nreturn '<br>'.join(new_signatures)\n"
    },
    {
        "functionName": "test_highlight",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_highlight.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "cursor_pos = {'line': 1, 'character': 0}\ndoc = Document(DOC_URI, workspace, DOC)\nassert pyls_document_highlight(doc, cursor_pos) == [{'range': {'start': {\n    'line': 0, 'character': 0}, 'end': {'line': 0, 'character': 1}}, 'kind':\n    lsp.DocumentHighlightKind.Write}, {'range': {'start': {'line': 1,\n    'character': 0}, 'end': {'line': 1, 'character': 1}}, 'kind': lsp.\n    DocumentHighlightKind.Read}]\n",
        "CUT_1": "range['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nlines = [(range['start']['line'] + 1, range['end']['line'] + 1)]\nreturn _format(document, lines=lines)\nhookimpl",
        "CUT_2": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_3": "log.info('Formatting document %s in range %s with autopep8', document, range)\nrange['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nline_range = range['start']['line'] + 1, range['end']['line'] + 1\nreturn _format(config, document, line_range=line_range)\nhookimpl(tryfirst=True)",
        "CUT_4": "code_position = _utils.position_to_jedi_linecolumn(document, position)\nusages = document.jedi_script().get_references(**code_position)\ndef is_valid(definition):\n    return definition.line is not None and definition.column is not None\ndef local_to_document(definition):\n    return not definition.module_path or str(definition.module_path\n        ) == document.path\nreturn [{'range': {'start': {'line': d.line - 1, 'character': d.column},\n    'end': {'line': d.line - 1, 'character': d.column + len(d.name)}},\n    'kind': lsp.DocumentHighlightKind.Write if d.is_definition() else lsp.\n    DocumentHighlightKind.Read} for d in usages if is_valid(d) and\n    local_to_document(d)]\nhookimpl",
        "CUT_5": "\"\"\"\n    Build a diagnostics from flake8's output, it should extract every result and format\n    it into a dict that looks like this:\n        {\n            'source': 'flake8',\n            'code': code, # 'E501'\n            'range': {\n                'start': {\n                    'line': start_line,\n                    'character': start_column,\n                },\n                'end': {\n                    'line': end_line,\n                    'character': end_column,\n                },\n            },\n            'message': msg,\n            'severity': lsp.DiagnosticSeverity.*,\n        }\n\n    Args:\n        document: The document to be linted.\n        stdout: output from flake8\n    Returns:\n        A list of dictionaries.\n    \"\"\"\ndiagnostics = []\nlines = stdout.splitlines()\nfor raw_line in lines:\n    parsed_line = re.match('(.*):(\\\\d*):(\\\\d*): (\\\\w*) (.*)', raw_line)\n    if not parsed_line:\n        log.debug(\"Flake8 output parser can't parse line '%s'\", raw_line)\n        continue\n    parsed_line = parsed_line.groups()\n    if len(parsed_line) != 5:\n        log.debug(\"Flake8 output parser can't parse line '%s'\", raw_line)\n        continue\n    _, line, character, code, msg = parsed_line\n    line = int(line) - 1\n    character = int(character) - 1\n    diagnostics.append({'source': 'flake8', 'code': code, 'range': {'start':\n        {'line': line, 'character': character}, 'end': {'line': line,\n        'character': len(document.lines[line])}}, 'message': msg,\n        'severity': lsp.DiagnosticSeverity.Warning})\nreturn diagnostics\n"
    },
    {
        "functionName": "test_sys_highlight",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_highlight.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "cursor_pos = {'line': 0, 'character': 8}\ndoc = Document(DOC_URI, workspace, SYS_DOC)\nassert pyls_document_highlight(doc, cursor_pos) == [{'range': {'start': {\n    'line': 0, 'character': 7}, 'end': {'line': 0, 'character': 10}},\n    'kind': lsp.DocumentHighlightKind.Write}, {'range': {'start': {'line': \n    1, 'character': 6}, 'end': {'line': 1, 'character': 9}}, 'kind': lsp.\n    DocumentHighlightKind.Read}]\n",
        "CUT_1": "range['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nlines = [(range['start']['line'] + 1, range['end']['line'] + 1)]\nreturn _format(document, lines=lines)\nhookimpl",
        "CUT_2": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_3": "log.info('Formatting document %s in range %s with autopep8', document, range)\nrange['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nline_range = range['start']['line'] + 1, range['end']['line'] + 1\nreturn _format(config, document, line_range=line_range)\nhookimpl(tryfirst=True)",
        "CUT_4": "code_position = _utils.position_to_jedi_linecolumn(document, position)\nusages = document.jedi_script().get_references(**code_position)\ndef is_valid(definition):\n    return definition.line is not None and definition.column is not None\ndef local_to_document(definition):\n    return not definition.module_path or str(definition.module_path\n        ) == document.path\nreturn [{'range': {'start': {'line': d.line - 1, 'character': d.column},\n    'end': {'line': d.line - 1, 'character': d.column + len(d.name)}},\n    'kind': lsp.DocumentHighlightKind.Write if d.is_definition() else lsp.\n    DocumentHighlightKind.Read} for d in usages if is_valid(d) and\n    local_to_document(d)]\nhookimpl",
        "CUT_5": "\"\"\"\n    Build a diagnostics from flake8's output, it should extract every result and format\n    it into a dict that looks like this:\n        {\n            'source': 'flake8',\n            'code': code, # 'E501'\n            'range': {\n                'start': {\n                    'line': start_line,\n                    'character': start_column,\n                },\n                'end': {\n                    'line': end_line,\n                    'character': end_column,\n                },\n            },\n            'message': msg,\n            'severity': lsp.DiagnosticSeverity.*,\n        }\n\n    Args:\n        document: The document to be linted.\n        stdout: output from flake8\n    Returns:\n        A list of dictionaries.\n    \"\"\"\ndiagnostics = []\nlines = stdout.splitlines()\nfor raw_line in lines:\n    parsed_line = re.match('(.*):(\\\\d*):(\\\\d*): (\\\\w*) (.*)', raw_line)\n    if not parsed_line:\n        log.debug(\"Flake8 output parser can't parse line '%s'\", raw_line)\n        continue\n    parsed_line = parsed_line.groups()\n    if len(parsed_line) != 5:\n        log.debug(\"Flake8 output parser can't parse line '%s'\", raw_line)\n        continue\n    _, line, character, code, msg = parsed_line\n    line = int(line) - 1\n    character = int(character) - 1\n    diagnostics.append({'source': 'flake8', 'code': code, 'range': {'start':\n        {'line': line, 'character': character}, 'end': {'line': line,\n        'character': len(document.lines[line])}}, 'message': msg,\n        'severity': lsp.DiagnosticSeverity.Warning})\nreturn diagnostics\n"
    },
    {
        "functionName": "test_pycodestyle",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pycodestyle_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\ndiags = pycodestyle_lint.pyls_lint(workspace, doc)\nassert all([(d['source'] == 'pycodestyle') for d in diags])\nmsg = 'W191 indentation contains tabs'\nmod_import = [d for d in diags if d['message'] == msg][0]\nassert mod_import['code'] == 'W191'\nassert mod_import['severity'] == lsp.DiagnosticSeverity.Warning\nassert mod_import['range']['start'] == {'line': 3, 'character': 0}\nassert mod_import['range']['end'] == {'line': 3, 'character': 6}\nmsg = 'W391 blank line at end of file'\nmod_import = [d for d in diags if d['message'] == msg][0]\nassert mod_import['code'] == 'W391'\nassert mod_import['severity'] == lsp.DiagnosticSeverity.Warning\nassert mod_import['range']['start'] == {'line': 10, 'character': 0}\nassert mod_import['range']['end'] == {'line': 10, 'character': 1}\nmsg = \"E201 whitespace after '('\"\nmod_import = [d for d in diags if d['message'] == msg][0]\nassert mod_import['code'] == 'E201'\nassert mod_import['severity'] == lsp.DiagnosticSeverity.Warning\nassert mod_import['range']['start'] == {'line': 2, 'character': 10}\nassert mod_import['range']['end'] == {'line': 2, 'character': 14}\nmsg = 'E128 continuation line under-indented for visual indent'\nmod_import = [d for d in diags if d['message'] == msg][0]\nassert mod_import['code'] == 'E128'\nassert mod_import['severity'] == lsp.DiagnosticSeverity.Warning\nassert mod_import['range']['start'] == {'line': 5, 'character': 1}\nassert mod_import['range']['end'] == {'line': 5, 'character': 10}\n",
        "CUT_1": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_2": "range['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nlines = [(range['start']['line'] + 1, range['end']['line'] + 1)]\nreturn _format(document, lines=lines)\nhookimpl",
        "CUT_3": "\"\"\"\n    Build a diagnostics from flake8's output, it should extract every result and format\n    it into a dict that looks like this:\n        {\n            'source': 'flake8',\n            'code': code, # 'E501'\n            'range': {\n                'start': {\n                    'line': start_line,\n                    'character': start_column,\n                },\n                'end': {\n                    'line': end_line,\n                    'character': end_column,\n                },\n            },\n            'message': msg,\n            'severity': lsp.DiagnosticSeverity.*,\n        }\n\n    Args:\n        document: The document to be linted.\n        stdout: output from flake8\n    Returns:\n        A list of dictionaries.\n    \"\"\"\ndiagnostics = []\nlines = stdout.splitlines()\nfor raw_line in lines:\n    parsed_line = re.match('(.*):(\\\\d*):(\\\\d*): (\\\\w*) (.*)', raw_line)\n    if not parsed_line:\n        log.debug(\"Flake8 output parser can't parse line '%s'\", raw_line)\n        continue\n    parsed_line = parsed_line.groups()\n    if len(parsed_line) != 5:\n        log.debug(\"Flake8 output parser can't parse line '%s'\", raw_line)\n        continue\n    _, line, character, code, msg = parsed_line\n    line = int(line) - 1\n    character = int(character) - 1\n    diagnostics.append({'source': 'flake8', 'code': code, 'range': {'start':\n        {'line': line, 'character': character}, 'end': {'line': line,\n        'character': len(document.lines[line])}}, 'message': msg,\n        'severity': lsp.DiagnosticSeverity.Warning})\nreturn diagnostics\n",
        "CUT_4": "lineno = error.definition.start - 1\nline = document.lines[0] if document.lines else ''\nstart_character = len(line) - len(line.lstrip())\nend_character = len(line)\nreturn {'source': 'pydocstyle', 'code': error.code, 'message': error.\n    message, 'severity': lsp.DiagnosticSeverity.Warning, 'range': {'start':\n    {'line': lineno, 'character': start_character}, 'end': {'line': lineno,\n    'character': end_character}}}\n",
        "CUT_5": "\"\"\"Parse pylint results.\n\n    :param document: document to run pylint on\n    :type document: pyls.workspace.Document\n    :param stdout: pylint results to parse\n    :type stdout: string\n\n    :return: linting diagnostics\n    :rtype: list\n    \"\"\"\ndiagnostics = []\nlines = stdout.splitlines()\nfor raw_line in lines:\n    parsed_line = re.match('(.*):(\\\\d*):(\\\\d*): (\\\\w*): (.*)', raw_line)\n    if not parsed_line:\n        log.debug(\"Pylint output parser can't parse line '%s'\", raw_line)\n        continue\n    parsed_line = parsed_line.groups()\n    if len(parsed_line) != 5:\n        log.debug(\"Pylint output parser can't parse line '%s'\", raw_line)\n        continue\n    _, line, character, code, msg = parsed_line\n    line = int(line) - 1\n    character = int(character)\n    severity_map = {'C': lsp.DiagnosticSeverity.Information, 'E': lsp.\n        DiagnosticSeverity.Error, 'F': lsp.DiagnosticSeverity.Error, 'R':\n        lsp.DiagnosticSeverity.Hint, 'W': lsp.DiagnosticSeverity.Warning}\n    severity = severity_map[code[0]]\n    diagnostics.append({'source': 'pylint', 'code': code, 'range': {'start':\n        {'line': line, 'character': character}, 'end': {'line': line,\n        'character': len(document.lines[line]) - 1}}, 'message': msg,\n        'severity': severity})\nreturn diagnostics\n"
    },
    {
        "functionName": "test_pycodestyle_config",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pycodestyle_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\" Test that we load config files properly.\n\n    Config files are loaded in the following order:\n        tox.ini pep8.cfg setup.cfg pycodestyle.cfg\n\n    Each overriding the values in the last.\n\n    These files are first looked for in the current document's\n    directory and then each parent directory until any one is found\n    terminating at the workspace root.\n\n    If any section called 'pycodestyle' exists that will be solely used\n    and any config in a 'pep8' section will be ignored\n    \"\"\"\ndoc_uri = uris.from_fs_path(os.path.join(workspace.root_path, 'test.py'))\nworkspace.put_document(doc_uri, DOC)\ndoc = workspace.get_document(doc_uri)\ndiags = pycodestyle_lint.pyls_lint(workspace, doc)\nassert [d for d in diags if d['code'] == 'W191']\ncontent = {'setup.cfg': (\"\"\"[pycodestyle]\nignore = W191, E201, E128\"\"\",\n    True), 'tox.ini': ('', False)}\nfor conf_file, (content, working) in list(content.items()):\n    with open(os.path.join(workspace.root_path, conf_file), 'w+') as f:\n        f.write(content)\n    workspace._config.settings.cache_clear()\n    diags = pycodestyle_lint.pyls_lint(workspace, doc)\n    assert len([d for d in diags if d['code'] == 'W191']) == (0 if working else\n        1)\n    assert len([d for d in diags if d['code'] == 'E201']) == (0 if working else\n        1)\n    assert [d for d in diags if d['code'] == 'W391']\n    os.unlink(os.path.join(workspace.root_path, conf_file))\nworkspace._config.update({'plugins': {'pycodestyle': {'ignore': ['W191',\n    'E201']}}})\ndiags = pycodestyle_lint.pyls_lint(workspace, doc)\nassert not [d for d in diags if d['code'] == 'W191']\nassert not [d for d in diags if d['code'] == 'E201']\nassert [d for d in diags if d['code'] == 'W391']\n",
        "CUT_1": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_2": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_3": "def create_file(name, content):\n    fn = os.path.join(workspace.root_path, name)\n    with open(fn, 'w') as f:\n        f.write(content)\n    workspace.put_document(uris.from_fs_path(fn), content)\nfor name, content in files.items():\n    create_file(name, content)\nreturn workspace\n",
        "CUT_4": "self.config.update((settings or {}).get('pyls', {}))\nfor workspace_uri in self.workspaces:\n    workspace = self.workspaces[workspace_uri]\n    workspace.update_config(settings)\n    for doc_uri in workspace.documents:\n        self.lint(doc_uri, is_saved=False)\n",
        "CUT_5": "\"\"\"\n    Returns a function that creates a temporary workspace from the files dict.\n    The dict is in the format {\"file_name\": \"file_contents\"}\n    \"\"\"\ndef fn(files):\n\n    def create_file(name, content):\n        fn = os.path.join(workspace.root_path, name)\n        with open(fn, 'w') as f:\n            f.write(content)\n        workspace.put_document(uris.from_fs_path(fn), content)\n    for name, content in files.items():\n        create_file(name, content)\n    return workspace\nreturn fn\npytest.fixture"
    },
    {
        "functionName": "test_folding",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_folding.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\nranges = pyls_folding_range(doc)\nexpected = [{'startLine': 1, 'endLine': 6}, {'startLine': 2, 'endLine': 3},\n    {'startLine': 5, 'endLine': 6}, {'startLine': 8, 'endLine': 11}, {\n    'startLine': 12, 'endLine': 20}, {'startLine': 13, 'endLine': 14}, {\n    'startLine': 15, 'endLine': 16}, {'startLine': 17, 'endLine': 18}, {\n    'startLine': 19, 'endLine': 20}, {'startLine': 22, 'endLine': 35}, {\n    'startLine': 23, 'endLine': 35}, {'startLine': 24, 'endLine': 25}, {\n    'startLine': 27, 'endLine': 29}, {'startLine': 28, 'endLine': 29}, {\n    'startLine': 30, 'endLine': 31}, {'startLine': 32, 'endLine': 34}, {\n    'startLine': 33, 'endLine': 34}, {'startLine': 38, 'endLine': 39}, {\n    'startLine': 41, 'endLine': 43}, {'startLine': 42, 'endLine': 43}, {\n    'startLine': 45, 'endLine': 54}, {'startLine': 47, 'endLine': 51}, {\n    'startLine': 49, 'endLine': 51}, {'startLine': 50, 'endLine': 51}, {\n    'startLine': 52, 'endLine': 54}, {'startLine': 53, 'endLine': 54}, {\n    'startLine': 56, 'endLine': 57}, {'startLine': 59, 'endLine': 65}, {\n    'startLine': 60, 'endLine': 61}, {'startLine': 62, 'endLine': 63}, {\n    'startLine': 64, 'endLine': 65}, {'startLine': 67, 'endLine': 68}]\nassert ranges == expected\n",
        "CUT_1": "program = document.source + '\\n'\nlines = program.splitlines()\ntree = parso.parse(program)\nranges = __compute_folding_ranges(tree, lines)\nresults = []\nfor start_line, end_line in ranges:\n    start_line -= 1\n    end_line -= 1\n    results.append({'startLine': start_line, 'endLine': end_line})\nreturn results\nhookimpl",
        "CUT_2": "results = []\nfor folding_range in result:\n    start_line = folding_range['startLine']\n    end_line = folding_range['endLine']\n    results.append((start_line, end_line))\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_FOLDING_RANGE, {\n        'params': results})\nhandles(LSPRequestTypes.DOCUMENT_FOLDING_RANGE)",
        "CUT_3": "results = []\nfor folding_range in result:\n    start_line = folding_range['startLine']\n    end_line = folding_range['endLine']\n    results.append((start_line, end_line))\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_FOLDING_RANGE, {\n        'params': results})\nhandles(LSPRequestTypes.DOCUMENT_FOLDING_RANGE)",
        "CUT_4": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n",
        "CUT_5": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n"
    },
    {
        "functionName": "test_folding_syntax_error",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_folding.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, SYNTAX_ERR)\nranges = pyls_folding_range(doc)\nexpected = [{'startLine': 1, 'endLine': 6}, {'startLine': 2, 'endLine': 3},\n    {'startLine': 5, 'endLine': 6}, {'startLine': 8, 'endLine': 9}, {\n    'startLine': 12, 'endLine': 13}, {'startLine': 15, 'endLine': 17}, {\n    'startLine': 16, 'endLine': 17}, {'startLine': 19, 'endLine': 28}, {\n    'startLine': 21, 'endLine': 25}, {'startLine': 23, 'endLine': 25}, {\n    'startLine': 24, 'endLine': 25}, {'startLine': 26, 'endLine': 28}, {\n    'startLine': 27, 'endLine': 28}]\nassert ranges == expected\n",
        "CUT_1": "program = document.source + '\\n'\nlines = program.splitlines()\ntree = parso.parse(program)\nranges = __compute_folding_ranges(tree, lines)\nresults = []\nfor start_line, end_line in ranges:\n    start_line -= 1\n    end_line -= 1\n    results.append({'startLine': start_line, 'endLine': end_line})\nreturn results\nhookimpl",
        "CUT_2": "results = []\nfor folding_range in result:\n    start_line = folding_range['startLine']\n    end_line = folding_range['endLine']\n    results.append((start_line, end_line))\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_FOLDING_RANGE, {\n        'params': results})\nhandles(LSPRequestTypes.DOCUMENT_FOLDING_RANGE)",
        "CUT_3": "results = []\nfor folding_range in result:\n    start_line = folding_range['startLine']\n    end_line = folding_range['endLine']\n    results.append((start_line, end_line))\nif req_id in self.req_reply:\n    self.req_reply[req_id](LSPRequestTypes.DOCUMENT_FOLDING_RANGE, {\n        'params': results})\nhandles(LSPRequestTypes.DOCUMENT_FOLDING_RANGE)",
        "CUT_4": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_5": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n"
    },
    {
        "functionName": "tmp_workspace",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_jedi_rename.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return temp_workspace_factory({DOC_NAME: DOC, DOC_NAME_EXTRA: DOC_EXTRA})\npytest.fixture",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_jedi_rename",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_jedi_rename.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "position = {'line': 0, 'character': 6}\nDOC_URI = uris.from_fs_path(os.path.join(tmp_workspace.root_path, DOC_NAME))\ndoc = Document(DOC_URI, tmp_workspace)\nresult = pyls_rename(config, tmp_workspace, doc, position, 'ShouldBeRenamed')\nassert len(result.keys()) == 1\nchanges = result.get('documentChanges')\nassert len(changes) == 2\nassert changes[0]['textDocument']['uri'] == doc.uri\nassert changes[0]['textDocument']['version'] == doc.version\nassert changes[0].get('edits') == [{'range': {'start': {'line': 0,\n    'character': 0}, 'end': {'line': 5, 'character': 0}}, 'newText':\n    \"\"\"class ShouldBeRenamed():\n    pass\n\nclass Test2(ShouldBeRenamed):\n    pass\n\"\"\"\n    }]\npath = os.path.join(tmp_workspace.root_path, DOC_NAME_EXTRA)\nuri_extra = uris.from_fs_path(path)\nassert changes[1]['textDocument']['uri'] == uri_extra\nassert changes[1]['textDocument']['version'] is None\nexpected = \"\"\"from test1 import ShouldBeRenamed\nx = ShouldBeRenamed()\n\"\"\"\nif os.name == 'nt':\n    expected = expected.replace('\\n', '\\r\\n')\nassert changes[1].get('edits') == [{'range': {'start': {'line': 0,\n    'character': 0}, 'end': {'line': 2, 'character': 0}}, 'newText': expected}]\npytest.mark.skipif(LT_PY36, reason=\n    'Jedi refactoring isnt supported on Python 2.x/3.5')",
        "CUT_1": "rope_config = config.settings(document_path=document.path).get('rope', {})\nrope_project = workspace._rope_project_builder(rope_config)\nrename = Rename(rope_project, libutils.path_to_resource(rope_project,\n    document.path), document.offset_at_position(position))\nlog.debug('Executing rename of %s to %s', document.word_at_position(\n    position), new_name)\nchangeset = rename.get_changes(new_name, in_hierarchy=True, docs=True)\nlog.debug('Finished rename: %s', changeset.changes)\nchanges = []\nfor change in changeset.changes:\n    uri = uris.from_fs_path(change.resource.path)\n    doc = workspace.get_maybe_document(uri)\n    changes.append({'textDocument': {'uri': uri, 'version': doc.version if\n        doc else None}, 'edits': [{'range': {'start': {'line': 0,\n        'character': 0}, 'end': {'line': _num_lines(change.resource),\n        'character': 0}}, 'newText': change.new_contents}]})\nreturn {'documentChanges': changes}\nhookimpl",
        "CUT_2": "log.debug('Executing rename of %s to %s', document.word_at_position(\n    position), new_name)\nkwargs = _utils.position_to_jedi_linecolumn(document, position)\nkwargs['new_name'] = new_name\ntry:\n    refactoring = document.jedi_script().rename(**kwargs)\nexcept NotImplementedError:\n    raise Exception(\n        'No support for renaming in Python 2/3.5 with Jedi. Consider using the rope_rename plugin instead'\n        )\nlog.debug('Finished rename: %s', refactoring.get_diff())\nchanges = []\nfor file_path, changed_file in refactoring.get_changed_files().items():\n    uri = uris.from_fs_path(str(file_path))\n    doc = workspace.get_maybe_document(uri)\n    changes.append({'textDocument': {'uri': uri, 'version': doc.version if\n        doc else None}, 'edits': [{'range': {'start': {'line': 0,\n        'character': 0}, 'end': {'line': _num_lines(changed_file.\n        get_new_code()), 'character': 0}}, 'newText': changed_file.\n        get_new_code()}]})\nreturn {'documentChanges': changes}\nhookimpl",
        "CUT_3": "workspace = self._match_uri_to_workspace(textDocument['uri'])\nworkspace.put_document(textDocument['uri'], textDocument['text'], version=\n    textDocument.get('version'))\nself._hook('pyls_document_did_open', textDocument['uri'])\nself.lint(textDocument['uri'], is_saved=True)\n",
        "CUT_4": "changes = []\nentries = params.get('params', [])\nfor entry in entries:\n    changes.append({'uri': path_as_uri(entry['file']), 'type': entry['kind']})\nparams = {'changes': changes}\nreturn params\nsend_notification(method=LSPRequestTypes.WORKSPACE_WATCHED_FILES_UPDATE)",
        "CUT_5": "changes = []\nentries = params.get('params', [])\nfor entry in entries:\n    changes.append({'uri': path_as_uri(entry['file']), 'type': entry['kind']})\nparams = {'changes': changes}\nreturn params\nsend_notification(method=LSPRequestTypes.WORKSPACE_WATCHED_FILES_UPDATE)"
    },
    {
        "functionName": "helper_check_symbols_all_scope",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_symbols.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "assert len(symbols) == 8\ndef sym(name):\n    return [s for s in symbols if s['name'] == name][0]\nassert sym('a')['kind'] == SymbolKind.Variable\nassert sym('B')['kind'] == SymbolKind.Class\nassert sym('__init__')['kind'] == SymbolKind.Method\nassert sym('main')['kind'] == SymbolKind.Function\nassert sym('a')['location']['range']['start'] == {'line': 2, 'character': 0}\n",
        "CUT_1": "\"\"\"Update and process symbol data.\"\"\"\nif data == self._data:\n    return\nself._data = data\nself._tree.clear()\nself.classes = []\nself.funcs = []\nfor item in data:\n    line_start = item['location']['range']['start']['line']\n    line_end = item['location']['range']['end']['line']\n    kind = item.get('kind')\n    block = self._editor.document().findBlockByLineNumber(line_start)\n    line_text = line_text = block.text() if block else ''\n    if line_start != line_end and ' import ' not in line_text:\n        self._tree[line_start:line_end] = item\n        if kind in [SymbolKind.CLASS]:\n            self.classes.append(item)\n        elif kind in [SymbolKind.FUNCTION, SymbolKind.METHOD]:\n            self.funcs.append(item)\nself.class_cb.clear()\nself.method_cb.clear()\nself.populate(self.class_cb, self.classes, add_parents=False)\nself.populate(self.method_cb, self.funcs, add_parents=True)\n",
        "CUT_2": "\"\"\"Update and process symbol data.\"\"\"\nif data == self._data:\n    return\nself._data = data\nself._tree.clear()\nself.classes = []\nself.funcs = []\nfor item in data:\n    line_start = item['location']['range']['start']['line']\n    line_end = item['location']['range']['end']['line']\n    kind = item.get('kind')\n    block = self._editor.document().findBlockByLineNumber(line_start)\n    line_text = line_text = block.text() if block else ''\n    if line_start != line_end and ' import ' not in line_text:\n        self._tree[line_start:line_end] = item\n        if kind in [SymbolKind.CLASS]:\n            self.classes.append(item)\n        elif kind in [SymbolKind.FUNCTION, SymbolKind.METHOD]:\n            self.funcs.append(item)\nself.class_cb.clear()\nself.method_cb.clear()\nself.populate(self.class_cb, self.classes, add_parents=False)\nself.populate(self.method_cb, self.funcs, add_parents=True)\n",
        "CUT_3": "\"\"\"Updates the dropdowns to reflect the current class and function.\"\"\"\npossible_parents = list(sorted(self._tree[linenum]))\nfor iv in possible_parents:\n    item = iv.data\n    kind = item.get('kind')\n    if kind in [SymbolKind.CLASS]:\n        for idx in range(self.class_cb.count()):\n            if self.class_cb.itemData(idx) == item:\n                self.class_cb.setCurrentIndex(idx)\n                break\n        else:\n            self.class_cb.setCurrentIndex(0)\n    elif kind in [SymbolKind.FUNCTION, SymbolKind.METHOD]:\n        for idx in range(self.method_cb.count()):\n            if self.method_cb.itemData(idx) == item:\n                self.method_cb.setCurrentIndex(idx)\n                break\n        else:\n            self.method_cb.setCurrentIndex(0)\n    else:\n        continue\nif len(possible_parents) == 0:\n    self.class_cb.setCurrentIndex(0)\n    self.method_cb.setCurrentIndex(0)\n",
        "CUT_4": "\"\"\"Updates the dropdowns to reflect the current class and function.\"\"\"\npossible_parents = list(sorted(self._tree[linenum]))\nfor iv in possible_parents:\n    item = iv.data\n    kind = item.get('kind')\n    if kind in [SymbolKind.CLASS]:\n        for idx in range(self.class_cb.count()):\n            if self.class_cb.itemData(idx) == item:\n                self.class_cb.setCurrentIndex(idx)\n                break\n        else:\n            self.class_cb.setCurrentIndex(0)\n    elif kind in [SymbolKind.FUNCTION, SymbolKind.METHOD]:\n        for idx in range(self.method_cb.count()):\n            if self.method_cb.itemData(idx) == item:\n                self.method_cb.setCurrentIndex(idx)\n                break\n        else:\n            self.method_cb.setCurrentIndex(0)\n    else:\n        continue\nif len(possible_parents) == 0:\n    self.class_cb.setCurrentIndex(0)\n    self.method_cb.setCurrentIndex(0)\n",
        "CUT_5": "\"\"\"Reset color scheme to default values\"\"\"\nassert name in sh.COLOR_SCHEME_NAMES\nset_color_scheme(name, sh.get_color_scheme(name), replace=replace)\n"
    },
    {
        "functionName": "sym",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_symbols.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return [s for s in symbols if s['name'] == name][0]\n",
        "CUT_1": "self.name = name\n",
        "CUT_2": "self.name = name\n",
        "CUT_3": "\"\"\"Returns a code cell name from a code cell comment.\"\"\"\nname = text.strip().lstrip('#% ')\nif name.startswith('<codecell>'):\n    name = name[10:].lstrip()\nelif name.startswith('In['):\n    name = name[2:]\n    if name.endswith(']:'):\n        name = name[:-1]\n    name = name.strip()\nreturn name\n",
        "CUT_4": "\"\"\"Returns a code cell name from a code cell comment.\"\"\"\nname = text.strip().lstrip('#% ')\nif name.startswith('<codecell>'):\n    name = name[10:].lstrip()\nelif name.startswith('In['):\n    name = name[2:]\n    if name.endswith(']:'):\n        name = name[:-1]\n    name = name.strip()\nreturn name\n",
        "CUT_5": "\"\"\"Handle symbols response.\"\"\"\ntry:\n    symbols = params['params']\n    symbols = [] if symbols is None else symbols\n    self.classfuncdropdown.update_data(symbols)\n    if self.oe_proxy is not None:\n        self.oe_proxy.update_outline_info(symbols)\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing symbols')\nhandles(LSPRequestTypes.DOCUMENT_SYMBOL)"
    },
    {
        "functionName": "test_symbols",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_symbols.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\nconfig.update({'plugins': {'jedi_symbols': {'all_scopes': False}}})\nsymbols = pyls_document_symbols(config, doc)\nassert len(symbols) == 5\ndef sym(name):\n    return [s for s in symbols if s['name'] == name][0]\nassert sym('a')['kind'] == SymbolKind.Variable\nassert sym('B')['kind'] == SymbolKind.Class\nassert sym('main')['kind'] == SymbolKind.Function\nassert sym('a')['location']['range']['start'] == {'line': 2, 'character': 0}\nassert sym('main')['location']['range']['start'] == {'line': 9, 'character': 0}\nassert sym('main')['location']['range']['end'] == {'line': 12, 'character': 0}\n",
        "CUT_1": "range['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nlines = [(range['start']['line'] + 1, range['end']['line'] + 1)]\nreturn _format(document, lines=lines)\nhookimpl",
        "CUT_2": "log.info('Formatting document %s in range %s with autopep8', document, range)\nrange['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nline_range = range['start']['line'] + 1, range['end']['line'] + 1\nreturn _format(config, document, line_range=line_range)\nhookimpl(tryfirst=True)",
        "CUT_3": "\"\"\"Update and process symbol data.\"\"\"\nif data == self._data:\n    return\nself._data = data\nself._tree.clear()\nself.classes = []\nself.funcs = []\nfor item in data:\n    line_start = item['location']['range']['start']['line']\n    line_end = item['location']['range']['end']['line']\n    kind = item.get('kind')\n    block = self._editor.document().findBlockByLineNumber(line_start)\n    line_text = line_text = block.text() if block else ''\n    if line_start != line_end and ' import ' not in line_text:\n        self._tree[line_start:line_end] = item\n        if kind in [SymbolKind.CLASS]:\n            self.classes.append(item)\n        elif kind in [SymbolKind.FUNCTION, SymbolKind.METHOD]:\n            self.funcs.append(item)\nself.class_cb.clear()\nself.method_cb.clear()\nself.populate(self.class_cb, self.classes, add_parents=False)\nself.populate(self.method_cb, self.funcs, add_parents=True)\n",
        "CUT_4": "\"\"\"Update and process symbol data.\"\"\"\nif data == self._data:\n    return\nself._data = data\nself._tree.clear()\nself.classes = []\nself.funcs = []\nfor item in data:\n    line_start = item['location']['range']['start']['line']\n    line_end = item['location']['range']['end']['line']\n    kind = item.get('kind')\n    block = self._editor.document().findBlockByLineNumber(line_start)\n    line_text = line_text = block.text() if block else ''\n    if line_start != line_end and ' import ' not in line_text:\n        self._tree[line_start:line_end] = item\n        if kind in [SymbolKind.CLASS]:\n            self.classes.append(item)\n        elif kind in [SymbolKind.FUNCTION, SymbolKind.METHOD]:\n            self.funcs.append(item)\nself.class_cb.clear()\nself.method_cb.clear()\nself.populate(self.class_cb, self.classes, add_parents=False)\nself.populate(self.method_cb, self.funcs, add_parents=True)\n",
        "CUT_5": "\"\"\"Handle symbols response.\"\"\"\ntry:\n    symbols = params['params']\n    symbols = [] if symbols is None else symbols\n    self.classfuncdropdown.update_data(symbols)\n    if self.oe_proxy is not None:\n        self.oe_proxy.update_outline_info(symbols)\nexcept RuntimeError:\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing symbols')\nhandles(LSPRequestTypes.DOCUMENT_SYMBOL)"
    },
    {
        "functionName": "test_symbols_all_scopes",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_symbols.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\nsymbols = pyls_document_symbols(config, doc)\nhelper_check_symbols_all_scope(symbols)\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_symbols_all_scopes_with_jedi_environment",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_symbols.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\nenv_path = '/tmp/pyenv/bin/python'\nsettings = {'pyls': {'plugins': {'jedi': {'environment': env_path}}}}\ndoc.update_config(settings)\nsymbols = pyls_document_symbols(doc._config, doc)\nhelper_check_symbols_all_scope(symbols)\npytest.mark.skipif(PY2 or not LINUX or not CI, reason=\n    'tested on linux and python 3 only')",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_mccabe",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_mccabe_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "old_settings = config.settings\ntry:\n    config.update({'plugins': {'mccabe': {'threshold': 1}}})\n    doc = Document(DOC_URI, workspace, DOC)\n    diags = mccabe_lint.pyls_lint(config, doc)\n    assert all([(d['source'] == 'mccabe') for d in diags])\n    msg = 'Cyclomatic complexity too high: 1 (threshold 1)'\n    mod_import = [d for d in diags if d['message'] == msg][0]\n    assert mod_import['severity'] == lsp.DiagnosticSeverity.Warning\n    assert mod_import['range']['start'] == {'line': 0, 'character': 0}\n    assert mod_import['range']['end'] == {'line': 0, 'character': 6}\nfinally:\n    config._settings = old_settings\n",
        "CUT_1": "threshold = config.plugin_settings('mccabe', document_path=document.path).get(\n    THRESHOLD, DEFAULT_THRESHOLD)\nlog.debug('Running mccabe lint with threshold: %s', threshold)\ntry:\n    tree = compile(document.source, document.path, 'exec', ast.PyCF_ONLY_AST)\nexcept SyntaxError:\n    return None\nvisitor = mccabe.PathGraphingAstVisitor()\nvisitor.preorder(tree, visitor)\ndiags = []\nfor graph in visitor.graphs.values():\n    if graph.complexity() >= threshold:\n        diags.append({'source': 'mccabe', 'range': {'start': {'line': graph\n            .lineno - 1, 'character': graph.column}, 'end': {'line': graph.\n            lineno - 1, 'character': len(document.lines[graph.lineno])}},\n            'message': 'Cyclomatic complexity too high: %s (threshold %s)' %\n            (graph.complexity(), threshold), 'severity': lsp.\n            DiagnosticSeverity.Warning})\nreturn diags\nhookimpl",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_4": "log.info('Formatting document %s in range %s with autopep8', document, range)\nrange['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nline_range = range['start']['line'] + 1, range['end']['line'] + 1\nreturn _format(config, document, line_range=line_range)\nhookimpl(tryfirst=True)",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_mccabe_syntax_error",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_mccabe_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC_SYNTAX_ERR)\nassert mccabe_lint.pyls_lint(config, doc) is None\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "workspace = self._match_uri_to_workspace(doc_uri)\nif doc_uri in workspace.documents:\n    workspace.publish_diagnostics(doc_uri, flatten(self._hook('pyls_lint',\n        doc_uri, is_saved=is_saved)))\n_utils.debounce(LINT_DEBOUNCE_S, keyed_by='doc_uri')",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_format",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_yapf_format.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\nres = pyls_format_document(doc)\nassert len(res) == 1\nassert res[0]['newText'] == \"\"\"A = ['h', 'w', 'a']\n\nB = ['h', 'w']\n\"\"\"\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_3": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_range_format",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_yapf_format.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\ndef_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 4,\n    'character': 10}}\nres = pyls_format_range(doc, def_range)\nassert len(res) == 1\nassert res[0]['newText'] == \"\"\"A = ['h', 'w', 'a']\n\nB = ['h',\n\n\n'w']\n\"\"\"\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_3": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_no_change",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_yapf_format.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, GOOD_DOC)\nassert not pyls_format_document(doc)\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "return self._hook('pyls_format_document', doc_uri)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n"
    },
    {
        "functionName": "test_config_file",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_yapf_format.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "conf = tmpdir.join('.style.yapf')\nconf.write(\"\"\"[style]\ncolumn_limit = 14\"\"\")\nsrc = tmpdir.join('test.py')\ndoc = Document(uris.from_fs_path(src.strpath), workspace, DOC)\nassert pyls_format_document(doc)[0]['newText'] == \"\"\"A = [\n    'h', 'w',\n    'a'\n]\n\nB = ['h', 'w']\n\"\"\"\n",
        "CUT_1": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "tmp_workspace",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_references.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return temp_workspace_factory({DOC1_NAME: DOC1, DOC2_NAME: DOC2})\npytest.fixture",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture",
        "CUT_5": "path = str(tmpdir)\ndefault_kwargs = {'name': 'spyder-test', 'path': path, 'defaults': DEFAULTS,\n    'load': True, 'version': CONF_VERSION, 'backup': True, 'raw_mode': True,\n    'remove_obsolete': False}\nconf = UserConfig(**default_kwargs)\ndef fin():\n    \"\"\"Fixture finalizer to delete the temporary CONF element.\"\"\"\n    shutil.rmtree(path)\nrequest.addfinalizer(fin)\nreturn conf\npytest.fixture"
    },
    {
        "functionName": "test_references",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_references.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "position = {'line': 0, 'character': 8}\nDOC1_URI = uris.from_fs_path(os.path.join(tmp_workspace.root_path, DOC1_NAME))\ndoc1 = Document(DOC1_URI, tmp_workspace)\nrefs = pyls_references(doc1, position)\nassert len(refs) == 3\nno_def_refs = pyls_references(doc1, position, exclude_declaration=True)\nassert len(no_def_refs) == 1\ndoc1_ref = [u for u in refs if u['uri'] == DOC1_URI][0]\nassert doc1_ref['range']['start'] == {'line': 0, 'character': 6}\nassert doc1_ref['range']['end'] == {'line': 0, 'character': 11}\ndoc2_import_ref = [u for u in refs if u['uri'] != DOC1_URI][0]\nassert doc2_import_ref['range']['start'] == {'line': 0, 'character': 18}\nassert doc2_import_ref['range']['end'] == {'line': 0, 'character': 23}\ndoc2_usage_ref = [u for u in refs if u['uri'] != DOC1_URI][1]\nassert doc2_usage_ref['range']['start'] == {'line': 3, 'character': 4}\nassert doc2_usage_ref['range']['end'] == {'line': 3, 'character': 9}\n",
        "CUT_1": "range['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nlines = [(range['start']['line'] + 1, range['end']['line'] + 1)]\nreturn _format(document, lines=lines)\nhookimpl",
        "CUT_2": "log.info('Formatting document %s in range %s with autopep8', document, range)\nrange['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nline_range = range['start']['line'] + 1, range['end']['line'] + 1\nreturn _format(config, document, line_range=line_range)\nhookimpl(tryfirst=True)",
        "CUT_3": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_4": "code_position = _utils.position_to_jedi_linecolumn(document, position)\nusages = document.jedi_script().get_references(**code_position)\nif exclude_declaration:\n    usages = [d for d in usages if not d.is_definition()]\nreturn [{'uri': uris.uri_with(document.uri, path=str(d.module_path)) if d.\n    module_path else document.uri, 'range': {'start': {'line': d.line - 1,\n    'character': d.column}, 'end': {'line': d.line - 1, 'character': d.\n    column + len(d.name)}}} for d in usages if not d.in_builtin_module()]\nhookimpl",
        "CUT_5": "lineno = error.definition.start - 1\nline = document.lines[0] if document.lines else ''\nstart_character = len(line) - len(line.lstrip())\nend_character = len(line)\nreturn {'source': 'pydocstyle', 'code': error.code, 'message': error.\n    message, 'severity': lsp.DiagnosticSeverity.Warning, 'range': {'start':\n    {'line': lineno, 'character': start_character}, 'end': {'line': lineno,\n    'character': end_character}}}\n"
    },
    {
        "functionName": "test_references_builtin",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_references.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "position = {'line': 4, 'character': 7}\ndoc2_uri = uris.from_fs_path(os.path.join(str(tmp_workspace.root_path),\n    DOC2_NAME))\ndoc2 = Document(doc2_uri, tmp_workspace)\nrefs = pyls_references(doc2, position)\nassert len(refs) >= 1\nexpected = {'start': {'line': 4, 'character': 7}, 'end': {'line': 4,\n    'character': 19}}\nranges = [r['range'] for r in refs]\nassert expected in ranges\npytest.mark.skipif(PY2, reason=\n    'Jedi sometimes fails while checking pylint example files in the modules path'\n    )",
        "CUT_1": "range['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nlines = [(range['start']['line'] + 1, range['end']['line'] + 1)]\nreturn _format(document, lines=lines)\nhookimpl",
        "CUT_2": "\"\"\"\n    Convert the LSP format 'line', 'character' to Jedi's 'line', 'column'\n\n    https://microsoft.github.io/language-server-protocol/specification#position\n    \"\"\"\ncode_position = {}\nif position:\n    code_position = {'line': position['line'] + 1, 'column': clip_column(\n        position['character'], document.lines, position['line'])}\nreturn code_position\n",
        "CUT_3": "log.info('Formatting document %s in range %s with autopep8', document, range)\nrange['start']['character'] = 0\nrange['end']['line'] += 1\nrange['end']['character'] = 0\nline_range = range['start']['line'] + 1, range['end']['line'] + 1\nreturn _format(config, document, line_range=line_range)\nhookimpl(tryfirst=True)",
        "CUT_4": "\"\"\"Return the byte-offset pointed at by the given position.\"\"\"\nreturn position['character'] + len(''.join(self.lines[:position['line']]))\n",
        "CUT_5": "lineno = error.definition.start - 1\nline = document.lines[0] if document.lines else ''\nstart_character = len(line) - len(line.lstrip())\nend_character = len(line)\nreturn {'source': 'pydocstyle', 'code': error.code, 'message': error.\n    message, 'severity': lsp.DiagnosticSeverity.Warning, 'range': {'start':\n    {'line': lineno, 'character': start_character}, 'end': {'line': lineno,\n    'character': end_character}}}\n"
    },
    {
        "functionName": "test_rope_import_completion",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "com_position = {'line': 0, 'character': 7}\ndoc = Document(DOC_URI, workspace, DOC)\nitems = pyls_rope_completions(config, workspace, doc, com_position)\nassert items is None\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_jedi_completion",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "com_position = {'line': 1, 'character': 15}\ndoc = Document(DOC_URI, workspace, DOC)\nitems = pyls_jedi_completions(config, doc, com_position)\nassert items\nlabels = [i['label'] for i in items]\nassert 'isabs(path)' in labels\npyls_jedi_completions(config, doc, {'line': 1, 'character': 1000})\n",
        "CUT_1": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "return Document(DOC_URI, workspace, DOC)\npytest.fixture"
    },
    {
        "functionName": "test_jedi_completion_with_fuzzy_enabled",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "config.update({'plugins': {'jedi_completion': {'fuzzy': True}}})\ncom_position = {'line': 1, 'character': 15}\ndoc = Document(DOC_URI, workspace, DOC)\nitems = pyls_jedi_completions(config, doc, com_position)\nassert items\nassert items[0]['label'] == 'commonprefix(list)'\npyls_jedi_completions(config, doc, {'line': 1, 'character': 1000})\n",
        "CUT_1": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n"
    },
    {
        "functionName": "test_rope_completion",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "com_position = {'line': 1, 'character': 15}\nworkspace.put_document(DOC_URI, source=DOC)\ndoc = workspace.get_document(DOC_URI)\nitems = pyls_rope_completions(config, workspace, doc, com_position)\nassert items\nassert items[0]['label'] == 'isabs'\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "workspace = self._match_uri_to_workspace(doc_uri)\nif doc_uri in workspace.documents:\n    workspace.publish_diagnostics(doc_uri, flatten(self._hook('pyls_lint',\n        doc_uri, is_saved=is_saved)))\n_utils.debounce(LINT_DEBOUNCE_S, keyed_by='doc_uri')",
        "CUT_4": "self.config.update((settings or {}).get('pyls', {}))\nfor workspace_uri in self.workspaces:\n    workspace = self.workspaces[workspace_uri]\n    workspace.update_config(settings)\n    for doc_uri in workspace.documents:\n        self.lint(doc_uri, is_saved=False)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_jedi_completion_ordering",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "com_position = {'line': 8, 'character': 0}\ndoc = Document(DOC_URI, workspace, DOC)\ncompletions = pyls_jedi_completions(config, doc, com_position)\nitems = {c['label']: c['sortText'] for c in completions}\nassert items['hello()'] < items['_a_hello()']\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_jedi_property_completion",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "com_position = {'line': 18, 'character': 15}\ndoc = Document(DOC_URI, workspace, DOC)\ncompletions = pyls_jedi_completions(config, doc, com_position)\nitems = {c['label']: c['sortText'] for c in completions}\nassert 'world' in list(items.keys())[0]\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_jedi_method_completion",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "com_position = {'line': 20, 'character': 19}\ndoc = Document(DOC_URI, workspace, DOC)\nconfig.capabilities['textDocument'] = {'completion': {'completionItem': {\n    'snippetSupport': True}}}\nconfig.update({'plugins': {'jedi_completion': {'include_params': True}}})\ncompletions = pyls_jedi_completions(config, doc, com_position)\neveryone_method = [completion for completion in completions if completion[\n    'label'] == 'everyone(a, b, c, d)'][0]\nassert everyone_method['insertTextFormat'] == lsp.InsertTextFormat.Snippet\nassert everyone_method['insertText'] == 'everyone(${1:a}, ${2:b})$0'\nconfig.update({'plugins': {'jedi_completion': {'include_params': False}}})\ncompletions = pyls_jedi_completions(config, doc, com_position)\neveryone_method = [completion for completion in completions if completion[\n    'label'] == 'everyone(a, b, c, d)'][0]\nassert 'insertTextFormat' not in everyone_method\nassert everyone_method['insertText'] == 'everyone'\n",
        "CUT_1": "\"\"\"Handle completion response.\"\"\"\nargs = self.completion_args\nif args is None:\n    return\nself.completion_args = None\nposition, automatic = args\nstart_cursor = self.textCursor()\nstart_cursor.movePosition(QTextCursor.StartOfBlock)\nline_text = self.get_text(start_cursor.position(), 'eol')\nleading_whitespace = self.compute_whitespace(line_text)\nindentation_whitespace = ' ' * leading_whitespace\neol_char = self.get_line_separator()\ntry:\n    completions = params['params']\n    completions = [] if completions is None else [completion for completion in\n        completions if completion.get('insertText') or completion.get(\n        'textEdit', {}).get('newText')]\n    prefix = self.get_current_word(completion=True, valid_python_variable=False\n        )\n    if len(completions) == 1 and completions[0].get('insertText'\n        ) == prefix and not completions[0].get('textEdit', {}).get('newText'):\n        completions.pop()\n    replace_end = self.textCursor().position()\n    under_cursor = self.get_current_word_and_position(completion=True)\n    if under_cursor:\n        word, replace_start = under_cursor\n    else:\n        word = ''\n        replace_start = replace_end\n    first_letter = ''\n    if len(word) > 0:\n        first_letter = word[0]\n\n    def sort_key(completion):\n        if 'textEdit' in completion:\n            text_insertion = completion['textEdit']['newText']\n        else:\n            text_insertion = completion['insertText']\n        first_insert_letter = text_insertion[0]\n        case_mismatch = first_letter.isupper() and first_insert_letter.islower(\n            ) or first_letter.islower() and first_insert_letter.isupper()\n        return case_mismatch, completion['sortText']\n    completion_list = sorted(completions, key=sort_key)\n    for completion in completion_list:\n        if 'textEdit' in completion:\n            c_replace_start = completion['textEdit']['range']['start']\n            c_replace_end = completion['textEdit']['range']['end']\n            if (c_replace_start == replace_start and c_replace_end ==\n                replace_end):\n                insert_text = completion['textEdit']['newText']\n                completion['filterText'] = insert_text\n                completion['insertText'] = insert_text\n                del completion['textEdit']\n        if 'insertText' in completion:\n            insert_text = completion['insertText']\n            insert_text_lines = insert_text.splitlines()\n            reindented_text = [insert_text_lines[0]]\n            for insert_line in insert_text_lines[1:]:\n                insert_line = indentation_whitespace + insert_line\n                reindented_text.append(insert_line)\n            reindented_text = eol_char.join(reindented_text)\n            completion['insertText'] = reindented_text\n    self.completion_widget.show_list(completion_list, position, automatic)\n    self.kite_call_to_action.handle_processed_completions(completions)\nexcept RuntimeError:\n    self.kite_call_to_action.hide_coverage_cta()\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing completions')\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_2": "\"\"\"Handle completion response.\"\"\"\nargs = self.completion_args\nif args is None:\n    return\nself.completion_args = None\nposition, automatic = args\nstart_cursor = self.textCursor()\nstart_cursor.movePosition(QTextCursor.StartOfBlock)\nline_text = self.get_text(start_cursor.position(), 'eol')\nleading_whitespace = self.compute_whitespace(line_text)\nindentation_whitespace = ' ' * leading_whitespace\neol_char = self.get_line_separator()\ntry:\n    completions = params['params']\n    completions = [] if completions is None else [completion for completion in\n        completions if completion.get('insertText') or completion.get(\n        'textEdit', {}).get('newText')]\n    prefix = self.get_current_word(completion=True, valid_python_variable=False\n        )\n    if len(completions) == 1 and completions[0].get('insertText'\n        ) == prefix and not completions[0].get('textEdit', {}).get('newText'):\n        completions.pop()\n    replace_end = self.textCursor().position()\n    under_cursor = self.get_current_word_and_position(completion=True)\n    if under_cursor:\n        word, replace_start = under_cursor\n    else:\n        word = ''\n        replace_start = replace_end\n    first_letter = ''\n    if len(word) > 0:\n        first_letter = word[0]\n\n    def sort_key(completion):\n        if 'textEdit' in completion:\n            text_insertion = completion['textEdit']['newText']\n        else:\n            text_insertion = completion['insertText']\n        first_insert_letter = text_insertion[0]\n        case_mismatch = first_letter.isupper() and first_insert_letter.islower(\n            ) or first_letter.islower() and first_insert_letter.isupper()\n        return case_mismatch, completion['sortText']\n    completion_list = sorted(completions, key=sort_key)\n    for completion in completion_list:\n        if 'textEdit' in completion:\n            c_replace_start = completion['textEdit']['range']['start']\n            c_replace_end = completion['textEdit']['range']['end']\n            if (c_replace_start == replace_start and c_replace_end ==\n                replace_end):\n                insert_text = completion['textEdit']['newText']\n                completion['filterText'] = insert_text\n                completion['insertText'] = insert_text\n                del completion['textEdit']\n        if 'insertText' in completion:\n            insert_text = completion['insertText']\n            insert_text_lines = insert_text.splitlines()\n            reindented_text = [insert_text_lines[0]]\n            for insert_line in insert_text_lines[1:]:\n                insert_line = indentation_whitespace + insert_line\n                reindented_text.append(insert_line)\n            reindented_text = eol_char.join(reindented_text)\n            completion['insertText'] = reindented_text\n    self.completion_widget.show_list(completion_list, position, automatic)\n    self.kite_call_to_action.handle_processed_completions(completions)\nexcept RuntimeError:\n    self.kite_call_to_action.hide_coverage_cta()\n    return\nexcept Exception:\n    self.log_lsp_handle_errors('Error when processing completions')\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_3": "completion = {'label': _label(d), 'kind': _TYPE_MAP.get(d.type), 'detail':\n    _detail(d), 'documentation': _utils.format_docstring(d.docstring()),\n    'sortText': _sort_text(d), 'insertText': d.name}\nif d.type == 'path':\n    path = osp.normpath(d.name)\n    path = path.replace('\\\\', '\\\\\\\\')\n    path = path.replace('/', '\\\\/')\n    completion['insertText'] = path\nsig = d.get_signatures()\nif include_params and sig and not is_exception_class(d.name):\n    positional_args = [param for param in sig[0].params if '=' not in param\n        .description and param.name not in {'/', '*'}]\n    if len(positional_args) > 1:\n        completion['insertTextFormat'] = lsp.InsertTextFormat.Snippet\n        snippet = d.name + '('\n        for i, param in enumerate(positional_args):\n            snippet += '${%s:%s}' % (i + 1, param.name)\n            if i < len(positional_args) - 1:\n                snippet += ', '\n        snippet += ')$0'\n        completion['insertText'] = snippet\n    elif len(positional_args) == 1:\n        completion['insertTextFormat'] = lsp.InsertTextFormat.Snippet\n        completion['insertText'] = d.name + '($0)'\n    else:\n        completion['insertText'] = d.name + '()'\nreturn completion\n",
        "CUT_4": "logger.debug(response)\nif response is None:\n    return {'params': []}\nspyder_completions = []\ncompletions = response['completions']\nif completions is not None:\n    for i, completion in enumerate(completions):\n        entry = {'kind': KITE_DOCUMENT_TYPES.get(completion['hint'],\n            CompletionItemKind.TEXT), 'label': completion['display'],\n            'textEdit': {'newText': convert_text_snippet(completion[\n            'snippet']), 'range': {'start': completion['replace']['begin'],\n            'end': completion['replace']['end']}}, 'filterText': '',\n            'sortText': (i, 0), 'documentation': completion['documentation'\n            ]['text'], 'provider': KITE_COMPLETION}\n        spyder_completions.append(entry)\n        if 'children' in completion:\n            for j, child in enumerate(completion['children']):\n                child_entry = {'kind': KITE_DOCUMENT_TYPES.get(child['hint'\n                    ], CompletionItemKind.TEXT), 'label': ' ' * 2 + child[\n                    'display'], 'textEdit': {'newText':\n                    convert_text_snippet(child['snippet']), 'range': {\n                    'start': child['replace']['begin'], 'end': child[\n                    'replace']['end']}}, 'insertText': convert_text_snippet\n                    (child['snippet']), 'filterText': '', 'sortText': (i, j +\n                    1), 'documentation': child['documentation']['text'],\n                    'provider': KITE_COMPLETION}\n                spyder_completions.append(child_entry)\nreturn {'params': spyder_completions}\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)",
        "CUT_5": "logger.debug(response)\nif response is None:\n    return {'params': []}\nspyder_completions = []\ncompletions = response['completions']\nif completions is not None:\n    for i, completion in enumerate(completions):\n        entry = {'kind': KITE_DOCUMENT_TYPES.get(completion['hint'],\n            CompletionItemKind.TEXT), 'label': completion['display'],\n            'textEdit': {'newText': convert_text_snippet(completion[\n            'snippet']), 'range': {'start': completion['replace']['begin'],\n            'end': completion['replace']['end']}}, 'filterText': '',\n            'sortText': (i, 0), 'documentation': completion['documentation'\n            ]['text'], 'provider': KITE_COMPLETION}\n        spyder_completions.append(entry)\n        if 'children' in completion:\n            for j, child in enumerate(completion['children']):\n                child_entry = {'kind': KITE_DOCUMENT_TYPES.get(child['hint'\n                    ], CompletionItemKind.TEXT), 'label': ' ' * 2 + child[\n                    'display'], 'textEdit': {'newText':\n                    convert_text_snippet(child['snippet']), 'range': {\n                    'start': child['replace']['begin'], 'end': child[\n                    'replace']['end']}}, 'insertText': convert_text_snippet\n                    (child['snippet']), 'filterText': '', 'sortText': (i, j +\n                    1), 'documentation': child['documentation']['text'],\n                    'provider': KITE_COMPLETION}\n                spyder_completions.append(child_entry)\nreturn {'params': spyder_completions}\nhandles(LSPRequestTypes.DOCUMENT_COMPLETION)"
    },
    {
        "functionName": "test_pyqt_completion",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc_pyqt = 'from PyQt5.QtWidgets import QA'\ncom_position = {'line': 0, 'character': len(doc_pyqt)}\ndoc = Document(DOC_URI, workspace, doc_pyqt)\ncompletions = pyls_jedi_completions(config, doc, com_position)\nassert completions is not None\npytest.mark.skipif(PY2 or sys.platform.startswith('linux') and os.environ.\n    get('CI') is not None, reason=\n    \"Test in Python 3 and not on CIs on Linux because wheels don't work on them.\"\n    )",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n",
        "CUT_4": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_numpy_completions",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc_numpy = 'import numpy as np; np.'\ncom_position = {'line': 0, 'character': len(doc_numpy)}\ndoc = Document(DOC_URI, workspace, doc_numpy)\nitems = pyls_jedi_completions(config, doc, com_position)\nassert items\nassert any([('array' in i['label']) for i in items])\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "items = self.selectedItems()\nif not items:\n    items = self.get_top_level_items()\nfor item in items:\n    self.__expand_item(item)\nif items:\n    self.scrollToItem(items[0])\nSlot()",
        "CUT_3": "items = self.selectedItems()\nif not items:\n    items = self.get_top_level_items()\nfor item in items:\n    self.__collapse_item(item)\nif items:\n    self.scrollToItem(items[0])\nSlot()",
        "CUT_4": "items = self.selectedItems()\nif not items:\n    items = self.get_top_level_items()\nfor item in items:\n    self.__expand_item(item)\nif items:\n    self.scrollToItem(items[0])\nSlot()",
        "CUT_5": "items = self.selectedItems()\nif not items:\n    items = self.get_top_level_items()\nfor item in items:\n    self.__collapse_item(item)\nif items:\n    self.scrollToItem(items[0])\nSlot()"
    },
    {
        "functionName": "test_pandas_completions",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc_pandas = 'import pandas as pd; pd.'\ncom_position = {'line': 0, 'character': len(doc_pandas)}\ndoc = Document(DOC_URI, workspace, doc_pandas)\nitems = pyls_jedi_completions(config, doc, com_position)\nassert items\nassert any([('DataFrame' in i['label']) for i in items])\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "items = self.selectedItems()\nif not items:\n    items = self.get_top_level_items()\nfor item in items:\n    self.__collapse_item(item)\nif items:\n    self.scrollToItem(items[0])\nSlot()",
        "CUT_3": "items = self.selectedItems()\nif not items:\n    items = self.get_top_level_items()\nfor item in items:\n    self.__collapse_item(item)\nif items:\n    self.scrollToItem(items[0])\nSlot()",
        "CUT_4": "items = self.selectedItems()\nif not items:\n    items = self.get_top_level_items()\nfor item in items:\n    self.__expand_item(item)\nif items:\n    self.scrollToItem(items[0])\nSlot()",
        "CUT_5": "items = self.selectedItems()\nif not items:\n    items = self.get_top_level_items()\nfor item in items:\n    self.__expand_item(item)\nif items:\n    self.scrollToItem(items[0])\nSlot()"
    },
    {
        "functionName": "test_matplotlib_completions",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc_mpl = 'import matplotlib.pyplot as plt; plt.'\ncom_position = {'line': 0, 'character': len(doc_mpl)}\ndoc = Document(DOC_URI, workspace, doc_mpl)\nitems = pyls_jedi_completions(config, doc, com_position)\nassert items\nassert any([('plot' in i['label']) for i in items])\n",
        "CUT_1": "\"\"\"Plot item\"\"\"\ndata = self.source_model.get_data()\nimport spyder.pyplot as plt\nplt.figure()\ngetattr(plt, funcname)(data[key])\nplt.show()\n",
        "CUT_2": "\"\"\"Plot item\"\"\"\ndata = self.source_model.get_data()\nimport spyder.pyplot as plt\nplt.figure()\ngetattr(plt, funcname)(data[key])\nplt.show()\n",
        "CUT_3": "\"\"\"Close all Matplotlib figures.\"\"\"\ntry:\n    import matplotlib.pyplot as plt\n    plt.close('all')\n    del plt\nexcept:\n    pass\n",
        "CUT_4": "\"\"\"Show item's image\"\"\"\ndata = self.source_model.get_data()\nimport spyder.pyplot as plt\nplt.figure()\nplt.imshow(data[key])\nplt.show()\n",
        "CUT_5": "\"\"\"Show item's image\"\"\"\ndata = self.source_model.get_data()\nimport spyder.pyplot as plt\nplt.figure()\nplt.imshow(data[key])\nplt.show()\n"
    },
    {
        "functionName": "test_snippets_completion",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc_snippets = \"\"\"from collections import defaultdict \na=defaultdict\"\"\"\ncom_position = {'line': 0, 'character': 35}\ndoc = Document(DOC_URI, workspace, doc_snippets)\nconfig.capabilities['textDocument'] = {'completion': {'completionItem': {\n    'snippetSupport': True}}}\nconfig.update({'plugins': {'jedi_completion': {'include_params': True}}})\ncompletions = pyls_jedi_completions(config, doc, com_position)\nassert completions[0]['insertText'] == 'defaultdict'\ncom_position = {'line': 1, 'character': len(doc_snippets)}\ncompletions = pyls_jedi_completions(config, doc, com_position)\nassert completions[0]['insertText'] == 'defaultdict($0)'\nassert completions[0]['insertTextFormat'] == lsp.InsertTextFormat.Snippet\n",
        "CUT_1": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n",
        "CUT_2": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n",
        "CUT_3": "return self.completions(textDocument['uri'], position)\n",
        "CUT_4": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_5": "\"\"\"Get formatted completions for current code position\"\"\"\nsettings = config.plugin_settings('jedi_completion', document_path=document\n    .path)\ncode_position = _utils.position_to_jedi_linecolumn(document, position)\ncode_position['fuzzy'] = settings.get('fuzzy', False)\ncompletions = document.jedi_script(use_document_path=True).complete(**\n    code_position)\nif not completions:\n    return None\ncompletion_capabilities = config.capabilities.get('textDocument', {}).get(\n    'completion', {})\nsnippet_support = completion_capabilities.get('completionItem', {}).get(\n    'snippetSupport')\nshould_include_params = settings.get('include_params')\nshould_include_class_objects = settings.get('include_class_objects', True)\ninclude_params = snippet_support and should_include_params and use_snippets(\n    document, position)\ninclude_class_objects = (snippet_support and should_include_class_objects and\n    use_snippets(document, position))\nready_completions = [_format_completion(c, include_params) for c in completions\n    ]\nif include_class_objects:\n    for c in completions:\n        if c.type == 'class':\n            completion_dict = _format_completion(c, False)\n            completion_dict['kind'] = lsp.CompletionItemKind.TypeParameter\n            completion_dict['label'] += ' object'\n            ready_completions.append(completion_dict)\nreturn ready_completions or None\nhookimpl"
    },
    {
        "functionName": "test_completion_with_class_objects",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc_text = \"\"\"class FOOBAR(Object): pass\nFOOB\"\"\"\ncom_position = {'line': 1, 'character': 4}\ndoc = Document(DOC_URI, workspace, doc_text)\nconfig.capabilities['textDocument'] = {'completion': {'completionItem': {\n    'snippetSupport': True}}}\nconfig.update({'plugins': {'jedi_completion': {'include_params': True,\n    'include_class_objects': True}}})\ncompletions = pyls_jedi_completions(config, doc, com_position)\nassert len(completions) == 2\nassert completions[0]['label'] == 'FOOBAR'\nassert completions[0]['kind'] == lsp.CompletionItemKind.Class\nassert completions[1]['label'] == 'FOOBAR object'\nassert completions[1]['kind'] == lsp.CompletionItemKind.TypeParameter\n",
        "CUT_1": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n",
        "CUT_2": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n",
        "CUT_3": "\"\"\"Get formatted completions for current code position\"\"\"\nsettings = config.plugin_settings('jedi_completion', document_path=document\n    .path)\ncode_position = _utils.position_to_jedi_linecolumn(document, position)\ncode_position['fuzzy'] = settings.get('fuzzy', False)\ncompletions = document.jedi_script(use_document_path=True).complete(**\n    code_position)\nif not completions:\n    return None\ncompletion_capabilities = config.capabilities.get('textDocument', {}).get(\n    'completion', {})\nsnippet_support = completion_capabilities.get('completionItem', {}).get(\n    'snippetSupport')\nshould_include_params = settings.get('include_params')\nshould_include_class_objects = settings.get('include_class_objects', True)\ninclude_params = snippet_support and should_include_params and use_snippets(\n    document, position)\ninclude_class_objects = (snippet_support and should_include_class_objects and\n    use_snippets(document, position))\nready_completions = [_format_completion(c, include_params) for c in completions\n    ]\nif include_class_objects:\n    for c in completions:\n        if c.type == 'class':\n            completion_dict = _format_completion(c, False)\n            completion_dict['kind'] = lsp.CompletionItemKind.TypeParameter\n            completion_dict['label'] += ' object'\n            ready_completions.append(completion_dict)\nreturn ready_completions or None\nhookimpl",
        "CUT_4": "return self.completions(textDocument['uri'], position)\n",
        "CUT_5": "\"\"\" Return the VSCode type \"\"\"\nMAP = {'none': lsp.CompletionItemKind.Value, 'type': lsp.CompletionItemKind\n    .Class, 'tuple': lsp.CompletionItemKind.Class, 'dict': lsp.\n    CompletionItemKind.Class, 'dictionary': lsp.CompletionItemKind.Class,\n    'function': lsp.CompletionItemKind.Function, 'lambda': lsp.\n    CompletionItemKind.Function, 'generator': lsp.CompletionItemKind.\n    Function, 'class': lsp.CompletionItemKind.Class, 'instance': lsp.\n    CompletionItemKind.Reference, 'method': lsp.CompletionItemKind.Method,\n    'builtin': lsp.CompletionItemKind.Class, 'builtinfunction': lsp.\n    CompletionItemKind.Function, 'module': lsp.CompletionItemKind.Module,\n    'file': lsp.CompletionItemKind.File, 'xrange': lsp.CompletionItemKind.\n    Class, 'slice': lsp.CompletionItemKind.Class, 'traceback': lsp.\n    CompletionItemKind.Class, 'frame': lsp.CompletionItemKind.Class,\n    'buffer': lsp.CompletionItemKind.Class, 'dictproxy': lsp.\n    CompletionItemKind.Class, 'funcdef': lsp.CompletionItemKind.Function,\n    'property': lsp.CompletionItemKind.Property, 'import': lsp.\n    CompletionItemKind.Module, 'keyword': lsp.CompletionItemKind.Keyword,\n    'constant': lsp.CompletionItemKind.Variable, 'variable': lsp.\n    CompletionItemKind.Variable, 'value': lsp.CompletionItemKind.Value,\n    'param': lsp.CompletionItemKind.Variable, 'statement': lsp.\n    CompletionItemKind.Keyword}\nreturn MAP.get(d.type)\n"
    },
    {
        "functionName": "test_snippet_parsing",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = \"\"\"import numpy as np\nnp.logical_and\"\"\"\ncompletion_position = {'line': 1, 'character': 14}\ndoc = Document(DOC_URI, workspace, doc)\nconfig.capabilities['textDocument'] = {'completion': {'completionItem': {\n    'snippetSupport': True}}}\nconfig.update({'plugins': {'jedi_completion': {'include_params': True}}})\ncompletions = pyls_jedi_completions(config, doc, completion_position)\nout = 'logical_and(${1:x1}, ${2:x2})$0'\nassert completions[0]['insertText'] == out\n",
        "CUT_1": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "return Document(DOC_URI, workspace, DOC)\npytest.fixture"
    },
    {
        "functionName": "test_multiline_import_snippets",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "document = \"\"\"from datetime import(\n date,\n datetime)\na=date\"\"\"\ndoc = Document(DOC_URI, workspace, document)\nconfig.capabilities['textDocument'] = {'completion': {'completionItem': {\n    'snippetSupport': True}}}\nconfig.update({'plugins': {'jedi_completion': {'include_params': True}}})\nposition = {'line': 1, 'character': 5}\ncompletions = pyls_jedi_completions(config, doc, position)\nassert completions[0]['insertText'] == 'date'\nposition = {'line': 2, 'character': 9}\ncompletions = pyls_jedi_completions(config, doc, position)\nassert completions[0]['insertText'] == 'datetime'\n",
        "CUT_1": "return self.completions(textDocument['uri'], position)\n",
        "CUT_2": "\"\"\"Get formatted completions for current code position\"\"\"\nsettings = config.plugin_settings('jedi_completion', document_path=document\n    .path)\ncode_position = _utils.position_to_jedi_linecolumn(document, position)\ncode_position['fuzzy'] = settings.get('fuzzy', False)\ncompletions = document.jedi_script(use_document_path=True).complete(**\n    code_position)\nif not completions:\n    return None\ncompletion_capabilities = config.capabilities.get('textDocument', {}).get(\n    'completion', {})\nsnippet_support = completion_capabilities.get('completionItem', {}).get(\n    'snippetSupport')\nshould_include_params = settings.get('include_params')\nshould_include_class_objects = settings.get('include_class_objects', True)\ninclude_params = snippet_support and should_include_params and use_snippets(\n    document, position)\ninclude_class_objects = (snippet_support and should_include_class_objects and\n    use_snippets(document, position))\nready_completions = [_format_completion(c, include_params) for c in completions\n    ]\nif include_class_objects:\n    for c in completions:\n        if c.type == 'class':\n            completion_dict = _format_completion(c, False)\n            completion_dict['kind'] = lsp.CompletionItemKind.TypeParameter\n            completion_dict['label'] += ' object'\n            ready_completions.append(completion_dict)\nreturn ready_completions or None\nhookimpl",
        "CUT_3": "completions = self._hook('pyls_completions', doc_uri, position=position)\nreturn {'isIncomplete': False, 'items': flatten(completions)}\n",
        "CUT_4": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n",
        "CUT_5": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n"
    },
    {
        "functionName": "test_multiline_snippets",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "document = \"\"\"from datetime import\\\\\n date,\\\\\n datetime \na=date\"\"\"\ndoc = Document(DOC_URI, workspace, document)\nconfig.capabilities['textDocument'] = {'completion': {'completionItem': {\n    'snippetSupport': True}}}\nconfig.update({'plugins': {'jedi_completion': {'include_params': True}}})\nposition = {'line': 1, 'character': 5}\ncompletions = pyls_jedi_completions(config, doc, position)\nassert completions[0]['insertText'] == 'date'\nposition = {'line': 2, 'character': 9}\ncompletions = pyls_jedi_completions(config, doc, position)\nassert completions[0]['insertText'] == 'datetime'\n",
        "CUT_1": "return self.completions(textDocument['uri'], position)\n",
        "CUT_2": "\"\"\"Get formatted completions for current code position\"\"\"\nsettings = config.plugin_settings('jedi_completion', document_path=document\n    .path)\ncode_position = _utils.position_to_jedi_linecolumn(document, position)\ncode_position['fuzzy'] = settings.get('fuzzy', False)\ncompletions = document.jedi_script(use_document_path=True).complete(**\n    code_position)\nif not completions:\n    return None\ncompletion_capabilities = config.capabilities.get('textDocument', {}).get(\n    'completion', {})\nsnippet_support = completion_capabilities.get('completionItem', {}).get(\n    'snippetSupport')\nshould_include_params = settings.get('include_params')\nshould_include_class_objects = settings.get('include_class_objects', True)\ninclude_params = snippet_support and should_include_params and use_snippets(\n    document, position)\ninclude_class_objects = (snippet_support and should_include_class_objects and\n    use_snippets(document, position))\nready_completions = [_format_completion(c, include_params) for c in completions\n    ]\nif include_class_objects:\n    for c in completions:\n        if c.type == 'class':\n            completion_dict = _format_completion(c, False)\n            completion_dict['kind'] = lsp.CompletionItemKind.TypeParameter\n            completion_dict['label'] += ' object'\n            ready_completions.append(completion_dict)\nreturn ready_completions or None\nhookimpl",
        "CUT_3": "completions = self._hook('pyls_completions', doc_uri, position=position)\nreturn {'isIncomplete': False, 'items': flatten(completions)}\n",
        "CUT_4": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n",
        "CUT_5": "\"\"\"Display the possible completions\"\"\"\nif not completions:\n    return\nif not isinstance(completions[0], tuple):\n    completions = [(c, '') for c in completions]\nif len(completions) == 1 and completions[0][0] == completion_text:\n    return\nself.completion_text = completion_text\nunderscore = set([(comp, t) for comp, t in completions if comp.startswith('_')]\n    )\ncompletions = sorted(set(completions) - underscore, key=lambda x: str_lower\n    (x[0]))\ncompletions += sorted(underscore, key=lambda x: str_lower(x[0]))\nself.show_completion_widget(completions)\n"
    },
    {
        "functionName": "test_multistatement_snippet",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "config.capabilities['textDocument'] = {'completion': {'completionItem': {\n    'snippetSupport': True}}}\nconfig.update({'plugins': {'jedi_completion': {'include_params': True}}})\ndocument = 'a = 1; from datetime import date'\ndoc = Document(DOC_URI, workspace, document)\nposition = {'line': 0, 'character': len(document)}\ncompletions = pyls_jedi_completions(config, doc, position)\nassert completions[0]['insertText'] == 'date'\ndocument = 'from datetime import date; a = date'\ndoc = Document(DOC_URI, workspace, document)\nposition = {'line': 0, 'character': len(document)}\ncompletions = pyls_jedi_completions(config, doc, position)\nassert completions[0]['insertText'\n    ] == 'date(${1:year}, ${2:month}, ${3:day})$0'\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "log.info('Formatting document %s with autopep8', document)\nreturn _format(config, document)\nhookimpl(tryfirst=True)",
        "CUT_4": "\"\"\"Get formatted completions for current code position\"\"\"\nsettings = config.plugin_settings('jedi_completion', document_path=document\n    .path)\ncode_position = _utils.position_to_jedi_linecolumn(document, position)\ncode_position['fuzzy'] = settings.get('fuzzy', False)\ncompletions = document.jedi_script(use_document_path=True).complete(**\n    code_position)\nif not completions:\n    return None\ncompletion_capabilities = config.capabilities.get('textDocument', {}).get(\n    'completion', {})\nsnippet_support = completion_capabilities.get('completionItem', {}).get(\n    'snippetSupport')\nshould_include_params = settings.get('include_params')\nshould_include_class_objects = settings.get('include_class_objects', True)\ninclude_params = snippet_support and should_include_params and use_snippets(\n    document, position)\ninclude_class_objects = (snippet_support and should_include_class_objects and\n    use_snippets(document, position))\nready_completions = [_format_completion(c, include_params) for c in completions\n    ]\nif include_class_objects:\n    for c in completions:\n        if c.type == 'class':\n            completion_dict = _format_completion(c, False)\n            completion_dict['kind'] = lsp.CompletionItemKind.TypeParameter\n            completion_dict['label'] += ' object'\n            ready_completions.append(completion_dict)\nreturn ready_completions or None\nhookimpl",
        "CUT_5": "return self.completions(textDocument['uri'], position)\n"
    },
    {
        "functionName": "test_jedi_completion_extra_paths",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "temp_doc_content = \"\"\"\ndef spam():\n    pass\n\"\"\"\np = tmpdir.mkdir('extra_path')\nextra_paths = [str(p)]\np = p.join('foo.py')\np.write(temp_doc_content)\ndoc_content = 'import foo\\nfoo.s'\ndoc = Document(DOC_URI, workspace, doc_content)\ncom_position = {'line': 1, 'character': 5}\ncompletions = pyls_jedi_completions(doc._config, doc, com_position)\nassert completions is None\nsettings = {'pyls': {'plugins': {'jedi': {'extra_paths': extra_paths}}}}\ndoc.update_config(settings)\ncom_position = {'line': 1, 'character': 5}\ncompletions = pyls_jedi_completions(doc._config, doc, com_position)\nassert completions[0]['label'] == 'spam()'\n",
        "CUT_1": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n"
    },
    {
        "functionName": "test_jedi_completion_environment",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc_content = 'import logh\\n'\ndoc = Document(DOC_URI, workspace, doc_content)\ncom_position = {'line': 0, 'character': 11}\nassert os.path.isdir('/tmp/pyenv/')\nsettings = {'pyls': {'plugins': {'jedi': {'environment': None}}}}\ndoc.update_config(settings)\ncompletions = pyls_jedi_completions(doc._config, doc, com_position)\nassert completions is None\nenv_path = '/tmp/pyenv/bin/python'\nsettings = {'pyls': {'plugins': {'jedi': {'environment': env_path}}}}\ndoc.update_config(settings)\ncompletions = pyls_jedi_completions(doc._config, doc, com_position)\nassert completions[0]['label'] == 'loghub'\nassert 'changelog generator' in completions[0]['documentation'].lower()\npytest.mark.skipif(PY2 or not LINUX or not CI, reason=\n    'tested on linux and python 3 only')",
        "CUT_1": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "\"\"\"\n        Return the expected height of this item's text, including\n        the text margins.\n        \"\"\"\ndoc = QTextDocument()\ndoc.setHtml('<hr>')\ndoc.setDocumentMargin(self._PADDING)\nreturn doc.size().height()\n"
    },
    {
        "functionName": "test_document_path_completions",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_completion.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "module_content = \"\"\"\ndef foo():\n    pass\n\"\"\"\np = tmpdir.join('mymodule.py')\np.write(module_content)\ndoc_content = \"\"\"import mymodule\nmymodule.f\"\"\"\ndoc_path = str(tmpdir) + os.path.sep + 'myfile.py'\ndoc_uri = uris.from_fs_path(doc_path)\ndoc = Document(doc_uri, workspace_other_root_path, doc_content)\ncom_position = {'line': 1, 'character': 10}\ncompletions = pyls_jedi_completions(doc._config, doc, com_position)\nassert completions[0]['label'] == 'foo()'\n",
        "CUT_1": "\"\"\"\n    Return Python documentation path\n    (Windows: return the PythonXX.chm path if available)\n    \"\"\"\nif os.name == 'nt':\n    doc_path = osp.join(sys.prefix, 'Doc')\n    if not osp.isdir(doc_path):\n        return\n    python_chm = [path for path in os.listdir(doc_path) if re.match(\n        '(?i)Python[0-9]{3,6}.chm', path)]\n    if python_chm:\n        return file_uri(osp.join(doc_path, python_chm[0]))\nelse:\n    vinf = sys.version_info\n    doc_path = '/usr/share/doc/python%d.%d/html' % (vinf[0], vinf[1])\npython_doc = osp.join(doc_path, 'index.html')\nif osp.isfile(python_doc):\n    return file_uri(python_doc)\n",
        "CUT_2": "\"\"\"\n    Return Python documentation path\n    (Windows: return the PythonXX.chm path if available)\n    \"\"\"\nif os.name == 'nt':\n    doc_path = osp.join(sys.prefix, 'Doc')\n    if not osp.isdir(doc_path):\n        return\n    python_chm = [path for path in os.listdir(doc_path) if re.match(\n        '(?i)Python[0-9]{3,6}.chm', path)]\n    if python_chm:\n        return file_uri(osp.join(doc_path, python_chm[0]))\nelse:\n    vinf = sys.version_info\n    doc_path = '/usr/share/doc/python%d.%d/html' % (vinf[0], vinf[1])\npython_doc = osp.join(doc_path, 'index.html')\nif osp.isfile(python_doc):\n    return file_uri(python_doc)\n",
        "CUT_3": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_4": "\"\"\"Create and save some python codes in temporary files.\"\"\"\ntmpdir = tmpdir_factory.mktemp('files')\ntmpdir = osp.normcase(tmpdir.strpath)\nfilenames = [osp.join(tmpdir, f) for f in ('file1.py', 'file2.py',\n    'file3.py', 'file4.py', 'untitled4.py')]\nfor filename in filenames:\n    with open(filename, 'w') as f:\n        f.write('# -*- coding: utf-8 -*-\\nprint(Hello World!)\\n')\nreturn filenames, tmpdir\npytest.fixture(scope='module')",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_pydocstyle",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pydocstyle_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\ndiags = pydocstyle_lint.pyls_lint(config, doc)\nassert all([(d['source'] == 'pydocstyle') for d in diags])\nassert diags[0] == {'code': 'D100', 'message':\n    'D100: Missing docstring in public module', 'severity': lsp.\n    DiagnosticSeverity.Warning, 'range': {'start': {'line': 0, 'character':\n    0}, 'end': {'line': 0, 'character': 11}}, 'source': 'pydocstyle'}\n",
        "CUT_1": "lineno = error.definition.start - 1\nline = document.lines[0] if document.lines else ''\nstart_character = len(line) - len(line.lstrip())\nend_character = len(line)\nreturn {'source': 'pydocstyle', 'code': error.code, 'message': error.\n    message, 'severity': lsp.DiagnosticSeverity.Warning, 'range': {'start':\n    {'line': lineno, 'character': start_character}, 'end': {'line': lineno,\n    'character': end_character}}}\n",
        "CUT_2": "err_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 0,\n    'character': 0}}\nself.diagnostics.append({'source': 'pyflakes', 'range': err_range,\n    'message': msg, 'severity': lsp.DiagnosticSeverity.Error})\n",
        "CUT_3": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_pydocstyle_test_document",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pydocstyle_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(TEST_DOC_URI, workspace, '')\ndiags = pydocstyle_lint.pyls_lint(config, doc)\nassert not diags\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_pydocstyle_empty_source",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pydocstyle_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, '')\ndiags = pydocstyle_lint.pyls_lint(config, doc)\nassert diags[0]['message'] == 'D100: Missing docstring in public module'\nassert len(diags) == 1\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "workspace = self._match_uri_to_workspace(doc_uri)\nif doc_uri in workspace.documents:\n    workspace.publish_diagnostics(doc_uri, flatten(self._hook('pyls_lint',\n        doc_uri, is_saved=is_saved)))\n_utils.debounce(LINT_DEBOUNCE_S, keyed_by='doc_uri')"
    },
    {
        "functionName": "test_pydocstyle_invalid_source",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_pydocstyle_lint.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, 'bad syntax')\ndiags = pydocstyle_lint.pyls_lint(config, doc)\nassert not diags\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "workspace = self._match_uri_to_workspace(doc_uri)\nif doc_uri in workspace.documents:\n    workspace.publish_diagnostics(doc_uri, flatten(self._hook('pyls_lint',\n        doc_uri, is_saved=is_saved)))\n_utils.debounce(LINT_DEBOUNCE_S, keyed_by='doc_uri')",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_format",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_autopep8_format.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\nres = pyls_format_document(config, doc)\nassert len(res) == 1\nassert res[0]['newText'] == \"\"\"a = 123\n\n\ndef func():\n    pass\n\"\"\"\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_3": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_range_format",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_autopep8_format.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, DOC)\ndef_range = {'start': {'line': 0, 'character': 0}, 'end': {'line': 2,\n    'character': 0}}\nres = pyls_format_range(config, doc, def_range)\nassert len(res) == 1\nassert res[0]['newText'] == \"\"\"a = 123\n\n\n\n\ndef func():\n    pass\n\"\"\"\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_3": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_no_change",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_autopep8_format.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, GOOD_DOC)\nassert not pyls_format_document(config, doc)\n",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Calls hook_name and returns a list of results from all registered handlers\"\"\"\nworkspace = self._match_uri_to_workspace(doc_uri)\ndoc = workspace.get_document(doc_uri) if doc_uri else None\nhook_handlers = self.config.plugin_manager.subset_hook_caller(hook_name,\n    self.config.disabled_plugins)\nreturn hook_handlers(config=self.config, workspace=workspace, document=doc,\n    **kwargs)\n",
        "CUT_3": "return self._hook('pyls_format_document', doc_uri)\n",
        "CUT_4": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n",
        "CUT_5": "html_text = self.html_text_no_doc\ndoc = self.doc\nif doc is not None:\n    if type(doc) is dict and 'docstring' in doc.keys():\n        try:\n            context = generate_context(name=doc['name'], argspec=doc[\n                'argspec'], note=doc['note'], math=self.math_option,\n                img_path=self.img_path, css_path=self.css_path)\n            html_text = sphinxify(doc['docstring'], context)\n            if doc['docstring'] == '':\n                if any([doc['name'], doc['argspec'], doc['note']]):\n                    msg = _('No further documentation available')\n                    html_text += '<div class=\"hr\"></div>'\n                else:\n                    msg = _('No documentation available')\n                html_text += '<div id=\"doc-warning\">%s</div>' % msg\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\n    elif self.context is not None:\n        try:\n            html_text = sphinxify(doc, self.context)\n        except Exception as error:\n            self.error_msg.emit(to_text_string(error))\n            return\nself.html_ready.emit(html_text)\n"
    },
    {
        "functionName": "test_hanging_indentation",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_autopep8_format.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "doc = Document(DOC_URI, workspace, INDENTED_DOC)\nres = pyls_format_document(config, doc)\nassert len(res) == 1\nassert res[0]['newText'] == CORRECT_INDENTED_DOC\n",
        "CUT_1": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_2": "\"\"\"\n    Convert file data to a string for display.\n\n    This function takes the file data produced by gather_file_data().\n    \"\"\"\nif not data:\n    return _('<i>File name not recorded</i>')\nres = data['name']\ntry:\n    mtime_as_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(data[\n        'mtime']))\n    res += '<br><i>{}</i>: {}'.format(_('Last modified'), mtime_as_str)\n    res += '<br><i>{}</i>: {} {}'.format(_('Size'), data['size'], _('bytes'))\nexcept KeyError:\n    res += '<br>' + _('<i>File no longer exists</i>')\nreturn res\n",
        "CUT_3": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_4": "\"\"\"\n    Gather data about a given file.\n\n    Returns a dict with fields 'name', 'mtime' and 'size', containing the\n    relevant data for the file. If the file does not exists, then the dict\n    contains only the field `name`.\n    \"\"\"\nres = {'name': name}\ntry:\n    res['mtime'] = osp.getmtime(name)\n    res['size'] = osp.getsize(name)\nexcept OSError:\n    pass\nreturn res\n",
        "CUT_5": "return Document(DOC_URI, workspace, DOC)\npytest.fixture"
    },
    {
        "functionName": "tmp_workspace",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_rope_rename.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "return temp_workspace_factory({DOC_NAME: DOC})\npytest.fixture",
        "CUT_1": "return Document(DOC_URI, workspace, DOC)\npytest.fixture",
        "CUT_2": "\"\"\"Return a config object.\"\"\"\nreturn Config(workspace.root_uri, {}, 0, {})\npytest.fixture",
        "CUT_3": "\"\"\"Module fixture for qtbot.\"\"\"\nresult = QtBot(request)\nreturn result\npytest.fixture(scope='module')",
        "CUT_4": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n",
        "CUT_5": "options = QStyleOptionViewItem(option)\nself.initStyleOption(options, index)\ndoc = QTextDocument()\ndoc.setHtml(options.text)\ndoc.setTextWidth(options.rect.width())\nreturn QSize(doc.idealWidth(), doc.size().height())\n"
    },
    {
        "functionName": "test_rope_rename",
        "className": null,
        "fileName": "/external-deps/python-language-server/test/plugins/test_rope_rename.py",
        "projectName": "spyder",
        "Label": 0,
        "isTest": true,
        "Body": "position = {'line': 0, 'character': 6}\nDOC_URI = uris.from_fs_path(os.path.join(tmp_workspace.root_path, DOC_NAME))\ndoc = Document(DOC_URI, tmp_workspace)\nresult = pyls_rename(config, tmp_workspace, doc, position, 'ShouldBeRenamed')\nassert len(result.keys()) == 1\nchanges = result.get('documentChanges')\nassert len(changes) == 1\nchanges = changes[0]\nassert changes.get('edits') == [{'range': {'start': {'line': 0, 'character':\n    0}, 'end': {'line': 5, 'character': 0}}, 'newText':\n    \"\"\"class ShouldBeRenamed():\n    pass\n\nclass Test2(ShouldBeRenamed):\n    pass\n\"\"\"\n    }]\n",
        "CUT_1": "rope_config = config.settings(document_path=document.path).get('rope', {})\nrope_project = workspace._rope_project_builder(rope_config)\nrename = Rename(rope_project, libutils.path_to_resource(rope_project,\n    document.path), document.offset_at_position(position))\nlog.debug('Executing rename of %s to %s', document.word_at_position(\n    position), new_name)\nchangeset = rename.get_changes(new_name, in_hierarchy=True, docs=True)\nlog.debug('Finished rename: %s', changeset.changes)\nchanges = []\nfor change in changeset.changes:\n    uri = uris.from_fs_path(change.resource.path)\n    doc = workspace.get_maybe_document(uri)\n    changes.append({'textDocument': {'uri': uri, 'version': doc.version if\n        doc else None}, 'edits': [{'range': {'start': {'line': 0,\n        'character': 0}, 'end': {'line': _num_lines(change.resource),\n        'character': 0}}, 'newText': change.new_contents}]})\nreturn {'documentChanges': changes}\nhookimpl",
        "CUT_2": "log.debug('Executing rename of %s to %s', document.word_at_position(\n    position), new_name)\nkwargs = _utils.position_to_jedi_linecolumn(document, position)\nkwargs['new_name'] = new_name\ntry:\n    refactoring = document.jedi_script().rename(**kwargs)\nexcept NotImplementedError:\n    raise Exception(\n        'No support for renaming in Python 2/3.5 with Jedi. Consider using the rope_rename plugin instead'\n        )\nlog.debug('Finished rename: %s', refactoring.get_diff())\nchanges = []\nfor file_path, changed_file in refactoring.get_changed_files().items():\n    uri = uris.from_fs_path(str(file_path))\n    doc = workspace.get_maybe_document(uri)\n    changes.append({'textDocument': {'uri': uri, 'version': doc.version if\n        doc else None}, 'edits': [{'range': {'start': {'line': 0,\n        'character': 0}, 'end': {'line': _num_lines(changed_file.\n        get_new_code()), 'character': 0}}, 'newText': changed_file.\n        get_new_code()}]})\nreturn {'documentChanges': changes}\nhookimpl",
        "CUT_3": "changes = []\nentries = params.get('params', [])\nfor entry in entries:\n    changes.append({'uri': path_as_uri(entry['file']), 'type': entry['kind']})\nparams = {'changes': changes}\nreturn params\nsend_notification(method=LSPRequestTypes.WORKSPACE_WATCHED_FILES_UPDATE)",
        "CUT_4": "changes = []\nentries = params.get('params', [])\nfor entry in entries:\n    changes.append({'uri': path_as_uri(entry['file']), 'type': entry['kind']})\nparams = {'changes': changes}\nreturn params\nsend_notification(method=LSPRequestTypes.WORKSPACE_WATCHED_FILES_UPDATE)",
        "CUT_5": "\"\"\"1 character key\"\"\"\npass\n"
    }
]