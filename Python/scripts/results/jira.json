[
    {
        "functionName": "test_Valid",
        "className": "TestTopologicallySorted",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/common_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that sorting works on a valid graph with one possible order.\"\"\"\ngraph = {'a': ['b', 'c'], 'b': [], 'c': ['d'], 'd': ['b']}\ndef GetEdge(node):\n    return tuple(graph[node])\nself.assertEqual(gyp.common.TopologicallySorted(graph.keys(), GetEdge), [\n    'a', 'c', 'd', 'b'])\n",
        "CUT_1": "\"\"\"Topologically sort based on a user provided edge definition.\n\n  Args:\n    graph: A list of node names.\n    get_edges: A function mapping from node name to a hashable collection\n               of node names which this node has outgoing edges to.\n  Returns:\n    A list containing all of the node in graph in topological order.\n    It is assumed that calling get_edges once for each node and caching is\n    cheaper than repeatedly calling get_edges.\n  Raises:\n    CycleError in the event of a cycle.\n  Example:\n    graph = {'a': '$(b) $(c)', 'b': 'hi', 'c': '$(b)'}\n    def GetEdges(node):\n      return re.findall(r'\\\\$\\\\(([^))]\\\\)', graph[node])\n    print TopologicallySorted(graph.keys(), GetEdges)\n    ==>\n    ['a', 'c', b']\n  \"\"\"\nget_edges = memoize(get_edges)\nvisited = set()\nvisiting = set()\nordered_nodes = []\ndef Visit(node):\n    if node in visiting:\n        raise CycleError(visiting)\n    if node in visited:\n        return\n    visited.add(node)\n    visiting.add(node)\n    for neighbor in get_edges(node):\n        Visit(neighbor)\n    visiting.remove(node)\n    ordered_nodes.insert(0, node)\nfor node in sorted(graph):\n    Visit(node)\nreturn ordered_nodes\n",
        "CUT_2": "if type(node) == dict and len(node) == 1 and list(node)[0\n    ] == parent + '.vcproj':\n    return node[list(node)[0]]\nif type(node) != dict:\n    return node\nfor child in node:\n    node[child] = _CollapseSingles(child, node[child])\nreturn node\n",
        "CUT_3": "trace('data', data)\nnode = data.get('node', '')[:12]\nif node:\n    node = 'h' + node\nif 'tag' in data:\n    return meta(data['tag'], config=config)\nelif 'latesttag' in data:\n    return meta(data['latesttag'], distance=data['latesttagdistance'], node\n        =node, config=config)\nelse:\n    return meta('0.0', node=node, config=config)\n",
        "CUT_4": "if node in visiting:\n    raise CycleError(visiting)\nif node in visited:\n    return\nvisited.add(node)\nvisiting.add(node)\nfor neighbor in get_edges(node):\n    Visit(neighbor)\nvisiting.remove(node)\nordered_nodes.insert(0, node)\n",
        "CUT_5": "if node.nodeType == Node.TEXT_NODE:\n    if node.data.strip():\n        print('%s%s' % (' ' * indent, node.data.strip()))\n    return\nif node.childNodes:\n    node.normalize()\nattr_count = 0\nif node.attributes:\n    attr_count = node.attributes.length\nif attr_count == 0:\n    print('%s<%s>' % (' ' * indent, node.nodeName))\nelse:\n    print('%s<%s' % (' ' * indent, node.nodeName))\n    all_attributes = []\n    for name, value in node.attributes.items():\n        all_attributes.append((name, value))\n        all_attributes.sort(CmpTuple())\n    for name, value in all_attributes:\n        print('%s  %s=\"%s\"' % (' ' * indent, name, value))\n    print('%s>' % (' ' * indent))\nif node.nodeValue:\n    print('%s  %s' % (' ' * indent, node.nodeValue))\nfor sub_node in node.childNodes:\n    PrettyPrintNode(sub_node, indent=indent + 2)\nprint('%s</%s>' % (' ' * indent, node.nodeName))\n"
    },
    {
        "functionName": "test_Cycle",
        "className": "TestTopologicallySorted",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/common_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Test that an exception is thrown on a cyclic graph.\"\"\"\ngraph = {'a': ['b'], 'b': ['c'], 'c': ['d'], 'd': ['a']}\ndef GetEdge(node):\n    return tuple(graph[node])\nself.assertRaises(gyp.common.CycleError, gyp.common.TopologicallySorted,\n    graph.keys(), GetEdge)\n",
        "CUT_1": "\"\"\"Topologically sort based on a user provided edge definition.\n\n  Args:\n    graph: A list of node names.\n    get_edges: A function mapping from node name to a hashable collection\n               of node names which this node has outgoing edges to.\n  Returns:\n    A list containing all of the node in graph in topological order.\n    It is assumed that calling get_edges once for each node and caching is\n    cheaper than repeatedly calling get_edges.\n  Raises:\n    CycleError in the event of a cycle.\n  Example:\n    graph = {'a': '$(b) $(c)', 'b': 'hi', 'c': '$(b)'}\n    def GetEdges(node):\n      return re.findall(r'\\\\$\\\\(([^))]\\\\)', graph[node])\n    print TopologicallySorted(graph.keys(), GetEdges)\n    ==>\n    ['a', 'c', b']\n  \"\"\"\nget_edges = memoize(get_edges)\nvisited = set()\nvisiting = set()\nordered_nodes = []\ndef Visit(node):\n    if node in visiting:\n        raise CycleError(visiting)\n    if node in visited:\n        return\n    visited.add(node)\n    visiting.add(node)\n    for neighbor in get_edges(node):\n        Visit(neighbor)\n    visiting.remove(node)\n    ordered_nodes.insert(0, node)\nfor node in sorted(graph):\n    Visit(node)\nreturn ordered_nodes\n",
        "CUT_2": "if type(node) == dict and len(node) == 1 and list(node)[0\n    ] == parent + '.vcproj':\n    return node[list(node)[0]]\nif type(node) != dict:\n    return node\nfor child in node:\n    node[child] = _CollapseSingles(child, node[child])\nreturn node\n",
        "CUT_3": "if node in visiting:\n    raise CycleError(visiting)\nif node in visited:\n    return\nvisited.add(node)\nvisiting.add(node)\nfor neighbor in get_edges(node):\n    Visit(neighbor)\nvisiting.remove(node)\nordered_nodes.insert(0, node)\n",
        "CUT_4": "trace('data', data)\nnode = data.get('node', '')[:12]\nif node:\n    node = 'h' + node\nif 'tag' in data:\n    return meta(data['tag'], config=config)\nelif 'latesttag' in data:\n    return meta(data['latesttag'], distance=data['latesttagdistance'], node\n        =node, config=config)\nelse:\n    return meta('0.0', node=node, config=config)\n",
        "CUT_5": "if node.nodeType == Node.TEXT_NODE:\n    if node.data.strip():\n        print('%s%s' % (' ' * indent, node.data.strip()))\n    return\nif node.childNodes:\n    node.normalize()\nattr_count = 0\nif node.attributes:\n    attr_count = node.attributes.length\nif attr_count == 0:\n    print('%s<%s>' % (' ' * indent, node.nodeName))\nelse:\n    print('%s<%s' % (' ' * indent, node.nodeName))\n    all_attributes = []\n    for name, value in node.attributes.items():\n        all_attributes.append((name, value))\n        all_attributes.sort(CmpTuple())\n    for name, value in all_attributes:\n        print('%s  %s=\"%s\"' % (' ' * indent, name, value))\n    print('%s>' % (' ' * indent))\nif node.nodeValue:\n    print('%s  %s' % (' ' * indent, node.nodeValue))\nfor sub_node in node.childNodes:\n    PrettyPrintNode(sub_node, indent=indent + 2)\nprint('%s</%s>' % (' ' * indent, node.nodeName))\n"
    },
    {
        "functionName": "GetEdge",
        "className": null,
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/common_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "return tuple(graph[node])\n",
        "CUT_1": "\"\"\"Topologically sort based on a user provided edge definition.\n\n  Args:\n    graph: A list of node names.\n    get_edges: A function mapping from node name to a hashable collection\n               of node names which this node has outgoing edges to.\n  Returns:\n    A list containing all of the node in graph in topological order.\n    It is assumed that calling get_edges once for each node and caching is\n    cheaper than repeatedly calling get_edges.\n  Raises:\n    CycleError in the event of a cycle.\n  Example:\n    graph = {'a': '$(b) $(c)', 'b': 'hi', 'c': '$(b)'}\n    def GetEdges(node):\n      return re.findall(r'\\\\$\\\\(([^))]\\\\)', graph[node])\n    print TopologicallySorted(graph.keys(), GetEdges)\n    ==>\n    ['a', 'c', b']\n  \"\"\"\nget_edges = memoize(get_edges)\nvisited = set()\nvisiting = set()\nordered_nodes = []\ndef Visit(node):\n    if node in visiting:\n        raise CycleError(visiting)\n    if node in visited:\n        return\n    visited.add(node)\n    visiting.add(node)\n    for neighbor in get_edges(node):\n        Visit(neighbor)\n    visiting.remove(node)\n    ordered_nodes.insert(0, node)\nfor node in sorted(graph):\n    Visit(node)\nreturn ordered_nodes\n",
        "CUT_2": "if type(node) == dict and len(node) == 1 and list(node)[0\n    ] == parent + '.vcproj':\n    return node[list(node)[0]]\nif type(node) != dict:\n    return node\nfor child in node:\n    node[child] = _CollapseSingles(child, node[child])\nreturn node\n",
        "CUT_3": "trace('data', data)\nnode = data.get('node', '')[:12]\nif node:\n    node = 'h' + node\nif 'tag' in data:\n    return meta(data['tag'], config=config)\nelif 'latesttag' in data:\n    return meta(data['latesttag'], distance=data['latesttagdistance'], node\n        =node, config=config)\nelse:\n    return meta('0.0', node=node, config=config)\n",
        "CUT_4": "if node in visiting:\n    raise CycleError(visiting)\nif node in visited:\n    return\nvisited.add(node)\nvisiting.add(node)\nfor neighbor in get_edges(node):\n    Visit(neighbor)\nvisiting.remove(node)\nordered_nodes.insert(0, node)\n",
        "CUT_5": "if node.nodeType == Node.TEXT_NODE:\n    if node.data.strip():\n        print('%s%s' % (' ' * indent, node.data.strip()))\n    return\nif node.childNodes:\n    node.normalize()\nattr_count = 0\nif node.attributes:\n    attr_count = node.attributes.length\nif attr_count == 0:\n    print('%s<%s>' % (' ' * indent, node.nodeName))\nelse:\n    print('%s<%s' % (' ' * indent, node.nodeName))\n    all_attributes = []\n    for name, value in node.attributes.items():\n        all_attributes.append((name, value))\n        all_attributes.sort(CmpTuple())\n    for name, value in all_attributes:\n        print('%s  %s=\"%s\"' % (' ' * indent, name, value))\n    print('%s>' % (' ' * indent))\nif node.nodeValue:\n    print('%s  %s' % (' ' * indent, node.nodeValue))\nfor sub_node in node.childNodes:\n    PrettyPrintNode(sub_node, indent=indent + 2)\nprint('%s</%s>' % (' ' * indent, node.nodeName))\n"
    },
    {
        "functionName": "setUp",
        "className": "TestGetFlavor",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/common_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.original_platform = sys.platform\n",
        "CUT_1": "\"\"\"Returns |params.flavor| if it's set, the system's default flavor else.\"\"\"\nflavors = {'cygwin': 'win', 'win32': 'win', 'darwin': 'mac'}\nif 'flavor' in params:\n    return params['flavor']\nif sys.platform in flavors:\n    return flavors[sys.platform]\nif sys.platform.startswith('sunos'):\n    return 'solaris'\nif sys.platform.startswith('freebsd'):\n    return 'freebsd'\nif sys.platform.startswith('openbsd'):\n    return 'openbsd'\nif sys.platform.startswith('netbsd'):\n    return 'netbsd'\nif sys.platform.startswith('aix'):\n    return 'aix'\nif sys.platform.startswith('zos'):\n    return 'zos'\nif sys.platform.startswith('os390'):\n    return 'zos'\nreturn 'linux'\n",
        "CUT_2": "configuration = name.rsplit('_', 1)[0]\nplatform = settings.get('msvs_configuration_platform', 'Win32')\nreturn configuration, platform\n",
        "CUT_3": "group = ['ItemGroup', {'Label': 'ProjectConfigurations'}]\nfor name, settings in sorted(configurations.items()):\n    configuration, platform = _GetConfigurationAndPlatform(name, settings)\n    designation = '%s|%s' % (configuration, platform)\n    group.append(['ProjectConfiguration', {'Include': designation}, [\n        'Configuration', configuration], ['Platform', platform]])\nreturn [group]\n",
        "CUT_4": "if len(sys.argv) < 2:\n    print(__doc__, file=sys.stderr)\n    print(file=sys.stderr)\n    print('usage: %s target1 target2...' % sys.argv[0], file=sys.stderr)\n    return 1\nedges = LoadEdges('dump.json', sys.argv[1:])\nWriteGraph(edges)\nreturn 0\n",
        "CUT_5": "\"\"\"Get architecture based on msvs_configuration_platform and\n    msvs_target_platform. Returns either 'x86' or 'x64'.\"\"\"\nconfiguration_platform = self.msvs_configuration_platform.get(config, '')\nplatform = self.msvs_target_platform.get(config, '')\nif not platform:\n    platform = configuration_platform\nreturn {'Win32': 'x86', 'x64': 'x64', 'ARM64': 'arm64'}.get(platform, 'x86')\n"
    },
    {
        "functionName": "tearDown",
        "className": "TestGetFlavor",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/common_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "sys.platform = self.original_platform\n",
        "CUT_1": "\"\"\"Returns |params.flavor| if it's set, the system's default flavor else.\"\"\"\nflavors = {'cygwin': 'win', 'win32': 'win', 'darwin': 'mac'}\nif 'flavor' in params:\n    return params['flavor']\nif sys.platform in flavors:\n    return flavors[sys.platform]\nif sys.platform.startswith('sunos'):\n    return 'solaris'\nif sys.platform.startswith('freebsd'):\n    return 'freebsd'\nif sys.platform.startswith('openbsd'):\n    return 'openbsd'\nif sys.platform.startswith('netbsd'):\n    return 'netbsd'\nif sys.platform.startswith('aix'):\n    return 'aix'\nif sys.platform.startswith('zos'):\n    return 'zos'\nif sys.platform.startswith('os390'):\n    return 'zos'\nreturn 'linux'\n",
        "CUT_2": "configuration = name.rsplit('_', 1)[0]\nplatform = settings.get('msvs_configuration_platform', 'Win32')\nreturn configuration, platform\n",
        "CUT_3": "group = ['ItemGroup', {'Label': 'ProjectConfigurations'}]\nfor name, settings in sorted(configurations.items()):\n    configuration, platform = _GetConfigurationAndPlatform(name, settings)\n    designation = '%s|%s' % (configuration, platform)\n    group.append(['ProjectConfiguration', {'Include': designation}, [\n        'Configuration', configuration], ['Platform', platform]])\nreturn [group]\n",
        "CUT_4": "if len(sys.argv) < 2:\n    print(__doc__, file=sys.stderr)\n    print(file=sys.stderr)\n    print('usage: %s target1 target2...' % sys.argv[0], file=sys.stderr)\n    return 1\nedges = LoadEdges('dump.json', sys.argv[1:])\nWriteGraph(edges)\nreturn 0\n",
        "CUT_5": "\"\"\"Get architecture based on msvs_configuration_platform and\n    msvs_target_platform. Returns either 'x86' or 'x64'.\"\"\"\nconfiguration_platform = self.msvs_configuration_platform.get(config, '')\nplatform = self.msvs_target_platform.get(config, '')\nif not platform:\n    platform = configuration_platform\nreturn {'Win32': 'x86', 'x64': 'x64', 'ARM64': 'arm64'}.get(platform, 'x86')\n"
    },
    {
        "functionName": "assertFlavor",
        "className": "TestGetFlavor",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/common_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "sys.platform = argument\nself.assertEqual(expected, gyp.common.GetFlavor(param))\n",
        "CUT_1": "return 'mac' == gyp.common.GetFlavor(params)\n",
        "CUT_2": "default_variables.setdefault('OS', gyp.common.GetFlavor(params))\n",
        "CUT_3": "\"\"\"Returns |params.flavor| if it's set, the system's default flavor else.\"\"\"\nflavors = {'cygwin': 'win', 'win32': 'win', 'darwin': 'mac'}\nif 'flavor' in params:\n    return params['flavor']\nif sys.platform in flavors:\n    return flavors[sys.platform]\nif sys.platform.startswith('sunos'):\n    return 'solaris'\nif sys.platform.startswith('freebsd'):\n    return 'freebsd'\nif sys.platform.startswith('openbsd'):\n    return 'openbsd'\nif sys.platform.startswith('netbsd'):\n    return 'netbsd'\nif sys.platform.startswith('aix'):\n    return 'aix'\nif sys.platform.startswith('zos'):\n    return 'zos'\nif sys.platform.startswith('os390'):\n    return 'zos'\nreturn 'linux'\n",
        "CUT_4": "\"\"\"Calculate additional variables for use in the build (called by gyp).\"\"\"\ndefault_variables.setdefault('OS', gyp.common.GetFlavor(params))\n",
        "CUT_5": "\"\"\"Encodes |argument| suitably for consumption by POSIX shells.\n\n  argument may be quoted and escaped as necessary to ensure that POSIX shells\n  treat the returned value as a literal representing the argument passed to\n  this function.  Parameter (variable) expansions beginning with $ are allowed\n  to remain intact without escaping the $, to allow the argument to contain\n  references to variables to be expanded by the shell.\n  \"\"\"\nif not isinstance(argument, str):\n    argument = str(argument)\nif _quote.search(argument):\n    quote = '\"'\nelse:\n    quote = ''\nencoded = quote + re.sub(_escape, '\\\\\\\\\\\\1', argument) + quote\nreturn encoded\n"
    },
    {
        "functionName": "test_platform_default",
        "className": "TestGetFlavor",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/common_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.assertFlavor('freebsd', 'freebsd9', {})\nself.assertFlavor('freebsd', 'freebsd10', {})\nself.assertFlavor('openbsd', 'openbsd5', {})\nself.assertFlavor('solaris', 'sunos5', {})\nself.assertFlavor('solaris', 'sunos', {})\nself.assertFlavor('linux', 'linux2', {})\nself.assertFlavor('linux', 'linux3', {})\n",
        "CUT_1": "return self\n",
        "CUT_2": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_3": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_4": "\"\"\"Returns |params.flavor| if it's set, the system's default flavor else.\"\"\"\nflavors = {'cygwin': 'win', 'win32': 'win', 'darwin': 'mac'}\nif 'flavor' in params:\n    return params['flavor']\nif sys.platform in flavors:\n    return flavors[sys.platform]\nif sys.platform.startswith('sunos'):\n    return 'solaris'\nif sys.platform.startswith('freebsd'):\n    return 'freebsd'\nif sys.platform.startswith('openbsd'):\n    return 'openbsd'\nif sys.platform.startswith('netbsd'):\n    return 'netbsd'\nif sys.platform.startswith('aix'):\n    return 'aix'\nif sys.platform.startswith('zos'):\n    return 'zos'\nif sys.platform.startswith('os390'):\n    return 'zos'\nreturn 'linux'\n",
        "CUT_5": "self.pool = None\nself.condition = None\nself.data = None\nself.pending = 0\nself.scheduled = set()\nself.dependencies = []\nself.error = False\n"
    },
    {
        "functionName": "test_param",
        "className": "TestGetFlavor",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/common_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.assertFlavor('foobar', 'linux2', {'flavor': 'foobar'})\n",
        "CUT_1": "\"\"\"Return the 'output basename' of a gyp spec.\n\n    E.g., the loadable module 'foobar' in directory 'baz' will produce\n      'libfoobar.so'\n    \"\"\"\nreturn ''.join(self.ComputeOutputParts(spec))\n",
        "CUT_2": "\"\"\"Return the 'output' (full output path) of a gyp spec.\n\n    E.g., the loadable module 'foobar' in directory 'baz' will produce\n      '$(obj)/baz/libfoobar.so'\n    \"\"\"\nassert not self.is_mac_bundle\npath = os.path.join('$(obj).' + self.toolset, self.path)\nif self.type == 'executable' or self._InstallImmediately():\n    path = '$(builddir)'\npath = spec.get('product_dir', path)\nreturn os.path.join(path, self.ComputeOutputBasename(spec))\n",
        "CUT_3": "\"\"\"Return the 'output' (full output path) of a gyp spec.\n\n    E.g., the loadable module 'foobar' in directory 'baz' will produce\n      '$(obj)/baz/libfoobar.so'\n    \"\"\"\nif self.type == 'executable':\n    path = '$(gyp_shared_intermediate_dir)'\nelif self.type == 'shared_library':\n    if self.toolset == 'host':\n        path = '$($(GYP_HOST_VAR_PREFIX)HOST_OUT_INTERMEDIATE_LIBRARIES)'\n    else:\n        path = '$($(GYP_VAR_PREFIX)TARGET_OUT_INTERMEDIATE_LIBRARIES)'\nelif self.toolset == 'host':\n    path = (\n        '$(call intermediates-dir-for,%s,%s,true,,$(GYP_HOST_VAR_PREFIX))' %\n        (self.android_class, self.android_module))\nelse:\n    path = '$(call intermediates-dir-for,%s,%s,,,$(GYP_VAR_PREFIX))' % (self\n        .android_class, self.android_module)\nassert spec.get('product_dir') is None\nreturn os.path.join(path, self.ComputeOutputBasename(spec))\n",
        "CUT_4": "return self.toolset == 'target' and self.flavor == 'mac' and self.type in (\n    'static_library', 'executable', 'shared_library', 'loadable_module')\n",
        "CUT_5": "\"\"\"Calculate additional variables for use in the build (called by gyp).\"\"\"\nflavor = gyp.common.GetFlavor(params)\nif flavor == 'mac':\n    default_variables.setdefault('OS', 'mac')\nelif flavor == 'win':\n    default_variables.setdefault('OS', 'win')\n    import gyp.generator.msvs as msvs_generator\n    generator_additional_non_configuration_keys = getattr(msvs_generator,\n        'generator_additional_non_configuration_keys', [])\n    generator_additional_path_sections = getattr(msvs_generator,\n        'generator_additional_path_sections', [])\n    gyp.msvs_emulation.CalculateCommonVariables(default_variables, params)\nelse:\n    operating_system = flavor\n    if flavor == 'android':\n        operating_system = 'linux'\n    default_variables.setdefault('OS', operating_system)\n"
    },
    {
        "functionName": "setUp",
        "className": "TestFindCycles",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/input_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.nodes = {}\nfor x in ('a', 'b', 'c', 'd', 'e'):\n    self.nodes[x] = gyp.input.DependencyGraphNode(x)\n",
        "CUT_1": "self.nodes = nodes\n",
        "CUT_2": "nodes = []\nfor node in vcproj.childNodes:\n    if node.nodeName == 'Configurations':\n        for sub_node in node.childNodes:\n            if sub_node.nodeName == 'Configuration':\n                nodes.append(sub_node)\nreturn nodes\n",
        "CUT_3": "return 'CycleError: cycle involving: ' + str(self.nodes)\n",
        "CUT_4": "return '<DependencyGraphNode: %r>' % self.ref\n",
        "CUT_5": "if input is None:\n    return []\nif isinstance(input, list):\n    return input\nreturn [input]\n"
    },
    {
        "functionName": "_create_dependency",
        "className": "TestFindCycles",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/input_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "dependent.dependencies.append(dependency)\ndependency.dependents.append(dependent)\n",
        "CUT_1": "\"\"\"Returns a list of just direct dependencies.\"\"\"\nif dependencies is None:\n    dependencies = []\nfor dependency in self.dependencies:\n    if dependency.ref != None and dependency.ref not in dependencies:\n        dependencies.append(dependency.ref)\nreturn dependencies\n",
        "CUT_2": "\"\"\"Returns an OrderedSet of all of a target's dependencies, recursively.\"\"\"\nif dependencies is None:\n    dependencies = OrderedSet()\nfor dependency in self.dependencies:\n    if dependency.ref is None:\n        continue\n    if dependency.ref not in dependencies:\n        dependency.DeepDependencies(dependencies)\n        dependencies.add(dependency.ref)\nreturn dependencies\n",
        "CUT_3": "\"\"\"Return the path, if any, that should be used as a dependency of\n    any dependent compile step.\"\"\"\nreturn self.actions_stamp or self.precompile_stamp\n",
        "CUT_4": "\"\"\"Returns a list of a target's direct dependencies and all indirect\n    dependencies that a dependency has advertised settings should be exported\n    through the dependency for.\n    \"\"\"\ndependencies = self.DirectDependencies(dependencies)\nreturn self._AddImportedDependencies(targets, dependencies)\n",
        "CUT_5": "for target in flat_list:\n    target_dict = targets[target]\n    target_type = target_dict['type']\n    if target_type == 'static_library':\n        if not 'dependencies' in target_dict:\n            continue\n        target_dict['dependencies_original'] = target_dict.get('dependencies',\n            [])[:]\n        dependencies = dependency_nodes[target].DirectAndImportedDependencies(\n            targets)\n        index = 0\n        while index < len(dependencies):\n            dependency = dependencies[index]\n            dependency_dict = targets[dependency]\n            if dependency_dict['type'\n                ] == 'static_library' and not dependency_dict.get(\n                'hard_dependency', False) or dependency_dict['type'\n                ] != 'static_library' and not dependency in target_dict[\n                'dependencies']:\n                del dependencies[index]\n            else:\n                index = index + 1\n        if len(dependencies) > 0:\n            target_dict['dependencies'] = dependencies\n        else:\n            del target_dict['dependencies']\n    elif target_type in linkable_types:\n        link_dependencies = dependency_nodes[target].DependenciesToLinkAgainst(\n            targets)\n        for dependency in link_dependencies:\n            if dependency == target:\n                continue\n            if not 'dependencies' in target_dict:\n                target_dict['dependencies'] = []\n            if not dependency in target_dict['dependencies']:\n                target_dict['dependencies'].append(dependency)\n        if sort_dependencies and 'dependencies' in target_dict:\n            target_dict['dependencies'] = [dep for dep in reversed(\n                flat_list) if dep in target_dict['dependencies']]\n"
    },
    {
        "functionName": "test_no_cycle_empty_graph",
        "className": "TestFindCycles",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/input_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "for label, node in self.nodes.items():\n    self.assertEqual([], node.FindCycles())\n",
        "CUT_1": "if type(node) == dict and len(node) == 1 and list(node)[0\n    ] == parent + '.vcproj':\n    return node[list(node)[0]]\nif type(node) != dict:\n    return node\nfor child in node:\n    node[child] = _CollapseSingles(child, node[child])\nreturn node\n",
        "CUT_2": "nodes = []\nfor node in vcproj.childNodes:\n    if node.nodeName == 'Configurations':\n        for sub_node in node.childNodes:\n            if sub_node.nodeName == 'Configuration':\n                nodes.append(sub_node)\nreturn nodes\n",
        "CUT_3": "trace('data', data)\nnode = data.get('node', '')[:12]\nif node:\n    node = 'h' + node\nif 'tag' in data:\n    return meta(data['tag'], config=config)\nelif 'latesttag' in data:\n    return meta(data['latesttag'], distance=data['latesttagdistance'], node\n        =node, config=config)\nelse:\n    return meta('0.0', node=node, config=config)\n",
        "CUT_4": "\"\"\"Topologically sort based on a user provided edge definition.\n\n  Args:\n    graph: A list of node names.\n    get_edges: A function mapping from node name to a hashable collection\n               of node names which this node has outgoing edges to.\n  Returns:\n    A list containing all of the node in graph in topological order.\n    It is assumed that calling get_edges once for each node and caching is\n    cheaper than repeatedly calling get_edges.\n  Raises:\n    CycleError in the event of a cycle.\n  Example:\n    graph = {'a': '$(b) $(c)', 'b': 'hi', 'c': '$(b)'}\n    def GetEdges(node):\n      return re.findall(r'\\\\$\\\\(([^))]\\\\)', graph[node])\n    print TopologicallySorted(graph.keys(), GetEdges)\n    ==>\n    ['a', 'c', b']\n  \"\"\"\nget_edges = memoize(get_edges)\nvisited = set()\nvisiting = set()\nordered_nodes = []\ndef Visit(node):\n    if node in visiting:\n        raise CycleError(visiting)\n    if node in visited:\n        return\n    visited.add(node)\n    visiting.add(node)\n    for neighbor in get_edges(node):\n        Visit(neighbor)\n    visiting.remove(node)\n    ordered_nodes.insert(0, node)\nfor node in sorted(graph):\n    Visit(node)\nreturn ordered_nodes\n",
        "CUT_5": "self.nodes = nodes\n"
    },
    {
        "functionName": "test_no_cycle_line",
        "className": "TestFindCycles",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/input_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self._create_dependency(self.nodes['a'], self.nodes['b'])\nself._create_dependency(self.nodes['b'], self.nodes['c'])\nself._create_dependency(self.nodes['c'], self.nodes['d'])\nfor label, node in self.nodes.items():\n    self.assertEqual([], node.FindCycles())\n",
        "CUT_1": "self.nodes = nodes\n",
        "CUT_2": "nodes = []\nfor node in vcproj.childNodes:\n    if node.nodeName == 'Configurations':\n        for sub_node in node.childNodes:\n            if sub_node.nodeName == 'Configuration':\n                nodes.append(sub_node)\nreturn nodes\n",
        "CUT_3": "return 'CycleError: cycle involving: ' + str(self.nodes)\n",
        "CUT_4": "return self\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_no_cycle_dag",
        "className": "TestFindCycles",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/input_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self._create_dependency(self.nodes['a'], self.nodes['b'])\nself._create_dependency(self.nodes['a'], self.nodes['c'])\nself._create_dependency(self.nodes['b'], self.nodes['c'])\nfor label, node in self.nodes.items():\n    self.assertEqual([], node.FindCycles())\n",
        "CUT_1": "self.nodes = nodes\n",
        "CUT_2": "nodes = []\nfor node in vcproj.childNodes:\n    if node.nodeName == 'Configurations':\n        for sub_node in node.childNodes:\n            if sub_node.nodeName == 'Configuration':\n                nodes.append(sub_node)\nreturn nodes\n",
        "CUT_3": "return 'CycleError: cycle involving: ' + str(self.nodes)\n",
        "CUT_4": "return self\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_cycle_self_reference",
        "className": "TestFindCycles",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/input_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self._create_dependency(self.nodes['a'], self.nodes['a'])\nself.assertEqual([[self.nodes['a'], self.nodes['a']]], self.nodes['a'].\n    FindCycles())\n",
        "CUT_1": "self.nodes = nodes\n",
        "CUT_2": "nodes = []\nfor node in vcproj.childNodes:\n    if node.nodeName == 'Configurations':\n        for sub_node in node.childNodes:\n            if sub_node.nodeName == 'Configuration':\n                nodes.append(sub_node)\nreturn nodes\n",
        "CUT_3": "return 'CycleError: cycle involving: ' + str(self.nodes)\n",
        "CUT_4": "return self\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_cycle_two_nodes",
        "className": "TestFindCycles",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/input_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self._create_dependency(self.nodes['a'], self.nodes['b'])\nself._create_dependency(self.nodes['b'], self.nodes['a'])\nself.assertEqual([[self.nodes['a'], self.nodes['b'], self.nodes['a']]],\n    self.nodes['a'].FindCycles())\nself.assertEqual([[self.nodes['b'], self.nodes['a'], self.nodes['b']]],\n    self.nodes['b'].FindCycles())\n",
        "CUT_1": "self.nodes = nodes\n",
        "CUT_2": "nodes = []\nfor node in vcproj.childNodes:\n    if node.nodeName == 'Configurations':\n        for sub_node in node.childNodes:\n            if sub_node.nodeName == 'Configuration':\n                nodes.append(sub_node)\nreturn nodes\n",
        "CUT_3": "return 'CycleError: cycle involving: ' + str(self.nodes)\n",
        "CUT_4": "return self\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_two_cycles",
        "className": "TestFindCycles",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/input_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self._create_dependency(self.nodes['a'], self.nodes['b'])\nself._create_dependency(self.nodes['b'], self.nodes['a'])\nself._create_dependency(self.nodes['b'], self.nodes['c'])\nself._create_dependency(self.nodes['c'], self.nodes['b'])\ncycles = self.nodes['a'].FindCycles()\nself.assertTrue([self.nodes['a'], self.nodes['b'], self.nodes['a']] in cycles)\nself.assertTrue([self.nodes['b'], self.nodes['c'], self.nodes['b']] in cycles)\nself.assertEqual(2, len(cycles))\n",
        "CUT_1": "self.nodes = nodes\n",
        "CUT_2": "nodes = []\nfor node in vcproj.childNodes:\n    if node.nodeName == 'Configurations':\n        for sub_node in node.childNodes:\n            if sub_node.nodeName == 'Configuration':\n                nodes.append(sub_node)\nreturn nodes\n",
        "CUT_3": "return 'CycleError: cycle involving: ' + str(self.nodes)\n",
        "CUT_4": "return self\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_big_cycle",
        "className": "TestFindCycles",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/input_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self._create_dependency(self.nodes['a'], self.nodes['b'])\nself._create_dependency(self.nodes['b'], self.nodes['c'])\nself._create_dependency(self.nodes['c'], self.nodes['d'])\nself._create_dependency(self.nodes['d'], self.nodes['e'])\nself._create_dependency(self.nodes['e'], self.nodes['a'])\nself.assertEqual([[self.nodes['a'], self.nodes['b'], self.nodes['c'], self.\n    nodes['d'], self.nodes['e'], self.nodes['a']]], self.nodes['a'].\n    FindCycles())\n",
        "CUT_1": "self.nodes = nodes\n",
        "CUT_2": "nodes = []\nfor node in vcproj.childNodes:\n    if node.nodeName == 'Configurations':\n        for sub_node in node.childNodes:\n            if sub_node.nodeName == 'Configuration':\n                nodes.append(sub_node)\nreturn nodes\n",
        "CUT_3": "return 'CycleError: cycle involving: ' + str(self.nodes)\n",
        "CUT_4": "return self\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "setUp",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/MSVSSettings_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.stderr = StringIO()\n",
        "CUT_1": "sys.stderr.write('%s\\n-----\\n' % filename)\nwith open(filename, 'rb') as f:\n    sys.stderr.write(f.read() + '\\n-----\\n')\n",
        "CUT_2": "try:\n    return gyp_main(args)\nexcept GypError as e:\n    sys.stderr.write('gyp: %s\\n' % e)\n    return 1\n",
        "CUT_3": "if len(sys.argv) < 2:\n    print(__doc__, file=sys.stderr)\n    print(file=sys.stderr)\n    print('usage: %s target1 target2...' % sys.argv[0], file=sys.stderr)\n    return 1\nedges = LoadEdges('dump.json', sys.argv[1:])\nWriteGraph(edges)\nreturn 0\n",
        "CUT_4": "\"\"\"Validates that the names of the settings are valid for MSVS.\n\n  Args:\n      settings: A dictionary.  The key is the tool name.  The values are\n          themselves dictionaries of settings and their values.\n      stderr: The stream receiving the error messages.\n  \"\"\"\n_ValidateSettings(_msvs_validators, settings, stderr)\n",
        "CUT_5": "\"\"\"Validates that the names of the settings are valid for MSBuild.\n\n  Args:\n      settings: A dictionary.  The key is the tool name.  The values are\n          themselves dictionaries of settings and their values.\n      stderr: The stream receiving the error messages.\n  \"\"\"\n_ValidateSettings(_msbuild_validators, settings, stderr)\n"
    },
    {
        "functionName": "_ExpectedWarnings",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/MSVSSettings_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Compares recorded lines to expected warnings.\"\"\"\nself.stderr.seek(0)\nactual = self.stderr.read().split('\\n')\nactual = [line for line in actual if line]\nself.assertEqual(sorted(expected), sorted(actual))\n",
        "CUT_1": "\"\"\"Does the main work of indenting the input based on the brace counts.\"\"\"\nindent = 0\nbasic_offset = 2\nlast_line = ''\nfor line in lines:\n    if COMMENT_RE.match(line):\n        print(line)\n    else:\n        line = line.strip('\\r\\n\\t ')\n        if len(line) > 0:\n            brace_diff, after = count_braces(line)\n            if brace_diff != 0:\n                if after:\n                    print(' ' * (basic_offset * indent) + line)\n                    indent += brace_diff\n                else:\n                    indent += brace_diff\n                    print(' ' * (basic_offset * indent) + line)\n            else:\n                print(' ' * (basic_offset * indent) + line)\n        else:\n            print('')\n        last_line = line\n",
        "CUT_2": "\"\"\"Returns the actual file name of the prefix header for language |lang|.\"\"\"\nassert self.compile_headers\nreturn self._CompiledHeader(lang, arch) + '.gch'\n",
        "CUT_3": "for line in textwrap.wrap(text, self.width - 2):\n    self.output.write('# ' + line + '\\n')\n",
        "CUT_4": "\"\"\"Filter logo banner from invocations of asm.exe.\"\"\"\nenv = self._GetEnv(arch)\npopen = subprocess.Popen(args, shell=True, env=env, stdout=subprocess.PIPE,\n    stderr=subprocess.STDOUT)\nout, _ = popen.communicate()\nif PY3:\n    out = out.decode('utf-8')\nfor line in out.splitlines():\n    if not line.startswith('Copyright (C) Microsoft Corporation'\n        ) and not line.startswith('Microsoft (R) Macro Assembler'\n        ) and not line.startswith(' Assembling: ') and line:\n        print(line)\nreturn popen.returncode\n",
        "CUT_5": "\"\"\"Filter logo banner from invocations of rc.exe. Older versions of RC\n    don't support the /nologo flag.\"\"\"\nenv = self._GetEnv(arch)\npopen = subprocess.Popen(args, shell=True, env=env, stdout=subprocess.PIPE,\n    stderr=subprocess.STDOUT)\nout, _ = popen.communicate()\nif PY3:\n    out = out.decode('utf-8')\nfor line in out.splitlines():\n    if not line.startswith('Microsoft (R) Windows (R) Resource Compiler'\n        ) and not line.startswith('Copyright (C) Microsoft Corporation'\n        ) and line:\n        print(line)\nreturn popen.returncode\n"
    },
    {
        "functionName": "testValidateMSVSSettings_tool_names",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/MSVSSettings_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests that only MSVS tool names are allowed.\"\"\"\nMSVSSettings.ValidateMSVSSettings({'VCCLCompilerTool': {}, 'VCLinkerTool':\n    {}, 'VCMIDLTool': {}, 'foo': {}, 'VCResourceCompilerTool': {},\n    'VCLibrarianTool': {}, 'VCManifestTool': {}, 'ClCompile': {}}, self.stderr)\nself._ExpectedWarnings(['Warning: unrecognized tool foo',\n    'Warning: unrecognized tool ClCompile'])\n",
        "CUT_1": "\"\"\"Adds a tool to the four dictionaries used to process settings.\n\n  This only defines the tool.  Each setting also needs to be added.\n\n  Args:\n    tool: The _Tool object to be added.\n  \"\"\"\n_msvs_validators[tool.msvs_name] = {}\n_msbuild_validators[tool.msbuild_name] = {}\n_msvs_to_msbuild_converters[tool.msvs_name] = {}\n_msbuild_name_of_tool[tool.msvs_name] = tool.msbuild_name\n",
        "CUT_2": "\"\"\"Creates an element for the tool.\n\n    Returns:\n      A new xml.dom.Element for the tool.\n    \"\"\"\nreturn ['Tool', self._attrs]\n",
        "CUT_3": "\"\"\"Defines a setting that is only found in MSVS.\n\n  Args:\n    tool: a dictionary that gives the names of the tool for MSVS and MSBuild.\n    name: the name of the setting.\n    setting_type: the type of this setting.\n  \"\"\"\ndef _Translate(unused_value, unused_msbuild_settings):\n    pass\n_msvs_validators[tool.msvs_name][name] = setting_type.ValidateMSVS\n_msvs_to_msbuild_converters[tool.msvs_name][name] = _Translate\n",
        "CUT_4": "\"\"\"Defines a setting that is only found in MSBuild.\n\n  Args:\n    tool: a dictionary that gives the names of the tool for MSVS and MSBuild.\n    name: the name of the setting.\n    setting_type: the type of this setting.\n  \"\"\"\ndef _Translate(value, msbuild_settings):\n    tool_settings = msbuild_settings.setdefault(tool.msbuild_name, {})\n    tool_settings[name] = value\n_msbuild_validators[tool.msbuild_name][name] = setting_type.ValidateMSBuild\n_msvs_to_msbuild_converters[tool.msvs_name][name] = _Translate\n",
        "CUT_5": "\"\"\"Defines a setting that has the same name in MSVS and MSBuild.\n\n  Args:\n    tool: a dictionary that gives the names of the tool for MSVS and MSBuild.\n    name: the name of the setting.\n    setting_type: the type of this setting.\n  \"\"\"\n_Renamed(tool, name, name, setting_type)\n"
    },
    {
        "functionName": "testValidateMSVSSettings_settings",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/MSVSSettings_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests that for invalid MSVS settings.\"\"\"\nMSVSSettings.ValidateMSVSSettings({'VCCLCompilerTool': {\n    'AdditionalIncludeDirectories': 'folder1;folder2', 'AdditionalOptions':\n    ['string1', 'string2'], 'AdditionalUsingDirectories': 'folder1;folder2',\n    'AssemblerListingLocation': 'a_file_name', 'AssemblerOutput': '0',\n    'BasicRuntimeChecks': '5', 'BrowseInformation': 'fdkslj',\n    'BrowseInformationFile': 'a_file_name', 'BufferSecurityCheck': 'true',\n    'CallingConvention': '-1', 'CompileAs': '1', 'DebugInformationFormat':\n    '2', 'DefaultCharIsUnsigned': 'true', 'Detect64BitPortabilityProblems':\n    'true', 'DisableLanguageExtensions': 'true', 'DisableSpecificWarnings':\n    'string1;string2', 'EnableEnhancedInstructionSet': '1',\n    'EnableFiberSafeOptimizations': 'true', 'EnableFunctionLevelLinking':\n    'true', 'EnableIntrinsicFunctions': 'true', 'EnablePREfast': 'true',\n    'Enableprefast': 'bogus', 'ErrorReporting': '1', 'ExceptionHandling':\n    '1', 'ExpandAttributedSource': 'true', 'FavorSizeOrSpeed': '1',\n    'FloatingPointExceptions': 'true', 'FloatingPointModel': '1',\n    'ForceConformanceInForLoopScope': 'true', 'ForcedIncludeFiles':\n    'file1;file2', 'ForcedUsingFiles': 'file1;file2',\n    'GeneratePreprocessedFile': '1', 'GenerateXMLDocumentationFiles':\n    'true', 'IgnoreStandardIncludePath': 'true', 'InlineFunctionExpansion':\n    '1', 'KeepComments': 'true', 'MinimalRebuild': 'true', 'ObjectFile':\n    'a_file_name', 'OmitDefaultLibName': 'true', 'OmitFramePointers':\n    'true', 'OpenMP': 'true', 'Optimization': '1', 'PrecompiledHeaderFile':\n    'a_file_name', 'PrecompiledHeaderThrough': 'a_file_name',\n    'PreprocessorDefinitions': 'string1;string2', 'ProgramDataBaseFileName':\n    'a_file_name', 'RuntimeLibrary': '1', 'RuntimeTypeInfo': 'true',\n    'ShowIncludes': 'true', 'SmallerTypeCheck': 'true', 'StringPooling':\n    'true', 'StructMemberAlignment': '1', 'SuppressStartupBanner': 'true',\n    'TreatWChar_tAsBuiltInType': 'true',\n    'UndefineAllPreprocessorDefinitions': 'true',\n    'UndefinePreprocessorDefinitions': 'string1;string2', 'UseFullPaths':\n    'true', 'UsePrecompiledHeader': '1', 'UseUnicodeResponseFiles': 'true',\n    'WarnAsError': 'true', 'WarningLevel': '1', 'WholeProgramOptimization':\n    'true', 'XMLDocumentationFileName': 'a_file_name', 'ZZXYZ': 'bogus'},\n    'VCLinkerTool': {'AdditionalDependencies': 'file1;file2',\n    'AdditionalDependencies_excluded': 'file3',\n    'AdditionalLibraryDirectories': 'folder1;folder2',\n    'AdditionalManifestDependencies': 'file1;file2', 'AdditionalOptions':\n    'a string1', 'AddModuleNamesToAssembly': 'file1;file2',\n    'AllowIsolation': 'true', 'AssemblyDebug': '2', 'AssemblyLinkResource':\n    'file1;file2', 'BaseAddress': 'a string1', 'CLRImageType': '2',\n    'CLRThreadAttribute': '2', 'CLRUnmanagedCodeCheck': 'true',\n    'DataExecutionPrevention': '2', 'DelayLoadDLLs': 'file1;file2',\n    'DelaySign': 'true', 'Driver': '2', 'EmbedManagedResourceFile':\n    'file1;file2', 'EnableCOMDATFolding': '2', 'EnableUAC': 'true',\n    'EntryPointSymbol': 'a string1', 'ErrorReporting': '2',\n    'FixedBaseAddress': '2', 'ForceSymbolReferences': 'file1;file2',\n    'FunctionOrder': 'a_file_name', 'GenerateDebugInformation': 'true',\n    'GenerateManifest': 'true', 'GenerateMapFile': 'true', 'HeapCommitSize':\n    'a string1', 'HeapReserveSize': 'a string1',\n    'IgnoreAllDefaultLibraries': 'true', 'IgnoreDefaultLibraryNames':\n    'file1;file2', 'IgnoreEmbeddedIDL': 'true', 'IgnoreImportLibrary':\n    'true', 'ImportLibrary': 'a_file_name', 'KeyContainer': 'a_file_name',\n    'KeyFile': 'a_file_name', 'LargeAddressAware': '2', 'LinkIncremental':\n    '2', 'LinkLibraryDependencies': 'true', 'LinkTimeCodeGeneration': '2',\n    'ManifestFile': 'a_file_name', 'MapExports': 'true', 'MapFileName':\n    'a_file_name', 'MergedIDLBaseFileName': 'a_file_name', 'MergeSections':\n    'a string1', 'MidlCommandFile': 'a_file_name', 'ModuleDefinitionFile':\n    'a_file_name', 'OptimizeForWindows98': '1', 'OptimizeReferences': '2',\n    'OutputFile': 'a_file_name', 'PerUserRedirection': 'true', 'Profile':\n    'true', 'ProfileGuidedDatabase': 'a_file_name', 'ProgramDatabaseFile':\n    'a_file_name', 'RandomizedBaseAddress': '2', 'RegisterOutput': 'true',\n    'ResourceOnlyDLL': 'true', 'SetChecksum': 'true', 'ShowProgress': '2',\n    'StackCommitSize': 'a string1', 'StackReserveSize': 'a string1',\n    'StripPrivateSymbols': 'a_file_name', 'SubSystem': '2',\n    'SupportUnloadOfDelayLoadedDLL': 'true', 'SuppressStartupBanner':\n    'true', 'SwapRunFromCD': 'true', 'SwapRunFromNet': 'true',\n    'TargetMachine': '2', 'TerminalServerAware': '2',\n    'TurnOffAssemblyGeneration': 'true', 'TypeLibraryFile': 'a_file_name',\n    'TypeLibraryResourceID': '33', 'UACExecutionLevel': '2', 'UACUIAccess':\n    'true', 'UseLibraryDependencyInputs': 'true', 'UseUnicodeResponseFiles':\n    'true', 'Version': 'a string1'}, 'VCMIDLTool': {\n    'AdditionalIncludeDirectories': 'folder1;folder2', 'AdditionalOptions':\n    'a string1', 'CPreprocessOptions': 'a string1', 'DefaultCharType': '1',\n    'DLLDataFileName': 'a_file_name', 'EnableErrorChecks': '1',\n    'ErrorCheckAllocations': 'true', 'ErrorCheckBounds': 'true',\n    'ErrorCheckEnumRange': 'true', 'ErrorCheckRefPointers': 'true',\n    'ErrorCheckStubData': 'true', 'GenerateStublessProxies': 'true',\n    'GenerateTypeLibrary': 'true', 'HeaderFileName': 'a_file_name',\n    'IgnoreStandardIncludePath': 'true', 'InterfaceIdentifierFileName':\n    'a_file_name', 'MkTypLibCompatible': 'true', 'notgood': 'bogus',\n    'OutputDirectory': 'a string1', 'PreprocessorDefinitions':\n    'string1;string2', 'ProxyFileName': 'a_file_name',\n    'RedirectOutputAndErrors': 'a_file_name', 'StructMemberAlignment': '1',\n    'SuppressStartupBanner': 'true', 'TargetEnvironment': '1',\n    'TypeLibraryName': 'a_file_name', 'UndefinePreprocessorDefinitions':\n    'string1;string2', 'ValidateParameters': 'true', 'WarnAsError': 'true',\n    'WarningLevel': '1'}, 'VCResourceCompilerTool': {'AdditionalOptions':\n    'a string1', 'AdditionalIncludeDirectories': 'folder1;folder2',\n    'Culture': '1003', 'IgnoreStandardIncludePath': 'true', 'notgood2':\n    'bogus', 'PreprocessorDefinitions': 'string1;string2',\n    'ResourceOutputFileName': 'a string1', 'ShowProgress': 'true',\n    'SuppressStartupBanner': 'true', 'UndefinePreprocessorDefinitions':\n    'string1;string2'}, 'VCLibrarianTool': {'AdditionalDependencies':\n    'file1;file2', 'AdditionalLibraryDirectories': 'folder1;folder2',\n    'AdditionalOptions': 'a string1', 'ExportNamedFunctions':\n    'string1;string2', 'ForceSymbolReferences': 'a string1',\n    'IgnoreAllDefaultLibraries': 'true', 'IgnoreSpecificDefaultLibraries':\n    'file1;file2', 'LinkLibraryDependencies': 'true',\n    'ModuleDefinitionFile': 'a_file_name', 'OutputFile': 'a_file_name',\n    'SuppressStartupBanner': 'true', 'UseUnicodeResponseFiles': 'true'},\n    'VCManifestTool': {'AdditionalManifestFiles': 'file1;file2',\n    'AdditionalOptions': 'a string1', 'AssemblyIdentity': 'a string1',\n    'ComponentFileName': 'a_file_name', 'DependencyInformationFile':\n    'a_file_name', 'GenerateCatalogFiles': 'true', 'InputResourceManifests':\n    'a string1', 'ManifestResourceFile': 'a_file_name',\n    'OutputManifestFile': 'a_file_name', 'RegistrarScriptFile':\n    'a_file_name', 'ReplacementsFile': 'a_file_name',\n    'SuppressStartupBanner': 'true', 'TypeLibraryFile': 'a_file_name',\n    'UpdateFileHashes': 'truel', 'UpdateFileHashesSearchPath':\n    'a_file_name', 'UseFAT32Workaround': 'true', 'UseUnicodeResponseFiles':\n    'true', 'VerboseOutput': 'true'}}, self.stderr)\nself._ExpectedWarnings([\n    'Warning: for VCCLCompilerTool/BasicRuntimeChecks, index value (5) not in expected range [0, 4)'\n    ,\n    \"Warning: for VCCLCompilerTool/BrowseInformation, invalid literal for int() with base 10: 'fdkslj'\"\n    ,\n    'Warning: for VCCLCompilerTool/CallingConvention, index value (-1) not in expected range [0, 4)'\n    ,\n    'Warning: for VCCLCompilerTool/DebugInformationFormat, converted value for 2 not specified.'\n    , 'Warning: unrecognized setting VCCLCompilerTool/Enableprefast',\n    'Warning: unrecognized setting VCCLCompilerTool/ZZXYZ',\n    'Warning: for VCLinkerTool/TargetMachine, converted value for 2 not specified.'\n    , 'Warning: unrecognized setting VCMIDLTool/notgood',\n    'Warning: unrecognized setting VCResourceCompilerTool/notgood2',\n    \"Warning: for VCManifestTool/UpdateFileHashes, expected bool; got 'truel'\"]\n    )\n",
        "CUT_1": "return True\n",
        "CUT_2": "\"\"\"Return true if the file is compilable (should be in OBJS).\"\"\"\nfor res in (filename.endswith(e) for e in COMPILABLE_EXTENSIONS):\n    if res:\n        return True\nreturn False\n",
        "CUT_3": "if value != 'true' and value != 'false':\n    raise ValueError('expected bool; got %r' % value)\n",
        "CUT_4": "\"\"\"Returns whether manifest should be linked into binary.\"\"\"\nconfig = self._TargetConfig(config)\nembed = self._Setting(('VCManifestTool', 'EmbedManifest'), config, default=\n    'true')\nreturn embed == 'true'\n",
        "CUT_5": "\"\"\"Returns true if any target contains the iOS specific key\n  IPHONEOS_DEPLOYMENT_TARGET.\"\"\"\nfor target_dict in targets.values():\n    for config in target_dict['configurations'].values():\n        if config.get('xcode_settings', {}).get('IPHONEOS_DEPLOYMENT_TARGET'):\n            return True\nreturn False\n"
    },
    {
        "functionName": "testValidateMSBuildSettings_settings",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/MSVSSettings_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests that for invalid MSBuild settings.\"\"\"\nMSVSSettings.ValidateMSBuildSettings({'ClCompile': {\n    'AdditionalIncludeDirectories': 'folder1;folder2', 'AdditionalOptions':\n    ['string1', 'string2'], 'AdditionalUsingDirectories': 'folder1;folder2',\n    'AssemblerListingLocation': 'a_file_name', 'AssemblerOutput':\n    'NoListing', 'BasicRuntimeChecks': 'StackFrameRuntimeCheck',\n    'BrowseInformation': 'false', 'BrowseInformationFile': 'a_file_name',\n    'BufferSecurityCheck': 'true', 'BuildingInIDE': 'true',\n    'CallingConvention': 'Cdecl', 'CompileAs': 'CompileAsC',\n    'CompileAsManaged': 'true', 'CreateHotpatchableImage': 'true',\n    'DebugInformationFormat': 'ProgramDatabase',\n    'DisableLanguageExtensions': 'true', 'DisableSpecificWarnings':\n    'string1;string2', 'EnableEnhancedInstructionSet':\n    'StreamingSIMDExtensions', 'EnableFiberSafeOptimizations': 'true',\n    'EnablePREfast': 'true', 'Enableprefast': 'bogus', 'ErrorReporting':\n    'Prompt', 'ExceptionHandling': 'SyncCThrow', 'ExpandAttributedSource':\n    'true', 'FavorSizeOrSpeed': 'Neither', 'FloatingPointExceptions':\n    'true', 'FloatingPointModel': 'Precise',\n    'ForceConformanceInForLoopScope': 'true', 'ForcedIncludeFiles':\n    'file1;file2', 'ForcedUsingFiles': 'file1;file2',\n    'FunctionLevelLinking': 'false', 'GenerateXMLDocumentationFiles':\n    'true', 'IgnoreStandardIncludePath': 'true', 'InlineFunctionExpansion':\n    'OnlyExplicitInline', 'IntrinsicFunctions': 'false', 'MinimalRebuild':\n    'true', 'MultiProcessorCompilation': 'true', 'ObjectFileName':\n    'a_file_name', 'OmitDefaultLibName': 'true', 'OmitFramePointers':\n    'true', 'OpenMPSupport': 'true', 'Optimization': 'Disabled',\n    'PrecompiledHeader': 'NotUsing', 'PrecompiledHeaderFile': 'a_file_name',\n    'PrecompiledHeaderOutputFile': 'a_file_name', 'PreprocessKeepComments':\n    'true', 'PreprocessorDefinitions': 'string1;string2',\n    'PreprocessOutputPath': 'a string1', 'PreprocessSuppressLineNumbers':\n    'false', 'PreprocessToFile': 'false', 'ProcessorNumber': '33',\n    'ProgramDataBaseFileName': 'a_file_name', 'RuntimeLibrary':\n    'MultiThreaded', 'RuntimeTypeInfo': 'true', 'ShowIncludes': 'true',\n    'SmallerTypeCheck': 'true', 'StringPooling': 'true',\n    'StructMemberAlignment': '1Byte', 'SuppressStartupBanner': 'true',\n    'TrackerLogDirectory': 'a_folder', 'TreatSpecificWarningsAsErrors':\n    'string1;string2', 'TreatWarningAsError': 'true',\n    'TreatWChar_tAsBuiltInType': 'true',\n    'UndefineAllPreprocessorDefinitions': 'true',\n    'UndefinePreprocessorDefinitions': 'string1;string2', 'UseFullPaths':\n    'true', 'UseUnicodeForAssemblerListing': 'true', 'WarningLevel':\n    'TurnOffAllWarnings', 'WholeProgramOptimization': 'true',\n    'XMLDocumentationFileName': 'a_file_name', 'ZZXYZ': 'bogus'}, 'Link': {\n    'AdditionalDependencies': 'file1;file2', 'AdditionalLibraryDirectories':\n    'folder1;folder2', 'AdditionalManifestDependencies': 'file1;file2',\n    'AdditionalOptions': 'a string1', 'AddModuleNamesToAssembly':\n    'file1;file2', 'AllowIsolation': 'true', 'AssemblyDebug': '',\n    'AssemblyLinkResource': 'file1;file2', 'BaseAddress': 'a string1',\n    'BuildingInIDE': 'true', 'CLRImageType': 'ForceIJWImage',\n    'CLRSupportLastError': 'Enabled', 'CLRThreadAttribute':\n    'MTAThreadingAttribute', 'CLRUnmanagedCodeCheck': 'true',\n    'CreateHotPatchableImage': 'X86Image', 'DataExecutionPrevention':\n    'false', 'DelayLoadDLLs': 'file1;file2', 'DelaySign': 'true', 'Driver':\n    'NotSet', 'EmbedManagedResourceFile': 'file1;file2',\n    'EnableCOMDATFolding': 'false', 'EnableUAC': 'true', 'EntryPointSymbol':\n    'a string1', 'FixedBaseAddress': 'false', 'ForceFileOutput': 'Enabled',\n    'ForceSymbolReferences': 'file1;file2', 'FunctionOrder': 'a_file_name',\n    'GenerateDebugInformation': 'true', 'GenerateMapFile': 'true',\n    'HeapCommitSize': 'a string1', 'HeapReserveSize': 'a string1',\n    'IgnoreAllDefaultLibraries': 'true', 'IgnoreEmbeddedIDL': 'true',\n    'IgnoreSpecificDefaultLibraries': 'a_file_list',\n    'ImageHasSafeExceptionHandlers': 'true', 'ImportLibrary': 'a_file_name',\n    'KeyContainer': 'a_file_name', 'KeyFile': 'a_file_name',\n    'LargeAddressAware': 'false', 'LinkDLL': 'true', 'LinkErrorReporting':\n    'SendErrorReport', 'LinkStatus': 'true', 'LinkTimeCodeGeneration':\n    'UseLinkTimeCodeGeneration', 'ManifestFile': 'a_file_name',\n    'MapExports': 'true', 'MapFileName': 'a_file_name',\n    'MergedIDLBaseFileName': 'a_file_name', 'MergeSections': 'a string1',\n    'MidlCommandFile': 'a_file_name', 'MinimumRequiredVersion': 'a string1',\n    'ModuleDefinitionFile': 'a_file_name', 'MSDOSStubFileName':\n    'a_file_name', 'NoEntryPoint': 'true', 'OptimizeReferences': 'false',\n    'OutputFile': 'a_file_name', 'PerUserRedirection': 'true',\n    'PreventDllBinding': 'true', 'Profile': 'true', 'ProfileGuidedDatabase':\n    'a_file_name', 'ProgramDatabaseFile': 'a_file_name',\n    'RandomizedBaseAddress': 'false', 'RegisterOutput': 'true',\n    'SectionAlignment': '33', 'SetChecksum': 'true', 'ShowProgress':\n    'LinkVerboseREF', 'SpecifySectionAttributes': 'a string1',\n    'StackCommitSize': 'a string1', 'StackReserveSize': 'a string1',\n    'StripPrivateSymbols': 'a_file_name', 'SubSystem': 'Console',\n    'SupportNobindOfDelayLoadedDLL': 'true',\n    'SupportUnloadOfDelayLoadedDLL': 'true', 'SuppressStartupBanner':\n    'true', 'SwapRunFromCD': 'true', 'SwapRunFromNET': 'true',\n    'TargetMachine': 'MachineX86', 'TerminalServerAware': 'false',\n    'TrackerLogDirectory': 'a_folder', 'TreatLinkerWarningAsErrors': 'true',\n    'TurnOffAssemblyGeneration': 'true', 'TypeLibraryFile': 'a_file_name',\n    'TypeLibraryResourceID': '33', 'UACExecutionLevel': 'AsInvoker',\n    'UACUIAccess': 'true', 'Version': 'a string1'}, 'ResourceCompile': {\n    'AdditionalIncludeDirectories': 'folder1;folder2', 'AdditionalOptions':\n    'a string1', 'Culture': '0x236', 'IgnoreStandardIncludePath': 'true',\n    'NullTerminateStrings': 'true', 'PreprocessorDefinitions':\n    'string1;string2', 'ResourceOutputFileName': 'a string1',\n    'ShowProgress': 'true', 'SuppressStartupBanner': 'true',\n    'TrackerLogDirectory': 'a_folder', 'UndefinePreprocessorDefinitions':\n    'string1;string2'}, 'Midl': {'AdditionalIncludeDirectories':\n    'folder1;folder2', 'AdditionalOptions': 'a string1',\n    'ApplicationConfigurationMode': 'true', 'ClientStubFile': 'a_file_name',\n    'CPreprocessOptions': 'a string1', 'DefaultCharType': 'Signed',\n    'DllDataFileName': 'a_file_name', 'EnableErrorChecks': 'EnableCustom',\n    'ErrorCheckAllocations': 'true', 'ErrorCheckBounds': 'true',\n    'ErrorCheckEnumRange': 'true', 'ErrorCheckRefPointers': 'true',\n    'ErrorCheckStubData': 'true', 'GenerateClientFiles': 'Stub',\n    'GenerateServerFiles': 'None', 'GenerateStublessProxies': 'true',\n    'GenerateTypeLibrary': 'true', 'HeaderFileName': 'a_file_name',\n    'IgnoreStandardIncludePath': 'true', 'InterfaceIdentifierFileName':\n    'a_file_name', 'LocaleID': '33', 'MkTypLibCompatible': 'true',\n    'OutputDirectory': 'a string1', 'PreprocessorDefinitions':\n    'string1;string2', 'ProxyFileName': 'a_file_name',\n    'RedirectOutputAndErrors': 'a_file_name', 'ServerStubFile':\n    'a_file_name', 'StructMemberAlignment': 'NotSet',\n    'SuppressCompilerWarnings': 'true', 'SuppressStartupBanner': 'true',\n    'TargetEnvironment': 'Itanium', 'TrackerLogDirectory': 'a_folder',\n    'TypeLibFormat': 'NewFormat', 'TypeLibraryName': 'a_file_name',\n    'UndefinePreprocessorDefinitions': 'string1;string2',\n    'ValidateAllParameters': 'true', 'WarnAsError': 'true', 'WarningLevel':\n    '1'}, 'Lib': {'AdditionalDependencies': 'file1;file2',\n    'AdditionalLibraryDirectories': 'folder1;folder2', 'AdditionalOptions':\n    'a string1', 'DisplayLibrary': 'a string1', 'ErrorReporting':\n    'PromptImmediately', 'ExportNamedFunctions': 'string1;string2',\n    'ForceSymbolReferences': 'a string1', 'IgnoreAllDefaultLibraries':\n    'true', 'IgnoreSpecificDefaultLibraries': 'file1;file2',\n    'LinkTimeCodeGeneration': 'true', 'MinimumRequiredVersion': 'a string1',\n    'ModuleDefinitionFile': 'a_file_name', 'Name': 'a_file_name',\n    'OutputFile': 'a_file_name', 'RemoveObjects': 'file1;file2',\n    'SubSystem': 'Console', 'SuppressStartupBanner': 'true',\n    'TargetMachine': 'MachineX86i', 'TrackerLogDirectory': 'a_folder',\n    'TreatLibWarningAsErrors': 'true', 'UseUnicodeResponseFiles': 'true',\n    'Verbose': 'true'}, 'Manifest': {'AdditionalManifestFiles':\n    'file1;file2', 'AdditionalOptions': 'a string1', 'AssemblyIdentity':\n    'a string1', 'ComponentFileName': 'a_file_name', 'EnableDPIAwareness':\n    'fal', 'GenerateCatalogFiles': 'truel', 'GenerateCategoryTags': 'true',\n    'InputResourceManifests': 'a string1', 'ManifestFromManagedAssembly':\n    'a_file_name', 'notgood3': 'bogus', 'OutputManifestFile': 'a_file_name',\n    'OutputResourceManifests': 'a string1', 'RegistrarScriptFile':\n    'a_file_name', 'ReplacementsFile': 'a_file_name',\n    'SuppressDependencyElement': 'true', 'SuppressStartupBanner': 'true',\n    'TrackerLogDirectory': 'a_folder', 'TypeLibraryFile': 'a_file_name',\n    'UpdateFileHashes': 'true', 'UpdateFileHashesSearchPath': 'a_file_name',\n    'VerboseOutput': 'true'}, 'ProjectReference': {\n    'LinkLibraryDependencies': 'true', 'UseLibraryDependencyInputs': 'true'\n    }, 'ManifestResourceCompile': {'ResourceOutputFileName': 'a_file_name'},\n    '': {'EmbedManifest': 'true', 'GenerateManifest': 'true',\n    'IgnoreImportLibrary': 'true', 'LinkIncremental': 'false'}}, self.stderr)\nself._ExpectedWarnings([\n    'Warning: unrecognized setting ClCompile/Enableprefast',\n    'Warning: unrecognized setting ClCompile/ZZXYZ',\n    'Warning: unrecognized setting Manifest/notgood3',\n    \"Warning: for Manifest/GenerateCatalogFiles, expected bool; got 'truel'\",\n    'Warning: for Lib/TargetMachine, unrecognized enumerated value MachineX86i'\n    , \"Warning: for Manifest/EnableDPIAwareness, expected bool; got 'fal'\"])\n",
        "CUT_1": "return True\n",
        "CUT_2": "\"\"\"Return true if the file is compilable (should be in OBJS).\"\"\"\nfor res in (filename.endswith(e) for e in COMPILABLE_EXTENSIONS):\n    if res:\n        return True\nreturn False\n",
        "CUT_3": "if value != 'true' and value != 'false':\n    raise ValueError('expected bool; got %r' % value)\n",
        "CUT_4": "\"\"\"Returns whether manifest should be linked into binary.\"\"\"\nconfig = self._TargetConfig(config)\nembed = self._Setting(('VCManifestTool', 'EmbedManifest'), config, default=\n    'true')\nreturn embed == 'true'\n",
        "CUT_5": "\"\"\"Returns true if any target contains the iOS specific key\n  IPHONEOS_DEPLOYMENT_TARGET.\"\"\"\nfor target_dict in targets.values():\n    for config in target_dict['configurations'].values():\n        if config.get('xcode_settings', {}).get('IPHONEOS_DEPLOYMENT_TARGET'):\n            return True\nreturn False\n"
    },
    {
        "functionName": "testConvertToMSBuildSettings_empty",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/MSVSSettings_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests an empty conversion.\"\"\"\nmsvs_settings = {}\nexpected_msbuild_settings = {}\nactual_msbuild_settings = MSVSSettings.ConvertToMSBuildSettings(msvs_settings,\n    self.stderr)\nself.assertEqual(expected_msbuild_settings, actual_msbuild_settings)\nself._ExpectedWarnings([])\n",
        "CUT_1": "\"\"\"_GetAndMunge for msvs_settings.\"\"\"\nreturn self._GetAndMunge(self.msvs_settings[config], path, default, prefix,\n    append, map)\n",
        "CUT_2": "\"\"\"Returns the variables Visual Studio would set for build steps.\"\"\"\nreturn self.msvs_settings.GetVSMacroEnv('$!PRODUCT_DIR', config=self.\n    config_name)\n",
        "CUT_3": "return self\n",
        "CUT_4": "self.display_name = rule['rule_name']\nself.rule_name = re.sub('\\\\W', '_', self.display_name)\nself.target_name = '_' + self.rule_name\nself.after_targets = self.rule_name + 'AfterTargets'\nself.before_targets = self.rule_name + 'BeforeTargets'\nself.depends_on = self.rule_name + 'DependsOn'\nself.compute_output = 'Compute%sOutput' % self.rule_name\nself.dirs_to_make = self.rule_name + 'DirsToMake'\nself.inputs = self.rule_name + '_inputs'\nself.tlog = self.rule_name + '_tlog'\nself.extension = rule['extension']\nif not self.extension.startswith('.'):\n    self.extension = '.' + self.extension\nself.description = MSVSSettings.ConvertVCMacrosToMSBuild(rule.get('message',\n    self.rule_name))\nold_additional_dependencies = _FixPaths(rule.get('inputs', []))\nself.additional_dependencies = ';'.join([MSVSSettings.\n    ConvertVCMacrosToMSBuild(i) for i in old_additional_dependencies])\nold_outputs = _FixPaths(rule.get('outputs', []))\nself.outputs = ';'.join([MSVSSettings.ConvertVCMacrosToMSBuild(i) for i in\n    old_outputs])\nold_command = _BuildCommandLineForRule(spec, rule, has_input_path=True,\n    do_setup_env=True)\nself.command = MSVSSettings.ConvertVCMacrosToMSBuild(old_command)\n",
        "CUT_5": "\"\"\"Write build rules to compile all of |sources|.\"\"\"\nextra_defines = []\nif self.flavor == 'mac':\n    cflags = self.xcode_settings.GetCflags(config_name, arch=arch)\n    cflags_c = self.xcode_settings.GetCflagsC(config_name)\n    cflags_cc = self.xcode_settings.GetCflagsCC(config_name)\n    cflags_objc = ['$cflags_c'] + self.xcode_settings.GetCflagsObjC(config_name\n        )\n    cflags_objcc = ['$cflags_cc'] + self.xcode_settings.GetCflagsObjCC(\n        config_name)\nelif self.flavor == 'win':\n    asmflags = self.msvs_settings.GetAsmflags(config_name)\n    cflags = self.msvs_settings.GetCflags(config_name)\n    cflags_c = self.msvs_settings.GetCflagsC(config_name)\n    cflags_cc = self.msvs_settings.GetCflagsCC(config_name)\n    extra_defines = self.msvs_settings.GetComputedDefines(config_name)\n    pdbpath_c = pdbpath_cc = self.msvs_settings.GetCompilerPdbName(config_name,\n        self.ExpandSpecial)\n    if not pdbpath_c:\n        obj = 'obj'\n        if self.toolset != 'target':\n            obj += '.' + self.toolset\n        pdbpath = os.path.normpath(os.path.join(obj, self.base_dir, self.name))\n        pdbpath_c = pdbpath + '.c.pdb'\n        pdbpath_cc = pdbpath + '.cc.pdb'\n    self.WriteVariableList(ninja_file, 'pdbname_c', [pdbpath_c])\n    self.WriteVariableList(ninja_file, 'pdbname_cc', [pdbpath_cc])\n    self.WriteVariableList(ninja_file, 'pchprefix', [self.name])\nelse:\n    cflags = config.get('cflags', [])\n    cflags_c = config.get('cflags_c', [])\n    cflags_cc = config.get('cflags_cc', [])\nif self.toolset == 'target':\n    cflags_c = os.environ.get('CPPFLAGS', '').split() + os.environ.get('CFLAGS'\n        , '').split() + cflags_c\n    cflags_cc = os.environ.get('CPPFLAGS', '').split() + os.environ.get(\n        'CXXFLAGS', '').split() + cflags_cc\nelif self.toolset == 'host':\n    cflags_c = os.environ.get('CPPFLAGS_host', '').split() + os.environ.get(\n        'CFLAGS_host', '').split() + cflags_c\n    cflags_cc = os.environ.get('CPPFLAGS_host', '').split() + os.environ.get(\n        'CXXFLAGS_host', '').split() + cflags_cc\ndefines = config.get('defines', []) + extra_defines\nself.WriteVariableList(ninja_file, 'defines', [Define(d, self.flavor) for d in\n    defines])\nif self.flavor == 'win':\n    self.WriteVariableList(ninja_file, 'asmflags', map(self.ExpandSpecial,\n        asmflags))\n    self.WriteVariableList(ninja_file, 'rcflags', [QuoteShellArgument(self.\n        ExpandSpecial(f), self.flavor) for f in self.msvs_settings.\n        GetRcflags(config_name, self.GypPathToNinja)])\ninclude_dirs = config.get('include_dirs', [])\nenv = self.GetToolchainEnv()\nif self.flavor == 'win':\n    include_dirs = self.msvs_settings.AdjustIncludeDirs(include_dirs,\n        config_name)\nself.WriteVariableList(ninja_file, 'includes', [QuoteShellArgument('-I' +\n    self.GypPathToNinja(i, env), self.flavor) for i in include_dirs])\nif self.flavor == 'win':\n    midl_include_dirs = config.get('midl_include_dirs', [])\n    midl_include_dirs = self.msvs_settings.AdjustMidlIncludeDirs(\n        midl_include_dirs, config_name)\n    self.WriteVariableList(ninja_file, 'midl_includes', [QuoteShellArgument\n        ('-I' + self.GypPathToNinja(i, env), self.flavor) for i in\n        midl_include_dirs])\npch_commands = precompiled_header.GetPchBuildCommands(arch)\nif self.flavor == 'mac':\n    for ext, var in [('c', 'cflags_pch_c'), ('cc', 'cflags_pch_cc'), ('m',\n        'cflags_pch_objc'), ('mm', 'cflags_pch_objcc')]:\n        include = precompiled_header.GetInclude(ext, arch)\n        if include:\n            ninja_file.variable(var, include)\narflags = config.get('arflags', [])\nself.WriteVariableList(ninja_file, 'cflags', map(self.ExpandSpecial, cflags))\nself.WriteVariableList(ninja_file, 'cflags_c', map(self.ExpandSpecial,\n    cflags_c))\nself.WriteVariableList(ninja_file, 'cflags_cc', map(self.ExpandSpecial,\n    cflags_cc))\nif self.flavor == 'mac':\n    self.WriteVariableList(ninja_file, 'cflags_objc', map(self.\n        ExpandSpecial, cflags_objc))\n    self.WriteVariableList(ninja_file, 'cflags_objcc', map(self.\n        ExpandSpecial, cflags_objcc))\nself.WriteVariableList(ninja_file, 'arflags', map(self.ExpandSpecial, arflags))\nninja_file.newline()\noutputs = []\nhas_rc_source = False\nfor source in sources:\n    filename, ext = os.path.splitext(source)\n    ext = ext[1:]\n    obj_ext = self.obj_ext\n    if ext in ('cc', 'cpp', 'cxx'):\n        command = 'cxx'\n        self.uses_cpp = True\n    elif ext == 'c' or ext == 'S' and self.flavor != 'win':\n        command = 'cc'\n    elif ext == 's' and self.flavor != 'win':\n        command = 'cc_s'\n    elif self.flavor == 'win' and ext == 'asm' and not self.msvs_settings.HasExplicitAsmRules(\n        spec):\n        command = 'asm'\n        obj_ext = '_asm.obj'\n    elif self.flavor == 'mac' and ext == 'm':\n        command = 'objc'\n    elif self.flavor == 'mac' and ext == 'mm':\n        command = 'objcxx'\n        self.uses_cpp = True\n    elif self.flavor == 'win' and ext == 'rc':\n        command = 'rc'\n        obj_ext = '.res'\n        has_rc_source = True\n    else:\n        continue\n    input = self.GypPathToNinja(source)\n    output = self.GypPathToUniqueOutput(filename + obj_ext)\n    if arch is not None:\n        output = AddArch(output, arch)\n    implicit = precompiled_header.GetObjDependencies([input], [output], arch)\n    variables = []\n    if self.flavor == 'win':\n        variables, output, implicit = precompiled_header.GetFlagsModifications(\n            input, output, implicit, command, cflags_c, cflags_cc, self.\n            ExpandSpecial)\n    ninja_file.build(output, command, input, implicit=[gch for _, _, gch in\n        implicit], order_only=predepends, variables=variables)\n    outputs.append(output)\nif has_rc_source:\n    resource_include_dirs = config.get('resource_include_dirs', include_dirs)\n    self.WriteVariableList(ninja_file, 'resource_includes', [\n        QuoteShellArgument('-I' + self.GypPathToNinja(i, env), self.flavor) for\n        i in resource_include_dirs])\nself.WritePchTargets(ninja_file, pch_commands)\nninja_file.newline()\nreturn outputs\n"
    },
    {
        "functionName": "testConvertToMSBuildSettings_minimal",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/MSVSSettings_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests a minimal conversion.\"\"\"\nmsvs_settings = {'VCCLCompilerTool': {'AdditionalIncludeDirectories':\n    'dir1', 'AdditionalOptions': '/foo', 'BasicRuntimeChecks': '0'},\n    'VCLinkerTool': {'LinkTimeCodeGeneration': '1', 'ErrorReporting': '1',\n    'DataExecutionPrevention': '2'}}\nexpected_msbuild_settings = {'ClCompile': {'AdditionalIncludeDirectories':\n    'dir1', 'AdditionalOptions': '/foo', 'BasicRuntimeChecks': 'Default'},\n    'Link': {'LinkTimeCodeGeneration': 'UseLinkTimeCodeGeneration',\n    'LinkErrorReporting': 'PromptImmediately', 'DataExecutionPrevention':\n    'true'}}\nactual_msbuild_settings = MSVSSettings.ConvertToMSBuildSettings(msvs_settings,\n    self.stderr)\nself.assertEqual(expected_msbuild_settings, actual_msbuild_settings)\nself._ExpectedWarnings([])\n",
        "CUT_1": "if type(value) == list:\n    if name in ['AdditionalIncludeDirectories',\n        'AdditionalLibraryDirectories', 'AdditionalOptions',\n        'DelayLoadDLLs', 'DisableSpecificWarnings', 'PreprocessorDefinitions']:\n        value.append('%%(%s)' % name)\n    exceptions = {'ClCompile': ['AdditionalOptions'], 'Link': [\n        'AdditionalOptions'], 'Lib': ['AdditionalOptions']}\n    if tool_name in exceptions and name in exceptions[tool_name]:\n        char = ' '\n    else:\n        char = ';'\n    formatted_value = char.join([MSVSSettings.ConvertVCMacrosToMSBuild(i) for\n        i in value])\nelse:\n    formatted_value = MSVSSettings.ConvertVCMacrosToMSBuild(value)\nreturn formatted_value\n",
        "CUT_2": "\"\"\"_GetAndMunge for msvs_settings.\"\"\"\nreturn self._GetAndMunge(self.msvs_settings[config], path, default, prefix,\n    append, map)\n",
        "CUT_3": "\"\"\"Takes a string containing variable references in the form ${FOO}, $(FOO),\n  or $FOO, and returns a string with all variable references in the form ${FOO}.\n  \"\"\"\nstr = re.sub('\\\\$([a-zA-Z_][a-zA-Z0-9_]*)', '${\\\\1}', str)\nmatches = re.findall('(\\\\$\\\\(([a-zA-Z0-9\\\\-_]+)\\\\))', str)\nfor match in matches:\n    to_replace, variable = match\n    assert '$(' not in match, '$($(FOO)) variables not supported: ' + match\n    str = str.replace(to_replace, '${' + variable + '}')\nreturn str\n",
        "CUT_4": "\"\"\"Returns the flags that need to be added to lib commands.\"\"\"\nconfig = self._TargetConfig(config)\nlibflags = []\nlib = self._GetWrapper(self, self.msvs_settings[config], 'VCLibrarianTool',\n    append=libflags)\nlibflags.extend(self._GetAdditionalLibraryDirectories('VCLibrarianTool',\n    config, gyp_to_build_path))\nlib('LinkTimeCodeGeneration', map={'true': '/LTCG'})\nlib('TargetMachine', map={'1': 'X86', '17': 'X64', '3': 'ARM'}, prefix=\n    '/MACHINE:')\nlib('AdditionalOptions')\nreturn libflags\n",
        "CUT_5": "\"\"\"Given an environment, returns a string looking like\n        'export FOO=foo; export BAR=\"${FOO} bar;'\n    that exports |env| to the shell.\"\"\"\nexport_str = []\nfor k, v in env:\n    export_str.append('export %s=%s;' % (k, ninja_syntax.escape(gyp.common.\n        EncodePOSIXShellArgument(v))))\nreturn ' '.join(export_str)\n"
    },
    {
        "functionName": "testConvertToMSBuildSettings_warnings",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/MSVSSettings_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests conversion that generates warnings.\"\"\"\nmsvs_settings = {'VCCLCompilerTool': {'AdditionalIncludeDirectories': '1',\n    'AdditionalOptions': '2', 'BasicRuntimeChecks': '12',\n    'BrowseInformation': '21', 'UsePrecompiledHeader': '13',\n    'GeneratePreprocessedFile': '14'}, 'VCLinkerTool': {'Driver': '10',\n    'LinkTimeCodeGeneration': '31', 'ErrorReporting': '21',\n    'FixedBaseAddress': '6'}, 'VCResourceCompilerTool': {'Culture': '1003'}}\nexpected_msbuild_settings = {'ClCompile': {'AdditionalIncludeDirectories':\n    '1', 'AdditionalOptions': '2'}, 'Link': {}, 'ResourceCompile': {\n    'Culture': '0x03eb'}}\nactual_msbuild_settings = MSVSSettings.ConvertToMSBuildSettings(msvs_settings,\n    self.stderr)\nself.assertEqual(expected_msbuild_settings, actual_msbuild_settings)\nself._ExpectedWarnings([\n    'Warning: while converting VCCLCompilerTool/BasicRuntimeChecks to MSBuild, index value (12) not in expected range [0, 4)'\n    ,\n    'Warning: while converting VCCLCompilerTool/BrowseInformation to MSBuild, index value (21) not in expected range [0, 3)'\n    ,\n    'Warning: while converting VCCLCompilerTool/UsePrecompiledHeader to MSBuild, index value (13) not in expected range [0, 3)'\n    ,\n    'Warning: while converting VCCLCompilerTool/GeneratePreprocessedFile to MSBuild, value must be one of [0, 1, 2]; got 14'\n    ,\n    'Warning: while converting VCLinkerTool/Driver to MSBuild, index value (10) not in expected range [0, 4)'\n    ,\n    'Warning: while converting VCLinkerTool/LinkTimeCodeGeneration to MSBuild, index value (31) not in expected range [0, 5)'\n    ,\n    'Warning: while converting VCLinkerTool/ErrorReporting to MSBuild, index value (21) not in expected range [0, 3)'\n    ,\n    'Warning: while converting VCLinkerTool/FixedBaseAddress to MSBuild, index value (6) not in expected range [0, 3)'\n    ])\n",
        "CUT_1": "index = int(value)\nif index < 0 or index >= len(self._label_list):\n    raise ValueError('index value (%d) not in expected range [0, %d)' % (\n        index, len(self._label_list)))\nlabel = self._label_list[index]\nif label is None:\n    raise ValueError('converted value for %s not specified.' % value)\nreturn label\n",
        "CUT_2": "\"\"\"Converts MSVS settings (VS2008 and earlier) to MSBuild settings (VS2010+).\n\n  Args:\n      msvs_settings: A dictionary.  The key is the tool name.  The values are\n          themselves dictionaries of settings and their values.\n      stderr: The stream receiving the error messages.\n\n  Returns:\n      A dictionary of MSBuild settings.  The key is either the MSBuild tool name\n      or the empty string (for the global settings).  The values are themselves\n      dictionaries of settings and their values.\n  \"\"\"\nmsbuild_settings = {}\nfor msvs_tool_name, msvs_tool_settings in msvs_settings.items():\n    if msvs_tool_name in _msvs_to_msbuild_converters:\n        msvs_tool = _msvs_to_msbuild_converters[msvs_tool_name]\n        for msvs_setting, msvs_value in msvs_tool_settings.items():\n            if msvs_setting in msvs_tool:\n                try:\n                    msvs_tool[msvs_setting](msvs_value, msbuild_settings)\n                except ValueError as e:\n                    print('Warning: while converting %s/%s to MSBuild, %s' %\n                        (msvs_tool_name, msvs_setting, e), file=stderr)\n            else:\n                _ValidateExclusionSetting(msvs_setting, msvs_tool, \n                    'Warning: unrecognized setting %s/%s while converting to MSBuild.'\n                     % (msvs_tool_name, msvs_setting), stderr)\n    else:\n        print('Warning: unrecognized tool %s while converting to MSBuild.' %\n            msvs_tool_name, file=stderr)\nreturn msbuild_settings\n",
        "CUT_3": "\"\"\"Verifies that the value is legal for MSBuild.\n\n    Args:\n      value: the value to check for this type.\n\n    Raises:\n      ValueError if value is not valid for MSBuild.\n    \"\"\"\n",
        "CUT_4": "if value != 'true' and value != 'false':\n    raise ValueError('expected bool; got %r' % value)\n",
        "CUT_5": "if not isinstance(value, string_types):\n    raise ValueError('expected string; got %r' % value)\n"
    },
    {
        "functionName": "testConvertToMSBuildSettings_full_synthetic",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/MSVSSettings_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests conversion of all the MSBuild settings.\"\"\"\nmsvs_settings = {'VCCLCompilerTool': {'AdditionalIncludeDirectories':\n    'folder1;folder2;folder3', 'AdditionalOptions': 'a_string',\n    'AdditionalUsingDirectories': 'folder1;folder2;folder3',\n    'AssemblerListingLocation': 'a_file_name', 'AssemblerOutput': '0',\n    'BasicRuntimeChecks': '1', 'BrowseInformation': '2',\n    'BrowseInformationFile': 'a_file_name', 'BufferSecurityCheck': 'true',\n    'CallingConvention': '0', 'CompileAs': '1', 'DebugInformationFormat':\n    '4', 'DefaultCharIsUnsigned': 'true', 'Detect64BitPortabilityProblems':\n    'true', 'DisableLanguageExtensions': 'true', 'DisableSpecificWarnings':\n    'd1;d2;d3', 'EnableEnhancedInstructionSet': '0',\n    'EnableFiberSafeOptimizations': 'true', 'EnableFunctionLevelLinking':\n    'true', 'EnableIntrinsicFunctions': 'true', 'EnablePREfast': 'true',\n    'ErrorReporting': '1', 'ExceptionHandling': '2',\n    'ExpandAttributedSource': 'true', 'FavorSizeOrSpeed': '0',\n    'FloatingPointExceptions': 'true', 'FloatingPointModel': '1',\n    'ForceConformanceInForLoopScope': 'true', 'ForcedIncludeFiles':\n    'file1;file2;file3', 'ForcedUsingFiles': 'file1;file2;file3',\n    'GeneratePreprocessedFile': '1', 'GenerateXMLDocumentationFiles':\n    'true', 'IgnoreStandardIncludePath': 'true', 'InlineFunctionExpansion':\n    '2', 'KeepComments': 'true', 'MinimalRebuild': 'true', 'ObjectFile':\n    'a_file_name', 'OmitDefaultLibName': 'true', 'OmitFramePointers':\n    'true', 'OpenMP': 'true', 'Optimization': '3', 'PrecompiledHeaderFile':\n    'a_file_name', 'PrecompiledHeaderThrough': 'a_file_name',\n    'PreprocessorDefinitions': 'd1;d2;d3', 'ProgramDataBaseFileName':\n    'a_file_name', 'RuntimeLibrary': '0', 'RuntimeTypeInfo': 'true',\n    'ShowIncludes': 'true', 'SmallerTypeCheck': 'true', 'StringPooling':\n    'true', 'StructMemberAlignment': '1', 'SuppressStartupBanner': 'true',\n    'TreatWChar_tAsBuiltInType': 'true',\n    'UndefineAllPreprocessorDefinitions': 'true',\n    'UndefinePreprocessorDefinitions': 'd1;d2;d3', 'UseFullPaths': 'true',\n    'UsePrecompiledHeader': '1', 'UseUnicodeResponseFiles': 'true',\n    'WarnAsError': 'true', 'WarningLevel': '2', 'WholeProgramOptimization':\n    'true', 'XMLDocumentationFileName': 'a_file_name'}, 'VCLinkerTool': {\n    'AdditionalDependencies': 'file1;file2;file3',\n    'AdditionalLibraryDirectories': 'folder1;folder2;folder3',\n    'AdditionalLibraryDirectories_excluded': 'folder1;folder2;folder3',\n    'AdditionalManifestDependencies': 'file1;file2;file3',\n    'AdditionalOptions': 'a_string', 'AddModuleNamesToAssembly':\n    'file1;file2;file3', 'AllowIsolation': 'true', 'AssemblyDebug': '0',\n    'AssemblyLinkResource': 'file1;file2;file3', 'BaseAddress': 'a_string',\n    'CLRImageType': '1', 'CLRThreadAttribute': '2', 'CLRUnmanagedCodeCheck':\n    'true', 'DataExecutionPrevention': '0', 'DelayLoadDLLs':\n    'file1;file2;file3', 'DelaySign': 'true', 'Driver': '1',\n    'EmbedManagedResourceFile': 'file1;file2;file3', 'EnableCOMDATFolding':\n    '0', 'EnableUAC': 'true', 'EntryPointSymbol': 'a_string',\n    'ErrorReporting': '0', 'FixedBaseAddress': '1', 'ForceSymbolReferences':\n    'file1;file2;file3', 'FunctionOrder': 'a_file_name',\n    'GenerateDebugInformation': 'true', 'GenerateManifest': 'true',\n    'GenerateMapFile': 'true', 'HeapCommitSize': 'a_string',\n    'HeapReserveSize': 'a_string', 'IgnoreAllDefaultLibraries': 'true',\n    'IgnoreDefaultLibraryNames': 'file1;file2;file3', 'IgnoreEmbeddedIDL':\n    'true', 'IgnoreImportLibrary': 'true', 'ImportLibrary': 'a_file_name',\n    'KeyContainer': 'a_file_name', 'KeyFile': 'a_file_name',\n    'LargeAddressAware': '2', 'LinkIncremental': '1',\n    'LinkLibraryDependencies': 'true', 'LinkTimeCodeGeneration': '2',\n    'ManifestFile': 'a_file_name', 'MapExports': 'true', 'MapFileName':\n    'a_file_name', 'MergedIDLBaseFileName': 'a_file_name', 'MergeSections':\n    'a_string', 'MidlCommandFile': 'a_file_name', 'ModuleDefinitionFile':\n    'a_file_name', 'OptimizeForWindows98': '1', 'OptimizeReferences': '0',\n    'OutputFile': 'a_file_name', 'PerUserRedirection': 'true', 'Profile':\n    'true', 'ProfileGuidedDatabase': 'a_file_name', 'ProgramDatabaseFile':\n    'a_file_name', 'RandomizedBaseAddress': '1', 'RegisterOutput': 'true',\n    'ResourceOnlyDLL': 'true', 'SetChecksum': 'true', 'ShowProgress': '0',\n    'StackCommitSize': 'a_string', 'StackReserveSize': 'a_string',\n    'StripPrivateSymbols': 'a_file_name', 'SubSystem': '2',\n    'SupportUnloadOfDelayLoadedDLL': 'true', 'SuppressStartupBanner':\n    'true', 'SwapRunFromCD': 'true', 'SwapRunFromNet': 'true',\n    'TargetMachine': '3', 'TerminalServerAware': '2',\n    'TurnOffAssemblyGeneration': 'true', 'TypeLibraryFile': 'a_file_name',\n    'TypeLibraryResourceID': '33', 'UACExecutionLevel': '1', 'UACUIAccess':\n    'true', 'UseLibraryDependencyInputs': 'false',\n    'UseUnicodeResponseFiles': 'true', 'Version': 'a_string'},\n    'VCResourceCompilerTool': {'AdditionalIncludeDirectories':\n    'folder1;folder2;folder3', 'AdditionalOptions': 'a_string', 'Culture':\n    '1003', 'IgnoreStandardIncludePath': 'true', 'PreprocessorDefinitions':\n    'd1;d2;d3', 'ResourceOutputFileName': 'a_string', 'ShowProgress':\n    'true', 'SuppressStartupBanner': 'true',\n    'UndefinePreprocessorDefinitions': 'd1;d2;d3'}, 'VCMIDLTool': {\n    'AdditionalIncludeDirectories': 'folder1;folder2;folder3',\n    'AdditionalOptions': 'a_string', 'CPreprocessOptions': 'a_string',\n    'DefaultCharType': '0', 'DLLDataFileName': 'a_file_name',\n    'EnableErrorChecks': '2', 'ErrorCheckAllocations': 'true',\n    'ErrorCheckBounds': 'true', 'ErrorCheckEnumRange': 'true',\n    'ErrorCheckRefPointers': 'true', 'ErrorCheckStubData': 'true',\n    'GenerateStublessProxies': 'true', 'GenerateTypeLibrary': 'true',\n    'HeaderFileName': 'a_file_name', 'IgnoreStandardIncludePath': 'true',\n    'InterfaceIdentifierFileName': 'a_file_name', 'MkTypLibCompatible':\n    'true', 'OutputDirectory': 'a_string', 'PreprocessorDefinitions':\n    'd1;d2;d3', 'ProxyFileName': 'a_file_name', 'RedirectOutputAndErrors':\n    'a_file_name', 'StructMemberAlignment': '3', 'SuppressStartupBanner':\n    'true', 'TargetEnvironment': '1', 'TypeLibraryName': 'a_file_name',\n    'UndefinePreprocessorDefinitions': 'd1;d2;d3', 'ValidateParameters':\n    'true', 'WarnAsError': 'true', 'WarningLevel': '4'}, 'VCLibrarianTool':\n    {'AdditionalDependencies': 'file1;file2;file3',\n    'AdditionalLibraryDirectories': 'folder1;folder2;folder3',\n    'AdditionalLibraryDirectories_excluded': 'folder1;folder2;folder3',\n    'AdditionalOptions': 'a_string', 'ExportNamedFunctions': 'd1;d2;d3',\n    'ForceSymbolReferences': 'a_string', 'IgnoreAllDefaultLibraries':\n    'true', 'IgnoreSpecificDefaultLibraries': 'file1;file2;file3',\n    'LinkLibraryDependencies': 'true', 'ModuleDefinitionFile':\n    'a_file_name', 'OutputFile': 'a_file_name', 'SuppressStartupBanner':\n    'true', 'UseUnicodeResponseFiles': 'true'}, 'VCManifestTool': {\n    'AdditionalManifestFiles': 'file1;file2;file3', 'AdditionalOptions':\n    'a_string', 'AssemblyIdentity': 'a_string', 'ComponentFileName':\n    'a_file_name', 'DependencyInformationFile': 'a_file_name',\n    'EmbedManifest': 'true', 'GenerateCatalogFiles': 'true',\n    'InputResourceManifests': 'a_string', 'ManifestResourceFile': 'my_name',\n    'OutputManifestFile': 'a_file_name', 'RegistrarScriptFile':\n    'a_file_name', 'ReplacementsFile': 'a_file_name',\n    'SuppressStartupBanner': 'true', 'TypeLibraryFile': 'a_file_name',\n    'UpdateFileHashes': 'true', 'UpdateFileHashesSearchPath': 'a_file_name',\n    'UseFAT32Workaround': 'true', 'UseUnicodeResponseFiles': 'true',\n    'VerboseOutput': 'true'}}\nexpected_msbuild_settings = {'ClCompile': {'AdditionalIncludeDirectories':\n    'folder1;folder2;folder3', 'AdditionalOptions': 'a_string /J',\n    'AdditionalUsingDirectories': 'folder1;folder2;folder3',\n    'AssemblerListingLocation': 'a_file_name', 'AssemblerOutput':\n    'NoListing', 'BasicRuntimeChecks': 'StackFrameRuntimeCheck',\n    'BrowseInformation': 'true', 'BrowseInformationFile': 'a_file_name',\n    'BufferSecurityCheck': 'true', 'CallingConvention': 'Cdecl',\n    'CompileAs': 'CompileAsC', 'DebugInformationFormat': 'EditAndContinue',\n    'DisableLanguageExtensions': 'true', 'DisableSpecificWarnings':\n    'd1;d2;d3', 'EnableEnhancedInstructionSet': 'NotSet',\n    'EnableFiberSafeOptimizations': 'true', 'EnablePREfast': 'true',\n    'ErrorReporting': 'Prompt', 'ExceptionHandling': 'Async',\n    'ExpandAttributedSource': 'true', 'FavorSizeOrSpeed': 'Neither',\n    'FloatingPointExceptions': 'true', 'FloatingPointModel': 'Strict',\n    'ForceConformanceInForLoopScope': 'true', 'ForcedIncludeFiles':\n    'file1;file2;file3', 'ForcedUsingFiles': 'file1;file2;file3',\n    'FunctionLevelLinking': 'true', 'GenerateXMLDocumentationFiles': 'true',\n    'IgnoreStandardIncludePath': 'true', 'InlineFunctionExpansion':\n    'AnySuitable', 'IntrinsicFunctions': 'true', 'MinimalRebuild': 'true',\n    'ObjectFileName': 'a_file_name', 'OmitDefaultLibName': 'true',\n    'OmitFramePointers': 'true', 'OpenMPSupport': 'true', 'Optimization':\n    'Full', 'PrecompiledHeader': 'Create', 'PrecompiledHeaderFile':\n    'a_file_name', 'PrecompiledHeaderOutputFile': 'a_file_name',\n    'PreprocessKeepComments': 'true', 'PreprocessorDefinitions': 'd1;d2;d3',\n    'PreprocessSuppressLineNumbers': 'false', 'PreprocessToFile': 'true',\n    'ProgramDataBaseFileName': 'a_file_name', 'RuntimeLibrary':\n    'MultiThreaded', 'RuntimeTypeInfo': 'true', 'ShowIncludes': 'true',\n    'SmallerTypeCheck': 'true', 'StringPooling': 'true',\n    'StructMemberAlignment': '1Byte', 'SuppressStartupBanner': 'true',\n    'TreatWarningAsError': 'true', 'TreatWChar_tAsBuiltInType': 'true',\n    'UndefineAllPreprocessorDefinitions': 'true',\n    'UndefinePreprocessorDefinitions': 'd1;d2;d3', 'UseFullPaths': 'true',\n    'WarningLevel': 'Level2', 'WholeProgramOptimization': 'true',\n    'XMLDocumentationFileName': 'a_file_name'}, 'Link': {\n    'AdditionalDependencies': 'file1;file2;file3',\n    'AdditionalLibraryDirectories': 'folder1;folder2;folder3',\n    'AdditionalManifestDependencies': 'file1;file2;file3',\n    'AdditionalOptions': 'a_string', 'AddModuleNamesToAssembly':\n    'file1;file2;file3', 'AllowIsolation': 'true', 'AssemblyDebug': '',\n    'AssemblyLinkResource': 'file1;file2;file3', 'BaseAddress': 'a_string',\n    'CLRImageType': 'ForceIJWImage', 'CLRThreadAttribute':\n    'STAThreadingAttribute', 'CLRUnmanagedCodeCheck': 'true',\n    'DataExecutionPrevention': '', 'DelayLoadDLLs': 'file1;file2;file3',\n    'DelaySign': 'true', 'Driver': 'Driver', 'EmbedManagedResourceFile':\n    'file1;file2;file3', 'EnableCOMDATFolding': '', 'EnableUAC': 'true',\n    'EntryPointSymbol': 'a_string', 'FixedBaseAddress': 'false',\n    'ForceSymbolReferences': 'file1;file2;file3', 'FunctionOrder':\n    'a_file_name', 'GenerateDebugInformation': 'true', 'GenerateMapFile':\n    'true', 'HeapCommitSize': 'a_string', 'HeapReserveSize': 'a_string',\n    'IgnoreAllDefaultLibraries': 'true', 'IgnoreEmbeddedIDL': 'true',\n    'IgnoreSpecificDefaultLibraries': 'file1;file2;file3', 'ImportLibrary':\n    'a_file_name', 'KeyContainer': 'a_file_name', 'KeyFile': 'a_file_name',\n    'LargeAddressAware': 'true', 'LinkErrorReporting': 'NoErrorReport',\n    'LinkTimeCodeGeneration': 'PGInstrument', 'ManifestFile': 'a_file_name',\n    'MapExports': 'true', 'MapFileName': 'a_file_name',\n    'MergedIDLBaseFileName': 'a_file_name', 'MergeSections': 'a_string',\n    'MidlCommandFile': 'a_file_name', 'ModuleDefinitionFile': 'a_file_name',\n    'NoEntryPoint': 'true', 'OptimizeReferences': '', 'OutputFile':\n    'a_file_name', 'PerUserRedirection': 'true', 'Profile': 'true',\n    'ProfileGuidedDatabase': 'a_file_name', 'ProgramDatabaseFile':\n    'a_file_name', 'RandomizedBaseAddress': 'false', 'RegisterOutput':\n    'true', 'SetChecksum': 'true', 'ShowProgress': 'NotSet',\n    'StackCommitSize': 'a_string', 'StackReserveSize': 'a_string',\n    'StripPrivateSymbols': 'a_file_name', 'SubSystem': 'Windows',\n    'SupportUnloadOfDelayLoadedDLL': 'true', 'SuppressStartupBanner':\n    'true', 'SwapRunFromCD': 'true', 'SwapRunFromNET': 'true',\n    'TargetMachine': 'MachineARM', 'TerminalServerAware': 'true',\n    'TurnOffAssemblyGeneration': 'true', 'TypeLibraryFile': 'a_file_name',\n    'TypeLibraryResourceID': '33', 'UACExecutionLevel': 'HighestAvailable',\n    'UACUIAccess': 'true', 'Version': 'a_string'}, 'ResourceCompile': {\n    'AdditionalIncludeDirectories': 'folder1;folder2;folder3',\n    'AdditionalOptions': 'a_string', 'Culture': '0x03eb',\n    'IgnoreStandardIncludePath': 'true', 'PreprocessorDefinitions':\n    'd1;d2;d3', 'ResourceOutputFileName': 'a_string', 'ShowProgress':\n    'true', 'SuppressStartupBanner': 'true',\n    'UndefinePreprocessorDefinitions': 'd1;d2;d3'}, 'Midl': {\n    'AdditionalIncludeDirectories': 'folder1;folder2;folder3',\n    'AdditionalOptions': 'a_string', 'CPreprocessOptions': 'a_string',\n    'DefaultCharType': 'Unsigned', 'DllDataFileName': 'a_file_name',\n    'EnableErrorChecks': 'All', 'ErrorCheckAllocations': 'true',\n    'ErrorCheckBounds': 'true', 'ErrorCheckEnumRange': 'true',\n    'ErrorCheckRefPointers': 'true', 'ErrorCheckStubData': 'true',\n    'GenerateStublessProxies': 'true', 'GenerateTypeLibrary': 'true',\n    'HeaderFileName': 'a_file_name', 'IgnoreStandardIncludePath': 'true',\n    'InterfaceIdentifierFileName': 'a_file_name', 'MkTypLibCompatible':\n    'true', 'OutputDirectory': 'a_string', 'PreprocessorDefinitions':\n    'd1;d2;d3', 'ProxyFileName': 'a_file_name', 'RedirectOutputAndErrors':\n    'a_file_name', 'StructMemberAlignment': '4', 'SuppressStartupBanner':\n    'true', 'TargetEnvironment': 'Win32', 'TypeLibraryName': 'a_file_name',\n    'UndefinePreprocessorDefinitions': 'd1;d2;d3', 'ValidateAllParameters':\n    'true', 'WarnAsError': 'true', 'WarningLevel': '4'}, 'Lib': {\n    'AdditionalDependencies': 'file1;file2;file3',\n    'AdditionalLibraryDirectories': 'folder1;folder2;folder3',\n    'AdditionalOptions': 'a_string', 'ExportNamedFunctions': 'd1;d2;d3',\n    'ForceSymbolReferences': 'a_string', 'IgnoreAllDefaultLibraries':\n    'true', 'IgnoreSpecificDefaultLibraries': 'file1;file2;file3',\n    'ModuleDefinitionFile': 'a_file_name', 'OutputFile': 'a_file_name',\n    'SuppressStartupBanner': 'true', 'UseUnicodeResponseFiles': 'true'},\n    'Manifest': {'AdditionalManifestFiles': 'file1;file2;file3',\n    'AdditionalOptions': 'a_string', 'AssemblyIdentity': 'a_string',\n    'ComponentFileName': 'a_file_name', 'GenerateCatalogFiles': 'true',\n    'InputResourceManifests': 'a_string', 'OutputManifestFile':\n    'a_file_name', 'RegistrarScriptFile': 'a_file_name', 'ReplacementsFile':\n    'a_file_name', 'SuppressStartupBanner': 'true', 'TypeLibraryFile':\n    'a_file_name', 'UpdateFileHashes': 'true', 'UpdateFileHashesSearchPath':\n    'a_file_name', 'VerboseOutput': 'true'}, 'ManifestResourceCompile': {\n    'ResourceOutputFileName': 'my_name'}, 'ProjectReference': {\n    'LinkLibraryDependencies': 'true', 'UseLibraryDependencyInputs':\n    'false'}, '': {'EmbedManifest': 'true', 'GenerateManifest': 'true',\n    'IgnoreImportLibrary': 'true', 'LinkIncremental': 'false'}}\nself.maxDiff = 9999\nactual_msbuild_settings = MSVSSettings.ConvertToMSBuildSettings(msvs_settings,\n    self.stderr)\nself.assertEqual(expected_msbuild_settings, actual_msbuild_settings)\nself._ExpectedWarnings([])\n",
        "CUT_1": "return True\n",
        "CUT_2": "\"\"\"Return true if the file is compilable (should be in OBJS).\"\"\"\nfor res in (filename.endswith(e) for e in COMPILABLE_EXTENSIONS):\n    if res:\n        return True\nreturn False\n",
        "CUT_3": "\"\"\"Returns whether manifest should be linked into binary.\"\"\"\nconfig = self._TargetConfig(config)\nembed = self._Setting(('VCManifestTool', 'EmbedManifest'), config, default=\n    'true')\nreturn embed == 'true'\n",
        "CUT_4": "\"\"\"Returns true if any target contains the iOS specific key\n  IPHONEOS_DEPLOYMENT_TARGET.\"\"\"\nfor target_dict in targets.values():\n    for config in target_dict['configurations'].values():\n        if config.get('xcode_settings', {}).get('IPHONEOS_DEPLOYMENT_TARGET'):\n            return True\nreturn False\n",
        "CUT_5": "\"\"\"Returns true if this version uses a vcxproj file.\"\"\"\nreturn self.uses_vcxproj\n"
    },
    {
        "functionName": "testConvertToMSBuildSettings_actual",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/MSVSSettings_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests the conversion of an actual project.\n\n    A VS2008 project with most of the options defined was created through the\n    VS2008 IDE.  It was then converted to VS2010.  The tool settings found in\n    the .vcproj and .vcxproj files were converted to the two dictionaries\n    msvs_settings and expected_msbuild_settings.\n\n    Note that for many settings, the VS2010 converter adds macros like\n    %(AdditionalIncludeDirectories) to make sure than inherited values are\n    included.  Since the Gyp projects we generate do not use inheritance,\n    we removed these macros.  They were:\n        ClCompile:\n            AdditionalIncludeDirectories:  ';%(AdditionalIncludeDirectories)'\n            AdditionalOptions:  ' %(AdditionalOptions)'\n            AdditionalUsingDirectories:  ';%(AdditionalUsingDirectories)'\n            DisableSpecificWarnings: ';%(DisableSpecificWarnings)',\n            ForcedIncludeFiles:  ';%(ForcedIncludeFiles)',\n            ForcedUsingFiles:  ';%(ForcedUsingFiles)',\n            PreprocessorDefinitions:  ';%(PreprocessorDefinitions)',\n            UndefinePreprocessorDefinitions:\n                ';%(UndefinePreprocessorDefinitions)',\n        Link:\n            AdditionalDependencies:  ';%(AdditionalDependencies)',\n            AdditionalLibraryDirectories:  ';%(AdditionalLibraryDirectories)',\n            AdditionalManifestDependencies:\n                ';%(AdditionalManifestDependencies)',\n            AdditionalOptions:  ' %(AdditionalOptions)',\n            AddModuleNamesToAssembly:  ';%(AddModuleNamesToAssembly)',\n            AssemblyLinkResource:  ';%(AssemblyLinkResource)',\n            DelayLoadDLLs:  ';%(DelayLoadDLLs)',\n            EmbedManagedResourceFile:  ';%(EmbedManagedResourceFile)',\n            ForceSymbolReferences:  ';%(ForceSymbolReferences)',\n            IgnoreSpecificDefaultLibraries:\n                ';%(IgnoreSpecificDefaultLibraries)',\n        ResourceCompile:\n            AdditionalIncludeDirectories:  ';%(AdditionalIncludeDirectories)',\n            AdditionalOptions:  ' %(AdditionalOptions)',\n            PreprocessorDefinitions:  ';%(PreprocessorDefinitions)',\n        Manifest:\n            AdditionalManifestFiles:  ';%(AdditionalManifestFiles)',\n            AdditionalOptions:  ' %(AdditionalOptions)',\n            InputResourceManifests:  ';%(InputResourceManifests)',\n    \"\"\"\nmsvs_settings = {'VCCLCompilerTool': {'AdditionalIncludeDirectories':\n    'dir1', 'AdditionalOptions': '/more', 'AdditionalUsingDirectories':\n    'test', 'AssemblerListingLocation': '$(IntDir)\\\\a', 'AssemblerOutput':\n    '1', 'BasicRuntimeChecks': '3', 'BrowseInformation': '1',\n    'BrowseInformationFile': '$(IntDir)\\\\e', 'BufferSecurityCheck': 'false',\n    'CallingConvention': '1', 'CompileAs': '1', 'DebugInformationFormat':\n    '4', 'DefaultCharIsUnsigned': 'true', 'Detect64BitPortabilityProblems':\n    'true', 'DisableLanguageExtensions': 'true', 'DisableSpecificWarnings':\n    'abc', 'EnableEnhancedInstructionSet': '1',\n    'EnableFiberSafeOptimizations': 'true', 'EnableFunctionLevelLinking':\n    'true', 'EnableIntrinsicFunctions': 'true', 'EnablePREfast': 'true',\n    'ErrorReporting': '2', 'ExceptionHandling': '2',\n    'ExpandAttributedSource': 'true', 'FavorSizeOrSpeed': '2',\n    'FloatingPointExceptions': 'true', 'FloatingPointModel': '1',\n    'ForceConformanceInForLoopScope': 'false', 'ForcedIncludeFiles': 'def',\n    'ForcedUsingFiles': 'ge', 'GeneratePreprocessedFile': '2',\n    'GenerateXMLDocumentationFiles': 'true', 'IgnoreStandardIncludePath':\n    'true', 'InlineFunctionExpansion': '1', 'KeepComments': 'true',\n    'MinimalRebuild': 'true', 'ObjectFile': '$(IntDir)\\\\b',\n    'OmitDefaultLibName': 'true', 'OmitFramePointers': 'true', 'OpenMP':\n    'true', 'Optimization': '3', 'PrecompiledHeaderFile':\n    '$(IntDir)\\\\$(TargetName).pche', 'PrecompiledHeaderThrough':\n    'StdAfx.hd', 'PreprocessorDefinitions': 'WIN32;_DEBUG;_CONSOLE',\n    'ProgramDataBaseFileName': '$(IntDir)\\\\vc90b.pdb', 'RuntimeLibrary':\n    '3', 'RuntimeTypeInfo': 'false', 'ShowIncludes': 'true',\n    'SmallerTypeCheck': 'true', 'StringPooling': 'true',\n    'StructMemberAlignment': '3', 'SuppressStartupBanner': 'false',\n    'TreatWChar_tAsBuiltInType': 'false',\n    'UndefineAllPreprocessorDefinitions': 'true',\n    'UndefinePreprocessorDefinitions': 'wer', 'UseFullPaths': 'true',\n    'UsePrecompiledHeader': '0', 'UseUnicodeResponseFiles': 'false',\n    'WarnAsError': 'true', 'WarningLevel': '3', 'WholeProgramOptimization':\n    'true', 'XMLDocumentationFileName': '$(IntDir)\\\\c'}, 'VCLinkerTool': {\n    'AdditionalDependencies': 'zx', 'AdditionalLibraryDirectories': 'asd',\n    'AdditionalManifestDependencies': 's2', 'AdditionalOptions': '/mor2',\n    'AddModuleNamesToAssembly': 'd1', 'AllowIsolation': 'false',\n    'AssemblyDebug': '1', 'AssemblyLinkResource': 'd5', 'BaseAddress':\n    '23423', 'CLRImageType': '3', 'CLRThreadAttribute': '1',\n    'CLRUnmanagedCodeCheck': 'true', 'DataExecutionPrevention': '0',\n    'DelayLoadDLLs': 'd4', 'DelaySign': 'true', 'Driver': '2',\n    'EmbedManagedResourceFile': 'd2', 'EnableCOMDATFolding': '1',\n    'EnableUAC': 'false', 'EntryPointSymbol': 'f5', 'ErrorReporting': '2',\n    'FixedBaseAddress': '1', 'ForceSymbolReferences': 'd3', 'FunctionOrder':\n    'fssdfsd', 'GenerateDebugInformation': 'true', 'GenerateManifest':\n    'false', 'GenerateMapFile': 'true', 'HeapCommitSize': '13',\n    'HeapReserveSize': '12', 'IgnoreAllDefaultLibraries': 'true',\n    'IgnoreDefaultLibraryNames': 'flob;flok', 'IgnoreEmbeddedIDL': 'true',\n    'IgnoreImportLibrary': 'true', 'ImportLibrary': 'f4', 'KeyContainer':\n    'f7', 'KeyFile': 'f6', 'LargeAddressAware': '2', 'LinkIncremental': '0',\n    'LinkLibraryDependencies': 'false', 'LinkTimeCodeGeneration': '1',\n    'ManifestFile': '$(IntDir)\\\\$(TargetFileName).2intermediate.manifest',\n    'MapExports': 'true', 'MapFileName': 'd5', 'MergedIDLBaseFileName':\n    'f2', 'MergeSections': 'f5', 'MidlCommandFile': 'f1',\n    'ModuleDefinitionFile': 'sdsd', 'OptimizeForWindows98': '2',\n    'OptimizeReferences': '2', 'OutputFile':\n    '$(OutDir)\\\\$(ProjectName)2.exe', 'PerUserRedirection': 'true',\n    'Profile': 'true', 'ProfileGuidedDatabase':\n    '$(TargetDir)$(TargetName).pgdd', 'ProgramDatabaseFile': 'Flob.pdb',\n    'RandomizedBaseAddress': '1', 'RegisterOutput': 'true',\n    'ResourceOnlyDLL': 'true', 'SetChecksum': 'false', 'ShowProgress': '1',\n    'StackCommitSize': '15', 'StackReserveSize': '14',\n    'StripPrivateSymbols': 'd3', 'SubSystem': '1',\n    'SupportUnloadOfDelayLoadedDLL': 'true', 'SuppressStartupBanner':\n    'false', 'SwapRunFromCD': 'true', 'SwapRunFromNet': 'true',\n    'TargetMachine': '1', 'TerminalServerAware': '1',\n    'TurnOffAssemblyGeneration': 'true', 'TypeLibraryFile': 'f3',\n    'TypeLibraryResourceID': '12', 'UACExecutionLevel': '2', 'UACUIAccess':\n    'true', 'UseLibraryDependencyInputs': 'true', 'UseUnicodeResponseFiles':\n    'false', 'Version': '333'}, 'VCResourceCompilerTool': {\n    'AdditionalIncludeDirectories': 'f3', 'AdditionalOptions': '/more3',\n    'Culture': '3084', 'IgnoreStandardIncludePath': 'true',\n    'PreprocessorDefinitions': '_UNICODE;UNICODE2',\n    'ResourceOutputFileName': '$(IntDir)/$(InputName)3.res', 'ShowProgress':\n    'true'}, 'VCManifestTool': {'AdditionalManifestFiles': 'sfsdfsd',\n    'AdditionalOptions': 'afdsdafsd', 'AssemblyIdentity': 'sddfdsadfsa',\n    'ComponentFileName': 'fsdfds', 'DependencyInformationFile':\n    '$(IntDir)\\\\mt.depdfd', 'EmbedManifest': 'false',\n    'GenerateCatalogFiles': 'true', 'InputResourceManifests': 'asfsfdafs',\n    'ManifestResourceFile':\n    '$(IntDir)\\\\$(TargetFileName).embed.manifest.resfdsf',\n    'OutputManifestFile': '$(TargetPath).manifestdfs',\n    'RegistrarScriptFile': 'sdfsfd', 'ReplacementsFile': 'sdffsd',\n    'SuppressStartupBanner': 'false', 'TypeLibraryFile': 'sfsd',\n    'UpdateFileHashes': 'true', 'UpdateFileHashesSearchPath': 'sfsd',\n    'UseFAT32Workaround': 'true', 'UseUnicodeResponseFiles': 'false',\n    'VerboseOutput': 'true'}}\nexpected_msbuild_settings = {'ClCompile': {'AdditionalIncludeDirectories':\n    'dir1', 'AdditionalOptions': '/more /J', 'AdditionalUsingDirectories':\n    'test', 'AssemblerListingLocation': '$(IntDir)a', 'AssemblerOutput':\n    'AssemblyCode', 'BasicRuntimeChecks': 'EnableFastChecks',\n    'BrowseInformation': 'true', 'BrowseInformationFile': '$(IntDir)e',\n    'BufferSecurityCheck': 'false', 'CallingConvention': 'FastCall',\n    'CompileAs': 'CompileAsC', 'DebugInformationFormat': 'EditAndContinue',\n    'DisableLanguageExtensions': 'true', 'DisableSpecificWarnings': 'abc',\n    'EnableEnhancedInstructionSet': 'StreamingSIMDExtensions',\n    'EnableFiberSafeOptimizations': 'true', 'EnablePREfast': 'true',\n    'ErrorReporting': 'Queue', 'ExceptionHandling': 'Async',\n    'ExpandAttributedSource': 'true', 'FavorSizeOrSpeed': 'Size',\n    'FloatingPointExceptions': 'true', 'FloatingPointModel': 'Strict',\n    'ForceConformanceInForLoopScope': 'false', 'ForcedIncludeFiles': 'def',\n    'ForcedUsingFiles': 'ge', 'FunctionLevelLinking': 'true',\n    'GenerateXMLDocumentationFiles': 'true', 'IgnoreStandardIncludePath':\n    'true', 'InlineFunctionExpansion': 'OnlyExplicitInline',\n    'IntrinsicFunctions': 'true', 'MinimalRebuild': 'true',\n    'ObjectFileName': '$(IntDir)b', 'OmitDefaultLibName': 'true',\n    'OmitFramePointers': 'true', 'OpenMPSupport': 'true', 'Optimization':\n    'Full', 'PrecompiledHeader': 'NotUsing', 'PrecompiledHeaderFile':\n    'StdAfx.hd', 'PrecompiledHeaderOutputFile':\n    '$(IntDir)$(TargetName).pche', 'PreprocessKeepComments': 'true',\n    'PreprocessorDefinitions': 'WIN32;_DEBUG;_CONSOLE',\n    'PreprocessSuppressLineNumbers': 'true', 'PreprocessToFile': 'true',\n    'ProgramDataBaseFileName': '$(IntDir)vc90b.pdb', 'RuntimeLibrary':\n    'MultiThreadedDebugDLL', 'RuntimeTypeInfo': 'false', 'ShowIncludes':\n    'true', 'SmallerTypeCheck': 'true', 'StringPooling': 'true',\n    'StructMemberAlignment': '4Bytes', 'SuppressStartupBanner': 'false',\n    'TreatWarningAsError': 'true', 'TreatWChar_tAsBuiltInType': 'false',\n    'UndefineAllPreprocessorDefinitions': 'true',\n    'UndefinePreprocessorDefinitions': 'wer', 'UseFullPaths': 'true',\n    'WarningLevel': 'Level3', 'WholeProgramOptimization': 'true',\n    'XMLDocumentationFileName': '$(IntDir)c'}, 'Link': {\n    'AdditionalDependencies': 'zx', 'AdditionalLibraryDirectories': 'asd',\n    'AdditionalManifestDependencies': 's2', 'AdditionalOptions': '/mor2',\n    'AddModuleNamesToAssembly': 'd1', 'AllowIsolation': 'false',\n    'AssemblyDebug': 'true', 'AssemblyLinkResource': 'd5', 'BaseAddress':\n    '23423', 'CLRImageType': 'ForceSafeILImage', 'CLRThreadAttribute':\n    'MTAThreadingAttribute', 'CLRUnmanagedCodeCheck': 'true',\n    'DataExecutionPrevention': '', 'DelayLoadDLLs': 'd4', 'DelaySign':\n    'true', 'Driver': 'UpOnly', 'EmbedManagedResourceFile': 'd2',\n    'EnableCOMDATFolding': 'false', 'EnableUAC': 'false',\n    'EntryPointSymbol': 'f5', 'FixedBaseAddress': 'false',\n    'ForceSymbolReferences': 'd3', 'FunctionOrder': 'fssdfsd',\n    'GenerateDebugInformation': 'true', 'GenerateMapFile': 'true',\n    'HeapCommitSize': '13', 'HeapReserveSize': '12',\n    'IgnoreAllDefaultLibraries': 'true', 'IgnoreEmbeddedIDL': 'true',\n    'IgnoreSpecificDefaultLibraries': 'flob;flok', 'ImportLibrary': 'f4',\n    'KeyContainer': 'f7', 'KeyFile': 'f6', 'LargeAddressAware': 'true',\n    'LinkErrorReporting': 'QueueForNextLogin', 'LinkTimeCodeGeneration':\n    'UseLinkTimeCodeGeneration', 'ManifestFile':\n    '$(IntDir)$(TargetFileName).2intermediate.manifest', 'MapExports':\n    'true', 'MapFileName': 'd5', 'MergedIDLBaseFileName': 'f2',\n    'MergeSections': 'f5', 'MidlCommandFile': 'f1', 'ModuleDefinitionFile':\n    'sdsd', 'NoEntryPoint': 'true', 'OptimizeReferences': 'true',\n    'OutputFile': '$(OutDir)$(ProjectName)2.exe', 'PerUserRedirection':\n    'true', 'Profile': 'true', 'ProfileGuidedDatabase':\n    '$(TargetDir)$(TargetName).pgdd', 'ProgramDatabaseFile': 'Flob.pdb',\n    'RandomizedBaseAddress': 'false', 'RegisterOutput': 'true',\n    'SetChecksum': 'false', 'ShowProgress': 'LinkVerbose',\n    'StackCommitSize': '15', 'StackReserveSize': '14',\n    'StripPrivateSymbols': 'd3', 'SubSystem': 'Console',\n    'SupportUnloadOfDelayLoadedDLL': 'true', 'SuppressStartupBanner':\n    'false', 'SwapRunFromCD': 'true', 'SwapRunFromNET': 'true',\n    'TargetMachine': 'MachineX86', 'TerminalServerAware': 'false',\n    'TurnOffAssemblyGeneration': 'true', 'TypeLibraryFile': 'f3',\n    'TypeLibraryResourceID': '12', 'UACExecutionLevel':\n    'RequireAdministrator', 'UACUIAccess': 'true', 'Version': '333'},\n    'ResourceCompile': {'AdditionalIncludeDirectories': 'f3',\n    'AdditionalOptions': '/more3', 'Culture': '0x0c0c',\n    'IgnoreStandardIncludePath': 'true', 'PreprocessorDefinitions':\n    '_UNICODE;UNICODE2', 'ResourceOutputFileName':\n    '$(IntDir)%(Filename)3.res', 'ShowProgress': 'true'}, 'Manifest': {\n    'AdditionalManifestFiles': 'sfsdfsd', 'AdditionalOptions': 'afdsdafsd',\n    'AssemblyIdentity': 'sddfdsadfsa', 'ComponentFileName': 'fsdfds',\n    'GenerateCatalogFiles': 'true', 'InputResourceManifests': 'asfsfdafs',\n    'OutputManifestFile': '$(TargetPath).manifestdfs',\n    'RegistrarScriptFile': 'sdfsfd', 'ReplacementsFile': 'sdffsd',\n    'SuppressStartupBanner': 'false', 'TypeLibraryFile': 'sfsd',\n    'UpdateFileHashes': 'true', 'UpdateFileHashesSearchPath': 'sfsd',\n    'VerboseOutput': 'true'}, 'ProjectReference': {\n    'LinkLibraryDependencies': 'false', 'UseLibraryDependencyInputs':\n    'true'}, '': {'EmbedManifest': 'false', 'GenerateManifest': 'false',\n    'IgnoreImportLibrary': 'true', 'LinkIncremental': ''},\n    'ManifestResourceCompile': {'ResourceOutputFileName':\n    '$(IntDir)$(TargetFileName).embed.manifest.resfdsf'}}\nself.maxDiff = 9999\nactual_msbuild_settings = MSVSSettings.ConvertToMSBuildSettings(msvs_settings,\n    self.stderr)\nself.assertEqual(expected_msbuild_settings, actual_msbuild_settings)\nself._ExpectedWarnings([])\n",
        "CUT_1": "return True\n",
        "CUT_2": "\"\"\"Return true if the file is compilable (should be in OBJS).\"\"\"\nfor res in (filename.endswith(e) for e in COMPILABLE_EXTENSIONS):\n    if res:\n        return True\nreturn False\n",
        "CUT_3": "self.jira = JIRA('https://jira.atlassian.com', logging=False, async_=True,\n    validate=False, get_server_info=False)\n",
        "CUT_4": "\"\"\"Returns whether manifest should be linked into binary.\"\"\"\nconfig = self._TargetConfig(config)\nembed = self._Setting(('VCManifestTool', 'EmbedManifest'), config, default=\n    'true')\nreturn embed == 'true'\n",
        "CUT_5": "\"\"\"Returns true if any target contains the iOS specific key\n  IPHONEOS_DEPLOYMENT_TARGET.\"\"\"\nfor target_dict in targets.values():\n    for config in target_dict['configurations'].values():\n        if config.get('xcode_settings', {}).get('IPHONEOS_DEPLOYMENT_TARGET'):\n            return True\nreturn False\n"
    },
    {
        "functionName": "setUp",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/easy_xml_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.stderr = StringIO()\n",
        "CUT_1": "sys.stderr.write('%s\\n-----\\n' % filename)\nwith open(filename, 'rb') as f:\n    sys.stderr.write(f.read() + '\\n-----\\n')\n",
        "CUT_2": "try:\n    return gyp_main(args)\nexcept GypError as e:\n    sys.stderr.write('gyp: %s\\n' % e)\n    return 1\n",
        "CUT_3": "if len(sys.argv) < 2:\n    print(__doc__, file=sys.stderr)\n    print(file=sys.stderr)\n    print('usage: %s target1 target2...' % sys.argv[0], file=sys.stderr)\n    return 1\nedges = LoadEdges('dump.json', sys.argv[1:])\nWriteGraph(edges)\nreturn 0\n",
        "CUT_4": "\"\"\"Validates that the names of the settings are valid for MSVS.\n\n  Args:\n      settings: A dictionary.  The key is the tool name.  The values are\n          themselves dictionaries of settings and their values.\n      stderr: The stream receiving the error messages.\n  \"\"\"\n_ValidateSettings(_msvs_validators, settings, stderr)\n",
        "CUT_5": "\"\"\"Validates that the names of the settings are valid for MSBuild.\n\n  Args:\n      settings: A dictionary.  The key is the tool name.  The values are\n          themselves dictionaries of settings and their values.\n      stderr: The stream receiving the error messages.\n  \"\"\"\n_ValidateSettings(_msbuild_validators, settings, stderr)\n"
    },
    {
        "functionName": "test_EasyXml_simple",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/easy_xml_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.assertEqual(easy_xml.XmlToString(['test']),\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?><test/>')\nself.assertEqual(easy_xml.XmlToString(['test'], encoding='Windows-1252'),\n    '<?xml version=\"1.0\" encoding=\"Windows-1252\"?><test/>')\n",
        "CUT_1": "\"\"\"Writes the tool file.\"\"\"\ncontent = ['VisualStudioToolFile', {'Version': '8.00', 'Name': self.name},\n    self.rules_section]\neasy_xml.WriteXmlIfChanged(content, self.tool_file_path, encoding=\n    'Windows-1252')\n",
        "CUT_2": "\"\"\"Writes the user file.\"\"\"\nconfigs = ['Configurations']\nfor config, spec in sorted(self.configurations.items()):\n    configs.append(spec)\ncontent = ['VisualStudioUserFile', {'Version': self.version.ProjectVersion(\n    ), 'Name': self.name}, configs]\neasy_xml.WriteXmlIfChanged(content, self.user_file_path, encoding=\n    'Windows-1252')\n",
        "CUT_3": "\"\"\"Writes the project file.\"\"\"\ncontent = ['VisualStudioProject', {'ProjectType': 'Visual C++', 'Version':\n    self.version.ProjectVersion(), 'Name': self.name, 'ProjectGUID': self.\n    guid, 'RootNamespace': self.name, 'Keyword': 'Win32Proj'}, self.\n    platform_section, self.tool_files_section, self.configurations_section,\n    ['References'], self.files_section, ['Globals']]\neasy_xml.WriteXmlIfChanged(content, self.project_path, encoding='Windows-1252')\n",
        "CUT_4": "encoding = locale.getdefaultlocale()[1]\nif not encoding:\n    return False\ntry:\n    sys.setdefaultencoding(encoding)\nexcept AttributeError:\n    pass\ntextmap = {'cp936': '\u4e2d\u6587', 'cp1252': 'Lat\u012bna', 'cp932': '\u306b\u307b\u3093\u3054'}\nif encoding in textmap:\n    print(textmap[encoding])\nreturn True\n",
        "CUT_5": "\"\"\" Writes the XML content to disk, touching the file only if it has changed.\n\n  Visual Studio files have a lot of pre-defined structures.  This function makes\n  it easy to represent these structures as Python data structures, instead of\n  having to create a lot of function calls.\n\n  Each XML element of the content is represented as a list composed of:\n  1. The name of the element, a string,\n  2. The attributes of the element, a dictionary (optional), and\n  3+. The content of the element, if any.  Strings are simple text nodes and\n      lists are child elements.\n\n  Example 1:\n      <test/>\n  becomes\n      ['test']\n\n  Example 2:\n      <myelement a='value1' b='value2'>\n         <childtype>This is</childtype>\n         <childtype>it!</childtype>\n      </myelement>\n\n  becomes\n      ['myelement', {'a':'value1', 'b':'value2'},\n         ['childtype', 'This is'],\n         ['childtype', 'it!'],\n      ]\n\n  Args:\n    content:  The structured content to be converted.\n    encoding: The encoding to report on the first XML line.\n    pretty: True if we want pretty printing with indents and new lines.\n\n  Returns:\n    The XML content as a string.\n  \"\"\"\nxml_parts = ['<?xml version=\"1.0\" encoding=\"%s\"?>' % encoding]\nif pretty:\n    xml_parts.append('\\n')\n_ConstructContentList(xml_parts, content, pretty)\nreturn ''.join(xml_parts)\n"
    },
    {
        "functionName": "test_EasyXml_simple_with_attributes",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/easy_xml_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.assertEqual(easy_xml.XmlToString(['test2', {'a': 'value1', 'b':\n    'value2'}]),\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?><test2 a=\"value1\" b=\"value2\"/>')\n",
        "CUT_1": "if not node2.attributes:\n    return\nfor name, value2 in node2.attributes.items():\n    if name == 'Name':\n        continue\n    value1 = node1.getAttribute(name)\n    if value1:\n        if value1 != value2:\n            node1.setAttribute(name, ';'.join([value1, value2]))\n    else:\n        node1.setAttribute(name, value2)\n    if name == 'InheritedPropertySheets':\n        node1.removeAttribute(name)\n",
        "CUT_2": "\"\"\" Writes the XML content to disk, touching the file only if it has changed.\n\n  Visual Studio files have a lot of pre-defined structures.  This function makes\n  it easy to represent these structures as Python data structures, instead of\n  having to create a lot of function calls.\n\n  Each XML element of the content is represented as a list composed of:\n  1. The name of the element, a string,\n  2. The attributes of the element, a dictionary (optional), and\n  3+. The content of the element, if any.  Strings are simple text nodes and\n      lists are child elements.\n\n  Example 1:\n      <test/>\n  becomes\n      ['test']\n\n  Example 2:\n      <myelement a='value1' b='value2'>\n         <childtype>This is</childtype>\n         <childtype>it!</childtype>\n      </myelement>\n\n  becomes\n      ['myelement', {'a':'value1', 'b':'value2'},\n         ['childtype', 'This is'],\n         ['childtype', 'it!'],\n      ]\n\n  Args:\n    content:  The structured content to be converted.\n    encoding: The encoding to report on the first XML line.\n    pretty: True if we want pretty printing with indents and new lines.\n\n  Returns:\n    The XML content as a string.\n  \"\"\"\nxml_parts = ['<?xml version=\"1.0\" encoding=\"%s\"?>' % encoding]\nif pretty:\n    xml_parts.append('\\n')\n_ConstructContentList(xml_parts, content, pretty)\nreturn ''.join(xml_parts)\n",
        "CUT_3": "encoding = locale.getdefaultlocale()[1]\nif not encoding:\n    return False\ntry:\n    sys.setdefaultencoding(encoding)\nexcept AttributeError:\n    pass\ntextmap = {'cp936': '\u4e2d\u6587', 'cp1252': 'Lat\u012bna', 'cp932': '\u306b\u307b\u3093\u3054'}\nif encoding in textmap:\n    print(textmap[encoding])\nreturn True\n",
        "CUT_4": "\"\"\"Writes the tool file.\"\"\"\ncontent = ['VisualStudioToolFile', {'Version': '8.00', 'Name': self.name},\n    self.rules_section]\neasy_xml.WriteXmlIfChanged(content, self.tool_file_path, encoding=\n    'Windows-1252')\n",
        "CUT_5": "\"\"\" Writes the XML content to disk, touching the file only if it has changed.\n\n  Args:\n    content:  The structured content to be written.\n    path: Location of the file.\n    encoding: The encoding to report on the first line of the XML file.\n    pretty: True if we want pretty printing with indents and new lines.\n  \"\"\"\nxml_string = XmlToString(content, encoding, pretty)\nif win32 and os.linesep != '\\r\\n':\n    xml_string = xml_string.replace('\\n', '\\r\\n')\ndefault_encoding = locale.getdefaultlocale()[1]\nif default_encoding.upper() != encoding.upper():\n    xml_string = xml_string.encode(encoding)\ntry:\n    f = open(path, 'r')\n    existing = f.read()\n    f.close()\nexcept:\n    existing = None\nif existing != xml_string:\n    f = open(path, 'wb')\n    f.write(xml_string)\n    f.close()\n"
    },
    {
        "functionName": "test_EasyXml_escaping",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/easy_xml_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "original = '<test>\\'\"\\r&\\nfoo'\nconverted = \"&lt;test&gt;'&quot;&#xD;&amp;&#xA;foo\"\nconverted_apos = converted.replace(\"'\", '&apos;')\nself.assertEqual(easy_xml.XmlToString(['test3', {'a': original}, original]),\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?><test3 a=\"%s\">%s</test3>' % (\n    converted, converted_apos))\n",
        "CUT_1": "\"\"\"Writes datachars to writer.\"\"\"\ndata = data.replace('&', '&amp;').replace('<', '&lt;')\ndata = data.replace('\"', '&quot;').replace('>', '&gt;')\nif is_attrib:\n    data = data.replace('\\r', '&#xD;').replace('\\n', '&#xA;').replace('\\t',\n        '&#x9;')\nwriter.write(data)\n",
        "CUT_2": "\"\"\" Writes the XML content to disk, touching the file only if it has changed.\n\n  Visual Studio files have a lot of pre-defined structures.  This function makes\n  it easy to represent these structures as Python data structures, instead of\n  having to create a lot of function calls.\n\n  Each XML element of the content is represented as a list composed of:\n  1. The name of the element, a string,\n  2. The attributes of the element, a dictionary (optional), and\n  3+. The content of the element, if any.  Strings are simple text nodes and\n      lists are child elements.\n\n  Example 1:\n      <test/>\n  becomes\n      ['test']\n\n  Example 2:\n      <myelement a='value1' b='value2'>\n         <childtype>This is</childtype>\n         <childtype>it!</childtype>\n      </myelement>\n\n  becomes\n      ['myelement', {'a':'value1', 'b':'value2'},\n         ['childtype', 'This is'],\n         ['childtype', 'it!'],\n      ]\n\n  Args:\n    content:  The structured content to be converted.\n    encoding: The encoding to report on the first XML line.\n    pretty: True if we want pretty printing with indents and new lines.\n\n  Returns:\n    The XML content as a string.\n  \"\"\"\nxml_parts = ['<?xml version=\"1.0\" encoding=\"%s\"?>' % encoding]\nif pretty:\n    xml_parts.append('\\n')\n_ConstructContentList(xml_parts, content, pretty)\nreturn ''.join(xml_parts)\n",
        "CUT_3": "encoding = locale.getdefaultlocale()[1]\nif not encoding:\n    return False\ntry:\n    sys.setdefaultencoding(encoding)\nexcept AttributeError:\n    pass\ntextmap = {'cp936': '\u4e2d\u6587', 'cp1252': 'Lat\u012bna', 'cp932': '\u306b\u307b\u3093\u3054'}\nif encoding in textmap:\n    print(textmap[encoding])\nreturn True\n",
        "CUT_4": "\"\"\"Writes the tool file.\"\"\"\ncontent = ['VisualStudioToolFile', {'Version': '8.00', 'Name': self.name},\n    self.rules_section]\neasy_xml.WriteXmlIfChanged(content, self.tool_file_path, encoding=\n    'Windows-1252')\n",
        "CUT_5": "\"\"\" Writes the XML content to disk, touching the file only if it has changed.\n\n  Args:\n    content:  The structured content to be written.\n    path: Location of the file.\n    encoding: The encoding to report on the first line of the XML file.\n    pretty: True if we want pretty printing with indents and new lines.\n  \"\"\"\nxml_string = XmlToString(content, encoding, pretty)\nif win32 and os.linesep != '\\r\\n':\n    xml_string = xml_string.replace('\\n', '\\r\\n')\ndefault_encoding = locale.getdefaultlocale()[1]\nif default_encoding.upper() != encoding.upper():\n    xml_string = xml_string.encode(encoding)\ntry:\n    f = open(path, 'r')\n    existing = f.read()\n    f.close()\nexcept:\n    existing = None\nif existing != xml_string:\n    f = open(path, 'wb')\n    f.write(xml_string)\n    f.close()\n"
    },
    {
        "functionName": "test_EasyXml_pretty",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/easy_xml_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.assertEqual(easy_xml.XmlToString(['test3', ['GrandParent', ['Parent1',\n    ['Child']], ['Parent2']]], pretty=True),\n    \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<test3>\n  <GrandParent>\n    <Parent1>\n      <Child/>\n    </Parent1>\n    <Parent2/>\n  </GrandParent>\n</test3>\n\"\"\"\n    )\n",
        "CUT_1": "for child in node.dependents:\n    if child in path:\n        results.append([child] + path[:path.index(child) + 1])\n    elif not child in visited:\n        visited.add(child)\n        Visit(child, [child] + path)\n",
        "CUT_2": "self.AppendProperty('children', child)\nself._AddChildToDicts(child)\n",
        "CUT_3": "if not 'children' in self._properties:\n    return None\nfor child in self._properties['children']:\n    if child.Name() == name:\n        return child\nreturn None\n",
        "CUT_4": "\"\"\"\n    Returns a list of cycles in the graph, where each cycle is its own list.\n    \"\"\"\nresults = []\nvisited = set()\ndef Visit(node, path):\n    for child in node.dependents:\n        if child in path:\n            results.append([child] + path[:path.index(child) + 1])\n        elif not child in visited:\n            visited.add(child)\n            Visit(child, [child] + path)\nvisited.add(self)\nVisit(self, [self])\nreturn results\n",
        "CUT_5": "if not 'children' in self._properties:\n    return None\nfor child in self._properties['children']:\n    if not isinstance(child, PBXReferenceProxy):\n        continue\n    container_proxy = child._properties['remoteRef']\n    if container_proxy._properties['remoteGlobalIDString'] == remote_object:\n        return child\nreturn None\n"
    },
    {
        "functionName": "test_EasyXml_complex",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/easy_xml_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "target = (\n    '<?xml version=\"1.0\" encoding=\"utf-8\"?><Project><PropertyGroup Label=\"Globals\"><ProjectGuid>{D2250C20-3A94-4FB9-AF73-11BC5B73884B}</ProjectGuid><Keyword>Win32Proj</Keyword><RootNamespace>automated_ui_tests</RootNamespace></PropertyGroup><Import Project=\"$(VCTargetsPath)\\\\Microsoft.Cpp.props\"/><PropertyGroup Condition=\"\\'$(Configuration)|$(Platform)\\'==\\'Debug|Win32\\'\" Label=\"Configuration\"><ConfigurationType>Application</ConfigurationType><CharacterSet>Unicode</CharacterSet></PropertyGroup></Project>'\n    )\nxml = easy_xml.XmlToString(['Project', ['PropertyGroup', {'Label':\n    'Globals'}, ['ProjectGuid', '{D2250C20-3A94-4FB9-AF73-11BC5B73884B}'],\n    ['Keyword', 'Win32Proj'], ['RootNamespace', 'automated_ui_tests']], [\n    'Import', {'Project': '$(VCTargetsPath)\\\\Microsoft.Cpp.props'}], [\n    'PropertyGroup', {'Condition':\n    \"'$(Configuration)|$(Platform)'=='Debug|Win32'\", 'Label':\n    'Configuration'}, ['ConfigurationType', 'Application'], ['CharacterSet',\n    'Unicode']]])\nself.assertEqual(xml, target)\n",
        "CUT_1": "\"\"\"Returns a PropertyGroup definition for the specified properties.\n\n  Arguments:\n    spec: The target project dict.\n    label: An optional label for the PropertyGroup.\n    properties: The dictionary to be converted.  The key is the name of the\n        property.  The value is itself a dictionary; its key is the value and\n        the value a list of condition for which this value is true.\n  \"\"\"\ngroup = ['PropertyGroup']\nif label:\n    group.append({'Label': label})\nnum_configurations = len(spec['configurations'])\ndef GetEdges(node):\n    edges = set()\n    for value in sorted(properties[node].keys()):\n        edges.update(set([v for v in MSVS_VARIABLE_REFERENCE.findall(value) if\n            v in properties and v != node]))\n    return edges\nproperties_ordered = gyp.common.TopologicallySorted(properties.keys(), GetEdges\n    )\nfor name in reversed(properties_ordered):\n    values = properties[name]\n    for value, conditions in sorted(values.items()):\n        if len(conditions) == num_configurations:\n            group.append([name, value])\n        else:\n            for condition in conditions:\n                group.append([name, {'Condition': condition}, value])\nreturn [group]\n",
        "CUT_2": "\"\"\"Writes the project file.\"\"\"\ncontent = ['VisualStudioProject', {'ProjectType': 'Visual C++', 'Version':\n    self.version.ProjectVersion(), 'Name': self.name, 'ProjectGUID': self.\n    guid, 'RootNamespace': self.name, 'Keyword': 'Win32Proj'}, self.\n    platform_section, self.tool_files_section, self.configurations_section,\n    ['References'], self.files_section, ['Globals']]\neasy_xml.WriteXmlIfChanged(content, self.project_path, encoding='Windows-1252')\n",
        "CUT_3": "user_props = '$(UserRootDir)\\\\Microsoft.Cpp.$(Platform).user.props'\nadditional_props = {}\nprops_specified = False\nfor name, settings in sorted(configurations.items()):\n    configuration = _GetConfigurationCondition(name, settings)\n    if 'msbuild_props' in settings:\n        additional_props[configuration] = _FixPaths(settings['msbuild_props'])\n        props_specified = True\n    else:\n        additional_props[configuration] = ''\nif not props_specified:\n    return [['ImportGroup', {'Label': 'PropertySheets'}, ['Import', {\n        'Project': user_props, 'Condition': \"exists('%s')\" % user_props,\n        'Label': 'LocalAppDataPlatform'}]]]\nelse:\n    sheets = []\n    for condition, props in additional_props.items():\n        import_group = ['ImportGroup', {'Label': 'PropertySheets',\n            'Condition': condition}, ['Import', {'Project': user_props,\n            'Condition': \"exists('%s')\" % user_props, 'Label':\n            'LocalAppDataPlatform'}]]\n        for props_file in props:\n            import_group.append(['Import', {'Project': props_file}])\n        sheets.append(import_group)\n    return sheets\n",
        "CUT_4": "spec = project.spec\nconfigurations = spec['configurations']\nproject_dir, project_file_name = os.path.split(project.path)\ngyp.common.EnsureDirExists(project.path)\ngyp_path = _NormalizedSource(project.build_file)\nrelative_path_of_gyp_file = gyp.common.RelativePath(gyp_path, project_dir)\ngyp_file = os.path.split(project.build_file)[1]\nsources, excluded_sources = _PrepareListOfSources(spec, generator_flags,\n    gyp_file)\nactions_to_add = {}\nprops_files_of_rules = set()\ntargets_files_of_rules = set()\nrule_dependencies = set()\nextension_to_rule_name = {}\nlist_excluded = generator_flags.get('msvs_list_excluded_files', True)\nif not spec.get('msvs_external_builder'):\n    _GenerateRulesForMSBuild(project_dir, options, spec, sources,\n        excluded_sources, props_files_of_rules, targets_files_of_rules,\n        actions_to_add, rule_dependencies, extension_to_rule_name)\nelse:\n    rules = spec.get('rules', [])\n    _AdjustSourcesForRules(rules, sources, excluded_sources, True)\nsources, excluded_sources, excluded_idl = (\n    _AdjustSourcesAndConvertToFilterHierarchy(spec, options, project_dir,\n    sources, excluded_sources, list_excluded, version))\nif not spec.get('msvs_external_builder'):\n    _AddActions(actions_to_add, spec, project.build_file)\n    _AddCopies(actions_to_add, spec)\n    excluded_sources = _FilterActionsFromExcluded(excluded_sources,\n        actions_to_add)\nexclusions = _GetExcludedFilesFromBuild(spec, excluded_sources, excluded_idl)\nactions_spec, sources_handled_by_action = _GenerateActionsForMSBuild(spec,\n    actions_to_add)\n_GenerateMSBuildFiltersFile(project.path + '.filters', sources,\n    rule_dependencies, extension_to_rule_name, _GetUniquePlatforms(spec))\nmissing_sources = _VerifySourcesExist(sources, project_dir)\nfor configuration in configurations.values():\n    _FinalizeMSBuildSettings(spec, configuration)\nimport_default_section = [['Import', {'Project':\n    '$(VCTargetsPath)\\\\Microsoft.Cpp.Default.props'}]]\nimport_cpp_props_section = [['Import', {'Project':\n    '$(VCTargetsPath)\\\\Microsoft.Cpp.props'}]]\nimport_cpp_targets_section = [['Import', {'Project':\n    '$(VCTargetsPath)\\\\Microsoft.Cpp.targets'}]]\nimport_masm_props_section = [['Import', {'Project':\n    '$(VCTargetsPath)\\\\BuildCustomizations\\\\masm.props'}]]\nimport_masm_targets_section = [['Import', {'Project':\n    '$(VCTargetsPath)\\\\BuildCustomizations\\\\masm.targets'}]]\nimport_marmasm_props_section = [['Import', {'Project':\n    '$(VCTargetsPath)\\\\BuildCustomizations\\\\marmasm.props'}]]\nimport_marmasm_targets_section = [['Import', {'Project':\n    '$(VCTargetsPath)\\\\BuildCustomizations\\\\marmasm.targets'}]]\nmacro_section = [['PropertyGroup', {'Label': 'UserMacros'}]]\ncontent = ['Project', {'xmlns':\n    'http://schemas.microsoft.com/developer/msbuild/2003', 'ToolsVersion':\n    version.ProjectVersion(), 'DefaultTargets': 'Build'}]\ncontent += _GetMSBuildProjectConfigurations(configurations)\ncontent += _GetMSBuildGlobalProperties(spec, project.guid, project_file_name)\ncontent += import_default_section\ncontent += _GetMSBuildConfigurationDetails(spec, project.build_file)\nif spec.get('msvs_enable_winphone'):\n    content += _GetMSBuildLocalProperties('v120_wp81')\nelse:\n    content += _GetMSBuildLocalProperties(project.msbuild_toolset)\ncontent += import_cpp_props_section\ncontent += import_masm_props_section\nif spec.get('msvs_enable_marmasm'):\n    content += import_marmasm_props_section\ncontent += _GetMSBuildExtensions(props_files_of_rules)\ncontent += _GetMSBuildPropertySheets(configurations)\ncontent += macro_section\ncontent += _GetMSBuildConfigurationGlobalProperties(spec, configurations,\n    project.build_file)\ncontent += _GetMSBuildToolSettingsSections(spec, configurations)\ncontent += _GetMSBuildSources(spec, sources, exclusions, rule_dependencies,\n    extension_to_rule_name, actions_spec, sources_handled_by_action,\n    list_excluded)\ncontent += _GetMSBuildProjectReferences(project)\ncontent += import_cpp_targets_section\ncontent += import_masm_targets_section\nif spec.get('msvs_enable_marmasm'):\n    content += import_marmasm_targets_section\ncontent += _GetMSBuildExtensionTargets(targets_files_of_rules)\nif spec.get('msvs_external_builder'):\n    content += _GetMSBuildExternalBuilderTargets(spec)\neasy_xml.WriteXmlIfChanged(content, project.path, pretty=True, win32=True)\nreturn missing_sources\n",
        "CUT_5": "configuration = name.rsplit('_', 1)[0]\nplatform = settings.get('msvs_configuration_platform', 'Win32')\nreturn configuration, platform\n"
    },
    {
        "functionName": "setUp",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/generator/msvs_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.stderr = StringIO()\n",
        "CUT_1": "sys.stderr.write('%s\\n-----\\n' % filename)\nwith open(filename, 'rb') as f:\n    sys.stderr.write(f.read() + '\\n-----\\n')\n",
        "CUT_2": "try:\n    return gyp_main(args)\nexcept GypError as e:\n    sys.stderr.write('gyp: %s\\n' % e)\n    return 1\n",
        "CUT_3": "if len(sys.argv) < 2:\n    print(__doc__, file=sys.stderr)\n    print(file=sys.stderr)\n    print('usage: %s target1 target2...' % sys.argv[0], file=sys.stderr)\n    return 1\nedges = LoadEdges('dump.json', sys.argv[1:])\nWriteGraph(edges)\nreturn 0\n",
        "CUT_4": "\"\"\"Validates that the names of the settings are valid for MSVS.\n\n  Args:\n      settings: A dictionary.  The key is the tool name.  The values are\n          themselves dictionaries of settings and their values.\n      stderr: The stream receiving the error messages.\n  \"\"\"\n_ValidateSettings(_msvs_validators, settings, stderr)\n",
        "CUT_5": "\"\"\"Validates that the names of the settings are valid for MSBuild.\n\n  Args:\n      settings: A dictionary.  The key is the tool name.  The values are\n          themselves dictionaries of settings and their values.\n      stderr: The stream receiving the error messages.\n  \"\"\"\n_ValidateSettings(_msbuild_validators, settings, stderr)\n"
    },
    {
        "functionName": "test_GetLibraries",
        "className": "TestSequenceFunctions",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/generator/msvs_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.assertEqual(msvs._GetLibraries({}), [])\nself.assertEqual(msvs._GetLibraries({'libraries': []}), [])\nself.assertEqual(msvs._GetLibraries({'other': 'foo', 'libraries': ['a.lib']\n    }), ['a.lib'])\nself.assertEqual(msvs._GetLibraries({'libraries': ['-la']}), ['a.lib'])\nself.assertEqual(msvs._GetLibraries({'libraries': ['a.lib', 'b.lib',\n    'c.lib', '-lb.lib', '-lb.lib', 'd.lib', 'a.lib']}), ['c.lib', 'b.lib',\n    'd.lib', 'a.lib'])\n",
        "CUT_1": "\"\"\"Strip -l from library if it's specified with that.\"\"\"\nlibs = [(lib[2:] if lib.startswith('-l') else lib) for lib in libraries]\nreturn [(lib + '.lib' if not lib.endswith('.lib') else lib) for lib in libs]\n",
        "CUT_2": "return self.spec.get('product_prefix', {'executable': '', 'static_library':\n    'lib', 'shared_library': 'lib', 'loadable_module': ''}[self.spec['type']])\n",
        "CUT_3": "\"\"\"Filter the 'libraries' key to separate things that shouldn't be ldflags.\n\n    Library entries that look like filenames should be converted to android\n    module names instead of being passed to the linker as flags.\n\n    Args:\n      libraries: the value of spec.get('libraries')\n    Returns:\n      A tuple (static_lib_modules, dynamic_lib_modules, ldflags)\n    \"\"\"\nstatic_lib_modules = []\ndynamic_lib_modules = []\nldflags = []\nfor libs in libraries:\n    for lib in libs.split():\n        if lib == '-lc' or lib == '-lstdc++' or lib == '-lm' or lib.endswith(\n            'libgcc.a'):\n            continue\n        match = re.search('([^/]+)\\\\.a$', lib)\n        if match:\n            static_lib_modules.append(match.group(1))\n            continue\n        match = re.search('([^/]+)\\\\.so$', lib)\n        if match:\n            dynamic_lib_modules.append(match.group(1))\n            continue\n        if lib.startswith('-l'):\n            ldflags.append(lib)\nreturn static_lib_modules, dynamic_lib_modules, ldflags\n",
        "CUT_4": "\"\"\"Returns the flags that need to be added to lib commands.\"\"\"\nconfig = self._TargetConfig(config)\nlibflags = []\nlib = self._GetWrapper(self, self.msvs_settings[config], 'VCLibrarianTool',\n    append=libflags)\nlibflags.extend(self._GetAdditionalLibraryDirectories('VCLibrarianTool',\n    config, gyp_to_build_path))\nlib('LinkTimeCodeGeneration', map={'true': '/LTCG'})\nlib('TargetMachine', map={'1': 'X86', '17': 'X64', '3': 'ARM'}, prefix=\n    '/MACHINE:')\nlib('AdditionalOptions')\nreturn libflags\n",
        "CUT_5": "\"\"\"Return the 'output basename' of a gyp spec.\n\n    E.g., the loadable module 'foobar' in directory 'baz' will produce\n      'libfoobar.so'\n    \"\"\"\nassert not self.is_mac_bundle\nif self.flavor == 'mac' and self.type in ('static_library', 'executable',\n    'shared_library', 'loadable_module'):\n    return self.xcode_settings.GetExecutablePath()\ntarget = spec['target_name']\ntarget_prefix = ''\ntarget_ext = ''\nif self.type == 'static_library':\n    if target[:3] == 'lib':\n        target = target[3:]\n    target_prefix = 'lib'\n    target_ext = '.a'\nelif self.type in ('loadable_module', 'shared_library'):\n    if target[:3] == 'lib':\n        target = target[3:]\n    target_prefix = 'lib'\n    if self.flavor == 'aix':\n        target_ext = '.a'\n    else:\n        target_ext = '.so'\nelif self.type == 'none':\n    target = '%s.stamp' % target\nelif self.type != 'executable':\n    print('ERROR: What output file should be generated?', 'type', self.type,\n        'target', target)\ntarget_prefix = spec.get('product_prefix', target_prefix)\ntarget = spec.get('product_name', target)\nproduct_ext = spec.get('product_extension')\nif product_ext:\n    target_ext = '.' + product_ext\nreturn target_prefix + target + target_ext\n"
    },
    {
        "functionName": "test_BinaryNamesWindows",
        "className": "TestPrefixesAndSuffixes",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/generator/ninja_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "if sys.platform.startswith('win'):\n    writer = ninja.NinjaWriter('foo', 'wee', '.', '.', 'build.ninja', '.',\n        'build.ninja', 'win')\n    spec = {'target_name': 'wee'}\n    self.assertTrue(writer.ComputeOutputFileName(spec, 'executable').\n        endswith('.exe'))\n    self.assertTrue(writer.ComputeOutputFileName(spec, 'shared_library').\n        endswith('.dll'))\n    self.assertTrue(writer.ComputeOutputFileName(spec, 'static_library').\n        endswith('.lib'))\n",
        "CUT_1": "writer.write(indent + '<' + self.tagName)\nattrs = self._get_attributes()\na_names = attrs.keys()\na_names.sort()\nfor a_name in a_names:\n    writer.write(' %s=\"' % a_name)\n    _Replacement_write_data(writer, attrs[a_name].value, is_attrib=True)\n    writer.write('\"')\nif self.childNodes:\n    writer.write('>%s' % newl)\n    for node in self.childNodes:\n        node.writexml(writer, indent + addindent, addindent, newl)\n    writer.write('%s</%s>%s' % (indent, self.tagName, newl))\nelse:\n    writer.write('/>%s' % newl)\n",
        "CUT_2": "return self.spec.get('product_prefix', {'executable': '', 'static_library':\n    'lib', 'shared_library': 'lib', 'loadable_module': ''}[self.spec['type']])\n",
        "CUT_3": "extensions = sorted(COMPILABLE_EXTENSIONS.keys(), key=str.lower)\nwriter.write('# Suffix rules, putting all outputs into $(obj).\\n')\nfor ext in extensions:\n    writer.write('$(obj).$(TOOLSET)/%%.o: $(srcdir)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\nwriter.write(\"\"\"\n# Try building from generated source, too.\n\"\"\")\nfor ext in extensions:\n    writer.write(\n        '$(obj).$(TOOLSET)/%%.o: $(obj).$(TOOLSET)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\nwriter.write('\\n')\nfor ext in extensions:\n    writer.write('$(obj).$(TOOLSET)/%%.o: $(obj)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\nwriter.write('\\n')\n",
        "CUT_4": "if 'product_extension' in self.spec:\n    return '.' + self.spec['product_extension']\nreturn {'executable': '', 'static_library': '.a', 'shared_library':\n    '.dylib', 'loadable_module': '.so'}[self.spec['type']]\n",
        "CUT_5": "\"\"\"Write build rules to compile all of |sources|.\"\"\"\nif self.toolset == 'host':\n    self.ninja.variable('ar', '$ar_host')\n    self.ninja.variable('cc', '$cc_host')\n    self.ninja.variable('cxx', '$cxx_host')\n    self.ninja.variable('ld', '$ld_host')\n    self.ninja.variable('ldxx', '$ldxx_host')\n    self.ninja.variable('nm', '$nm_host')\n    self.ninja.variable('readelf', '$readelf_host')\nif self.flavor != 'mac' or len(self.archs) == 1:\n    return self.WriteSourcesForArch(self.ninja, config_name, config,\n        sources, predepends, precompiled_header, spec)\nelse:\n    return dict((arch, self.WriteSourcesForArch(self.arch_subninjas[arch],\n        config_name, config, sources, predepends, precompiled_header, spec,\n        arch=arch)) for arch in self.archs)\n"
    },
    {
        "functionName": "test_BinaryNamesLinux",
        "className": "TestPrefixesAndSuffixes",
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/generator/ninja_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "writer = ninja.NinjaWriter('foo', 'wee', '.', '.', 'build.ninja', '.',\n    'build.ninja', 'linux')\nspec = {'target_name': 'wee'}\nself.assertTrue('.' not in writer.ComputeOutputFileName(spec, 'executable'))\nself.assertTrue(writer.ComputeOutputFileName(spec, 'shared_library').\n    startswith('lib'))\nself.assertTrue(writer.ComputeOutputFileName(spec, 'static_library').\n    startswith('lib'))\nself.assertTrue(writer.ComputeOutputFileName(spec, 'shared_library').\n    endswith('.so'))\nself.assertTrue(writer.ComputeOutputFileName(spec, 'static_library').\n    endswith('.a'))\n",
        "CUT_1": "return self.spec.get('product_prefix', {'executable': '', 'static_library':\n    'lib', 'shared_library': 'lib', 'loadable_module': ''}[self.spec['type']])\n",
        "CUT_2": "writer.write(indent + '<' + self.tagName)\nattrs = self._get_attributes()\na_names = attrs.keys()\na_names.sort()\nfor a_name in a_names:\n    writer.write(' %s=\"' % a_name)\n    _Replacement_write_data(writer, attrs[a_name].value, is_attrib=True)\n    writer.write('\"')\nif self.childNodes:\n    writer.write('>%s' % newl)\n    for node in self.childNodes:\n        node.writexml(writer, indent + addindent, addindent, newl)\n    writer.write('%s</%s>%s' % (indent, self.tagName, newl))\nelse:\n    writer.write('/>%s' % newl)\n",
        "CUT_3": "extensions = sorted(COMPILABLE_EXTENSIONS.keys(), key=str.lower)\nwriter.write('# Suffix rules, putting all outputs into $(obj).\\n')\nfor ext in extensions:\n    writer.write('$(obj).$(TOOLSET)/%%.o: $(srcdir)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\nwriter.write(\"\"\"\n# Try building from generated source, too.\n\"\"\")\nfor ext in extensions:\n    writer.write(\n        '$(obj).$(TOOLSET)/%%.o: $(obj).$(TOOLSET)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\nwriter.write('\\n')\nfor ext in extensions:\n    writer.write('$(obj).$(TOOLSET)/%%.o: $(obj)/%%%s FORCE_DO_CMD\\n' % ext)\n    writer.write('\\t@$(call do_cmd,%s,1)\\n' % COMPILABLE_EXTENSIONS[ext])\nwriter.write('\\n')\n",
        "CUT_4": "if 'product_extension' in self.spec:\n    return '.' + self.spec['product_extension']\nreturn {'executable': '', 'static_library': '.a', 'shared_library':\n    '.dylib', 'loadable_module': '.so'}[self.spec['type']]\n",
        "CUT_5": "\"\"\"Returns the name of the non-bundle binary represented by this target.\n    E.g. hello_world. Only valid for non-bundles.\"\"\"\nassert not self._IsBundle()\nassert self.spec['type'] in ('executable', 'shared_library',\n    'static_library', 'loadable_module'), 'Unexpected type %s' % self.spec[\n    'type']\ntarget = self.spec['target_name']\nif self.spec['type'] == 'static_library':\n    if target[:3] == 'lib':\n        target = target[3:]\nelif self.spec['type'] in ('loadable_module', 'shared_library'):\n    if target[:3] == 'lib':\n        target = target[3:]\ntarget_prefix = self._GetStandaloneExecutablePrefix()\ntarget = self.spec.get('product_name', target)\ntarget_ext = self._GetStandaloneExecutableSuffix()\nreturn target_prefix + target + target_ext\n"
    },
    {
        "functionName": "test_InheritedRemainsUnescaped",
        "className": null,
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/generator/xcode_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.assertEqual(xcode.EscapeXcodeDefine('$(inherited)'), '$(inherited)')\n",
        "CUT_1": "\"\"\"We must escape the defines that we give to XCode so that it knows not to\n     split on spaces and to respect backslash and quote literals. However, we\n     must not quote the define, or Xcode will incorrectly intepret variables\n     especially $(inherited).\"\"\"\nreturn re.sub(_xcode_define_re, '\\\\\\\\\\\\1', s)\n",
        "CUT_2": "\"\"\"Returns flags that need to be added to .cc, and .mm compilations.\"\"\"\nself.configname = configname\ncflags_cc = []\nclang_cxx_language_standard = self._Settings().get(\n    'CLANG_CXX_LANGUAGE_STANDARD')\nif clang_cxx_language_standard:\n    cflags_cc.append('-std=%s' % clang_cxx_language_standard)\nself._Appendf(cflags_cc, 'CLANG_CXX_LIBRARY', '-stdlib=%s')\nif self._Test('GCC_ENABLE_CPP_RTTI', 'NO', default='YES'):\n    cflags_cc.append('-fno-rtti')\nif self._Test('GCC_ENABLE_CPP_EXCEPTIONS', 'NO', default='YES'):\n    cflags_cc.append('-fno-exceptions')\nif self._Test('GCC_INLINES_ARE_PRIVATE_EXTERN', 'YES', default='NO'):\n    cflags_cc.append('-fvisibility-inlines-hidden')\nif self._Test('GCC_THREADSAFE_STATICS', 'NO', default='YES'):\n    cflags_cc.append('-fno-threadsafe-statics')\nif self._Test('GCC_WARN_ABOUT_INVALID_OFFSETOF_MACRO', 'NO', default='YES'):\n    cflags_cc.append('-Wno-invalid-offsetof')\nother_ccflags = []\nfor flag in self._Settings().get('OTHER_CPLUSPLUSFLAGS', ['$(inherited)']):\n    if flag in ('$inherited', '$(inherited)', '${inherited}'):\n        flag = '$OTHER_CFLAGS'\n    if flag in ('$OTHER_CFLAGS', '$(OTHER_CFLAGS)', '${OTHER_CFLAGS}'):\n        other_ccflags += self._Settings().get('OTHER_CFLAGS', [])\n    else:\n        other_ccflags.append(flag)\ncflags_cc += other_ccflags\nself.configname = None\nreturn cflags_cc\n",
        "CUT_3": "\"\"\"Returns the |XcodeArchsDefault| object to use to expand ARCHS for the\n  installed version of Xcode. The default values used by Xcode for ARCHS\n  and the expansion of the variables depends on the version of Xcode used.\n\n  For all version anterior to Xcode 5.0 or posterior to Xcode 5.1 included\n  uses $(ARCHS_STANDARD) if ARCHS is unset, while Xcode 5.0 to 5.0.2 uses\n  $(ARCHS_STANDARD_INCLUDING_64_BIT). This variable was added to Xcode 5.0\n  and deprecated with Xcode 5.1.\n\n  For \"macosx\" SDKROOT, all version starting with Xcode 5.0 includes 64-bit\n  architecture as part of $(ARCHS_STANDARD) and default to only building it.\n\n  For \"iphoneos\" and \"iphonesimulator\" SDKROOT, 64-bit architectures are part\n  of $(ARCHS_STANDARD_INCLUDING_64_BIT) from Xcode 5.0. From Xcode 5.1, they\n  are also part of $(ARCHS_STANDARD).\n\n  All thoses rules are coded in the construction of the |XcodeArchsDefault|\n  object to use depending on the version of Xcode detected. The object is\n  for performance reason.\"\"\"\nglobal XCODE_ARCHS_DEFAULT_CACHE\nif XCODE_ARCHS_DEFAULT_CACHE:\n    return XCODE_ARCHS_DEFAULT_CACHE\nxcode_version, _ = XcodeVersion()\nif xcode_version < '0500':\n    XCODE_ARCHS_DEFAULT_CACHE = XcodeArchsDefault('$(ARCHS_STANDARD)',\n        XcodeArchsVariableMapping(['i386']), XcodeArchsVariableMapping([\n        'i386']), XcodeArchsVariableMapping(['armv7']))\nelif xcode_version < '0510':\n    XCODE_ARCHS_DEFAULT_CACHE = XcodeArchsDefault(\n        '$(ARCHS_STANDARD_INCLUDING_64_BIT)', XcodeArchsVariableMapping([\n        'x86_64'], ['x86_64']), XcodeArchsVariableMapping(['i386'], ['i386',\n        'x86_64']), XcodeArchsVariableMapping(['armv7', 'armv7s'], ['armv7',\n        'armv7s', 'arm64']))\nelse:\n    XCODE_ARCHS_DEFAULT_CACHE = XcodeArchsDefault('$(ARCHS_STANDARD)',\n        XcodeArchsVariableMapping(['x86_64'], ['x86_64']),\n        XcodeArchsVariableMapping(['i386', 'x86_64'], ['i386', 'x86_64']),\n        XcodeArchsVariableMapping(['armv7', 'armv7s', 'arm64'], ['armv7',\n        'armv7s', 'arm64']))\nreturn XCODE_ARCHS_DEFAULT_CACHE\n",
        "CUT_4": "\"\"\"Encodes a comment to be placed in the project file output, mimicing\n    Xcode behavior.\n    \"\"\"\nreturn '/* ' + comment.replace('*/', '(*)/') + ' */'\n",
        "CUT_5": "return self\n"
    },
    {
        "functionName": "test_Escaping",
        "className": null,
        "fileName": "/node_modules/npm/node_modules/node-gyp/gyp/pylib/gyp/generator/xcode_test.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.assertEqual(xcode.EscapeXcodeDefine('a b\"c\\\\'), 'a\\\\ b\\\\\"c\\\\\\\\')\n",
        "CUT_1": "\"\"\"Returns the |XcodeArchsDefault| object to use to expand ARCHS for the\n  installed version of Xcode. The default values used by Xcode for ARCHS\n  and the expansion of the variables depends on the version of Xcode used.\n\n  For all version anterior to Xcode 5.0 or posterior to Xcode 5.1 included\n  uses $(ARCHS_STANDARD) if ARCHS is unset, while Xcode 5.0 to 5.0.2 uses\n  $(ARCHS_STANDARD_INCLUDING_64_BIT). This variable was added to Xcode 5.0\n  and deprecated with Xcode 5.1.\n\n  For \"macosx\" SDKROOT, all version starting with Xcode 5.0 includes 64-bit\n  architecture as part of $(ARCHS_STANDARD) and default to only building it.\n\n  For \"iphoneos\" and \"iphonesimulator\" SDKROOT, 64-bit architectures are part\n  of $(ARCHS_STANDARD_INCLUDING_64_BIT) from Xcode 5.0. From Xcode 5.1, they\n  are also part of $(ARCHS_STANDARD).\n\n  All thoses rules are coded in the construction of the |XcodeArchsDefault|\n  object to use depending on the version of Xcode detected. The object is\n  for performance reason.\"\"\"\nglobal XCODE_ARCHS_DEFAULT_CACHE\nif XCODE_ARCHS_DEFAULT_CACHE:\n    return XCODE_ARCHS_DEFAULT_CACHE\nxcode_version, _ = XcodeVersion()\nif xcode_version < '0500':\n    XCODE_ARCHS_DEFAULT_CACHE = XcodeArchsDefault('$(ARCHS_STANDARD)',\n        XcodeArchsVariableMapping(['i386']), XcodeArchsVariableMapping([\n        'i386']), XcodeArchsVariableMapping(['armv7']))\nelif xcode_version < '0510':\n    XCODE_ARCHS_DEFAULT_CACHE = XcodeArchsDefault(\n        '$(ARCHS_STANDARD_INCLUDING_64_BIT)', XcodeArchsVariableMapping([\n        'x86_64'], ['x86_64']), XcodeArchsVariableMapping(['i386'], ['i386',\n        'x86_64']), XcodeArchsVariableMapping(['armv7', 'armv7s'], ['armv7',\n        'armv7s', 'arm64']))\nelse:\n    XCODE_ARCHS_DEFAULT_CACHE = XcodeArchsDefault('$(ARCHS_STANDARD)',\n        XcodeArchsVariableMapping(['x86_64'], ['x86_64']),\n        XcodeArchsVariableMapping(['i386', 'x86_64'], ['i386', 'x86_64']),\n        XcodeArchsVariableMapping(['armv7', 'armv7s', 'arm64'], ['armv7',\n        'armv7s', 'arm64']))\nreturn XCODE_ARCHS_DEFAULT_CACHE\n",
        "CUT_2": "\"\"\"Encodes a comment to be placed in the project file output, mimicing\n    Xcode behavior.\n    \"\"\"\nreturn '/* ' + comment.replace('*/', '(*)/') + ' */'\n",
        "CUT_3": "\"\"\"We must escape the defines that we give to XCode so that it knows not to\n     split on spaces and to respect backslash and quote literals. However, we\n     must not quote the define, or Xcode will incorrectly intepret variables\n     especially $(inherited).\"\"\"\nreturn re.sub(_xcode_define_re, '\\\\\\\\\\\\1', s)\n",
        "CUT_4": "return self\n",
        "CUT_5": "\"\"\"Encodes a string to be placed in the project file output, mimicing\n    Xcode behavior.\n    \"\"\"\nif _unquoted.search(value) and not _quoted.search(value):\n    return value\nreturn '\"' + _escaped.sub(self._EncodeTransform, value) + '\"'\n"
    },
    {
        "functionName": "test_universal_find_existing_resource",
        "className": "UniversalResourceTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "resource = self.jira.find('issue/{0}', self.test_manager.project_b_issue1)\nissue = self.jira.issue(self.test_manager.project_b_issue1)\nself.assertEqual(resource.self, issue.self)\nself.assertEqual(resource.key, issue.key)\n",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_normal\nself.issue_1 = self.test_manager.project_b_issue1\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue1\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.attachment = None\n"
    },
    {
        "functionName": "test_find_invalid_resource_raises_exception",
        "className": "UniversalResourceTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "with self.assertRaises(JIRAError) as cm:\n    self.jira.find('woopsydoodle/{0}', '666')\nex = cm.exception\nassert ex.status_code in [400, 404]\nself.assertIsNotNone(ex.text)\nself.assertRegex(ex.url, '^https?://.*/rest/api/(2|latest)/woopsydoodle/666$')\n",
        "CUT_1": "\"\"\"Return a string representation of the error.\n\n        :rtype: str\n        \"\"\"\nt = 'JiraError HTTP %s' % self.status_code\nif self.url:\n    t += ' url: %s' % self.url\ndetails = ''\nif self.request is not None and hasattr(self.request, 'headers'):\n    details += '\\n\\trequest headers = %s' % self.request.headers\nif self.request is not None and hasattr(self.request, 'text'):\n    details += '\\n\\trequest text = %s' % self.request.text\nif self.response is not None and hasattr(self.response, 'headers'):\n    details += '\\n\\tresponse headers = %s' % self.response.headers\nif self.response is not None and hasattr(self.response, 'text'):\n    details += '\\n\\tresponse text = %s' % self.response.text\nif self.travis:\n    if self.text:\n        t += '\\n\\ttext: %s' % self.text\n    t += details\nelif self.log_to_tempfile:\n    fd, file_name = tempfile.mkstemp(suffix='.tmp', prefix='jiraerror-')\n    with open(file_name, 'w') as f:\n        t += ' details: %s' % file_name\n        f.write(details)\nelse:\n    if self.text:\n        t += '\\n\\ttext: %s' % self.text\n    t += '\\n\\t' + details\nreturn t\n",
        "CUT_2": "\"\"\"Return a string representation of the error.\n\n        :rtype: str\n        \"\"\"\nt = 'JiraError HTTP %s' % self.status_code\nif self.url:\n    t += ' url: %s' % self.url\ndetails = ''\nif self.request is not None and hasattr(self.request, 'headers'):\n    details += '\\n\\trequest headers = %s' % self.request.headers\nif self.request is not None and hasattr(self.request, 'text'):\n    details += '\\n\\trequest text = %s' % self.request.text\nif self.response is not None and hasattr(self.response, 'headers'):\n    details += '\\n\\tresponse headers = %s' % self.response.headers\nif self.response is not None and hasattr(self.response, 'text'):\n    details += '\\n\\tresponse text = %s' % self.response.text\nif self.travis:\n    if self.text:\n        t += '\\n\\ttext: %s' % self.text\n    t += details\nelif self.log_to_tempfile:\n    fd, file_name = tempfile.mkstemp(suffix='.tmp', prefix='jiraerror-')\n    with open(file_name, 'w') as f:\n        t += ' details: %s' % file_name\n        f.write(details)\nelse:\n    if self.text:\n        t += '\\n\\ttext: %s' % self.text\n    t += '\\n\\t' + details\nreturn t\n",
        "CUT_3": "\"\"\"Return Jira role information.\n\n        :return: List of current user roles\n        :rtype: Iterable\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/role'\nr = self._session.get(url)\nreturn json_loads(r)\n",
        "CUT_4": "\"\"\"Return Jira role information.\n\n        :return: List of current user roles\n        :rtype: Iterable\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/role'\nr = self._session.get(url)\nreturn json_loads(r)\n",
        "CUT_5": "return self\n"
    },
    {
        "functionName": "test_pickling_resource",
        "className": "UniversalResourceTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "resource = self.jira.find('issue/{0}', self.test_manager.project_b_issue1)\npickled = pickle.dumps(resource.raw)\nunpickled = pickle.loads(pickled)\ncls = cls_for_resource(unpickled['self'])\nunpickled_instance = cls(self.jira._options, self.jira._session, raw=pickle\n    .loads(pickled))\nself.assertEqual(resource.key, unpickled_instance.key)\nself.assertTrue(resource == unpickled_instance)\n",
        "CUT_1": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_2": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_3": "Resource.__init__(self, 'issue/{0}/comment/{1}', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_4": "Resource.__init__(self, 'issue/{0}/comment/{1}', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_5": "Resource.__init__(self, 'project/{0}', options, session)\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_cls_for_resource",
        "className": "ResourceTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "self.assertEqual(cls_for_resource(\n    'https://jira.atlassian.com/rest/                api/latest/issue/JRA-1330'\n    ), Issue)\nself.assertEqual(cls_for_resource(\n    'http://localhost:2990/jira/rest/                api/latest/project/BULK'\n    ), Project)\nself.assertEqual(cls_for_resource(\n    'http://imaginary-jira.com/rest/                api/latest/project/IMG/role/10002'\n    ), Role)\nself.assertEqual(cls_for_resource(\n    'http://customized-jira.com/rest/                plugin-resource/4.5/json/getMyObject'\n    ), UnknownResource)\nself.assertEqual(cls_for_resource(\n    'http://customized-jira.com/rest/                group?groupname=bla'),\n    Group)\n",
        "CUT_1": "\"\"\"Return Jira role information.\n\n        :return: List of current user roles\n        :rtype: Iterable\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/role'\nr = self._session.get(url)\nreturn json_loads(r)\n",
        "CUT_2": "\"\"\"Return Jira role information.\n\n        :return: List of current user roles\n        :rtype: Iterable\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/role'\nr = self._session.get(url)\nreturn json_loads(r)\n",
        "CUT_3": "self.jira = JIRA('https://jira.atlassian.com', logging=False, async_=True,\n    validate=False, get_server_info=False)\n",
        "CUT_4": "\"\"\"Delete a group from the Jira instance.\n\n        :param groupname: The group to be deleted from the Jira instance.\n        :type groupname: str\n        :return: Boolean. Returns True on success.\n        :rtype: bool\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/group'\nx = {'groupname': groupname}\nself._session.delete(url, params=x)\nreturn True\n",
        "CUT_5": "\"\"\"Delete a group from the Jira instance.\n\n        :param groupname: The group to be deleted from the Jira instance.\n        :type groupname: str\n        :return: Boolean. Returns True on success.\n        :rtype: bool\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/group'\nx = {'groupname': groupname}\nself._session.delete(url, params=x)\nreturn True\n"
    },
    {
        "functionName": "test_application_properties",
        "className": "ApplicationPropertiesTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "props = self.jira.application_properties()\nfor p in props:\n    self.assertIsInstance(p, dict)\n    self.assertTrue(set(p.keys()).issuperset(set(['type', 'name', 'value',\n        'key', 'id'])))\n",
        "CUT_1": "props = self._properties\nname = '%s.gyp:%s' % (props['containerPortal'].Name(), props['remoteInfo'])\nreturn '<%s %r at 0x%x>' % (self.__class__.__name__, name, id(self))\n",
        "CUT_2": "self.files = []\nself.targets = set()\nself.additional_compile_target_names = set()\nself.test_target_names = set()\n",
        "CUT_3": "\"\"\"Set the application property.\n\n        :param key: key of the property to set\n        :type key: str\n        :param value: value to assign to the property\n        :type value: str\n        \"\"\"\nurl = self._options['server'\n    ] + '/rest/api/latest/application-properties/' + key\npayload = {'id': key, 'value': value}\nreturn self._session.put(url, data=json.dumps(payload))\n",
        "CUT_4": "\"\"\"Set the application property.\n\n        :param key: key of the property to set\n        :type key: str\n        :param value: value to assign to the property\n        :type value: str\n        \"\"\"\nurl = self._options['server'\n    ] + '/rest/api/latest/application-properties/' + key\npayload = {'id': key, 'value': value}\nreturn self._session.put(url, data=json.dumps(payload))\n",
        "CUT_5": "for key, value in the_dict.items():\n    if type(value) in (str, int, list):\n        variables['_' + key] = value\n"
    },
    {
        "functionName": "test_application_property",
        "className": "ApplicationPropertiesTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "clone_prefix = self.jira.application_properties(key=\n    'jira.lf.text.headingcolour')\nself.assertEqual(clone_prefix['value'], '#292929')\n",
        "CUT_1": "self.jira = JIRA('https://jira.atlassian.com', logging=False, async_=True,\n    validate=False, get_server_info=False)\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_set_application_property",
        "className": "ApplicationPropertiesTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "prop = 'jira.lf.favicon.hires.url'\nvalid_value = '/jira-favicon-hires.png'\ninvalid_value = '/invalid-jira-favicon-hires.png'\nself.jira.set_application_property(prop, invalid_value)\nself.assertEqual(self.jira.application_properties(key=prop)['value'],\n    invalid_value)\nself.jira.set_application_property(prop, valid_value)\nself.assertEqual(self.jira.application_properties(key=prop)['value'],\n    valid_value)\n",
        "CUT_1": "self.jira = JIRA('https://jira.atlassian.com', logging=False, async_=True,\n    validate=False, get_server_info=False)\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_setting_bad_property_raises",
        "className": "ApplicationPropertiesTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "prop = 'random.nonexistent.property'\nself.assertRaises(JIRAError, self.jira.set_application_property, prop, '666')\n",
        "CUT_1": "s = ''.join(random.sample(string.ascii_uppercase, 5)) + ''.join(random.\n    sample(string.ascii_lowercase, 5)) + ''.join(random.sample(string.\n    digits, 2)) + ''.join(random.sample(\"~`!@#$%^&*()_+-=[]\\\\{}|;':<>?,./\", 2))\nreturn ''.join(random.sample(s, len(s)))\n",
        "CUT_2": "return ''.join(random.sample(string.ascii_lowercase, 6))\n",
        "CUT_3": "return self.distance is None\nproperty",
        "CUT_4": "return self._session.cookies\nproperty",
        "CUT_5": "return self._session.cookies\nproperty"
    },
    {
        "functionName": "test_0_attachment_meta",
        "className": "AttachmentTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "meta = self.jira.attachment_meta()\nself.assertTrue(meta['enabled'])\nself.assertIn('uploadLimit', meta)\n",
        "CUT_1": "\"\"\"Get the attachment metadata.\n\n        :rtype: Dict[str, int]\n        \"\"\"\nreturn self._get_json('attachment/meta')\n",
        "CUT_2": "\"\"\"Get the attachment metadata.\n\n        :rtype: Dict[str, int]\n        \"\"\"\nreturn self._get_json('attachment/meta')\n",
        "CUT_3": "trace('data', data)\nnode = data.get('node', '')[:12]\nif node:\n    node = 'h' + node\nif 'tag' in data:\n    return meta(data['tag'], config=config)\nelif 'latesttag' in data:\n    return meta(data['latesttag'], distance=data['latesttagdistance'], node\n        =node, config=config)\nelse:\n    return meta('0.0', node=node, config=config)\n",
        "CUT_4": "trace('data', data)\nversions = tags_to_versions(tag_re.findall(data.get('ref-names', '')))\nif versions:\n    return meta(versions[0])\n",
        "CUT_5": "if config.parentdir_prefix_version is not None:\n    _, parent_name = os.path.split(os.path.abspath(root))\n    if parent_name.startswith(config.parentdir_prefix_version):\n        version = tag_to_version(parent_name[len(config.\n            parentdir_prefix_version):], config)\n        if version is not None:\n            return meta(str(version), preformatted=True, config=config)\nif config.fallback_version is not None:\n    return meta(config.fallback_version, preformatted=True, config=config)\n"
    },
    {
        "functionName": "test_1_add_remove_attachment",
        "className": "AttachmentTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.issue(self.issue_1)\nwith open(TEST_ATTACH_PATH, 'rb') as f:\n    attachment = self.jira.add_attachment(issue, f, 'new test attachment')\n    new_attachment = self.jira.attachment(attachment.id)\n    msg = 'attachment %s of issue %s' % (new_attachment.__dict__, issue)\n    self.assertEqual(new_attachment.filename, 'new test attachment', msg=msg)\n    self.assertEqual(new_attachment.size, os.path.getsize(TEST_ATTACH_PATH),\n        msg=msg)\n    self.assertEqual(attachment.delete().status_code, 204)\n",
        "CUT_1": "\"\"\"Attach an attachment to an issue and returns a Resource for it.\n\n        The client will *not* attempt to open or validate the attachment; it expects a file-like object to be ready\n        for its use. The user is still responsible for tidying up (e.g., closing the file, killing the socket, etc.)\n\n        :param issue: the issue to attach the attachment to\n        :type issue: str\n        :param attachment: file-like object to attach to the issue, also works if it is a string with the filename.\n        :type attachment: BufferedReader\n        :param filename: optional name for the attached file. If omitted, the file object's ``name`` attribute\n            is used. If you acquired the file-like object by any other method than ``open()``, make sure\n            that a name is specified in one way or the other.\n        :type filename: str\n        :rtype: Attachment\n        \"\"\"\nif isinstance(attachment, str):\n    attachment = open(attachment, 'rb')\nif hasattr(attachment, 'read') and hasattr(attachment, 'mode'\n    ) and attachment.mode != 'rb':\n    logging.warning(\n        \"%s was not opened in 'rb' mode, attaching file may fail.\" %\n        attachment.name)\nurl = self._get_url('issue/' + str(issue) + '/attachments')\nfname = filename\nif not fname:\n    fname = os.path.basename(attachment.name)\nif 'MultipartEncoder' not in globals():\n    method = 'old'\n    r = self._session.post(url, files={'file': (fname, attachment,\n        'application/octet-stream')}, headers=CaseInsensitiveDict({\n        'content-type': None, 'X-Atlassian-Token': 'nocheck'}))\nelse:\n    method = 'MultipartEncoder'\n\n    def file_stream():\n        \"\"\"Returns files stream of attachment.\n\n                :rtype: MultipartEncoder\n                \"\"\"\n        return MultipartEncoder(fields={'file': (fname, attachment,\n            'application/octet-stream')})\n    m = file_stream()\n    r = self._session.post(url, data=m, headers=CaseInsensitiveDict({\n        'content-type': m.content_type, 'X-Atlassian-Token': 'nocheck'}),\n        retry_data=file_stream)\njs = json_loads(r)\nif not js or not isinstance(js, Iterable):\n    raise JIRAError('Unable to parse JSON: %s' % js)\nattachment = Attachment(self._options, self._session, js[0])\nif attachment.size == 0:\n    raise JIRAError(\n        'Added empty attachment via %s method?!: r: %s\\nattachment: %s' % (\n        method, r, attachment))\nreturn attachment\ntranslate_resource_args",
        "CUT_2": "\"\"\"Attach an attachment to an issue and returns a Resource for it.\n\n        The client will *not* attempt to open or validate the attachment; it expects a file-like object to be ready\n        for its use. The user is still responsible for tidying up (e.g., closing the file, killing the socket, etc.)\n\n        :param issue: the issue to attach the attachment to\n        :type issue: str\n        :param attachment: file-like object to attach to the issue, also works if it is a string with the filename.\n        :type attachment: BufferedReader\n        :param filename: optional name for the attached file. If omitted, the file object's ``name`` attribute\n            is used. If you acquired the file-like object by any other method than ``open()``, make sure\n            that a name is specified in one way or the other.\n        :type filename: str\n        :rtype: Attachment\n        \"\"\"\nif isinstance(attachment, str):\n    attachment = open(attachment, 'rb')\nif hasattr(attachment, 'read') and hasattr(attachment, 'mode'\n    ) and attachment.mode != 'rb':\n    logging.warning(\n        \"%s was not opened in 'rb' mode, attaching file may fail.\" %\n        attachment.name)\nurl = self._get_url('issue/' + str(issue) + '/attachments')\nfname = filename\nif not fname:\n    fname = os.path.basename(attachment.name)\nif 'MultipartEncoder' not in globals():\n    method = 'old'\n    r = self._session.post(url, files={'file': (fname, attachment,\n        'application/octet-stream')}, headers=CaseInsensitiveDict({\n        'content-type': None, 'X-Atlassian-Token': 'nocheck'}))\nelse:\n    method = 'MultipartEncoder'\n\n    def file_stream():\n        \"\"\"Returns files stream of attachment.\n\n                :rtype: MultipartEncoder\n                \"\"\"\n        return MultipartEncoder(fields={'file': (fname, attachment,\n            'application/octet-stream')})\n    m = file_stream()\n    r = self._session.post(url, data=m, headers=CaseInsensitiveDict({\n        'content-type': m.content_type, 'X-Atlassian-Token': 'nocheck'}),\n        retry_data=file_stream)\njs = json_loads(r)\nif not js or not isinstance(js, Iterable):\n    raise JIRAError('Unable to parse JSON: %s' % js)\nattachment = Attachment(self._options, self._session, js[0])\nif attachment.size == 0:\n    raise JIRAError(\n        'Added empty attachment via %s method?!: r: %s\\nattachment: %s' % (\n        method, r, attachment))\nreturn attachment\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get an attachment Resource from the server for the specified ID.\n\n        :param id: The Attachment ID\n        :type id: str\n        :rtype: Attachment\n        \"\"\"\nreturn self._find_for_resource(Attachment, id)\n",
        "CUT_4": "\"\"\"Get an attachment Resource from the server for the specified ID.\n\n        :param id: The Attachment ID\n        :type id: str\n        :rtype: Attachment\n        \"\"\"\nreturn self._find_for_resource(Attachment, id)\n",
        "CUT_5": "\"\"\"Get the attachment metadata.\n\n        :rtype: Dict[str, int]\n        \"\"\"\nreturn self._get_json('attachment/meta')\n"
    },
    {
        "functionName": "test_2_create_component",
        "className": "ComponentTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "proj = self.jira.project(self.project_b)\nname = 'project-%s-component-%s' % (proj, rndstr())\ncomponent = self.jira.create_component(name, proj, description='test!!',\n    assigneeType='COMPONENT_LEAD', isAssigneeTypeValid=False)\nself.assertEqual(component.name, name)\nself.assertEqual(component.description, 'test!!')\nself.assertEqual(component.assigneeType, 'COMPONENT_LEAD')\nself.assertFalse(component.isAssigneeTypeValid)\ncomponent.delete()\n",
        "CUT_1": "\"\"\"Create a component inside a project and return a Resource for it.\n\n        :param name: name of the component\n        :type name: str\n        :param project: key of the project to create the component in\n        :type project: str\n        :param description: a description of the component\n        :type description: str\n        :param leadUserName: the username of the user responsible for this component\n        :type leadUserName: Optional[str]\n        :param assigneeType: see the ComponentBean.AssigneeType class for valid values\n        :type assigneeType: Optional[str]\n        :param isAssigneeTypeValid: boolean specifying whether the assignee type is acceptable (Default: False)\n        :type isAssigneeTypeValid: bool\n        :rtype: Component\n        \"\"\"\ndata = {'name': name, 'project': project, 'isAssigneeTypeValid':\n    isAssigneeTypeValid}\nif description is not None:\n    data['description'] = description\nif leadUserName is not None:\n    data['leadUserName'] = leadUserName\nif assigneeType is not None:\n    data['assigneeType'] = assigneeType\nurl = self._get_url('component')\nr = self._session.post(url, data=json.dumps(data))\ncomponent = Component(self._options, self._session, raw=json_loads(r))\nreturn component\ntranslate_resource_args",
        "CUT_2": "\"\"\"Create a component inside a project and return a Resource for it.\n\n        :param name: name of the component\n        :type name: str\n        :param project: key of the project to create the component in\n        :type project: str\n        :param description: a description of the component\n        :type description: str\n        :param leadUserName: the username of the user responsible for this component\n        :type leadUserName: Optional[str]\n        :param assigneeType: see the ComponentBean.AssigneeType class for valid values\n        :type assigneeType: Optional[str]\n        :param isAssigneeTypeValid: boolean specifying whether the assignee type is acceptable (Default: False)\n        :type isAssigneeTypeValid: bool\n        :rtype: Component\n        \"\"\"\ndata = {'name': name, 'project': project, 'isAssigneeTypeValid':\n    isAssigneeTypeValid}\nif description is not None:\n    data['description'] = description\nif leadUserName is not None:\n    data['leadUserName'] = leadUserName\nif assigneeType is not None:\n    data['assigneeType'] = assigneeType\nurl = self._get_url('component')\nr = self._session.post(url, data=json.dumps(data))\ncomponent = Component(self._options, self._session, raw=json_loads(r))\nreturn component\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a component Resource from the server.\n\n        :param id: ID of the component to get\n        :type id: str\n        \"\"\"\nreturn self._find_for_resource(Component, id)\n",
        "CUT_4": "\"\"\"Get a component Resource from the server.\n\n        :param id: ID of the component to get\n        :type id: str\n        \"\"\"\nreturn self._find_for_resource(Component, id)\n",
        "CUT_5": "\"\"\"Delete component by id.\n\n        :param id: ID of the component to use\n        :type id: str\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('component/' + str(id))\nreturn self._session.delete(url)\n"
    },
    {
        "functionName": "test_3_update",
        "className": "ComponentTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "try:\n    components = self.jira.project_components(self.project_b)\n    for component in components:\n        if component.name == 'To be updated':\n            component.delete()\n            break\nexcept Exception:\n    raise\nname = 'component-' + rndstr()\ncomponent = self.jira.create_component(name, self.project_b, description=\n    'stand by!', leadUserName=self.jira.current_user())\nname = 'renamed-' + name\ncomponent.update(name=name, description='It is done.', leadUserName=self.\n    jira.current_user())\nself.assertEqual(component.name, name)\nself.assertEqual(component.description, 'It is done.')\nself.assertEqual(component.lead.name, self.jira.current_user())\ncomponent.delete()\n",
        "CUT_1": "\"\"\"Create a component inside a project and return a Resource for it.\n\n        :param name: name of the component\n        :type name: str\n        :param project: key of the project to create the component in\n        :type project: str\n        :param description: a description of the component\n        :type description: str\n        :param leadUserName: the username of the user responsible for this component\n        :type leadUserName: Optional[str]\n        :param assigneeType: see the ComponentBean.AssigneeType class for valid values\n        :type assigneeType: Optional[str]\n        :param isAssigneeTypeValid: boolean specifying whether the assignee type is acceptable (Default: False)\n        :type isAssigneeTypeValid: bool\n        :rtype: Component\n        \"\"\"\ndata = {'name': name, 'project': project, 'isAssigneeTypeValid':\n    isAssigneeTypeValid}\nif description is not None:\n    data['description'] = description\nif leadUserName is not None:\n    data['leadUserName'] = leadUserName\nif assigneeType is not None:\n    data['assigneeType'] = assigneeType\nurl = self._get_url('component')\nr = self._session.post(url, data=json.dumps(data))\ncomponent = Component(self._options, self._session, raw=json_loads(r))\nreturn component\ntranslate_resource_args",
        "CUT_2": "\"\"\"Create a component inside a project and return a Resource for it.\n\n        :param name: name of the component\n        :type name: str\n        :param project: key of the project to create the component in\n        :type project: str\n        :param description: a description of the component\n        :type description: str\n        :param leadUserName: the username of the user responsible for this component\n        :type leadUserName: Optional[str]\n        :param assigneeType: see the ComponentBean.AssigneeType class for valid values\n        :type assigneeType: Optional[str]\n        :param isAssigneeTypeValid: boolean specifying whether the assignee type is acceptable (Default: False)\n        :type isAssigneeTypeValid: bool\n        :rtype: Component\n        \"\"\"\ndata = {'name': name, 'project': project, 'isAssigneeTypeValid':\n    isAssigneeTypeValid}\nif description is not None:\n    data['description'] = description\nif leadUserName is not None:\n    data['leadUserName'] = leadUserName\nif assigneeType is not None:\n    data['assigneeType'] = assigneeType\nurl = self._get_url('component')\nr = self._session.post(url, data=json.dumps(data))\ncomponent = Component(self._options, self._session, raw=json_loads(r))\nreturn component\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a component Resource from the server.\n\n        :param id: ID of the component to get\n        :type id: str\n        \"\"\"\nreturn self._find_for_resource(Component, id)\n",
        "CUT_4": "\"\"\"Get a component Resource from the server.\n\n        :param id: ID of the component to get\n        :type id: str\n        \"\"\"\nreturn self._find_for_resource(Component, id)\n",
        "CUT_5": "\"\"\"Delete component by id.\n\n        :param id: ID of the component to use\n        :type id: str\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('component/' + str(id))\nreturn self._session.delete(url)\n"
    },
    {
        "functionName": "test_4_delete",
        "className": "ComponentTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "component = self.jira.create_component('To be deleted', self.project_b,\n    description='not long for this world')\nmyid = component.id\ncomponent.delete()\nself.assertRaises(JIRAError, self.jira.component, myid)\n",
        "CUT_1": "\"\"\"Get a component Resource from the server.\n\n        :param id: ID of the component to get\n        :type id: str\n        \"\"\"\nreturn self._find_for_resource(Component, id)\n",
        "CUT_2": "\"\"\"Get a component Resource from the server.\n\n        :param id: ID of the component to get\n        :type id: str\n        \"\"\"\nreturn self._find_for_resource(Component, id)\n",
        "CUT_3": "\"\"\"Delete component by id.\n\n        :param id: ID of the component to use\n        :type id: str\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('component/' + str(id))\nreturn self._session.delete(url)\n",
        "CUT_4": "\"\"\"Delete component by id.\n\n        :param id: ID of the component to use\n        :type id: str\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('component/' + str(id))\nreturn self._session.delete(url)\n",
        "CUT_5": "\"\"\"Get the count of related issues for a component.\n\n        :type id: integer\n        :param id: ID of the component to use\n        \"\"\"\nreturn self._get_json('component/' + id + '/relatedIssueCounts')['issueCount']\n"
    },
    {
        "functionName": "test_delete_component_by_id",
        "className": "ComponentTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "component = self.jira.create_component('To be deleted', self.project_b,\n    description='not long for this world')\nmyid = component.id\nself.jira.delete_component(myid)\nself.assertRaises(JIRAError, self.jira.component, myid)\n",
        "CUT_1": "\"\"\"Get a component Resource from the server.\n\n        :param id: ID of the component to get\n        :type id: str\n        \"\"\"\nreturn self._find_for_resource(Component, id)\n",
        "CUT_2": "\"\"\"Get a component Resource from the server.\n\n        :param id: ID of the component to get\n        :type id: str\n        \"\"\"\nreturn self._find_for_resource(Component, id)\n",
        "CUT_3": "\"\"\"Delete component by id.\n\n        :param id: ID of the component to use\n        :type id: str\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('component/' + str(id))\nreturn self._session.delete(url)\n",
        "CUT_4": "\"\"\"Delete component by id.\n\n        :param id: ID of the component to use\n        :type id: str\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('component/' + str(id))\nreturn self._session.delete(url)\n",
        "CUT_5": "\"\"\"Get the count of related issues for a component.\n\n        :type id: integer\n        :param id: ID of the component to use\n        \"\"\"\nreturn self._get_json('component/' + id + '/relatedIssueCounts')['issueCount']\n"
    },
    {
        "functionName": "test_custom_field_option",
        "className": "CustomFieldOptionTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "option = self.jira.custom_field_option('10001')\nself.assertEqual(option.value, 'To Do')\nnot_on_custom_jira_instance",
        "CUT_1": "if not os.path.exists(CONFIG_PATH):\n    return {}, {}, {}, {}\nparser = configparser.ConfigParser()\ntry:\n    parser.read(CONFIG_PATH)\nexcept configparser.ParsingError as err:\n    print(\"Couldn't read config file at path: {}\\n{}\".format(CONFIG_PATH, err))\n    raise\nif parser.has_section('options'):\n    options = {}\n    for option, value in parser.items('options'):\n        if option in ('verify', 'async'):\n            value = parser.getboolean('options', option)\n        options[option] = value\nelse:\n    options = {}\nif parser.has_section('basic_auth'):\n    basic_auth = dict(parser.items('basic_auth'))\nelse:\n    basic_auth = {}\nif parser.has_section('oauth'):\n    oauth = {}\n    for option, value in parser.items('oauth'):\n        if option in ('oauth_dance', 'print_tokens'):\n            value = parser.getboolean('oauth', option)\n        oauth[option] = value\nelse:\n    oauth = {}\nif parser.has_section('kerberos_auth'):\n    kerberos_auth = {}\n    for option, value in parser.items('kerberos_auth'):\n        if option in 'use_kerberos':\n            value = parser.getboolean('kerberos_auth', option)\n        kerberos_auth[option] = value\nelse:\n    kerberos_auth = {}\nreturn options, basic_auth, oauth, kerberos_auth\n",
        "CUT_2": "if not os.path.exists(CONFIG_PATH):\n    return {}, {}, {}, {}\nparser = configparser.ConfigParser()\ntry:\n    parser.read(CONFIG_PATH)\nexcept configparser.ParsingError as err:\n    print(\"Couldn't read config file at path: {}\\n{}\".format(CONFIG_PATH, err))\n    raise\nif parser.has_section('options'):\n    options = {}\n    for option, value in parser.items('options'):\n        if option in ('verify', 'async'):\n            value = parser.getboolean('options', option)\n        options[option] = value\nelse:\n    options = {}\nif parser.has_section('basic_auth'):\n    basic_auth = dict(parser.items('basic_auth'))\nelse:\n    basic_auth = {}\nif parser.has_section('oauth'):\n    oauth = {}\n    for option, value in parser.items('oauth'):\n        if option in ('oauth_dance', 'print_tokens'):\n            value = parser.getboolean('oauth', option)\n        oauth[option] = value\nelse:\n    oauth = {}\nif parser.has_section('kerberos_auth'):\n    kerberos_auth = {}\n    for option, value in parser.items('kerberos_auth'):\n        if option in 'use_kerberos':\n            value = parser.getboolean('kerberos_auth', option)\n        kerberos_auth[option] = value\nelse:\n    kerberos_auth = {}\nreturn options, basic_auth, oauth, kerberos_auth\n",
        "CUT_3": "\"\"\"Add an option to the parser.\n\n    This accepts the same arguments as ArgumentParser.add_argument, plus the\n    following:\n      regenerate: can be set to False to prevent this option from being included\n                  in regeneration.\n      env_name: name of environment variable that additional values for this\n                option come from.\n      type: adds type='path', to tell the regenerator that the values of\n            this option need to be made relative to options.depth\n    \"\"\"\nenv_name = kw.pop('env_name', None)\nif 'dest' in kw and kw.pop('regenerate', True):\n    dest = kw['dest']\n    type = kw.get('type')\n    if type == 'path':\n        kw['type'] = str\n    self.__regeneratable_options[dest] = {'action': kw.get('action'),\n        'type': type, 'env_name': env_name, 'opt': args[0]}\nargparse.ArgumentParser.add_argument(self, *args, **kw)\n",
        "CUT_4": "\"\"\"Get a custom field option Resource from the server.\n\n        :param id: ID of the custom field to use\n        :type id: str\n        :rtype: CustomFieldOption\n        \"\"\"\nreturn self._find_for_resource(CustomFieldOption, id)\n",
        "CUT_5": "\"\"\"Get a custom field option Resource from the server.\n\n        :param id: ID of the custom field to use\n        :type id: str\n        :rtype: CustomFieldOption\n        \"\"\"\nreturn self._find_for_resource(CustomFieldOption, id)\n"
    },
    {
        "functionName": "test_dashboards",
        "className": "DashboardTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "dashboards = self.jira.dashboards()\nself.assertEqual(len(dashboards), 3)\n",
        "CUT_1": "\"\"\"Return a ResultList of Dashboard resources and a ``total`` count.\n\n        :param filter: either \"favourite\" or \"my\", the type of dashboards to return\n        :type filter: Optional[str]\n        :param startAt: index of the first dashboard to return (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of dashboards to return.\n            If maxResults evaluates as False, it will try to get all items in batches. (Default: 20)\n        :type maxResults: int\n\n        :rtype: ResultList\n        \"\"\"\nparams = {}\nif filter is not None:\n    params['filter'] = filter\nreturn self._fetch_pages(Dashboard, 'dashboards', 'dashboard', startAt,\n    maxResults, params)\n",
        "CUT_2": "\"\"\"Return a ResultList of Dashboard resources and a ``total`` count.\n\n        :param filter: either \"favourite\" or \"my\", the type of dashboards to return\n        :type filter: Optional[str]\n        :param startAt: index of the first dashboard to return (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of dashboards to return.\n            If maxResults evaluates as False, it will try to get all items in batches. (Default: 20)\n        :type maxResults: int\n\n        :rtype: ResultList\n        \"\"\"\nparams = {}\nif filter is not None:\n    params['filter'] = filter\nreturn self._fetch_pages(Dashboard, 'dashboards', 'dashboard', startAt,\n    maxResults, params)\n",
        "CUT_3": "return len(self.map)\n",
        "CUT_4": "return self\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_dashboards_filter",
        "className": "DashboardTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "dashboards = self.jira.dashboards(filter='my')\nself.assertEqual(len(dashboards), 2)\nself.assertEqual(dashboards[0].id, '10101')\n",
        "CUT_1": "\"\"\"Return a ResultList of Dashboard resources and a ``total`` count.\n\n        :param filter: either \"favourite\" or \"my\", the type of dashboards to return\n        :type filter: Optional[str]\n        :param startAt: index of the first dashboard to return (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of dashboards to return.\n            If maxResults evaluates as False, it will try to get all items in batches. (Default: 20)\n        :type maxResults: int\n\n        :rtype: ResultList\n        \"\"\"\nparams = {}\nif filter is not None:\n    params['filter'] = filter\nreturn self._fetch_pages(Dashboard, 'dashboards', 'dashboard', startAt,\n    maxResults, params)\n",
        "CUT_2": "\"\"\"Return a ResultList of Dashboard resources and a ``total`` count.\n\n        :param filter: either \"favourite\" or \"my\", the type of dashboards to return\n        :type filter: Optional[str]\n        :param startAt: index of the first dashboard to return (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of dashboards to return.\n            If maxResults evaluates as False, it will try to get all items in batches. (Default: 20)\n        :type maxResults: int\n\n        :rtype: ResultList\n        \"\"\"\nparams = {}\nif filter is not None:\n    params['filter'] = filter\nreturn self._fetch_pages(Dashboard, 'dashboards', 'dashboard', startAt,\n    maxResults, params)\n",
        "CUT_3": "\"\"\"Get a filter Resource from the server.\n\n        :param id: ID of the filter to get.\n        :type id: str\n        :rtype: Filter\n        \"\"\"\nreturn self._find_for_resource(Filter, id)\n",
        "CUT_4": "\"\"\"Get a filter Resource from the server.\n\n        :param id: ID of the filter to get.\n        :type id: str\n        :rtype: Filter\n        \"\"\"\nreturn self._find_for_resource(Filter, id)\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_dashboards_startat",
        "className": "DashboardTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "dashboards = self.jira.dashboards(startAt=1, maxResults=1)\nself.assertEqual(len(dashboards), 1)\n",
        "CUT_1": "\"\"\"Return a ResultList of Dashboard resources and a ``total`` count.\n\n        :param filter: either \"favourite\" or \"my\", the type of dashboards to return\n        :type filter: Optional[str]\n        :param startAt: index of the first dashboard to return (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of dashboards to return.\n            If maxResults evaluates as False, it will try to get all items in batches. (Default: 20)\n        :type maxResults: int\n\n        :rtype: ResultList\n        \"\"\"\nparams = {}\nif filter is not None:\n    params['filter'] = filter\nreturn self._fetch_pages(Dashboard, 'dashboards', 'dashboard', startAt,\n    maxResults, params)\n",
        "CUT_2": "\"\"\"Return a ResultList of Dashboard resources and a ``total`` count.\n\n        :param filter: either \"favourite\" or \"my\", the type of dashboards to return\n        :type filter: Optional[str]\n        :param startAt: index of the first dashboard to return (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of dashboards to return.\n            If maxResults evaluates as False, it will try to get all items in batches. (Default: 20)\n        :type maxResults: int\n\n        :rtype: ResultList\n        \"\"\"\nparams = {}\nif filter is not None:\n    params['filter'] = filter\nreturn self._fetch_pages(Dashboard, 'dashboards', 'dashboard', startAt,\n    maxResults, params)\n",
        "CUT_3": "\"\"\"Get a list of user Resources that match the search string and can be assigned issues for projects.\n\n        :param username: A string to match usernames against\n        :type username: str\n        :param projectKeys: Comma-separated list of project keys to check for issue assignment permissions\n        :type projectKeys: str\n        :param startAt: Index of the first user to return (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of users to return.\n                If maxResults evaluates as False, it will try to get all users in batches. (Default: 50)\n        :type maxResults: int\n\n        :rtype: ResultList\n\n        \"\"\"\nparams = {'username': username, 'projectKeys': projectKeys}\nreturn self._fetch_pages(User, None, 'user/assignable/multiProjectSearch',\n    startAt, maxResults, params)\n",
        "CUT_4": "\"\"\"Get a list of user Resources that match the search string and can be assigned issues for projects.\n\n        :param username: A string to match usernames against\n        :type username: str\n        :param projectKeys: Comma-separated list of project keys to check for issue assignment permissions\n        :type projectKeys: str\n        :param startAt: Index of the first user to return (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of users to return.\n                If maxResults evaluates as False, it will try to get all users in batches. (Default: 50)\n        :type maxResults: int\n\n        :rtype: ResultList\n\n        \"\"\"\nparams = {'username': username, 'projectKeys': projectKeys}\nreturn self._fetch_pages(User, None, 'user/assignable/multiProjectSearch',\n    startAt, maxResults, params)\n",
        "CUT_5": "\"\"\"Fetch pages.\n\n        :param item_type: Type of single item. ResultList of such items will be returned.\n        :type item_type: type\n        :param items_key: Path to the items in JSON returned from server.\n                Set it to None, if response is an array, and not a JSON object.\n        :type items_key: Optional[str]\n        :param request_path: path in request URL\n        :type request_path: str\n        :param startAt: index of the first record to be fetched. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of items to return.\n                If maxResults evaluates as False, it will try to get all items in batches. (Default:50)\n        :type maxResults: int\n        :param params: Params to be used in all requests. Should not contain startAt and maxResults,\n                        as they will be added for each request created from this function.\n        :type params: Dict[str, Any]\n        :param base: base URL\n        :type base: str\n        :rtype: ResultList\n        \"\"\"\nasync_class = None\nif self._options['async']:\n    try:\n        from requests_futures.sessions import FuturesSession\n        async_class = FuturesSession\n    except ImportError:\n        pass\n    async_workers = self._options['async_workers']\npage_params = params.copy() if params else {}\nif startAt:\n    page_params['startAt'] = startAt\nif maxResults:\n    page_params['maxResults'] = maxResults\nresource = self._get_json(request_path, params=page_params, base=base)\nnext_items_page = self._get_items_from_page(item_type, items_key, resource)\nitems = next_items_page\nif True:\n    if isinstance(resource, dict):\n        total = resource.get('total')\n        is_last = resource.get('isLast', False)\n        start_at_from_response = resource.get('startAt', 0)\n        max_results_from_response = resource.get('maxResults', 1)\n    else:\n        total = 1\n        is_last = True\n        start_at_from_response = 0\n        max_results_from_response = 1\n    if not maxResults:\n        page_size = max_results_from_response or len(items)\n        page_start = (startAt or start_at_from_response or 0) + page_size\n        if async_class is not None and not is_last and (total is not None and\n            len(items) < total):\n            async_fetches = []\n            future_session = async_class(session=self._session, max_workers\n                =async_workers)\n            for start_index in range(page_start, total, page_size):\n                page_params = params.copy()\n                page_params['startAt'] = start_index\n                page_params['maxResults'] = page_size\n                url = self._get_url(request_path)\n                r = future_session.get(url, params=page_params)\n                async_fetches.append(r)\n            for future in async_fetches:\n                response = future.result()\n                resource = json_loads(response)\n                if resource:\n                    next_items_page = self._get_items_from_page(item_type,\n                        items_key, resource)\n                    items.extend(next_items_page)\n        while async_class is None and not is_last and (total is None or \n            page_start < total) and len(next_items_page) == page_size:\n            page_params['startAt'] = page_start\n            page_params['maxResults'] = page_size\n            resource = self._get_json(request_path, params=page_params,\n                base=base)\n            if resource:\n                next_items_page = self._get_items_from_page(item_type,\n                    items_key, resource)\n                items.extend(next_items_page)\n                page_start += page_size\n            else:\n                break\n    return ResultList(items, start_at_from_response,\n        max_results_from_response, total, is_last)\nelse:\n    return ResultList([item_type(self._options, self._session, resource)], \n        0, 1, 1, True)\n"
    },
    {
        "functionName": "test_dashboards_maxresults",
        "className": "DashboardTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "dashboards = self.jira.dashboards(maxResults=1)\nself.assertEqual(len(dashboards), 1)\n",
        "CUT_1": "\"\"\"Return a ResultList of Dashboard resources and a ``total`` count.\n\n        :param filter: either \"favourite\" or \"my\", the type of dashboards to return\n        :type filter: Optional[str]\n        :param startAt: index of the first dashboard to return (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of dashboards to return.\n            If maxResults evaluates as False, it will try to get all items in batches. (Default: 20)\n        :type maxResults: int\n\n        :rtype: ResultList\n        \"\"\"\nparams = {}\nif filter is not None:\n    params['filter'] = filter\nreturn self._fetch_pages(Dashboard, 'dashboards', 'dashboard', startAt,\n    maxResults, params)\n",
        "CUT_2": "\"\"\"Return a ResultList of Dashboard resources and a ``total`` count.\n\n        :param filter: either \"favourite\" or \"my\", the type of dashboards to return\n        :type filter: Optional[str]\n        :param startAt: index of the first dashboard to return (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of dashboards to return.\n            If maxResults evaluates as False, it will try to get all items in batches. (Default: 20)\n        :type maxResults: int\n\n        :rtype: ResultList\n        \"\"\"\nparams = {}\nif filter is not None:\n    params['filter'] = filter\nreturn self._fetch_pages(Dashboard, 'dashboards', 'dashboard', startAt,\n    maxResults, params)\n",
        "CUT_3": "return len(self.map)\n",
        "CUT_4": "return self\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_dashboard",
        "className": "DashboardTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "dashboard = self.jira.dashboard('10101')\nself.assertEqual(dashboard.id, '10101')\nself.assertEqual(dashboard.name, 'Another test dashboard')\n",
        "CUT_1": "\"\"\"Get a dashboard Resource from the server.\n\n        :param id: ID of the dashboard to get.\n        :type id: str\n        :rtype: Dashboard\n        \"\"\"\nreturn self._find_for_resource(Dashboard, id)\n",
        "CUT_2": "\"\"\"Get a dashboard Resource from the server.\n\n        :param id: ID of the dashboard to get.\n        :type id: str\n        :rtype: Dashboard\n        \"\"\"\nreturn self._find_for_resource(Dashboard, id)\n",
        "CUT_3": "Resource.__init__(self, 'dashboard/{0}', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_4": "Resource.__init__(self, 'dashboard/{0}', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_5": "\"\"\"Return a ResultList of Dashboard resources and a ``total`` count.\n\n        :param filter: either \"favourite\" or \"my\", the type of dashboards to return\n        :type filter: Optional[str]\n        :param startAt: index of the first dashboard to return (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of dashboards to return.\n            If maxResults evaluates as False, it will try to get all items in batches. (Default: 20)\n        :type maxResults: int\n\n        :rtype: ResultList\n        \"\"\"\nparams = {}\nif filter is not None:\n    params['filter'] = filter\nreturn self._fetch_pages(Dashboard, 'dashboards', 'dashboard', startAt,\n    maxResults, params)\n"
    },
    {
        "functionName": "test_fields",
        "className": "FieldsTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "fields = self.jira.fields()\nself.assertGreater(len(fields), 10)\n",
        "CUT_1": "\"\"\"\n    :type fields: Optional[Dict[str, Any]]\n    :type fieldargs: **Any\n    :return: Union[Dict[str, Dict[str, Any]], Dict[str, Dict[str, str]]]\n    \"\"\"\nif fields is not None:\n    return {'fields': fields}\nreturn {'fields': fieldargs}\n",
        "CUT_2": "\"\"\"\n    :type fields: Optional[Dict[str, Any]]\n    :type fieldargs: **Any\n    :return: Union[Dict[str, Dict[str, Any]], Dict[str, Dict[str, str]]]\n    \"\"\"\nif fields is not None:\n    return {'fields': fields}\nreturn {'fields': fieldargs}\n",
        "CUT_3": "\"\"\"Get a :class:`~jira.client.ResultList` of issue Resources matching a JQL search string.\n\n        :param jql_str: The JQL search string.\n        :type jql_str: str\n        :param startAt: Index of the first issue to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of issues to return. Total number of results\n            is available in the ``total`` attribute of the returned :class:`~jira.client.ResultList`.\n            If maxResults evaluates as False, it will try to get all issues in batches. (Default: 50)\n        :type maxResults: int\n        :param validate_query: Whether or not the query should be validated. (Default: True)\n        :type validate_query: bool\n        :param fields: comma-separated string or list of issue fields to include in the results.\n            Default is to include all fields.\n        :type fields: Optional[str or list]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :param json_result: JSON response will be returned when this parameter is set to True.\n                Otherwise, :class:`~jira.client.ResultList` will be returned.\n        :type json_result: bool\n\n        :rtype: dict or :class:`~jira.client.ResultList`\n\n        \"\"\"\nif isinstance(fields, str):\n    fields = fields.split(',')\nelse:\n    fields = list(fields or [])\nuntranslate = {}\nif self._fields:\n    for i, field in enumerate(fields):\n        if field in self._fields:\n            untranslate[self._fields[field]] = fields[i]\n            fields[i] = self._fields[field]\nsearch_params = {'jql': jql_str, 'startAt': startAt, 'validateQuery':\n    validate_query, 'fields': fields, 'expand': expand}\nif json_result:\n    search_params['maxResults'] = maxResults\n    if not maxResults:\n        warnings.warn(\n            'All issues cannot be fetched at once, when json_result parameter is set'\n            , Warning)\n    return self._get_json('search', params=search_params)\nissues = self._fetch_pages(Issue, 'issues', 'search', startAt, maxResults,\n    search_params)\nif untranslate:\n    for i in issues:\n        for k, v in untranslate.items():\n            if k in i.raw.get('fields', {}):\n                i.raw['fields'][v] = i.raw['fields'][k]\nreturn issues\n",
        "CUT_4": "\"\"\"Get a :class:`~jira.client.ResultList` of issue Resources matching a JQL search string.\n\n        :param jql_str: The JQL search string.\n        :type jql_str: str\n        :param startAt: Index of the first issue to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of issues to return. Total number of results\n            is available in the ``total`` attribute of the returned :class:`~jira.client.ResultList`.\n            If maxResults evaluates as False, it will try to get all issues in batches. (Default: 50)\n        :type maxResults: int\n        :param validate_query: Whether or not the query should be validated. (Default: True)\n        :type validate_query: bool\n        :param fields: comma-separated string or list of issue fields to include in the results.\n            Default is to include all fields.\n        :type fields: Optional[str or list]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :param json_result: JSON response will be returned when this parameter is set to True.\n                Otherwise, :class:`~jira.client.ResultList` will be returned.\n        :type json_result: bool\n\n        :rtype: dict or :class:`~jira.client.ResultList`\n\n        \"\"\"\nif isinstance(fields, str):\n    fields = fields.split(',')\nelse:\n    fields = list(fields or [])\nuntranslate = {}\nif self._fields:\n    for i, field in enumerate(fields):\n        if field in self._fields:\n            untranslate[self._fields[field]] = fields[i]\n            fields[i] = self._fields[field]\nsearch_params = {'jql': jql_str, 'startAt': startAt, 'validateQuery':\n    validate_query, 'fields': fields, 'expand': expand}\nif json_result:\n    search_params['maxResults'] = maxResults\n    if not maxResults:\n        warnings.warn(\n            'All issues cannot be fetched at once, when json_result parameter is set'\n            , Warning)\n    return self._get_json('search', params=search_params)\nissues = self._fetch_pages(Issue, 'issues', 'search', startAt, maxResults,\n    search_params)\nif untranslate:\n    for i in issues:\n        for k, v in untranslate.items():\n            if k in i.raw.get('fields', {}):\n                i.raw['fields'][v] = i.raw['fields'][k]\nreturn issues\n",
        "CUT_5": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n"
    },
    {
        "functionName": "test_filter",
        "className": "FilterTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "jql = 'project = %s and component is not empty' % self.project_b\nname = 'same filter ' + rndstr()\nmyfilter = self.jira.create_filter(name=name, description=\n    'just some new test filter', jql=jql, favourite=False)\nself.assertEqual(myfilter.name, name)\nself.assertEqual(myfilter.owner.name, self.test_manager.user_admin.name)\nmyfilter.delete()\n",
        "CUT_1": "\"\"\"Create a new filter and return a filter Resource for it.\n\n        :param name: name of the new filter\n        :type name: str\n        :param description: useful human readable description of the new filter\n        :type description: str\n        :param jql: query string that defines the filter\n        :type jql: str\n        :param favourite: whether to add this filter to the current user's favorites\n        :type favourite: bool\n        :rtype: Filter\n\n        \"\"\"\ndata = {}\nif name is not None:\n    data['name'] = name\nif description is not None:\n    data['description'] = description\nif jql is not None:\n    data['jql'] = jql\nif favourite is not None:\n    data['favourite'] = favourite\nurl = self._get_url('filter')\nr = self._session.post(url, data=json.dumps(data))\nraw_filter_json = json_loads(r)\nreturn Filter(self._options, self._session, raw=raw_filter_json)\n",
        "CUT_2": "\"\"\"Create a new filter and return a filter Resource for it.\n\n        :param name: name of the new filter\n        :type name: str\n        :param description: useful human readable description of the new filter\n        :type description: str\n        :param jql: query string that defines the filter\n        :type jql: str\n        :param favourite: whether to add this filter to the current user's favorites\n        :type favourite: bool\n        :rtype: Filter\n\n        \"\"\"\ndata = {}\nif name is not None:\n    data['name'] = name\nif description is not None:\n    data['description'] = description\nif jql is not None:\n    data['jql'] = jql\nif favourite is not None:\n    data['favourite'] = favourite\nurl = self._get_url('filter')\nr = self._session.post(url, data=json.dumps(data))\nraw_filter_json = json_loads(r)\nreturn Filter(self._options, self._session, raw=raw_filter_json)\n",
        "CUT_3": "\"\"\"Update a filter and return a filter Resource for it.\n\n        :param name: name of the new filter\n        :type name: Optional[str]\n        :param description: useful human readable description of the new filter\n        :type description: Optional[str]\n        :param jql: query string that defines the filter\n        :type jql: Optional[str]\n        :param favourite: whether to add this filter to the current user's favorites\n        :type favourite: Optional[bool]\n\n        \"\"\"\nfilter = self.filter(filter_id)\ndata = {}\ndata['name'] = name or filter.name\ndata['description'] = description or filter.description\ndata['jql'] = jql or filter.jql\ndata['favourite'] = favourite or filter.favourite\nurl = self._get_url('filter/%s' % filter_id)\nr = self._session.put(url, headers={'content-type': 'application/json'},\n    data=json.dumps(data))\nraw_filter_json = json.loads(r.text)\nreturn Filter(self._options, self._session, raw=raw_filter_json)\n",
        "CUT_4": "\"\"\"Update a filter and return a filter Resource for it.\n\n        :param name: name of the new filter\n        :type name: Optional[str]\n        :param description: useful human readable description of the new filter\n        :type description: Optional[str]\n        :param jql: query string that defines the filter\n        :type jql: Optional[str]\n        :param favourite: whether to add this filter to the current user's favorites\n        :type favourite: Optional[bool]\n\n        \"\"\"\nfilter = self.filter(filter_id)\ndata = {}\ndata['name'] = name or filter.name\ndata['description'] = description or filter.description\ndata['jql'] = jql or filter.jql\ndata['favourite'] = favourite or filter.favourite\nurl = self._get_url('filter/%s' % filter_id)\nr = self._session.put(url, headers={'content-type': 'application/json'},\n    data=json.dumps(data))\nraw_filter_json = json.loads(r.text)\nreturn Filter(self._options, self._session, raw=raw_filter_json)\n",
        "CUT_5": "\"\"\"Adds a configuration to the project.\n\n    Args:\n      name: Configuration name.\n    \"\"\"\nself.configurations[name] = ['Configuration', {'Name': name}]\n"
    },
    {
        "functionName": "test_favourite_filters",
        "className": "FilterTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "jql = 'project = %s and component is not empty' % self.project_b\nname = 'filter-to-fav-' + rndstr()\nmyfilter = self.jira.create_filter(name=name, description=\n    'just some new test filter', jql=jql, favourite=True)\nnew_filters = self.jira.favourite_filters()\nassert name in [f.name for f in new_filters]\nmyfilter.delete()\n",
        "CUT_1": "\"\"\"Create a new filter and return a filter Resource for it.\n\n        :param name: name of the new filter\n        :type name: str\n        :param description: useful human readable description of the new filter\n        :type description: str\n        :param jql: query string that defines the filter\n        :type jql: str\n        :param favourite: whether to add this filter to the current user's favorites\n        :type favourite: bool\n        :rtype: Filter\n\n        \"\"\"\ndata = {}\nif name is not None:\n    data['name'] = name\nif description is not None:\n    data['description'] = description\nif jql is not None:\n    data['jql'] = jql\nif favourite is not None:\n    data['favourite'] = favourite\nurl = self._get_url('filter')\nr = self._session.post(url, data=json.dumps(data))\nraw_filter_json = json_loads(r)\nreturn Filter(self._options, self._session, raw=raw_filter_json)\n",
        "CUT_2": "\"\"\"Create a new filter and return a filter Resource for it.\n\n        :param name: name of the new filter\n        :type name: str\n        :param description: useful human readable description of the new filter\n        :type description: str\n        :param jql: query string that defines the filter\n        :type jql: str\n        :param favourite: whether to add this filter to the current user's favorites\n        :type favourite: bool\n        :rtype: Filter\n\n        \"\"\"\ndata = {}\nif name is not None:\n    data['name'] = name\nif description is not None:\n    data['description'] = description\nif jql is not None:\n    data['jql'] = jql\nif favourite is not None:\n    data['favourite'] = favourite\nurl = self._get_url('filter')\nr = self._session.post(url, data=json.dumps(data))\nraw_filter_json = json_loads(r)\nreturn Filter(self._options, self._session, raw=raw_filter_json)\n",
        "CUT_3": "\"\"\"Update a filter and return a filter Resource for it.\n\n        :param name: name of the new filter\n        :type name: Optional[str]\n        :param description: useful human readable description of the new filter\n        :type description: Optional[str]\n        :param jql: query string that defines the filter\n        :type jql: Optional[str]\n        :param favourite: whether to add this filter to the current user's favorites\n        :type favourite: Optional[bool]\n\n        \"\"\"\nfilter = self.filter(filter_id)\ndata = {}\ndata['name'] = name or filter.name\ndata['description'] = description or filter.description\ndata['jql'] = jql or filter.jql\ndata['favourite'] = favourite or filter.favourite\nurl = self._get_url('filter/%s' % filter_id)\nr = self._session.put(url, headers={'content-type': 'application/json'},\n    data=json.dumps(data))\nraw_filter_json = json.loads(r.text)\nreturn Filter(self._options, self._session, raw=raw_filter_json)\n",
        "CUT_4": "\"\"\"Update a filter and return a filter Resource for it.\n\n        :param name: name of the new filter\n        :type name: Optional[str]\n        :param description: useful human readable description of the new filter\n        :type description: Optional[str]\n        :param jql: query string that defines the filter\n        :type jql: Optional[str]\n        :param favourite: whether to add this filter to the current user's favorites\n        :type favourite: Optional[bool]\n\n        \"\"\"\nfilter = self.filter(filter_id)\ndata = {}\ndata['name'] = name or filter.name\ndata['description'] = description or filter.description\ndata['jql'] = jql or filter.jql\ndata['favourite'] = favourite or filter.favourite\nurl = self._get_url('filter/%s' % filter_id)\nr = self._session.put(url, headers={'content-type': 'application/json'},\n    data=json.dumps(data))\nraw_filter_json = json.loads(r.text)\nreturn Filter(self._options, self._session, raw=raw_filter_json)\n",
        "CUT_5": "\"\"\"Adds a configuration to the project.\n\n    Args:\n      name: Configuration name.\n    \"\"\"\nself.configurations[name] = ['Configuration', {'Name': name}]\n"
    },
    {
        "functionName": "test_group",
        "className": "GroupsTest",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "group = self.jira.group('jira-users')\nself.assertEqual(group.name, 'jira-users')\n",
        "CUT_1": "\"\"\"Return a hash or users with their information. Requires Jira 6.0 or will raise NotImplemented.\n\n        :param group: Name of the group.\n        :type group: str\n        \"\"\"\nif self._version < (6, 0, 0):\n    raise NotImplementedError(\n        'Group members is not implemented in Jira before version 6.0, upgrade the instance, if possible.'\n        )\nparams = {'groupname': group, 'expand': 'users'}\nr = self._get_json('group', params=params)\nsize = r['users']['size']\nend_index = r['users']['end-index']\nwhile end_index < size - 1:\n    params = {'groupname': group, 'expand': 'users[%s:%s]' % (end_index + 1,\n        end_index + 50)}\n    r2 = self._get_json('group', params=params)\n    for user in r2['users']['items']:\n        r['users']['items'].append(user)\n    end_index = r2['users']['end-index']\n    size = r['users']['size']\nresult = {}\nfor user in r['users']['items']:\n    result[user['key']] = {'name': user['name'], 'fullname': user[\n        'displayName'], 'email': user.get('emailAddress', 'hidden'),\n        'active': user['active']}\nreturn OrderedDict(sorted(result.items(), key=lambda t: t[0]))\n",
        "CUT_2": "\"\"\"Return a hash or users with their information. Requires Jira 6.0 or will raise NotImplemented.\n\n        :param group: Name of the group.\n        :type group: str\n        \"\"\"\nif self._version < (6, 0, 0):\n    raise NotImplementedError(\n        'Group members is not implemented in Jira before version 6.0, upgrade the instance, if possible.'\n        )\nparams = {'groupname': group, 'expand': 'users'}\nr = self._get_json('group', params=params)\nsize = r['users']['size']\nend_index = r['users']['end-index']\nwhile end_index < size - 1:\n    params = {'groupname': group, 'expand': 'users[%s:%s]' % (end_index + 1,\n        end_index + 50)}\n    r2 = self._get_json('group', params=params)\n    for user in r2['users']['items']:\n        r['users']['items'].append(user)\n    end_index = r2['users']['end-index']\n    size = r['users']['size']\nresult = {}\nfor user in r['users']['items']:\n    result[user['key']] = {'name': user['name'], 'fullname': user[\n        'displayName'], 'email': user.get('emailAddress', 'hidden'),\n        'active': user['active']}\nreturn OrderedDict(sorted(result.items(), key=lambda t: t[0]))\n",
        "CUT_3": "\"\"\"Add a user to an existing group.\n\n        :param username: Username that will be added to specified group.\n        :type username: str\n        :param group: Group that the user will be added to.\n        :type group: str\n\n        :return: json response from Jira server for success or a value that evaluates as False in case of failure.\n        :rtype: Union[bool,Dict[str,Any]]\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/group/user'\nx = {'groupname': group}\ny = {'name': username}\npayload = json.dumps(y)\nr = json_loads(self._session.post(url, params=x, data=payload))\nif 'name' not in r or r['name'] != group:\n    return False\nelse:\n    return r\n",
        "CUT_4": "\"\"\"Add a user to an existing group.\n\n        :param username: Username that will be added to specified group.\n        :type username: str\n        :param group: Group that the user will be added to.\n        :type group: str\n\n        :return: json response from Jira server for success or a value that evaluates as False in case of failure.\n        :rtype: Union[bool,Dict[str,Any]]\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/group/user'\nx = {'groupname': group}\ny = {'name': username}\npayload = json.dumps(y)\nr = json_loads(self._session.post(url, params=x, data=payload))\nif 'name' not in r or r['name'] != group:\n    return False\nelse:\n    return r\n",
        "CUT_5": "return 2 * match.group(1) + '\\\\\"'\n"
    },
    {
        "functionName": "test_groups",
        "className": "GroupsTest",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "groups = self.jira.groups()\nself.assertGreater(len(groups), 0)\n",
        "CUT_1": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_2": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_3": "\"\"\"Add the specified users or groups to this project role. One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'id': self.id, 'categorisedActors': {'atlassian-user-role-actor':\n    users, 'atlassian-group-role-actor': groups}}\nsuper(Role, self).update(**data)\n",
        "CUT_4": "\"\"\"Add the specified users or groups to this project role. One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'id': self.id, 'categorisedActors': {'atlassian-user-role-actor':\n    users, 'atlassian-group-role-actor': groups}}\nsuper(Role, self).update(**data)\n",
        "CUT_5": "\"\"\"Return a list of groups matching the specified criteria.\n\n        :param query: filter groups by name with this string\n        :type query: Optional[str]\n        :param exclude: filter out groups by name with this string\n        :type exclude: Optional[Any]\n        :param maxResults: maximum results to return. (Default: 9999)\n        :type maxResults: int\n        :rtype: List[str]\n\n        \"\"\"\nparams = {}\ngroups = []\nif query is not None:\n    params['query'] = query\nif exclude is not None:\n    params['exclude'] = exclude\nif maxResults is not None:\n    params['maxResults'] = maxResults\nfor group in self._get_json('groups/picker', params=params)['groups']:\n    groups.append(group['name'])\nreturn sorted(groups)\n"
    },
    {
        "functionName": "test_groups_for_users",
        "className": "GroupsTest",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "groups = self.jira.groups('jira-users')\nself.assertGreater(len(groups), 0)\n",
        "CUT_1": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_2": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_3": "\"\"\"Add the specified users or groups to this project role. One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'id': self.id, 'categorisedActors': {'atlassian-user-role-actor':\n    users, 'atlassian-group-role-actor': groups}}\nsuper(Role, self).update(**data)\n",
        "CUT_4": "\"\"\"Add the specified users or groups to this project role. One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'id': self.id, 'categorisedActors': {'atlassian-user-role-actor':\n    users, 'atlassian-group-role-actor': groups}}\nsuper(Role, self).update(**data)\n",
        "CUT_5": "\"\"\"Return a list of groups matching the specified criteria.\n\n        :param query: filter groups by name with this string\n        :type query: Optional[str]\n        :param exclude: filter out groups by name with this string\n        :type exclude: Optional[Any]\n        :param maxResults: maximum results to return. (Default: 9999)\n        :type maxResults: int\n        :rtype: List[str]\n\n        \"\"\"\nparams = {}\ngroups = []\nif query is not None:\n    params['query'] = query\nif exclude is not None:\n    params['exclude'] = exclude\nif maxResults is not None:\n    params['maxResults'] = maxResults\nfor group in self._get_json('groups/picker', params=params)['groups']:\n    groups.append(group['name'])\nreturn sorted(groups)\n"
    },
    {
        "functionName": "test_issue",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.issue(self.issue_1)\nself.assertEqual(issue.key, self.issue_1)\nself.assertEqual(issue.fields.summary, 'issue 1 from %s' % self.project_b)\n",
        "CUT_1": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_2": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_3": "\"\"\"Remove the current authenticated user's vote from an issue.\n\n        :param issue: ID or key of the issue to remove vote on\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nself._session.delete(url)\ntranslate_resource_args",
        "CUT_4": "\"\"\"Remove the current authenticated user's vote from an issue.\n\n        :param issue: ID or key of the issue to remove vote on\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nself._session.delete(url)\ntranslate_resource_args",
        "CUT_5": "\"\"\"Register a vote for the current authenticated user on an issue.\n\n        :param issue: ID or key of the issue to vote on\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nreturn self._session.post(url)\ntranslate_resource_args"
    },
    {
        "functionName": "test_issue_field_limiting",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.issue(self.issue_2, fields='summary,comment')\nself.assertEqual(issue.fields.summary, 'issue 2 from %s' % self.project_b)\ncomment1 = self.jira.add_comment(issue, 'First comment')\ncomment2 = self.jira.add_comment(issue, 'Second comment')\ncomment3 = self.jira.add_comment(issue, 'Third comment')\nself.jira.issue(self.issue_2, fields='summary,comment')\nlogging.warning(issue.raw['fields'])\nself.assertFalse(hasattr(issue.fields, 'reporter'))\nself.assertFalse(hasattr(issue.fields, 'progress'))\ncomment1.delete()\ncomment2.delete()\ncomment3.delete()\nunittest.skip('disabled as it seems to be ignored by jira, returning all')",
        "CUT_1": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_2": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_3": "\"\"\"Get a comment Resource from the server for the specified ID.\n\n        :param issue: ID or key of the issue to get the comment from\n        :param comment: ID of the comment to get\n        \"\"\"\nreturn self._find_for_resource(Comment, (issue, comment))\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a comment Resource from the server for the specified ID.\n\n        :param issue: ID or key of the issue to get the comment from\n        :param comment: ID of the comment to get\n        \"\"\"\nreturn self._find_for_resource(Comment, (issue, comment))\ntranslate_resource_args",
        "CUT_5": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n"
    },
    {
        "functionName": "test_issue_equal",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue1 = self.jira.issue(self.issue_1)\nissue2 = self.jira.issue(self.issue_2)\nissues = self.jira.search_issues('key=%s' % self.issue_1)\nself.assertTrue(issue1 is not None)\nself.assertTrue(issue1 == issues[0])\nself.assertFalse(issue2 == issues[0])\n",
        "CUT_1": "return self\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_normal\nself.issue_1 = self.test_manager.project_b_issue1\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.attachment = None\n"
    },
    {
        "functionName": "test_issue_expand",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.issue(self.issue_1, expand='editmeta,schema')\nself.assertTrue(hasattr(issue, 'editmeta'))\nself.assertTrue(hasattr(issue, 'schema'))\n",
        "CUT_1": "\"\"\"Get the edit metadata for an issue.\n\n        :param issue: the issue to get metadata for\n        :rtype: Dict[str, Dict[str, Dict[str, Any]]]\n\n        \"\"\"\nreturn self._get_json('issue/' + str(issue) + '/editmeta')\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get the edit metadata for an issue.\n\n        :param issue: the issue to get metadata for\n        :rtype: Dict[str, Dict[str, Dict[str, Any]]]\n\n        \"\"\"\nreturn self._get_json('issue/' + str(issue) + '/editmeta')\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_4": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_5": "\"\"\"Register a vote for the current authenticated user on an issue.\n\n        :param issue: ID or key of the issue to vote on\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nreturn self._session.post(url)\ntranslate_resource_args"
    },
    {
        "functionName": "test_create_issue_with_fieldargs",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.create_issue(project=self.project_b, summary=\n    'Test issue created', description='foo description', issuetype={'name':\n    'Bug'})\nself.assertEqual(issue.fields.summary, 'Test issue created')\nself.assertEqual(issue.fields.description, 'foo description')\nself.assertEqual(issue.fields.issuetype.name, 'Bug')\nself.assertEqual(issue.fields.project.key, self.project_b)\nissue.delete()\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_2": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_3": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_4": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_5": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n"
    },
    {
        "functionName": "test_create_issue_with_fielddict",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "fields = {'project': {'key': self.project_b}, 'summary':\n    'Issue created from field dict', 'description':\n    'Some new issue for test', 'issuetype': {'name': 'Bug'}, 'priority': {\n    'name': 'Major'}}\nissue = self.jira.create_issue(fields=fields)\nself.assertEqual(issue.fields.summary, 'Issue created from field dict')\nself.assertEqual(issue.fields.description, 'Some new issue for test')\nself.assertEqual(issue.fields.issuetype.name, 'Bug')\nself.assertEqual(issue.fields.project.key, self.project_b)\nself.assertEqual(issue.fields.priority.name, 'Major')\nissue.delete()\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_2": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_3": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_4": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_5": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n"
    },
    {
        "functionName": "test_create_issue_without_prefetch",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.create_issue(prefetch=False, project=self.project_b,\n    summary='Test issue created', description='some details', issuetype={\n    'name': 'Bug'})\nassert hasattr(issue, 'self')\nassert hasattr(issue, 'raw')\nassert 'fields' not in issue.raw\nissue.delete()\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_2": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_3": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_4": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_5": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n"
    },
    {
        "functionName": "test_create_issues",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "field_list = [{'project': {'key': self.project_b}, 'summary':\n    'Issue created via bulk create #1', 'description':\n    'Some new issue for test', 'issuetype': {'name': 'Bug'}, 'priority': {\n    'name': 'Major'}}, {'project': {'key': self.project_a}, 'issuetype': {\n    'name': 'Bug'}, 'summary': 'Issue created via bulk create #2',\n    'description': 'Another new issue for bulk test', 'priority': {'name':\n    'Major'}}]\nissues = self.jira.create_issues(field_list=field_list)\nself.assertEqual(len(issues), 2)\nself.assertIsNotNone(issues[0]['issue'], 'the first issue has not been created'\n    )\nself.assertEqual(issues[0]['issue'].fields.summary,\n    'Issue created via bulk create #1')\nself.assertEqual(issues[0]['issue'].fields.description,\n    'Some new issue for test')\nself.assertEqual(issues[0]['issue'].fields.issuetype.name, 'Bug')\nself.assertEqual(issues[0]['issue'].fields.project.key, self.project_b)\nself.assertEqual(issues[0]['issue'].fields.priority.name, 'Major')\nself.assertIsNotNone(issues[1]['issue'],\n    'the second issue has not been created')\nself.assertEqual(issues[1]['issue'].fields.summary,\n    'Issue created via bulk create #2')\nself.assertEqual(issues[1]['issue'].fields.description,\n    'Another new issue for bulk test')\nself.assertEqual(issues[1]['issue'].fields.issuetype.name, 'Bug')\nself.assertEqual(issues[1]['issue'].fields.project.key, self.project_a)\nself.assertEqual(issues[1]['issue'].fields.priority.name, 'Major')\nfor issue in issues:\n    issue['issue'].delete()\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n",
        "CUT_2": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n",
        "CUT_3": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_4": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_5": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n"
    },
    {
        "functionName": "test_create_issues_one_failure",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "field_list = [{'project': {'key': self.project_b}, 'summary':\n    'Issue created via bulk create #1', 'description':\n    'Some new issue for test', 'issuetype': {'name': 'Bug'}, 'priority': {\n    'name': 'Major'}}, {'project': {'key': self.project_a}, 'issuetype': {\n    'name': 'InvalidIssueType'}, 'summary': 'This issue will not succeed',\n    'description': 'Should not be seen.', 'priority': {'name': 'Blah'}}, {\n    'project': {'key': self.project_a}, 'issuetype': {'name': 'Bug'},\n    'summary': 'However, this one will.', 'description': 'Should be seen.',\n    'priority': {'name': 'Major'}}]\nissues = self.jira.create_issues(field_list=field_list)\nself.assertEqual(issues[0]['issue'].fields.summary,\n    'Issue created via bulk create #1')\nself.assertEqual(issues[0]['issue'].fields.description,\n    'Some new issue for test')\nself.assertEqual(issues[0]['issue'].fields.issuetype.name, 'Bug')\nself.assertEqual(issues[0]['issue'].fields.project.key, self.project_b)\nself.assertEqual(issues[0]['issue'].fields.priority.name, 'Major')\nself.assertEqual(issues[0]['error'], None)\nself.assertEqual(issues[1]['issue'], None)\nself.assertEqual(issues[1]['error'], {'issuetype': 'issue type is required'})\nself.assertEqual(issues[1]['input_fields'], field_list[1])\nself.assertEqual(issues[2]['issue'].fields.summary, 'However, this one will.')\nself.assertEqual(issues[2]['issue'].fields.description, 'Should be seen.')\nself.assertEqual(issues[2]['issue'].fields.issuetype.name, 'Bug')\nself.assertEqual(issues[2]['issue'].fields.project.key, self.project_a)\nself.assertEqual(issues[2]['issue'].fields.priority.name, 'Major')\nself.assertEqual(issues[2]['error'], None)\nself.assertEqual(len(issues), 3)\nfor issue in issues:\n    if issue['issue'] is not None:\n        issue['issue'].delete()\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n",
        "CUT_2": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n",
        "CUT_3": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_4": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_5": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n"
    },
    {
        "functionName": "test_create_issues_without_prefetch",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "field_list = [dict(project=self.project_b, summary='Test issue created',\n    description='some details', issuetype={'name': 'Bug'}), dict(project=\n    self.project_a, summary='Test issue #2', description='foo description',\n    issuetype={'name': 'Bug'})]\nissues = self.jira.create_issues(field_list, prefetch=False)\nassert hasattr(issues[0]['issue'], 'self')\nassert hasattr(issues[0]['issue'], 'raw')\nassert hasattr(issues[1]['issue'], 'self')\nassert hasattr(issues[1]['issue'], 'raw')\nassert 'fields' not in issues[0]['issue'].raw\nassert 'fields' not in issues[1]['issue'].raw\nfor issue in issues:\n    issue['issue'].delete()\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n",
        "CUT_2": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n",
        "CUT_3": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_4": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_5": "\"\"\"Get the edit metadata for an issue.\n\n        :param issue: the issue to get metadata for\n        :rtype: Dict[str, Dict[str, Dict[str, Any]]]\n\n        \"\"\"\nreturn self._get_json('issue/' + str(issue) + '/editmeta')\ntranslate_resource_args"
    },
    {
        "functionName": "test_update_with_fieldargs",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.create_issue(project=self.project_b, summary=\n    'Test issue for updating', description='Will be updated shortly',\n    issuetype={'name': 'Bug'})\nissue.update(summary='Updated summary', description='Now updated',\n    issuetype={'name': 'Story'})\nself.assertEqual(issue.fields.summary, 'Updated summary')\nself.assertEqual(issue.fields.description, 'Now updated')\nself.assertEqual(issue.fields.issuetype.name, 'Story')\nself.assertEqual(issue.fields.project.key, self.project_b)\nissue.delete()\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_2": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_3": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_4": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_5": "\"\"\"Returns a minimal json object for an issue. \"\"\"\nreturn {'id': '%s' % issue_id, 'summary': summary, 'key': key, 'self':\n    kwargs.get('self', 'http://example.com/%s' % issue_id)}\n"
    },
    {
        "functionName": "test_update_with_fielddict",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.create_issue(project=self.project_b, summary=\n    'Test issue for updating', description='Will be updated shortly',\n    issuetype={'name': 'Bug'})\nfields = {'summary': 'Issue is updated', 'description': 'it sure is',\n    'issuetype': {'name': 'Story'}, 'priority': {'name': 'Major'}}\nissue.update(fields=fields)\nself.assertEqual(issue.fields.summary, 'Issue is updated')\nself.assertEqual(issue.fields.description, 'it sure is')\nself.assertEqual(issue.fields.issuetype.name, 'Story')\nself.assertEqual(issue.fields.priority.name, 'Major')\nissue.delete()\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_2": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_3": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_4": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_5": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n"
    },
    {
        "functionName": "test_update_with_label",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.create_issue(project=self.project_b, summary=\n    'Test issue for updating labels', description='Label testing',\n    issuetype=self.test_manager.CI_JIRA_ISSUE)\nlabelarray = ['testLabel']\nfields = {'labels': labelarray}\nissue.update(fields=fields)\nself.assertEqual(issue.fields.labels, ['testLabel'])\n",
        "CUT_1": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_2": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_3": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_4": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_5": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n"
    },
    {
        "functionName": "test_update_with_bad_label",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.create_issue(project=self.project_b, summary=\n    'Test issue for updating labels', description='Label testing',\n    issuetype=self.test_manager.CI_JIRA_ISSUE)\nissue.fields.labels.append('this should not work')\nfields = {'labels': issue.fields.labels}\nself.assertRaises(JIRAError, issue.update, fields=fields)\n",
        "CUT_1": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_2": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_3": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_4": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n",
        "CUT_5": "\"\"\"Bulk create new issues and return an issue Resource for each successfully created issue.\n\n        See `create_issue` documentation for field information.\n\n        :param field_list: a list of dicts each containing field names and the values to use. Each dict\n            is an individual issue to create and is subject to its minimum requirements.\n        :type field_list: List[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource for each created issue so that all\n            of its data is present in the value returned from this method.\n        :type prefetch: bool\n        :rtype: List[Dict[str, Any]]\n\n        \"\"\"\ndata = {'issueUpdates': []}\nfor field_dict in field_list:\n    issue_data = _field_worker(field_dict)\n    p = issue_data['fields']['project']\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['project'] = {'id': self.project(p).id}\n    p = issue_data['fields']['issuetype']\n    if isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': p}\n    if isinstance(p, str) or isinstance(p, int):\n        issue_data['fields']['issuetype'] = {'id': self.issue_type_by_name(\n            p).id}\n    data['issueUpdates'].append(issue_data)\nurl = self._get_url('issue/bulk')\ntry:\n    r = self._session.post(url, data=json.dumps(data))\n    raw_issue_json = json_loads(r)\nexcept JIRAError as je:\n    if je.status_code == 400:\n        raw_issue_json = json.loads(je.response.text)\n    else:\n        raise\nissue_list = []\nerrors = {}\nfor error in raw_issue_json['errors']:\n    errors[error['failedElementNumber']] = error['elementErrors']['errors']\nfor index, fields in enumerate(field_list):\n    if index in errors:\n        issue_list.append({'status': 'Error', 'error': errors[index],\n            'issue': None, 'input_fields': fields})\n    else:\n        issue = raw_issue_json['issues'].pop(0)\n        if prefetch:\n            issue = self.issue(issue['key'])\n        else:\n            issue = Issue(self._options, self._session, raw=issue)\n        issue_list.append({'status': 'Success', 'issue': issue, 'error':\n            None, 'input_fields': fields})\nreturn issue_list\n"
    },
    {
        "functionName": "test_update_with_notify_false",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.create_issue(project=self.project_b, summary=\n    'Test issue for updating', description='Will be updated shortly',\n    issuetype={'name': 'Bug'})\nissue.update(notify=False, description='Now updated, but silently')\nself.assertEqual(issue.fields.description, 'Now updated, but silently')\nissue.delete()\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_2": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_3": "\"\"\"Remove the current authenticated user's vote from an issue.\n\n        :param issue: ID or key of the issue to remove vote on\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nself._session.delete(url)\ntranslate_resource_args",
        "CUT_4": "\"\"\"Remove the current authenticated user's vote from an issue.\n\n        :param issue: ID or key of the issue to remove vote on\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nself._session.delete(url)\ntranslate_resource_args",
        "CUT_5": "\"\"\"Create a new issue and return an issue Resource for it.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored.\n\n        By default, the client will immediately reload the issue Resource created by this method in order to return\n        a complete Issue object to the caller; this behavior can be controlled through the 'prefetch' argument.\n\n        Jira projects may contain many different issue types. Some issue screens have different requirements for\n        fields in a new issue. This information is available through the 'createmeta' method. Further examples are\n        available here: https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Create+Issue\n\n        :param fields: a dict containing field names and the values to use. If present, all other keyword arguments\n            will be ignored\n        :type fields: Optional[Dict[str, Any]]\n        :param prefetch: whether to reload the created issue Resource so that all of its data is present in the value\n            returned from this method\n        :type prefetch: bool\n        :rtype: Issue\n        \"\"\"\ndata = _field_worker(fields, **fieldargs)\np = data['fields']['project']\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['project'] = {'id': self.project(p).id}\np = data['fields']['issuetype']\nif isinstance(p, int):\n    data['fields']['issuetype'] = {'id': p}\nif isinstance(p, str) or isinstance(p, int):\n    data['fields']['issuetype'] = {'id': self.issue_type_by_name(p).id}\nurl = self._get_url('issue')\nr = self._session.post(url, data=json.dumps(data))\nraw_issue_json = json_loads(r)\nif 'key' not in raw_issue_json:\n    raise JIRAError(r.status_code, response=r, url=url, text=json.dumps(data))\nif prefetch:\n    return self.issue(raw_issue_json['key'])\nelse:\n    return Issue(self._options, self._session, raw=raw_issue_json)\n"
    },
    {
        "functionName": "test_delete",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.create_issue(project=self.project_b, summary=\n    'Test issue created', description='Not long for this world', issuetype=\n    self.test_manager.CI_JIRA_ISSUE)\nkey = issue.key\nissue.delete()\nself.assertRaises(JIRAError, self.jira.issue, key)\n",
        "CUT_1": "\"\"\"Remove the current authenticated user's vote from an issue.\n\n        :param issue: ID or key of the issue to remove vote on\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nself._session.delete(url)\ntranslate_resource_args",
        "CUT_2": "\"\"\"Remove the current authenticated user's vote from an issue.\n\n        :param issue: ID or key of the issue to remove vote on\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nself._session.delete(url)\ntranslate_resource_args",
        "CUT_3": "\"\"\"Register a vote for the current authenticated user on an issue.\n\n        :param issue: ID or key of the issue to vote on\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nreturn self._session.post(url)\ntranslate_resource_args",
        "CUT_4": "\"\"\"Register a vote for the current authenticated user on an issue.\n\n        :param issue: ID or key of the issue to vote on\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nreturn self._session.post(url)\ntranslate_resource_args",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue1\n"
    },
    {
        "functionName": "test_createmeta",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "meta = self.jira.createmeta()\nproj = find_by_key(meta['projects'], self.project_b)\nself.assertGreaterEqual(len(proj['issuetypes']), 1)\nnot_on_custom_jira_instance",
        "CUT_1": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\n",
        "CUT_2": "self.manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\n",
        "CUT_3": "\"\"\"Get the attachment metadata.\n\n        :rtype: Dict[str, int]\n        \"\"\"\nreturn self._get_json('attachment/meta')\n",
        "CUT_4": "\"\"\"Get the attachment metadata.\n\n        :rtype: Dict[str, int]\n        \"\"\"\nreturn self._get_json('attachment/meta')\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue1\n"
    },
    {
        "functionName": "test_createmeta_filter_by_projectkey_and_name",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "meta = self.jira.createmeta(projectKeys=self.project_b, issuetypeNames='Bug')\nself.assertEqual(len(meta['projects']), 1)\nself.assertEqual(len(meta['projects'][0]['issuetypes']), 1)\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Get the attachment metadata.\n\n        :rtype: Dict[str, int]\n        \"\"\"\nreturn self._get_json('attachment/meta')\n",
        "CUT_2": "\"\"\"Get the attachment metadata.\n\n        :rtype: Dict[str, int]\n        \"\"\"\nreturn self._get_json('attachment/meta')\n",
        "CUT_3": "return self._GroupByName('Projects')\n",
        "CUT_4": "\"\"\"Get the metadata required to create issues, optionally filtered by projects and issue types.\n\n        :param projectKeys: keys of the projects to filter the results with.\n            Can be a single value or a comma-delimited string. May be combined\n            with projectIds.\n        :type projectKeys: Union[None, Tuple[str, str], str]\n        :param projectIds: IDs of the projects to filter the results with. Can\n            be a single value or a comma-delimited string. May be combined with\n            projectKeys.\n        :type projectIds: Union[List, Tuple[str, str]]\n        :param issuetypeIds: IDs of the issue types to filter the results with.\n            Can be a single value or a comma-delimited string. May be combined\n            with issuetypeNames.\n        :type issuetypeIds: Optional[List[str]]\n        :param issuetypeNames: Names of the issue types to filter the results\n            with. Can be a single value or a comma-delimited string. May be\n            combined with issuetypeIds.\n        :type issuetypeNames: Optional[str]\n        :param expand: extra information to fetch inside each resource.\n        :type expand: Optional[str]\n        :rtype: Dict[str, Any]\n\n        \"\"\"\nparams = {}\nif projectKeys is not None:\n    params['projectKeys'] = projectKeys\nif projectIds is not None:\n    if isinstance(projectIds, str):\n        projectIds = projectIds.split(',')\n    params['projectIds'] = projectIds\nif issuetypeIds is not None:\n    params['issuetypeIds'] = issuetypeIds\nif issuetypeNames is not None:\n    params['issuetypeNames'] = issuetypeNames\nif expand is not None:\n    params['expand'] = expand\nreturn self._get_json('issue/createmeta', params)\n",
        "CUT_5": "\"\"\"Get the metadata required to create issues, optionally filtered by projects and issue types.\n\n        :param projectKeys: keys of the projects to filter the results with.\n            Can be a single value or a comma-delimited string. May be combined\n            with projectIds.\n        :type projectKeys: Union[None, Tuple[str, str], str]\n        :param projectIds: IDs of the projects to filter the results with. Can\n            be a single value or a comma-delimited string. May be combined with\n            projectKeys.\n        :type projectIds: Union[List, Tuple[str, str]]\n        :param issuetypeIds: IDs of the issue types to filter the results with.\n            Can be a single value or a comma-delimited string. May be combined\n            with issuetypeNames.\n        :type issuetypeIds: Optional[List[str]]\n        :param issuetypeNames: Names of the issue types to filter the results\n            with. Can be a single value or a comma-delimited string. May be\n            combined with issuetypeIds.\n        :type issuetypeNames: Optional[str]\n        :param expand: extra information to fetch inside each resource.\n        :type expand: Optional[str]\n        :rtype: Dict[str, Any]\n\n        \"\"\"\nparams = {}\nif projectKeys is not None:\n    params['projectKeys'] = projectKeys\nif projectIds is not None:\n    if isinstance(projectIds, str):\n        projectIds = projectIds.split(',')\n    params['projectIds'] = projectIds\nif issuetypeIds is not None:\n    params['issuetypeIds'] = issuetypeIds\nif issuetypeNames is not None:\n    params['issuetypeNames'] = issuetypeNames\nif expand is not None:\n    params['expand'] = expand\nreturn self._get_json('issue/createmeta', params)\n"
    },
    {
        "functionName": "test_createmeta_filter_by_projectkeys_and_name",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "meta = self.jira.createmeta(projectKeys=(self.project_a, self.project_b),\n    issuetypeNames='Story')\nself.assertEqual(len(meta['projects']), 2)\nfor project in meta['projects']:\n    self.assertEqual(len(project['issuetypes']), 1)\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Get a list of project Resources from the server visible to the current authenticated user.\n\n        :rtype: List[Project]\n\n        \"\"\"\nr_json = self._get_json('project')\nprojects = [Project(self._options, self._session, raw_project_json) for\n    raw_project_json in r_json]\nreturn projects\n",
        "CUT_2": "\"\"\"Get a list of project Resources from the server visible to the current authenticated user.\n\n        :rtype: List[Project]\n\n        \"\"\"\nr_json = self._get_json('project')\nprojects = [Project(self._options, self._session, raw_project_json) for\n    raw_project_json in r_json]\nreturn projects\n",
        "CUT_3": "self.__dict__ = self.__shared_state\nif not self.__dict__:\n    self.initialized = 0\n    if 'CI_JIRA_URL' in os.environ:\n        self.CI_JIRA_URL = os.environ['CI_JIRA_URL']\n        self.max_retries = 5\n    else:\n        self.CI_JIRA_URL = 'https://pycontribs.atlassian.net'\n        self.max_retries = 5\n    if 'CI_JIRA_ADMIN' in os.environ:\n        self.CI_JIRA_ADMIN = os.environ['CI_JIRA_ADMIN']\n    else:\n        self.CI_JIRA_ADMIN = 'ci-admin'\n    if 'CI_JIRA_ADMIN_PASSWORD' in os.environ:\n        self.CI_JIRA_ADMIN_PASSWORD = os.environ['CI_JIRA_ADMIN_PASSWORD']\n    else:\n        self.CI_JIRA_ADMIN_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    if 'CI_JIRA_USER' in os.environ:\n        self.CI_JIRA_USER = os.environ['CI_JIRA_USER']\n    else:\n        self.CI_JIRA_USER = 'ci-user'\n    if 'CI_JIRA_USER_PASSWORD' in os.environ:\n        self.CI_JIRA_USER_PASSWORD = os.environ['CI_JIRA_USER_PASSWORD']\n    else:\n        self.CI_JIRA_USER_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    self.CI_JIRA_ISSUE = os.environ.get('CI_JIRA_ISSUE', 'Bug')\n    if OAUTH:\n        self.jira_admin = JIRA(oauth={'access_token':\n            'hTxcwsbUQiFuFALf7KZHDaeAJIo3tLUK', 'access_token_secret':\n            'aNCLQFP3ORNU6WY7HQISbqbhf0UudDAf', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    if not self.jira_admin.current_user():\n        self.initialized = 1\n        sys.exit(3)\n    if OAUTH:\n        self.jira_sysadmin = JIRA(oauth={'access_token':\n            '4ul1ETSFo7ybbIxAxzyRal39cTrwEGFv', 'access_token_secret':\n            'K83jBZnjnuVRcfjBflrKyThJa0KSjSs2', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA}, logging=False,\n            max_retries=self.max_retries)\n    elif self.CI_JIRA_ADMIN:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, logging=False,\n            max_retries=self.max_retries)\n    if OAUTH:\n        self.jira_normal = JIRA(oauth={'access_token':\n            'ZVDgYDyIQqJY8IFlQ446jZaURIz5ECiB', 'access_token_secret':\n            '5WbLBybPDg1lqqyFjyXSCsCtAWTwz1eD', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_USER, self.CI_JIRA_USER_PASSWORD), validate=True,\n            logging=False, max_retries=self.max_retries)\n    else:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    \"\"\" `jid` is important for avoiding concurency problems when\n            executing tests in parallel as we have only one test instance.\n\n            jid length must be less than 9 characters because we may append\n            another one and the Jira Project key length limit is 10.\n\n            Tests run in parallel:\n            * git branches master or developer, git pr or developers running\n                tests outside Travis\n            * Travis is using \"Travis\" username\n\n            https://docs.travis-ci.com/user/environment-variables/\n            \"\"\"\n    self.jid = get_unique_project_name()\n    self.project_a = self.jid + 'A'\n    self.project_a_name = 'Test user=%s key=%s A' % (getpass.getuser(),\n        self.project_a)\n    self.project_b = self.jid + 'B'\n    self.project_b_name = 'Test user=%s key=%s B' % (getpass.getuser(),\n        self.project_b)\n    self.project_sd = self.jid + 'C'\n    self.project_sd_name = 'Test user=%s key=%s C' % (getpass.getuser(),\n        self.project_b)\n    try:\n        self.jira_admin.project(self.project_a)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_a)\n        except Exception as e:\n            pass\n    try:\n        self.jira_admin.project(self.project_b)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_b)\n        except Exception as e:\n            pass\n    for i in range(1, 20):\n        try:\n            self.jira_admin.project(self.project_b)\n        except Exception:\n            break\n        print('Warning: Project not deleted yet....')\n        sleep(2)\n    for i in range(6):\n        try:\n            if self.jira_admin.create_project(self.project_a, self.\n                project_a_name):\n                break\n        except Exception as e:\n            if 'A project with that name already exists' not in e.text:\n                raise e\n    self.project_a_id = self.jira_admin.project(self.project_a).id\n    self.jira_admin.create_project(self.project_b, self.project_b_name)\n    try:\n        self.jira_admin.create_project(self.project_b, self.project_b_name)\n    except Exception:\n        pass\n    sleep(1)\n    self.project_b_issue1_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 1 from %s' % self.project_b, issuetype=\n        self.CI_JIRA_ISSUE)\n    self.project_b_issue1 = self.project_b_issue1_obj.key\n    self.project_b_issue2_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 2 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue2 = self.project_b_issue2_obj.key\n    self.project_b_issue3_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 3 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue3 = self.project_b_issue3_obj.key\nif not hasattr(self, 'jira_normal') or not hasattr(self, 'jira_admin'):\n    py.test.exit('FATAL: WTF!?')\nself.user_admin = self.jira_admin.search_users(self.CI_JIRA_ADMIN)[0]\nself.initialized = 1\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\nself.project_a = JiraTestManager().project_a\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue3\n",
        "CUT_5": "return self._GroupByName('Projects')\n"
    },
    {
        "functionName": "test_createmeta_filter_by_id",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "projects = self.jira.projects()\nproja = find_by_key_value(projects, self.project_a)\nprojb = find_by_key_value(projects, self.project_b)\nissue_type_ids = dict()\nfull_meta = self.jira.createmeta(projectIds=(proja.id, projb.id))\nfor project in full_meta['projects']:\n    for issue_t in project['issuetypes']:\n        issue_t_id = issue_t['id']\n        val = issue_type_ids.get(issue_t_id)\n        if val is None:\n            issue_type_ids[issue_t_id] = []\n        issue_type_ids[issue_t_id].append([project['id']])\ncommon_issue_ids = []\nfor key, val in issue_type_ids.items():\n    if len(val) == 2:\n        common_issue_ids.append(key)\nself.assertNotEqual(len(common_issue_ids), 0)\nfor_lookup_common_issue_ids = common_issue_ids\nif len(common_issue_ids) > 2:\n    for_lookup_common_issue_ids = common_issue_ids[:-1]\nmeta = self.jira.createmeta(projectIds=(proja.id, projb.id), issuetypeIds=\n    for_lookup_common_issue_ids)\nself.assertEqual(len(meta['projects']), 2)\nfor project in meta['projects']:\n    self.assertEqual(len(project['issuetypes']), len(\n        for_lookup_common_issue_ids))\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Get a list of project Resources from the server visible to the current authenticated user.\n\n        :rtype: List[Project]\n\n        \"\"\"\nr_json = self._get_json('project')\nprojects = [Project(self._options, self._session, raw_project_json) for\n    raw_project_json in r_json]\nreturn projects\n",
        "CUT_2": "\"\"\"Get a list of project Resources from the server visible to the current authenticated user.\n\n        :rtype: List[Project]\n\n        \"\"\"\nr_json = self._get_json('project')\nprojects = [Project(self._options, self._session, raw_project_json) for\n    raw_project_json in r_json]\nreturn projects\n",
        "CUT_3": "\"\"\"Get a project Resource from the server.\n\n        :param id: ID or key of the project to get\n        :rtype: Project\n        \"\"\"\nreturn self._find_for_resource(Project, id)\n",
        "CUT_4": "\"\"\"Get a project Resource from the server.\n\n        :param id: ID or key of the project to get\n        :rtype: Project\n        \"\"\"\nreturn self._find_for_resource(Project, id)\n",
        "CUT_5": "return self._GroupByName('Projects')\n"
    },
    {
        "functionName": "test_createmeta_expand",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "meta = self.jira.createmeta(projectKeys=self.project_b, expand=\n    'projects.issuetypes.fields')\nself.assertTrue('fields' in meta['projects'][0]['issuetypes'][0])\n",
        "CUT_1": "return self._GroupByName('Projects')\n",
        "CUT_2": "\"\"\"Get a :class:`~jira.client.ResultList` of issue Resources matching a JQL search string.\n\n        :param jql_str: The JQL search string.\n        :type jql_str: str\n        :param startAt: Index of the first issue to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of issues to return. Total number of results\n            is available in the ``total`` attribute of the returned :class:`~jira.client.ResultList`.\n            If maxResults evaluates as False, it will try to get all issues in batches. (Default: 50)\n        :type maxResults: int\n        :param validate_query: Whether or not the query should be validated. (Default: True)\n        :type validate_query: bool\n        :param fields: comma-separated string or list of issue fields to include in the results.\n            Default is to include all fields.\n        :type fields: Optional[str or list]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :param json_result: JSON response will be returned when this parameter is set to True.\n                Otherwise, :class:`~jira.client.ResultList` will be returned.\n        :type json_result: bool\n\n        :rtype: dict or :class:`~jira.client.ResultList`\n\n        \"\"\"\nif isinstance(fields, str):\n    fields = fields.split(',')\nelse:\n    fields = list(fields or [])\nuntranslate = {}\nif self._fields:\n    for i, field in enumerate(fields):\n        if field in self._fields:\n            untranslate[self._fields[field]] = fields[i]\n            fields[i] = self._fields[field]\nsearch_params = {'jql': jql_str, 'startAt': startAt, 'validateQuery':\n    validate_query, 'fields': fields, 'expand': expand}\nif json_result:\n    search_params['maxResults'] = maxResults\n    if not maxResults:\n        warnings.warn(\n            'All issues cannot be fetched at once, when json_result parameter is set'\n            , Warning)\n    return self._get_json('search', params=search_params)\nissues = self._fetch_pages(Issue, 'issues', 'search', startAt, maxResults,\n    search_params)\nif untranslate:\n    for i in issues:\n        for k, v in untranslate.items():\n            if k in i.raw.get('fields', {}):\n                i.raw['fields'][v] = i.raw['fields'][k]\nreturn issues\n",
        "CUT_3": "\"\"\"Get a :class:`~jira.client.ResultList` of issue Resources matching a JQL search string.\n\n        :param jql_str: The JQL search string.\n        :type jql_str: str\n        :param startAt: Index of the first issue to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of issues to return. Total number of results\n            is available in the ``total`` attribute of the returned :class:`~jira.client.ResultList`.\n            If maxResults evaluates as False, it will try to get all issues in batches. (Default: 50)\n        :type maxResults: int\n        :param validate_query: Whether or not the query should be validated. (Default: True)\n        :type validate_query: bool\n        :param fields: comma-separated string or list of issue fields to include in the results.\n            Default is to include all fields.\n        :type fields: Optional[str or list]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :param json_result: JSON response will be returned when this parameter is set to True.\n                Otherwise, :class:`~jira.client.ResultList` will be returned.\n        :type json_result: bool\n\n        :rtype: dict or :class:`~jira.client.ResultList`\n\n        \"\"\"\nif isinstance(fields, str):\n    fields = fields.split(',')\nelse:\n    fields = list(fields or [])\nuntranslate = {}\nif self._fields:\n    for i, field in enumerate(fields):\n        if field in self._fields:\n            untranslate[self._fields[field]] = fields[i]\n            fields[i] = self._fields[field]\nsearch_params = {'jql': jql_str, 'startAt': startAt, 'validateQuery':\n    validate_query, 'fields': fields, 'expand': expand}\nif json_result:\n    search_params['maxResults'] = maxResults\n    if not maxResults:\n        warnings.warn(\n            'All issues cannot be fetched at once, when json_result parameter is set'\n            , Warning)\n    return self._get_json('search', params=search_params)\nissues = self._fetch_pages(Issue, 'issues', 'search', startAt, maxResults,\n    search_params)\nif untranslate:\n    for i in issues:\n        for k, v in untranslate.items():\n            if k in i.raw.get('fields', {}):\n                i.raw['fields'][v] = i.raw['fields'][k]\nreturn issues\n",
        "CUT_4": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_5": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n"
    },
    {
        "functionName": "test_assign_issue",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "self.assertTrue(self.jira.assign_issue(self.issue_1, self.user_admin.name))\nself.assertEqual(self.jira.issue(self.issue_1).fields.assignee.name, self.\n    user_admin.name)\n",
        "CUT_1": "return self\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_normal\nself.issue_1 = self.test_manager.project_b_issue1\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_4": "name = self._properties.get('name') or self._properties['target'].Name()\nreturn '<%s %r at 0x%x>' % (self.__class__.__name__, name, id(self))\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.attachment = None\n"
    },
    {
        "functionName": "test_assign_issue_with_issue_obj",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.issue(self.issue_1)\nx = self.jira.assign_issue(issue, self.user_admin.name)\nself.assertTrue(x)\nself.assertEqual(self.jira.issue(self.issue_1).fields.assignee.name, self.\n    user_admin.name)\n",
        "CUT_1": "\"\"\"Assign an issue to a user. None will set it to unassigned. -1 will set it to Automatic.\n\n        :param issue: the issue ID or key to assign\n        :type issue: int or str\n        :param assignee: the user to assign the issue to\n        :type assignee: str\n\n        :rtype: bool\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/issue/' + str(issue\n    ) + '/assignee'\npayload = {'accountId': self._get_user_accountid(assignee)}\nr = self._session.put(url, data=json.dumps(payload))\nraise_on_error(r)\nreturn True\ntranslate_resource_args",
        "CUT_2": "\"\"\"Assign an issue to a user. None will set it to unassigned. -1 will set it to Automatic.\n\n        :param issue: the issue ID or key to assign\n        :type issue: int or str\n        :param assignee: the user to assign the issue to\n        :type assignee: str\n\n        :rtype: bool\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/issue/' + str(issue\n    ) + '/assignee'\npayload = {'accountId': self._get_user_accountid(assignee)}\nr = self._session.put(url, data=json.dumps(payload))\nraise_on_error(r)\nreturn True\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_4": "\"\"\"Get an issue Resource from the server.\n\n        :param id: ID or key of the issue to get\n        :type id: Union[Issue, str]\n        :param fields: comma-separated string of issue fields to include in the results\n        :type fields: Optional[str]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :rtype: Issue\n        \"\"\"\nif isinstance(id, Issue):\n    return id\nissue = Issue(self._options, self._session)\nparams = {}\nif fields is not None:\n    params['fields'] = fields\nif expand is not None:\n    params['expand'] = expand\nissue.find(id, params=params)\nreturn issue\n",
        "CUT_5": "Resource.__init__(self, 'issue/{0}', options, session)\nself.fields = None\n\"\"\" :type: :class:`~Issue._IssueFields` \"\"\"\nself.id = None\n\"\"\" :type: int \"\"\"\nself.key = None\n\"\"\" :type: str \"\"\"\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_assign_to_bad_issue_raises",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "self.assertRaises(JIRAError, self.jira.assign_issue, 'NOPE-1', 'notauser')\n",
        "CUT_1": "return self\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_comments",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "for issue in [self.issue_1, self.jira.issue(self.issue_2)]:\n    self.jira.issue(issue)\n    comment1 = self.jira.add_comment(issue, 'First comment')\n    comment2 = self.jira.add_comment(issue, 'Second comment')\n    comments = self.jira.comments(issue)\n    assert comments[0].body == 'First comment'\n    assert comments[1].body == 'Second comment'\n    comment1.delete()\n    comment2.delete()\n    comments = self.jira.comments(issue)\n    assert len(comments) == 0\n",
        "CUT_1": "\"\"\"Get a list of comment Resources.\n\n        :param issue: the issue to get comments from\n        :type issue: str\n        :rtype: List[Comment]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/comment')\ncomments = [Comment(self._options, self._session, raw_comment_json) for\n    raw_comment_json in r_json['comments']]\nreturn comments\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a list of comment Resources.\n\n        :param issue: the issue to get comments from\n        :type issue: str\n        :rtype: List[Comment]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/comment')\ncomments = [Comment(self._options, self._session, raw_comment_json) for\n    raw_comment_json in r_json['comments']]\nreturn comments\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a comment Resource from the server for the specified ID.\n\n        :param issue: ID or key of the issue to get the comment from\n        :param comment: ID of the comment to get\n        \"\"\"\nreturn self._find_for_resource(Comment, (issue, comment))\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a comment Resource from the server for the specified ID.\n\n        :param issue: ID or key of the issue to get the comment from\n        :param comment: ID of the comment to get\n        \"\"\"\nreturn self._find_for_resource(Comment, (issue, comment))\ntranslate_resource_args",
        "CUT_5": "\"\"\"Add a comment from the current authenticated user on the specified issue and return a Resource for it.\n\n        The issue identifier and comment body are required.\n\n        :param issue: ID or key of the issue to add the comment to\n        :type issue: str\n        :param body: Text of the comment to add\n        :type body: str\n        :param visibility: a dict containing two entries: \"type\" and \"value\".\n            \"type\" is 'role' (or 'group' if the Jira server has configured\n            comment visibility for groups) and 'value' is the name of the role\n            (or group) to which viewing of this comment will be restricted.\n        :type visibility: Optional[Dict[str, str]]\n        :param is_internal: Defines whether a comment has to be marked as 'Internal' in Jira Service Desk (Default: False)\n        :type is_internal: bool\n        :rtype: Comment\n\n        \"\"\"\ndata = {'body': body}\nif is_internal:\n    data.update({'properties': [{'key': 'sd.public.comment', 'value': {\n        'internal': is_internal}}]})\nif visibility is not None:\n    data['visibility'] = visibility\nurl = self._get_url('issue/' + str(issue) + '/comment')\nr = self._session.post(url, data=json.dumps(data))\ncomment = Comment(self._options, self._session, raw=json_loads(r))\nreturn comment\ntranslate_resource_args"
    },
    {
        "functionName": "test_add_comment",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "comment = self.jira.add_comment(self.issue_3, 'a test comment!', visibility\n    ={'type': 'role', 'value': 'Administrators'})\nself.assertEqual(comment.body, 'a test comment!')\nself.assertEqual(comment.visibility.type, 'role')\nself.assertEqual(comment.visibility.value, 'Administrators')\ncomment.delete()\n",
        "CUT_1": "\"\"\"Add a comment from the current authenticated user on the specified issue and return a Resource for it.\n\n        The issue identifier and comment body are required.\n\n        :param issue: ID or key of the issue to add the comment to\n        :type issue: str\n        :param body: Text of the comment to add\n        :type body: str\n        :param visibility: a dict containing two entries: \"type\" and \"value\".\n            \"type\" is 'role' (or 'group' if the Jira server has configured\n            comment visibility for groups) and 'value' is the name of the role\n            (or group) to which viewing of this comment will be restricted.\n        :type visibility: Optional[Dict[str, str]]\n        :param is_internal: Defines whether a comment has to be marked as 'Internal' in Jira Service Desk (Default: False)\n        :type is_internal: bool\n        :rtype: Comment\n\n        \"\"\"\ndata = {'body': body}\nif is_internal:\n    data.update({'properties': [{'key': 'sd.public.comment', 'value': {\n        'internal': is_internal}}]})\nif visibility is not None:\n    data['visibility'] = visibility\nurl = self._get_url('issue/' + str(issue) + '/comment')\nr = self._session.post(url, data=json.dumps(data))\ncomment = Comment(self._options, self._session, raw=json_loads(r))\nreturn comment\ntranslate_resource_args",
        "CUT_2": "\"\"\"Add a comment from the current authenticated user on the specified issue and return a Resource for it.\n\n        The issue identifier and comment body are required.\n\n        :param issue: ID or key of the issue to add the comment to\n        :type issue: str\n        :param body: Text of the comment to add\n        :type body: str\n        :param visibility: a dict containing two entries: \"type\" and \"value\".\n            \"type\" is 'role' (or 'group' if the Jira server has configured\n            comment visibility for groups) and 'value' is the name of the role\n            (or group) to which viewing of this comment will be restricted.\n        :type visibility: Optional[Dict[str, str]]\n        :param is_internal: Defines whether a comment has to be marked as 'Internal' in Jira Service Desk (Default: False)\n        :type is_internal: bool\n        :rtype: Comment\n\n        \"\"\"\ndata = {'body': body}\nif is_internal:\n    data.update({'properties': [{'key': 'sd.public.comment', 'value': {\n        'internal': is_internal}}]})\nif visibility is not None:\n    data['visibility'] = visibility\nurl = self._get_url('issue/' + str(issue) + '/comment')\nr = self._session.post(url, data=json.dumps(data))\ncomment = Comment(self._options, self._session, raw=json_loads(r))\nreturn comment\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a comment Resource from the server for the specified ID.\n\n        :param issue: ID or key of the issue to get the comment from\n        :param comment: ID of the comment to get\n        \"\"\"\nreturn self._find_for_resource(Comment, (issue, comment))\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a comment Resource from the server for the specified ID.\n\n        :param issue: ID or key of the issue to get the comment from\n        :param comment: ID of the comment to get\n        \"\"\"\nreturn self._find_for_resource(Comment, (issue, comment))\ntranslate_resource_args",
        "CUT_5": "\"\"\"Update a comment\"\"\"\ndata = {}\nif body:\n    data['body'] = body\nif visibility:\n    data['visibility'] = visibility\nsuper(Comment, self).update(data)\n"
    },
    {
        "functionName": "test_add_comment_with_issue_obj",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.issue(self.issue_3)\ncomment = self.jira.add_comment(issue, 'a new test comment!', visibility={\n    'type': 'role', 'value': 'Administrators'})\nself.assertEqual(comment.body, 'a new test comment!')\nself.assertEqual(comment.visibility.type, 'role')\nself.assertEqual(comment.visibility.value, 'Administrators')\ncomment.delete()\n",
        "CUT_1": "\"\"\"Add a comment from the current authenticated user on the specified issue and return a Resource for it.\n\n        The issue identifier and comment body are required.\n\n        :param issue: ID or key of the issue to add the comment to\n        :type issue: str\n        :param body: Text of the comment to add\n        :type body: str\n        :param visibility: a dict containing two entries: \"type\" and \"value\".\n            \"type\" is 'role' (or 'group' if the Jira server has configured\n            comment visibility for groups) and 'value' is the name of the role\n            (or group) to which viewing of this comment will be restricted.\n        :type visibility: Optional[Dict[str, str]]\n        :param is_internal: Defines whether a comment has to be marked as 'Internal' in Jira Service Desk (Default: False)\n        :type is_internal: bool\n        :rtype: Comment\n\n        \"\"\"\ndata = {'body': body}\nif is_internal:\n    data.update({'properties': [{'key': 'sd.public.comment', 'value': {\n        'internal': is_internal}}]})\nif visibility is not None:\n    data['visibility'] = visibility\nurl = self._get_url('issue/' + str(issue) + '/comment')\nr = self._session.post(url, data=json.dumps(data))\ncomment = Comment(self._options, self._session, raw=json_loads(r))\nreturn comment\ntranslate_resource_args",
        "CUT_2": "\"\"\"Add a comment from the current authenticated user on the specified issue and return a Resource for it.\n\n        The issue identifier and comment body are required.\n\n        :param issue: ID or key of the issue to add the comment to\n        :type issue: str\n        :param body: Text of the comment to add\n        :type body: str\n        :param visibility: a dict containing two entries: \"type\" and \"value\".\n            \"type\" is 'role' (or 'group' if the Jira server has configured\n            comment visibility for groups) and 'value' is the name of the role\n            (or group) to which viewing of this comment will be restricted.\n        :type visibility: Optional[Dict[str, str]]\n        :param is_internal: Defines whether a comment has to be marked as 'Internal' in Jira Service Desk (Default: False)\n        :type is_internal: bool\n        :rtype: Comment\n\n        \"\"\"\ndata = {'body': body}\nif is_internal:\n    data.update({'properties': [{'key': 'sd.public.comment', 'value': {\n        'internal': is_internal}}]})\nif visibility is not None:\n    data['visibility'] = visibility\nurl = self._get_url('issue/' + str(issue) + '/comment')\nr = self._session.post(url, data=json.dumps(data))\ncomment = Comment(self._options, self._session, raw=json_loads(r))\nreturn comment\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a comment Resource from the server for the specified ID.\n\n        :param issue: ID or key of the issue to get the comment from\n        :param comment: ID of the comment to get\n        \"\"\"\nreturn self._find_for_resource(Comment, (issue, comment))\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a comment Resource from the server for the specified ID.\n\n        :param issue: ID or key of the issue to get the comment from\n        :param comment: ID of the comment to get\n        \"\"\"\nreturn self._find_for_resource(Comment, (issue, comment))\ntranslate_resource_args",
        "CUT_5": "\"\"\"Update a comment\"\"\"\ndata = {}\nif body:\n    data['body'] = body\nif visibility:\n    data['visibility'] = visibility\nsuper(Comment, self).update(data)\n"
    },
    {
        "functionName": "test_update_comment",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "comment = self.jira.add_comment(self.issue_3, 'updating soon!')\ncomment.update(body='updated!')\nself.assertEqual(comment.body, 'updated!')\ncomment.delete()\n",
        "CUT_1": "\"\"\"Get a comment Resource from the server for the specified ID.\n\n        :param issue: ID or key of the issue to get the comment from\n        :param comment: ID of the comment to get\n        \"\"\"\nreturn self._find_for_resource(Comment, (issue, comment))\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a comment Resource from the server for the specified ID.\n\n        :param issue: ID or key of the issue to get the comment from\n        :param comment: ID of the comment to get\n        \"\"\"\nreturn self._find_for_resource(Comment, (issue, comment))\ntranslate_resource_args",
        "CUT_3": "\"\"\"Add a comment from the current authenticated user on the specified issue and return a Resource for it.\n\n        The issue identifier and comment body are required.\n\n        :param issue: ID or key of the issue to add the comment to\n        :type issue: str\n        :param body: Text of the comment to add\n        :type body: str\n        :param visibility: a dict containing two entries: \"type\" and \"value\".\n            \"type\" is 'role' (or 'group' if the Jira server has configured\n            comment visibility for groups) and 'value' is the name of the role\n            (or group) to which viewing of this comment will be restricted.\n        :type visibility: Optional[Dict[str, str]]\n        :param is_internal: Defines whether a comment has to be marked as 'Internal' in Jira Service Desk (Default: False)\n        :type is_internal: bool\n        :rtype: Comment\n\n        \"\"\"\ndata = {'body': body}\nif is_internal:\n    data.update({'properties': [{'key': 'sd.public.comment', 'value': {\n        'internal': is_internal}}]})\nif visibility is not None:\n    data['visibility'] = visibility\nurl = self._get_url('issue/' + str(issue) + '/comment')\nr = self._session.post(url, data=json.dumps(data))\ncomment = Comment(self._options, self._session, raw=json_loads(r))\nreturn comment\ntranslate_resource_args",
        "CUT_4": "\"\"\"Add a comment from the current authenticated user on the specified issue and return a Resource for it.\n\n        The issue identifier and comment body are required.\n\n        :param issue: ID or key of the issue to add the comment to\n        :type issue: str\n        :param body: Text of the comment to add\n        :type body: str\n        :param visibility: a dict containing two entries: \"type\" and \"value\".\n            \"type\" is 'role' (or 'group' if the Jira server has configured\n            comment visibility for groups) and 'value' is the name of the role\n            (or group) to which viewing of this comment will be restricted.\n        :type visibility: Optional[Dict[str, str]]\n        :param is_internal: Defines whether a comment has to be marked as 'Internal' in Jira Service Desk (Default: False)\n        :type is_internal: bool\n        :rtype: Comment\n\n        \"\"\"\ndata = {'body': body}\nif is_internal:\n    data.update({'properties': [{'key': 'sd.public.comment', 'value': {\n        'internal': is_internal}}]})\nif visibility is not None:\n    data['visibility'] = visibility\nurl = self._get_url('issue/' + str(issue) + '/comment')\nr = self._session.post(url, data=json.dumps(data))\ncomment = Comment(self._options, self._session, raw=json_loads(r))\nreturn comment\ntranslate_resource_args",
        "CUT_5": "\"\"\"Update a comment\"\"\"\ndata = {}\nif body:\n    data['body'] = body\nif visibility:\n    data['visibility'] = visibility\nsuper(Comment, self).update(data)\n"
    },
    {
        "functionName": "test_editmeta",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "expected_fields = {'assignee', 'attachment', 'comment', 'components',\n    'description', 'environment', 'fixVersions', 'issuelinks', 'labels',\n    'summary', 'versions'}\nfor i in (self.issue_1, self.issue_2):\n    meta = self.jira.editmeta(i)\n    meta_field_set = set(meta['fields'].keys())\n    self.assertEqual(meta_field_set.intersection(expected_fields),\n        expected_fields)\n",
        "CUT_1": "\"\"\"Get the attachment metadata.\n\n        :rtype: Dict[str, int]\n        \"\"\"\nreturn self._get_json('attachment/meta')\n",
        "CUT_2": "\"\"\"Get the attachment metadata.\n\n        :rtype: Dict[str, int]\n        \"\"\"\nreturn self._get_json('attachment/meta')\n",
        "CUT_3": "self.attachment = None\n\"\"\" :type : list[Attachment] \"\"\"\nself.description = None\n\"\"\" :type : str \"\"\"\nself.project = None\n\"\"\" :type : Project \"\"\"\nself.comment = None\n\"\"\" :type : list[Comment] \"\"\"\nself.issuelinks = None\n\"\"\" :type : list[IssueLink] \"\"\"\nself.worklog = None\n\"\"\" :type : list[Worklog] \"\"\"\n",
        "CUT_4": "self.attachment = None\n\"\"\" :type : list[Attachment] \"\"\"\nself.description = None\n\"\"\" :type : str \"\"\"\nself.project = None\n\"\"\" :type : Project \"\"\"\nself.comment = None\n\"\"\" :type : list[Comment] \"\"\"\nself.issuelinks = None\n\"\"\" :type : list[IssueLink] \"\"\"\nself.worklog = None\n\"\"\" :type : list[Worklog] \"\"\"\n",
        "CUT_5": "trace('data', data)\nversions = tags_to_versions(tag_re.findall(data.get('ref-names', '')))\nif versions:\n    return meta(versions[0])\n"
    },
    {
        "functionName": "test_transitioning",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "transitions = []\nfor issue in [self.issue_2, self.jira.issue(self.issue_2)]:\n    transitions = self.jira.transitions(issue)\n    self.assertTrue(transitions)\n    self.assertTrue('id' in transitions[0])\n    self.assertTrue('name' in transitions[0])\nself.assertTrue(transitions, msg='Expecting at least one transition')\ntransition = self.jira.transitions(self.issue_2, transitions[0]['id'])[0]\nself.assertDictEqual(transition, transitions[0])\ntransition = self.jira.transitions(self.issue_2, transitions[0]['id'],\n    expand='transitions.fields')[0]\nself.assertTrue('fields' in transition)\n",
        "CUT_1": "\"\"\"Get a list of the transitions available on the specified issue to the current user.\n\n        :param issue: ID or key of the issue to get the transitions from\n        :param id: if present, get only the transition matching this ID\n        :param expand: extra information to fetch inside each transition\n        \"\"\"\nparams = {}\nif id is not None:\n    params['transitionId'] = id\nif expand is not None:\n    params['expand'] = expand\nreturn self._get_json('issue/' + str(issue) + '/transitions', params=params)[\n    'transitions']\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a list of the transitions available on the specified issue to the current user.\n\n        :param issue: ID or key of the issue to get the transitions from\n        :param id: if present, get only the transition matching this ID\n        :param expand: extra information to fetch inside each transition\n        \"\"\"\nparams = {}\nif id is not None:\n    params['transitionId'] = id\nif expand is not None:\n    params['expand'] = expand\nreturn self._get_json('issue/' + str(issue) + '/transitions', params=params)[\n    'transitions']\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a transitionid available on the specified issue to the current user.\n\n        Look at https://developer.atlassian.com/static/rest/jira/6.1.html#d2e1074 for json reference\n\n        :param issue: ID or key of the issue to get the transitions from\n        :param trans_name: iname of transition we are looking for\n        \"\"\"\ntransitions_json = self.transitions(issue)\nid = None\nfor transition in transitions_json:\n    if transition['name'].lower() == transition_name.lower():\n        id = transition['id']\n        break\nreturn id\n",
        "CUT_4": "\"\"\"Get a transitionid available on the specified issue to the current user.\n\n        Look at https://developer.atlassian.com/static/rest/jira/6.1.html#d2e1074 for json reference\n\n        :param issue: ID or key of the issue to get the transitions from\n        :param trans_name: iname of transition we are looking for\n        \"\"\"\ntransitions_json = self.transitions(issue)\nid = None\nfor transition in transitions_json:\n    if transition['name'].lower() == transition_name.lower():\n        id = transition['id']\n        break\nreturn id\n",
        "CUT_5": "\"\"\"Perform a transition on an issue.\n\n        Each keyword argument (other than the predefined ones) is treated as a field name and the argument's value\n        is treated as the intended value for that field -- if the fields argument is used, all other keyword arguments\n        will be ignored. Field values will be set on the issue as part of the transition process.\n\n        :param issue: ID or key of the issue to perform the transition on\n        :param transition: ID or name of the transition to perform\n        :param comment: *Optional* String to add as comment to the issue when\n            performing the transition.\n        :param fields: a dict containing field names and the values to use.\n            If present, all other keyword arguments will be ignored\n        \"\"\"\ntransitionId = None\ntry:\n    transitionId = int(transition)\nexcept Exception:\n    transitionId = self.find_transitionid_by_name(issue, transition)\n    if transitionId is None:\n        raise JIRAError('Invalid transition name. %s' % transition)\ndata = {'transition': {'id': transitionId}}\nif comment:\n    data['update'] = {'comment': [{'add': {'body': comment}}]}\nif worklog:\n    data['update'] = {'worklog': [{'add': {'timeSpent': worklog}}]}\nif fields is not None:\n    data['fields'] = fields\nelse:\n    fields_dict = {}\n    for field in fieldargs:\n        fields_dict[field] = fieldargs[field]\n    data['fields'] = fields_dict\nurl = self._get_url('issue/' + str(issue) + '/transitions')\nr = self._session.post(url, data=json.dumps(data))\ntry:\n    r_json = json_loads(r)\nexcept ValueError as e:\n    logging.error('%s\\n%s' % (e, r.text))\n    raise e\nreturn r_json\ntranslate_resource_args"
    },
    {
        "functionName": "test_votes",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "self.jira_normal.remove_vote(self.issue_1)\nvotes = self.jira.votes(self.issue_1)\nself.assertEqual(votes.votes, 0)\nself.jira_normal.add_vote(self.issue_1)\nnew_votes = self.jira.votes(self.issue_1)\nassert votes.votes + 1 == new_votes.votes\nself.jira_normal.remove_vote(self.issue_1)\nnew_votes = self.jira.votes(self.issue_1)\nassert votes.votes == new_votes.votes\n",
        "CUT_1": "\"\"\"Get a votes Resource from the server.\n\n        :param issue: ID or key of the issue to get the votes for\n        :rtype: Votes\n        \"\"\"\nreturn self._find_for_resource(Votes, issue)\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a votes Resource from the server.\n\n        :param issue: ID or key of the issue to get the votes for\n        :rtype: Votes\n        \"\"\"\nreturn self._find_for_resource(Votes, issue)\ntranslate_resource_args",
        "CUT_3": "Resource.__init__(self, 'issue/{0}/votes', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_4": "Resource.__init__(self, 'issue/{0}/votes', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_normal\nself.issue_1 = self.test_manager.project_b_issue1\n"
    },
    {
        "functionName": "test_votes_with_issue_obj",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira_normal.issue(self.issue_1)\nself.jira_normal.remove_vote(issue)\nvotes = self.jira.votes(issue)\nself.assertEqual(votes.votes, 0)\nself.jira_normal.add_vote(issue)\nnew_votes = self.jira.votes(issue)\nassert votes.votes + 1 == new_votes.votes\nself.jira_normal.remove_vote(issue)\nnew_votes = self.jira.votes(issue)\nassert votes.votes == new_votes.votes\n",
        "CUT_1": "\"\"\"Get a votes Resource from the server.\n\n        :param issue: ID or key of the issue to get the votes for\n        :rtype: Votes\n        \"\"\"\nreturn self._find_for_resource(Votes, issue)\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a votes Resource from the server.\n\n        :param issue: ID or key of the issue to get the votes for\n        :rtype: Votes\n        \"\"\"\nreturn self._find_for_resource(Votes, issue)\ntranslate_resource_args",
        "CUT_3": "Resource.__init__(self, 'issue/{0}/votes', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_4": "Resource.__init__(self, 'issue/{0}/votes', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_5": "\"\"\"Register a vote for the current authenticated user on an issue.\n\n        :param issue: ID or key of the issue to vote on\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('issue/' + str(issue) + '/votes')\nreturn self._session.post(url)\ntranslate_resource_args"
    },
    {
        "functionName": "test_add_remove_watcher",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "self.jira.remove_watcher(self.issue_1, self.test_manager.user_admin.accountId)\ninit_watchers = self.jira.watchers(self.issue_1).watchCount\nself.jira.add_watcher(self.issue_1, self.test_manager.user_admin.accountId)\nself.assertEqual(self.jira.watchers(self.issue_1).watchCount, init_watchers + 1\n    )\nself.jira.remove_watcher(self.issue_1, self.test_manager.user_admin.accountId)\nnew_watchers = self.jira.watchers(self.issue_1).watchCount\nself.assertEqual(init_watchers, new_watchers)\n",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_normal\nself.issue_1 = self.test_manager.project_b_issue1\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.attachment = None\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n"
    },
    {
        "functionName": "test_agile",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "uniq = rndstr()\nboard_name = 'board-' + uniq\nsprint_name = 'sprint-' + uniq\nb = self.jira.create_board(board_name, self.project_a)\nassert isinstance(b.id, int)\ns = self.jira.create_sprint(sprint_name, b.id)\nassert isinstance(s.id, int)\nassert s.name == sprint_name\nassert s.state == 'FUTURE'\nself.jira.add_issues_to_sprint(s.id, [self.issue_1])\nsprint_field_name = 'Sprint'\nsprint_field_id = [f['schema']['customId'] for f in self.jira.fields() if f\n    ['name'] == sprint_field_name][0]\nsprint_customfield = 'customfield_' + str(sprint_field_id)\nupdated_issue_1 = self.jira.issue(self.issue_1)\nserialised_sprint = getattr(updated_issue_1.fields, sprint_customfield)[0]\nassert re.search('\\\\[id=' + str(s.id) + ',', serialised_sprint)\nsleep(2)\ns.delete()\nsleep(2)\nb.delete()\nnot_on_custom_jira_instance",
        "CUT_1": "sprint_field_name = 'Sprint'\nsprint_field_id = [f['schema']['customId'] for f in self.fields() if f[\n    'name'] == sprint_field_name][0]\nreturn sprint_field_id\n",
        "CUT_2": "sprint_field_name = 'Sprint'\nsprint_field_id = [f['schema']['customId'] for f in self.fields() if f[\n    'name'] == sprint_field_name][0]\nreturn sprint_field_id\n",
        "CUT_3": "\"\"\"Delete attachment by id.\n\n        :param id: ID of the attachment to delete\n        :type id: str\n        \"\"\"\nurl = self._get_url('attachment/' + str(id))\nreturn self._session.delete(url)\n",
        "CUT_4": "\"\"\"Delete attachment by id.\n\n        :param id: ID of the attachment to delete\n        :type id: str\n        \"\"\"\nurl = self._get_url('attachment/' + str(id))\nreturn self._session.delete(url)\n",
        "CUT_5": "\"\"\"Delete component by id.\n\n        :param id: ID of the component to use\n        :type id: str\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('component/' + str(id))\nreturn self._session.delete(url)\n"
    },
    {
        "functionName": "test_worklogs",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "worklog = self.jira.add_worklog(self.issue_1, '2h')\nworklogs = self.jira.worklogs(self.issue_1)\nself.assertEqual(len(worklogs), 1)\nworklog.delete()\n",
        "CUT_1": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_normal\nself.issue_1 = self.test_manager.project_b_issue1\n"
    },
    {
        "functionName": "test_worklogs_with_issue_obj",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.issue(self.issue_1)\nworklog = self.jira.add_worklog(issue, '2h')\nworklogs = self.jira.worklogs(issue)\nself.assertEqual(len(worklogs), 1)\nworklog.delete()\n",
        "CUT_1": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_5": "Resource.__init__(self, 'issue/{0}/worklog/{1}', options, session)\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_worklog",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "worklog = self.jira.add_worklog(self.issue_1, '1d 2h')\nnew_worklog = self.jira.worklog(self.issue_1, str(worklog))\nself.assertEqual(new_worklog.author.name, self.test_manager.user_admin.name)\nself.assertEqual(new_worklog.timeSpent, '1d 2h')\nworklog.delete()\n",
        "CUT_1": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_normal\nself.issue_1 = self.test_manager.project_b_issue1\n",
        "CUT_4": "Resource.__init__(self, 'issue/{0}/worklog/{1}', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_5": "Resource.__init__(self, 'issue/{0}/worklog/{1}', options, session)\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_worklog_with_issue_obj",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.issue(self.issue_1)\nworklog = self.jira.add_worklog(issue, '1d 2h')\nnew_worklog = self.jira.worklog(issue, str(worklog))\nself.assertEqual(new_worklog.author.name, self.test_manager.user_admin.name)\nself.assertEqual(new_worklog.timeSpent, '1d 2h')\nworklog.delete()\n",
        "CUT_1": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args",
        "CUT_5": "Resource.__init__(self, 'issue/{0}/worklog/{1}', options, session)\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_add_worklog",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "worklog_count = len(self.jira.worklogs(self.issue_2))\nworklog = self.jira.add_worklog(self.issue_2, '2h')\nself.assertIsNotNone(worklog)\nself.assertEqual(len(self.jira.worklogs(self.issue_2)), worklog_count + 1)\nworklog.delete()\n",
        "CUT_1": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_5": "Resource.__init__(self, 'issue/{0}/worklog/{1}', options, session)\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_add_worklog_with_issue_obj",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issue = self.jira.issue(self.issue_2)\nworklog_count = len(self.jira.worklogs(issue))\nworklog = self.jira.add_worklog(issue, '2h')\nself.assertIsNotNone(worklog)\nself.assertEqual(len(self.jira.worklogs(issue)), worklog_count + 1)\nworklog.delete()\n",
        "CUT_1": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_5": "Resource.__init__(self, 'issue/{0}/worklog/{1}', options, session)\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_update_and_delete_worklog",
        "className": "IssueTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "worklog = self.jira.add_worklog(self.issue_3, '3h')\nissue = self.jira.issue(self.issue_3, fields='worklog,timetracking')\nworklog.update(comment='Updated!', timeSpent='2h')\nself.assertEqual(worklog.comment, 'Updated!')\nself.assertEqual(worklog.timeSpent, '2h')\nissue = self.jira.issue(self.issue_3, fields='worklog,timetracking')\nself.assertEqual(issue.fields.timetracking.remainingEstimate, '1h')\nworklog.delete()\nissue = self.jira.issue(self.issue_3, fields='worklog,timetracking')\nself.assertEqual(issue.fields.timetracking.remainingEstimate, '3h')\n",
        "CUT_1": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a specific worklog Resource from the server.\n\n        :param issue: ID or key of the issue to get the worklog from\n        :param id: ID of the worklog to get\n        :rtype: Worklog\n        \"\"\"\nreturn self._find_for_resource(Worklog, (issue, id))\ntranslate_resource_args",
        "CUT_3": "Resource.__init__(self, 'issue/{0}/worklog/{1}', options, session)\nself.remainingEstimate = None\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_4": "Resource.__init__(self, 'issue/{0}/worklog/{1}', options, session)\nself.remainingEstimate = None\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_5": "\"\"\"Get a list of worklog Resources from the server for an issue.\n\n        :param issue: ID or key of the issue to get worklogs from\n        :rtype: List[Worklog]\n        \"\"\"\nr_json = self._get_json('issue/' + str(issue) + '/worklog')\nworklogs = [Worklog(self._options, self._session, raw_worklog_json) for\n    raw_worklog_json in r_json['worklogs']]\nreturn worklogs\ntranslate_resource_args"
    },
    {
        "functionName": "test_issue_link",
        "className": "IssueLinkTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "self.link = self.manager.jira_admin.issue_link_type(self.link_types[0].id)\nlink = self.link\nself.assertEqual(link.id, self.link_types[0].id)\n",
        "CUT_1": "self.manager = JiraTestManager()\nself.link_types = self.manager.jira_admin.issue_link_types()\n",
        "CUT_2": "\"\"\"Get an issue link Resource from the server.\n\n        :param id: ID of the issue link to get\n        \"\"\"\nreturn self._find_for_resource(IssueLink, id)\n",
        "CUT_3": "\"\"\"Get an issue link Resource from the server.\n\n        :param id: ID of the issue link to get\n        \"\"\"\nreturn self._find_for_resource(IssueLink, id)\n",
        "CUT_4": "\"\"\"Get an issue link type Resource from the server.\n\n        :param id: ID of the issue link type to get\n        :type id: str\n        :rtype: IssueLinkType\n\n        \"\"\"\nreturn self._find_for_resource(IssueLinkType, id)\n",
        "CUT_5": "\"\"\"Get an issue link type Resource from the server.\n\n        :param id: ID of the issue link type to get\n        :type id: str\n        :rtype: IssueLinkType\n\n        \"\"\"\nreturn self._find_for_resource(IssueLinkType, id)\n"
    },
    {
        "functionName": "test_create_issue_link",
        "className": "IssueLinkTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "self.manager.jira_admin.create_issue_link(self.link_types[0].outward,\n    JiraTestManager().project_b_issue1, JiraTestManager().project_b_issue2)\n",
        "CUT_1": "self.manager = JiraTestManager()\nself.link_types = self.manager.jira_admin.issue_link_types()\n",
        "CUT_2": "self.manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_create_issue_link_with_issue_obj",
        "className": "IssueLinkTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "inwardissue = self.manager.jira_admin.issue(JiraTestManager().project_b_issue1)\nself.assertIsNotNone(inwardissue)\noutwardissue = self.manager.jira_admin.issue(JiraTestManager().project_b_issue2\n    )\nself.assertIsNotNone(outwardissue)\nself.manager.jira_admin.create_issue_link(self.link_types[0].outward,\n    inwardissue, outwardissue)\n",
        "CUT_1": "self.manager = JiraTestManager()\nself.link_types = self.manager.jira_admin.issue_link_types()\n",
        "CUT_2": "self.manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_issue_link_type",
        "className": "IssueLinkTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "link_type = self.manager.jira_admin.issue_link_type(self.link_types[0].id)\nself.assertEqual(link_type.id, self.link_types[0].id)\nself.assertEqual(link_type.name, self.link_types[0].name)\n",
        "CUT_1": "self.manager = JiraTestManager()\nself.link_types = self.manager.jira_admin.issue_link_types()\n",
        "CUT_2": "\"\"\"Comparison.\"\"\"\nreturn self.id == other.id and self.name == other.name\n",
        "CUT_3": "\"\"\"Comparison.\"\"\"\nreturn self.id == other.id and self.name == other.name\n",
        "CUT_4": "name = self._properties.get('name') or self._properties['target'].Name()\nreturn '<%s %r at 0x%x>' % (self.__class__.__name__, name, id(self))\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_my_permissions",
        "className": "MyPermissionsTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "perms = self.jira.my_permissions()\nself.assertGreaterEqual(len(perms['permissions']), 40)\n",
        "CUT_1": "return len(self.map)\n",
        "CUT_2": "return self\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_my_permissions_by_project",
        "className": "MyPermissionsTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "perms = self.jira.my_permissions(projectKey=self.test_manager.project_a)\nself.assertGreaterEqual(len(perms['permissions']), 10)\nperms = self.jira.my_permissions(projectId=self.test_manager.project_a_id)\nself.assertGreaterEqual(len(perms['permissions']), 10)\n",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\nself.test_username = 'test_%s' % self.test_manager.project_a\nself.test_email = '%s@example.com' % self.test_username\nself.test_password = rndpassword()\nself.test_groupname = 'testGroupFor_%s' % self.test_manager.project_a\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n"
    },
    {
        "functionName": "test_my_permissions_by_issue",
        "className": "MyPermissionsTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "perms = self.jira.my_permissions(issueKey='ZTRAVISDEB-7')\nself.assertGreaterEqual(len(perms['permissions']), 10)\nperms = self.jira.my_permissions(issueId='11021')\nself.assertGreaterEqual(len(perms['permissions']), 10)\nunittest.skip('broken')",
        "CUT_1": "\"\"\"Get a dict of all available permissions on the server.\n\n        :param projectKey: limit returned permissions to the specified project\n        :type projectKey: Optional[str]\n        :param projectId: limit returned permissions to the specified project\n        :type projectId: Optional[str]\n        :param issueKey: limit returned permissions to the specified issue\n        :type issueKey: Optional[str]\n        :param issueId: limit returned permissions to the specified issue\n        :type issueId: Optional[str]\n        :rtype: Dict[str, Dict[str, Dict[str, str]]]\n        \"\"\"\nparams = {}\nif projectKey is not None:\n    params['projectKey'] = projectKey\nif projectId is not None:\n    params['projectId'] = projectId\nif issueKey is not None:\n    params['issueKey'] = issueKey\nif issueId is not None:\n    params['issueId'] = issueId\nreturn self._get_json('mypermissions', params=params)\n",
        "CUT_2": "\"\"\"Get a dict of all available permissions on the server.\n\n        :param projectKey: limit returned permissions to the specified project\n        :type projectKey: Optional[str]\n        :param projectId: limit returned permissions to the specified project\n        :type projectId: Optional[str]\n        :param issueKey: limit returned permissions to the specified issue\n        :type issueKey: Optional[str]\n        :param issueId: limit returned permissions to the specified issue\n        :type issueId: Optional[str]\n        :rtype: Dict[str, Dict[str, Dict[str, str]]]\n        \"\"\"\nparams = {}\nif projectKey is not None:\n    params['projectKey'] = projectKey\nif projectId is not None:\n    params['projectId'] = projectId\nif issueKey is not None:\n    params['issueKey'] = issueKey\nif issueId is not None:\n    params['issueId'] = issueId\nreturn self._get_json('mypermissions', params=params)\n",
        "CUT_3": "name = self.path\nif name[-10:] == '.xcodeproj':\n    name = name[:-10]\nreturn posixpath.basename(name)\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\nif not self.jira.supports_service_desk():\n    pytest.skip('Skipping Service Desk not enabled')\ntry:\n    self.jira.delete_project(self.test_manager.project_sd)\nexcept Exception:\n    pass\n",
        "CUT_5": "return len(self.map)\n"
    },
    {
        "functionName": "test_priorities",
        "className": "PrioritiesTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "priorities = self.jira.priorities()\nself.assertEqual(len(priorities), 5)\n",
        "CUT_1": "\"\"\"Get a list of priority Resources from the server.\n\n        :rtype: List[Priority]\n\n        \"\"\"\nr_json = self._get_json('priority')\npriorities = [Priority(self._options, self._session, raw_priority_json) for\n    raw_priority_json in r_json]\nreturn priorities\n",
        "CUT_2": "\"\"\"Get a list of priority Resources from the server.\n\n        :rtype: List[Priority]\n\n        \"\"\"\nr_json = self._get_json('priority')\npriorities = [Priority(self._options, self._session, raw_priority_json) for\n    raw_priority_json in r_json]\nreturn priorities\n",
        "CUT_3": "return len(self.map)\n",
        "CUT_4": "return self\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_priority",
        "className": "PrioritiesTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "priority = self.jira.priority('2')\nself.assertEqual(priority.id, '2')\nself.assertEqual(priority.name, 'Critical')\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Get a priority Resource from the server.\n\n        :param id: ID of the priority to get\n        :type id: str\n        :rtype: Priority\n\n        \"\"\"\nreturn self._find_for_resource(Priority, id)\n",
        "CUT_2": "\"\"\"Get a priority Resource from the server.\n\n        :param id: ID of the priority to get\n        :type id: str\n        :rtype: Priority\n\n        \"\"\"\nreturn self._find_for_resource(Priority, id)\n",
        "CUT_3": "\"\"\"Get a list of priority Resources from the server.\n\n        :rtype: List[Priority]\n\n        \"\"\"\nr_json = self._get_json('priority')\npriorities = [Priority(self._options, self._session, raw_priority_json) for\n    raw_priority_json in r_json]\nreturn priorities\n",
        "CUT_4": "\"\"\"Get a list of priority Resources from the server.\n\n        :rtype: List[Priority]\n\n        \"\"\"\nr_json = self._get_json('priority')\npriorities = [Priority(self._options, self._session, raw_priority_json) for\n    raw_priority_json in r_json]\nreturn priorities\n",
        "CUT_5": "Resource.__init__(self, 'priority/{0}', options, session)\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_projects",
        "className": "ProjectTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "projects = self.jira.projects()\nself.assertGreaterEqual(len(projects), 2)\n",
        "CUT_1": "return self._GroupByName('Projects')\n",
        "CUT_2": "if len(sys.argv) < 2:\n    print('Usage: %s \"c:\\\\path\\\\to\\\\project.sln\"' % sys.argv[0])\n    return 1\nprojects, deps = ParseSolution(sys.argv[1])\nPrintDependencies(projects, deps)\nPrintBuildOrder(projects, deps)\nif '--recursive' in sys.argv:\n    PrintVCProj(projects)\nreturn 0\n",
        "CUT_3": "\"\"\"Get a list of project Resources from the server visible to the current authenticated user.\n\n        :rtype: List[Project]\n\n        \"\"\"\nr_json = self._get_json('project')\nprojects = [Project(self._options, self._session, raw_project_json) for\n    raw_project_json in r_json]\nreturn projects\n",
        "CUT_4": "\"\"\"Get a list of project Resources from the server visible to the current authenticated user.\n\n        :rtype: List[Project]\n\n        \"\"\"\nr_json = self._get_json('project')\nprojects = [Project(self._options, self._session, raw_project_json) for\n    raw_project_json in r_json]\nreturn projects\n",
        "CUT_5": "\"\"\"Create a MSVSProject object for the targets found in target list.\n\n  Arguments:\n    target_list: the list of targets to generate project objects for.\n    target_dicts: the dictionary of specifications.\n    options: global generator options.\n    msvs_version: the MSVSVersion object.\n  Returns:\n    A set of created projects, keyed by target.\n  \"\"\"\nglobal fixpath_prefix\nprojects = {}\nfor qualified_target in target_list:\n    spec = target_dicts[qualified_target]\n    if spec['toolset'] != 'target':\n        raise GypError(\n            'Multiple toolsets not supported in msvs build (target %s)' %\n            qualified_target)\n    proj_path, fixpath_prefix = _GetPathOfProject(qualified_target, spec,\n        options, msvs_version)\n    guid = _GetGuidOfProject(proj_path, spec)\n    overrides = _GetPlatformOverridesOfProject(spec)\n    build_file = gyp.common.BuildFile(qualified_target)\n    obj = MSVSNew.MSVSProject(proj_path, name=spec['target_name'], guid=\n        guid, spec=spec, build_file=build_file, config_platform_overrides=\n        overrides, fixpath_prefix=fixpath_prefix)\n    if msvs_version.UsesVcxproj():\n        obj.set_msbuild_toolset(_GetMsbuildToolsetOfProject(proj_path, spec,\n            msvs_version))\n    projects[qualified_target] = obj\nfor project in projects.values():\n    if not project.spec.get('msvs_external_builder'):\n        deps = project.spec.get('dependencies', [])\n        deps = [projects[d] for d in deps]\n        project.set_dependencies(deps)\nreturn projects\n"
    },
    {
        "functionName": "test_project",
        "className": "ProjectTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "project = self.jira.project(self.project_b)\nself.assertEqual(project.key, self.project_b)\n",
        "CUT_1": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\n",
        "CUT_2": "self.manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\n",
        "CUT_3": "\"\"\"Get a project Resource from the server.\n\n        :param id: ID or key of the project to get\n        :rtype: Project\n        \"\"\"\nreturn self._find_for_resource(Project, id)\n",
        "CUT_4": "\"\"\"Get a project Resource from the server.\n\n        :param id: ID or key of the project to get\n        :rtype: Project\n        \"\"\"\nreturn self._find_for_resource(Project, id)\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue1\n"
    },
    {
        "functionName": "test_project_components",
        "className": "ProjectTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "proj = self.jira.project(self.project_b)\nname = 'component-%s from project %s' % (proj, rndstr())\ncomponent = self.jira.create_component(name, proj, description='test!!',\n    assigneeType='COMPONENT_LEAD', isAssigneeTypeValid=False)\ncomponents = self.jira.project_components(self.project_b)\nself.assertGreaterEqual(len(components), 1)\nsample = find_by_id(components, component.id)\nself.assertEqual(sample.id, component.id)\nself.assertEqual(sample.name, name)\ncomponent.delete()\n",
        "CUT_1": "\"\"\"Get a list of component Resources present on a project.\n\n        :param project: ID or key of the project to get components from\n        :type project: str\n        :rtype: List[Component]\n        \"\"\"\nr_json = self._get_json('project/' + project + '/components')\ncomponents = [Component(self._options, self._session, raw_comp_json) for\n    raw_comp_json in r_json]\nreturn components\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a list of component Resources present on a project.\n\n        :param project: ID or key of the project to get components from\n        :type project: str\n        :rtype: List[Component]\n        \"\"\"\nr_json = self._get_json('project/' + project + '/components')\ncomponents = [Component(self._options, self._session, raw_comp_json) for\n    raw_comp_json in r_json]\nreturn components\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a component Resource from the server.\n\n        :param id: ID of the component to get\n        :type id: str\n        \"\"\"\nreturn self._find_for_resource(Component, id)\n",
        "CUT_4": "\"\"\"Get a component Resource from the server.\n\n        :param id: ID of the component to get\n        :type id: str\n        \"\"\"\nreturn self._find_for_resource(Component, id)\n",
        "CUT_5": "\"\"\"Delete component by id.\n\n        :param id: ID of the component to use\n        :type id: str\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('component/' + str(id))\nreturn self._session.delete(url)\n"
    },
    {
        "functionName": "test_project_versions",
        "className": "ProjectTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "name = 'version-%s' % rndstr()\nversion = self.jira.create_version(name, self.project_b, 'will be deleted soon'\n    )\nversions = self.jira.project_versions(self.project_b)\nself.assertGreaterEqual(len(versions), 1)\ntest = find_by_id(versions, version.id)\nself.assertEqual(test.id, version.id)\nself.assertEqual(test.name, name)\ni = self.jira.issue(JiraTestManager().project_b_issue1)\ni.update(fields={'versions': [{'id': version.id}], 'fixVersions': [{'id':\n    version.id}]})\nversion.delete()\n",
        "CUT_1": "\"\"\"Get a version Resource by its name present on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :param version_name: name of the version to search for\n        :type version_name: str\n        :rtype: Optional[Version]\n        \"\"\"\nversions = self.project_versions(project)\nfor version in versions:\n    if version.name == version_name:\n        return version\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a version Resource by its name present on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :param version_name: name of the version to search for\n        :type version_name: str\n        :rtype: Optional[Version]\n        \"\"\"\nversions = self.project_versions(project)\nfor version in versions:\n    if version.name == version_name:\n        return version\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a list of version Resources present on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :rtype: List[Version]\n        \"\"\"\nr_json = self._get_json('project/' + project + '/versions')\nversions = [Version(self._options, self._session, raw_ver_json) for\n    raw_ver_json in r_json]\nreturn versions\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a list of version Resources present on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :rtype: List[Version]\n        \"\"\"\nr_json = self._get_json('project/' + project + '/versions')\nversions = [Version(self._options, self._session, raw_ver_json) for\n    raw_ver_json in r_json]\nreturn versions\ntranslate_resource_args",
        "CUT_5": "\"\"\"Get a version Resource.\n\n        :param id: ID of the version to get\n        :type id: str\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[Any]\n\n        :rtype: Version\n        \"\"\"\nversion = Version(self._options, self._session)\nparams = {}\nif expand is not None:\n    params['expand'] = expand\nversion.find(id, params=params)\nreturn version\n"
    },
    {
        "functionName": "test_get_project_version_by_name",
        "className": "ProjectTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "name = 'version-%s' % rndstr()\nversion = self.jira.create_version(name, self.project_b, 'will be deleted soon'\n    )\nfound_version = self.jira.get_project_version_by_name(self.project_b, name)\nself.assertEqual(found_version.id, version.id)\nself.assertEqual(found_version.name, name)\nnot_found_version = self.jira.get_project_version_by_name(self.project_b,\n    'non-existent')\nself.assertEqual(not_found_version, None)\ni = self.jira.issue(JiraTestManager().project_b_issue1)\ni.update(fields={'versions': [{'id': version.id}], 'fixVersions': [{'id':\n    version.id}]})\nversion.delete()\n",
        "CUT_1": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue1\n",
        "CUT_2": "\"\"\"Get a version Resource.\n\n        :param id: ID of the version to get\n        :type id: str\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[Any]\n\n        :rtype: Version\n        \"\"\"\nversion = Version(self._options, self._session)\nparams = {}\nif expand is not None:\n    params['expand'] = expand\nversion.find(id, params=params)\nreturn version\n",
        "CUT_3": "\"\"\"Get a version Resource.\n\n        :param id: ID of the version to get\n        :type id: str\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[Any]\n\n        :rtype: Version\n        \"\"\"\nversion = Version(self._options, self._session)\nparams = {}\nif expand is not None:\n    params['expand'] = expand\nversion.find(id, params=params)\nreturn version\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\n",
        "CUT_5": "self.manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\n"
    },
    {
        "functionName": "test_rename_version",
        "className": "ProjectTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "old_name = 'version-%s' % rndstr()\nversion = self.jira.create_version(old_name, self.project_b,\n    'will be deleted soon')\nnew_name = old_name + '-renamed'\nself.jira.rename_version(self.project_b, old_name, new_name)\nfound_version = self.jira.get_project_version_by_name(self.project_b, new_name)\nself.assertEqual(found_version.id, version.id)\nself.assertEqual(found_version.name, new_name)\nnot_found_version = self.jira.get_project_version_by_name(self.project_b,\n    old_name)\nself.assertEqual(not_found_version, None)\ni = self.jira.issue(JiraTestManager().project_b_issue1)\ni.update(fields={'versions': [{'id': version.id}], 'fixVersions': [{'id':\n    version.id}]})\nversion.delete()\n",
        "CUT_1": "\"\"\"Rename a version Resource on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :param old_name: old name of the version to rename\n        :type old_name: str\n        :param new_name: new name of the version to rename\n        :type new_name: str\n        :rtype: None\n        \"\"\"\nversion = self.get_project_version_by_name(project, old_name)\nif version:\n    version.update(name=new_name)\ntranslate_resource_args",
        "CUT_2": "\"\"\"Rename a version Resource on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :param old_name: old name of the version to rename\n        :type old_name: str\n        :param new_name: new name of the version to rename\n        :type new_name: str\n        :rtype: None\n        \"\"\"\nversion = self.get_project_version_by_name(project, old_name)\nif version:\n    version.update(name=new_name)\ntranslate_resource_args",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue1\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\n",
        "CUT_5": "self.manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\n"
    },
    {
        "functionName": "test_project_versions_with_project_obj",
        "className": "ProjectTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "name = 'version-%s' % rndstr()\nversion = self.jira.create_version(name, self.project_b, 'will be deleted soon'\n    )\nproject = self.jira.project(self.project_b)\nversions = self.jira.project_versions(project)\nself.assertGreaterEqual(len(versions), 1)\ntest = find_by_id(versions, version.id)\nself.assertEqual(test.id, version.id)\nself.assertEqual(test.name, name)\nversion.delete()\n",
        "CUT_1": "\"\"\"Get a version Resource by its name present on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :param version_name: name of the version to search for\n        :type version_name: str\n        :rtype: Optional[Version]\n        \"\"\"\nversions = self.project_versions(project)\nfor version in versions:\n    if version.name == version_name:\n        return version\ntranslate_resource_args",
        "CUT_2": "\"\"\"Get a version Resource by its name present on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :param version_name: name of the version to search for\n        :type version_name: str\n        :rtype: Optional[Version]\n        \"\"\"\nversions = self.project_versions(project)\nfor version in versions:\n    if version.name == version_name:\n        return version\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a list of version Resources present on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :rtype: List[Version]\n        \"\"\"\nr_json = self._get_json('project/' + project + '/versions')\nversions = [Version(self._options, self._session, raw_ver_json) for\n    raw_ver_json in r_json]\nreturn versions\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a list of version Resources present on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :rtype: List[Version]\n        \"\"\"\nr_json = self._get_json('project/' + project + '/versions')\nversions = [Version(self._options, self._session, raw_ver_json) for\n    raw_ver_json in r_json]\nreturn versions\ntranslate_resource_args",
        "CUT_5": "\"\"\"Rename a version Resource on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :param old_name: old name of the version to rename\n        :type old_name: str\n        :param new_name: new name of the version to rename\n        :type new_name: str\n        :rtype: None\n        \"\"\"\nversion = self.get_project_version_by_name(project, old_name)\nif version:\n    version.update(name=new_name)\ntranslate_resource_args"
    },
    {
        "functionName": "test_project_roles",
        "className": "ProjectTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "project = self.jira.project(self.project_b)\nrole_name = 'Developers'\ndev = None\nfor roles in [self.jira.project_roles(self.project_b), self.jira.\n    project_roles(project)]:\n    self.assertGreaterEqual(len(roles), 5)\n    self.assertIn('Users', roles)\n    self.assertIn(role_name, roles)\n    dev = roles[role_name]\nself.assertTrue(dev)\nrole = self.jira.project_role(self.project_b, dev.id)\nself.assertEqual(role.id, dev.id)\nself.assertEqual(role.name, dev.name)\nuser = self.test_manager.jira_admin\nself.assertNotIn(user, role.actors)\nrole.update(users=user, groups=['jira-developers', 'jira-users'])\nrole = self.jira.project_role(self.project_b, dev.id)\nself.assertIn(user, role.actors)\nunittest.skip(\n    'temporary disabled because roles() return a dictionary of role_name:role_url and we have no call to convert it to proper Role()'\n    )",
        "CUT_1": "\"\"\"Return Jira role information.\n\n        :return: List of current user roles\n        :rtype: Iterable\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/role'\nr = self._session.get(url)\nreturn json_loads(r)\n",
        "CUT_2": "\"\"\"Return Jira role information.\n\n        :return: List of current user roles\n        :rtype: Iterable\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/role'\nr = self._session.get(url)\nreturn json_loads(r)\n",
        "CUT_3": "\"\"\"Get a role Resource.\n\n        :param project: ID or key of the project to get the role from\n        :param id: ID of the role to get\n        \"\"\"\nif isinstance(id, Number):\n    id = '%s' % id\nreturn self._find_for_resource(Role, (project, id))\ntranslate_resource_args",
        "CUT_4": "\"\"\"Get a role Resource.\n\n        :param project: ID or key of the project to get the role from\n        :param id: ID of the role to get\n        \"\"\"\nif isinstance(id, Number):\n    id = '%s' % id\nreturn self._find_for_resource(Role, (project, id))\ntranslate_resource_args",
        "CUT_5": "if '.dev' not in version:\n    return\nprefix, tail = version.rsplit('.dev', 1)\nassert tail == '0', 'own dev numbers are unsupported'\nreturn prefix\n"
    },
    {
        "functionName": "test_resolutions",
        "className": "ResolutionTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "resolutions = self.jira.resolutions()\nself.assertGreaterEqual(len(resolutions), 1)\n",
        "CUT_1": "\"\"\"Get a list of resolution Resources from the server.\n\n        :rtype: List[Resolution]\n\n        \"\"\"\nr_json = self._get_json('resolution')\nresolutions = [Resolution(self._options, self._session, raw_res_json) for\n    raw_res_json in r_json]\nreturn resolutions\n",
        "CUT_2": "\"\"\"Get a list of resolution Resources from the server.\n\n        :rtype: List[Resolution]\n\n        \"\"\"\nr_json = self._get_json('resolution')\nresolutions = [Resolution(self._options, self._session, raw_res_json) for\n    raw_res_json in r_json]\nreturn resolutions\n",
        "CUT_3": "return len(self.map)\n",
        "CUT_4": "return self\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_resolution",
        "className": "ResolutionTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "resolution = self.jira.resolution('2')\nself.assertEqual(resolution.id, '2')\nself.assertEqual(resolution.name, \"Won't Fix\")\n",
        "CUT_1": "\"\"\"Get a resolution Resource from the server.\n\n        :param id: ID of the resolution to get\n        :type id: str\n        :rtype: Resolution\n        \"\"\"\nreturn self._find_for_resource(Resolution, id)\n",
        "CUT_2": "\"\"\"Get a resolution Resource from the server.\n\n        :param id: ID of the resolution to get\n        :type id: str\n        :rtype: Resolution\n        \"\"\"\nreturn self._find_for_resource(Resolution, id)\n",
        "CUT_3": "\"\"\"Get a list of resolution Resources from the server.\n\n        :rtype: List[Resolution]\n\n        \"\"\"\nr_json = self._get_json('resolution')\nresolutions = [Resolution(self._options, self._session, raw_res_json) for\n    raw_res_json in r_json]\nreturn resolutions\n",
        "CUT_4": "\"\"\"Get a list of resolution Resources from the server.\n\n        :rtype: List[Resolution]\n\n        \"\"\"\nr_json = self._get_json('resolution')\nresolutions = [Resolution(self._options, self._session, raw_res_json) for\n    raw_res_json in r_json]\nreturn resolutions\n",
        "CUT_5": "Resource.__init__(self, 'resolution/{0}', options, session)\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_search_issues",
        "className": "SearchTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issues = self.jira.search_issues('project=%s' % self.project_b)\nself.assertLessEqual(len(issues), 50)\nfor issue in issues:\n    self.assertTrue(issue.key.startswith(self.project_b))\n",
        "CUT_1": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue1\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\n",
        "CUT_3": "\"\"\"Returns a minimal json object for Jira issue search results. \"\"\"\nreturn {'startAt': kwargs.get('start_at', 0), 'maxResults': kwargs.get(\n    'max_results', 50), 'total': kwargs.get('total', len(issues)), 'issues':\n    issues}\n",
        "CUT_4": "self.manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\n",
        "CUT_5": "self.__dict__ = self.__shared_state\nif not self.__dict__:\n    self.initialized = 0\n    if 'CI_JIRA_URL' in os.environ:\n        self.CI_JIRA_URL = os.environ['CI_JIRA_URL']\n        self.max_retries = 5\n    else:\n        self.CI_JIRA_URL = 'https://pycontribs.atlassian.net'\n        self.max_retries = 5\n    if 'CI_JIRA_ADMIN' in os.environ:\n        self.CI_JIRA_ADMIN = os.environ['CI_JIRA_ADMIN']\n    else:\n        self.CI_JIRA_ADMIN = 'ci-admin'\n    if 'CI_JIRA_ADMIN_PASSWORD' in os.environ:\n        self.CI_JIRA_ADMIN_PASSWORD = os.environ['CI_JIRA_ADMIN_PASSWORD']\n    else:\n        self.CI_JIRA_ADMIN_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    if 'CI_JIRA_USER' in os.environ:\n        self.CI_JIRA_USER = os.environ['CI_JIRA_USER']\n    else:\n        self.CI_JIRA_USER = 'ci-user'\n    if 'CI_JIRA_USER_PASSWORD' in os.environ:\n        self.CI_JIRA_USER_PASSWORD = os.environ['CI_JIRA_USER_PASSWORD']\n    else:\n        self.CI_JIRA_USER_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    self.CI_JIRA_ISSUE = os.environ.get('CI_JIRA_ISSUE', 'Bug')\n    if OAUTH:\n        self.jira_admin = JIRA(oauth={'access_token':\n            'hTxcwsbUQiFuFALf7KZHDaeAJIo3tLUK', 'access_token_secret':\n            'aNCLQFP3ORNU6WY7HQISbqbhf0UudDAf', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    if not self.jira_admin.current_user():\n        self.initialized = 1\n        sys.exit(3)\n    if OAUTH:\n        self.jira_sysadmin = JIRA(oauth={'access_token':\n            '4ul1ETSFo7ybbIxAxzyRal39cTrwEGFv', 'access_token_secret':\n            'K83jBZnjnuVRcfjBflrKyThJa0KSjSs2', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA}, logging=False,\n            max_retries=self.max_retries)\n    elif self.CI_JIRA_ADMIN:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, logging=False,\n            max_retries=self.max_retries)\n    if OAUTH:\n        self.jira_normal = JIRA(oauth={'access_token':\n            'ZVDgYDyIQqJY8IFlQ446jZaURIz5ECiB', 'access_token_secret':\n            '5WbLBybPDg1lqqyFjyXSCsCtAWTwz1eD', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_USER, self.CI_JIRA_USER_PASSWORD), validate=True,\n            logging=False, max_retries=self.max_retries)\n    else:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    \"\"\" `jid` is important for avoiding concurency problems when\n            executing tests in parallel as we have only one test instance.\n\n            jid length must be less than 9 characters because we may append\n            another one and the Jira Project key length limit is 10.\n\n            Tests run in parallel:\n            * git branches master or developer, git pr or developers running\n                tests outside Travis\n            * Travis is using \"Travis\" username\n\n            https://docs.travis-ci.com/user/environment-variables/\n            \"\"\"\n    self.jid = get_unique_project_name()\n    self.project_a = self.jid + 'A'\n    self.project_a_name = 'Test user=%s key=%s A' % (getpass.getuser(),\n        self.project_a)\n    self.project_b = self.jid + 'B'\n    self.project_b_name = 'Test user=%s key=%s B' % (getpass.getuser(),\n        self.project_b)\n    self.project_sd = self.jid + 'C'\n    self.project_sd_name = 'Test user=%s key=%s C' % (getpass.getuser(),\n        self.project_b)\n    try:\n        self.jira_admin.project(self.project_a)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_a)\n        except Exception as e:\n            pass\n    try:\n        self.jira_admin.project(self.project_b)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_b)\n        except Exception as e:\n            pass\n    for i in range(1, 20):\n        try:\n            self.jira_admin.project(self.project_b)\n        except Exception:\n            break\n        print('Warning: Project not deleted yet....')\n        sleep(2)\n    for i in range(6):\n        try:\n            if self.jira_admin.create_project(self.project_a, self.\n                project_a_name):\n                break\n        except Exception as e:\n            if 'A project with that name already exists' not in e.text:\n                raise e\n    self.project_a_id = self.jira_admin.project(self.project_a).id\n    self.jira_admin.create_project(self.project_b, self.project_b_name)\n    try:\n        self.jira_admin.create_project(self.project_b, self.project_b_name)\n    except Exception:\n        pass\n    sleep(1)\n    self.project_b_issue1_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 1 from %s' % self.project_b, issuetype=\n        self.CI_JIRA_ISSUE)\n    self.project_b_issue1 = self.project_b_issue1_obj.key\n    self.project_b_issue2_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 2 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue2 = self.project_b_issue2_obj.key\n    self.project_b_issue3_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 3 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue3 = self.project_b_issue3_obj.key\nif not hasattr(self, 'jira_normal') or not hasattr(self, 'jira_admin'):\n    py.test.exit('FATAL: WTF!?')\nself.user_admin = self.jira_admin.search_users(self.CI_JIRA_ADMIN)[0]\nself.initialized = 1\n"
    },
    {
        "functionName": "test_search_issues_async",
        "className": "SearchTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "original_val = self.jira._options['async']\ntry:\n    self.jira._options['async'] = True\n    issues = self.jira.search_issues('project=%s' % self.project_b,\n        maxResults=False)\n    self.assertEqual(len(issues), issues.total)\n    for issue in issues:\n        self.assertTrue(issue.key.startswith(self.project_b))\nfinally:\n    self.jira._options['async'] = original_val\n",
        "CUT_1": "\"\"\"Returns a minimal json object for Jira issue search results. \"\"\"\nreturn {'startAt': kwargs.get('start_at', 0), 'maxResults': kwargs.get(\n    'max_results', 50), 'total': kwargs.get('total', len(issues)), 'issues':\n    issues}\n",
        "CUT_2": "self.__dict__ = self.__shared_state\nif not self.__dict__:\n    self.initialized = 0\n    if 'CI_JIRA_URL' in os.environ:\n        self.CI_JIRA_URL = os.environ['CI_JIRA_URL']\n        self.max_retries = 5\n    else:\n        self.CI_JIRA_URL = 'https://pycontribs.atlassian.net'\n        self.max_retries = 5\n    if 'CI_JIRA_ADMIN' in os.environ:\n        self.CI_JIRA_ADMIN = os.environ['CI_JIRA_ADMIN']\n    else:\n        self.CI_JIRA_ADMIN = 'ci-admin'\n    if 'CI_JIRA_ADMIN_PASSWORD' in os.environ:\n        self.CI_JIRA_ADMIN_PASSWORD = os.environ['CI_JIRA_ADMIN_PASSWORD']\n    else:\n        self.CI_JIRA_ADMIN_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    if 'CI_JIRA_USER' in os.environ:\n        self.CI_JIRA_USER = os.environ['CI_JIRA_USER']\n    else:\n        self.CI_JIRA_USER = 'ci-user'\n    if 'CI_JIRA_USER_PASSWORD' in os.environ:\n        self.CI_JIRA_USER_PASSWORD = os.environ['CI_JIRA_USER_PASSWORD']\n    else:\n        self.CI_JIRA_USER_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    self.CI_JIRA_ISSUE = os.environ.get('CI_JIRA_ISSUE', 'Bug')\n    if OAUTH:\n        self.jira_admin = JIRA(oauth={'access_token':\n            'hTxcwsbUQiFuFALf7KZHDaeAJIo3tLUK', 'access_token_secret':\n            'aNCLQFP3ORNU6WY7HQISbqbhf0UudDAf', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    if not self.jira_admin.current_user():\n        self.initialized = 1\n        sys.exit(3)\n    if OAUTH:\n        self.jira_sysadmin = JIRA(oauth={'access_token':\n            '4ul1ETSFo7ybbIxAxzyRal39cTrwEGFv', 'access_token_secret':\n            'K83jBZnjnuVRcfjBflrKyThJa0KSjSs2', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA}, logging=False,\n            max_retries=self.max_retries)\n    elif self.CI_JIRA_ADMIN:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, logging=False,\n            max_retries=self.max_retries)\n    if OAUTH:\n        self.jira_normal = JIRA(oauth={'access_token':\n            'ZVDgYDyIQqJY8IFlQ446jZaURIz5ECiB', 'access_token_secret':\n            '5WbLBybPDg1lqqyFjyXSCsCtAWTwz1eD', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_USER, self.CI_JIRA_USER_PASSWORD), validate=True,\n            logging=False, max_retries=self.max_retries)\n    else:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    \"\"\" `jid` is important for avoiding concurency problems when\n            executing tests in parallel as we have only one test instance.\n\n            jid length must be less than 9 characters because we may append\n            another one and the Jira Project key length limit is 10.\n\n            Tests run in parallel:\n            * git branches master or developer, git pr or developers running\n                tests outside Travis\n            * Travis is using \"Travis\" username\n\n            https://docs.travis-ci.com/user/environment-variables/\n            \"\"\"\n    self.jid = get_unique_project_name()\n    self.project_a = self.jid + 'A'\n    self.project_a_name = 'Test user=%s key=%s A' % (getpass.getuser(),\n        self.project_a)\n    self.project_b = self.jid + 'B'\n    self.project_b_name = 'Test user=%s key=%s B' % (getpass.getuser(),\n        self.project_b)\n    self.project_sd = self.jid + 'C'\n    self.project_sd_name = 'Test user=%s key=%s C' % (getpass.getuser(),\n        self.project_b)\n    try:\n        self.jira_admin.project(self.project_a)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_a)\n        except Exception as e:\n            pass\n    try:\n        self.jira_admin.project(self.project_b)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_b)\n        except Exception as e:\n            pass\n    for i in range(1, 20):\n        try:\n            self.jira_admin.project(self.project_b)\n        except Exception:\n            break\n        print('Warning: Project not deleted yet....')\n        sleep(2)\n    for i in range(6):\n        try:\n            if self.jira_admin.create_project(self.project_a, self.\n                project_a_name):\n                break\n        except Exception as e:\n            if 'A project with that name already exists' not in e.text:\n                raise e\n    self.project_a_id = self.jira_admin.project(self.project_a).id\n    self.jira_admin.create_project(self.project_b, self.project_b_name)\n    try:\n        self.jira_admin.create_project(self.project_b, self.project_b_name)\n    except Exception:\n        pass\n    sleep(1)\n    self.project_b_issue1_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 1 from %s' % self.project_b, issuetype=\n        self.CI_JIRA_ISSUE)\n    self.project_b_issue1 = self.project_b_issue1_obj.key\n    self.project_b_issue2_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 2 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue2 = self.project_b_issue2_obj.key\n    self.project_b_issue3_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 3 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue3 = self.project_b_issue3_obj.key\nif not hasattr(self, 'jira_normal') or not hasattr(self, 'jira_admin'):\n    py.test.exit('FATAL: WTF!?')\nself.user_admin = self.jira_admin.search_users(self.CI_JIRA_ADMIN)[0]\nself.initialized = 1\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue1\n",
        "CUT_4": "\"\"\"Return the completed issues for the sprint.\"\"\"\nr_json = self._get_json(\n    'rapid/charts/sprintreport?rapidViewId=%s&sprintId=%s' % (board_id,\n    sprint_id), base=self.AGILE_BASE_URL)\nissues = [Issue(self._options, self._session, raw_issues_json) for\n    raw_issues_json in r_json['contents']['puntedIssues']]\nreturn issues\n",
        "CUT_5": "\"\"\"Return the completed issues for the sprint.\"\"\"\nr_json = self._get_json(\n    'rapid/charts/sprintreport?rapidViewId=%s&sprintId=%s' % (board_id,\n    sprint_id), base=self.AGILE_BASE_URL)\nissues = [Issue(self._options, self._session, raw_issues_json) for\n    raw_issues_json in r_json['contents']['puntedIssues']]\nreturn issues\n"
    },
    {
        "functionName": "test_search_issues_maxresults",
        "className": "SearchTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issues = self.jira.search_issues('project=%s' % self.project_b, maxResults=10)\nself.assertLessEqual(len(issues), 10)\n",
        "CUT_1": "name = self.path\nif name[-10:] == '.xcodeproj':\n    name = name[:-10]\nreturn posixpath.basename(name)\n",
        "CUT_2": "\"\"\"Returns a minimal json object for Jira issue search results. \"\"\"\nreturn {'startAt': kwargs.get('start_at', 0), 'maxResults': kwargs.get(\n    'max_results', 50), 'total': kwargs.get('total', len(issues)), 'issues':\n    issues}\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\n",
        "CUT_4": "self.__dict__ = self.__shared_state\nif not self.__dict__:\n    self.initialized = 0\n    if 'CI_JIRA_URL' in os.environ:\n        self.CI_JIRA_URL = os.environ['CI_JIRA_URL']\n        self.max_retries = 5\n    else:\n        self.CI_JIRA_URL = 'https://pycontribs.atlassian.net'\n        self.max_retries = 5\n    if 'CI_JIRA_ADMIN' in os.environ:\n        self.CI_JIRA_ADMIN = os.environ['CI_JIRA_ADMIN']\n    else:\n        self.CI_JIRA_ADMIN = 'ci-admin'\n    if 'CI_JIRA_ADMIN_PASSWORD' in os.environ:\n        self.CI_JIRA_ADMIN_PASSWORD = os.environ['CI_JIRA_ADMIN_PASSWORD']\n    else:\n        self.CI_JIRA_ADMIN_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    if 'CI_JIRA_USER' in os.environ:\n        self.CI_JIRA_USER = os.environ['CI_JIRA_USER']\n    else:\n        self.CI_JIRA_USER = 'ci-user'\n    if 'CI_JIRA_USER_PASSWORD' in os.environ:\n        self.CI_JIRA_USER_PASSWORD = os.environ['CI_JIRA_USER_PASSWORD']\n    else:\n        self.CI_JIRA_USER_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    self.CI_JIRA_ISSUE = os.environ.get('CI_JIRA_ISSUE', 'Bug')\n    if OAUTH:\n        self.jira_admin = JIRA(oauth={'access_token':\n            'hTxcwsbUQiFuFALf7KZHDaeAJIo3tLUK', 'access_token_secret':\n            'aNCLQFP3ORNU6WY7HQISbqbhf0UudDAf', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    if not self.jira_admin.current_user():\n        self.initialized = 1\n        sys.exit(3)\n    if OAUTH:\n        self.jira_sysadmin = JIRA(oauth={'access_token':\n            '4ul1ETSFo7ybbIxAxzyRal39cTrwEGFv', 'access_token_secret':\n            'K83jBZnjnuVRcfjBflrKyThJa0KSjSs2', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA}, logging=False,\n            max_retries=self.max_retries)\n    elif self.CI_JIRA_ADMIN:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, logging=False,\n            max_retries=self.max_retries)\n    if OAUTH:\n        self.jira_normal = JIRA(oauth={'access_token':\n            'ZVDgYDyIQqJY8IFlQ446jZaURIz5ECiB', 'access_token_secret':\n            '5WbLBybPDg1lqqyFjyXSCsCtAWTwz1eD', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_USER, self.CI_JIRA_USER_PASSWORD), validate=True,\n            logging=False, max_retries=self.max_retries)\n    else:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    \"\"\" `jid` is important for avoiding concurency problems when\n            executing tests in parallel as we have only one test instance.\n\n            jid length must be less than 9 characters because we may append\n            another one and the Jira Project key length limit is 10.\n\n            Tests run in parallel:\n            * git branches master or developer, git pr or developers running\n                tests outside Travis\n            * Travis is using \"Travis\" username\n\n            https://docs.travis-ci.com/user/environment-variables/\n            \"\"\"\n    self.jid = get_unique_project_name()\n    self.project_a = self.jid + 'A'\n    self.project_a_name = 'Test user=%s key=%s A' % (getpass.getuser(),\n        self.project_a)\n    self.project_b = self.jid + 'B'\n    self.project_b_name = 'Test user=%s key=%s B' % (getpass.getuser(),\n        self.project_b)\n    self.project_sd = self.jid + 'C'\n    self.project_sd_name = 'Test user=%s key=%s C' % (getpass.getuser(),\n        self.project_b)\n    try:\n        self.jira_admin.project(self.project_a)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_a)\n        except Exception as e:\n            pass\n    try:\n        self.jira_admin.project(self.project_b)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_b)\n        except Exception as e:\n            pass\n    for i in range(1, 20):\n        try:\n            self.jira_admin.project(self.project_b)\n        except Exception:\n            break\n        print('Warning: Project not deleted yet....')\n        sleep(2)\n    for i in range(6):\n        try:\n            if self.jira_admin.create_project(self.project_a, self.\n                project_a_name):\n                break\n        except Exception as e:\n            if 'A project with that name already exists' not in e.text:\n                raise e\n    self.project_a_id = self.jira_admin.project(self.project_a).id\n    self.jira_admin.create_project(self.project_b, self.project_b_name)\n    try:\n        self.jira_admin.create_project(self.project_b, self.project_b_name)\n    except Exception:\n        pass\n    sleep(1)\n    self.project_b_issue1_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 1 from %s' % self.project_b, issuetype=\n        self.CI_JIRA_ISSUE)\n    self.project_b_issue1 = self.project_b_issue1_obj.key\n    self.project_b_issue2_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 2 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue2 = self.project_b_issue2_obj.key\n    self.project_b_issue3_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 3 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue3 = self.project_b_issue3_obj.key\nif not hasattr(self, 'jira_normal') or not hasattr(self, 'jira_admin'):\n    py.test.exit('FATAL: WTF!?')\nself.user_admin = self.jira_admin.search_users(self.CI_JIRA_ADMIN)[0]\nself.initialized = 1\n",
        "CUT_5": "self.manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\n"
    },
    {
        "functionName": "test_search_issues_startat",
        "className": "SearchTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issues = self.jira.search_issues('project=%s' % self.project_b, startAt=2,\n    maxResults=10)\nself.assertGreaterEqual(len(issues), 1)\n",
        "CUT_1": "\"\"\"Returns a minimal json object for Jira issue search results. \"\"\"\nreturn {'startAt': kwargs.get('start_at', 0), 'maxResults': kwargs.get(\n    'max_results', 50), 'total': kwargs.get('total', len(issues)), 'issues':\n    issues}\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\n",
        "CUT_3": "self.manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\n",
        "CUT_4": "\"\"\"Get a :class:`~jira.client.ResultList` of issue Resources matching a JQL search string.\n\n        :param jql_str: The JQL search string.\n        :type jql_str: str\n        :param startAt: Index of the first issue to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of issues to return. Total number of results\n            is available in the ``total`` attribute of the returned :class:`~jira.client.ResultList`.\n            If maxResults evaluates as False, it will try to get all issues in batches. (Default: 50)\n        :type maxResults: int\n        :param validate_query: Whether or not the query should be validated. (Default: True)\n        :type validate_query: bool\n        :param fields: comma-separated string or list of issue fields to include in the results.\n            Default is to include all fields.\n        :type fields: Optional[str or list]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :param json_result: JSON response will be returned when this parameter is set to True.\n                Otherwise, :class:`~jira.client.ResultList` will be returned.\n        :type json_result: bool\n\n        :rtype: dict or :class:`~jira.client.ResultList`\n\n        \"\"\"\nif isinstance(fields, str):\n    fields = fields.split(',')\nelse:\n    fields = list(fields or [])\nuntranslate = {}\nif self._fields:\n    for i, field in enumerate(fields):\n        if field in self._fields:\n            untranslate[self._fields[field]] = fields[i]\n            fields[i] = self._fields[field]\nsearch_params = {'jql': jql_str, 'startAt': startAt, 'validateQuery':\n    validate_query, 'fields': fields, 'expand': expand}\nif json_result:\n    search_params['maxResults'] = maxResults\n    if not maxResults:\n        warnings.warn(\n            'All issues cannot be fetched at once, when json_result parameter is set'\n            , Warning)\n    return self._get_json('search', params=search_params)\nissues = self._fetch_pages(Issue, 'issues', 'search', startAt, maxResults,\n    search_params)\nif untranslate:\n    for i in issues:\n        for k, v in untranslate.items():\n            if k in i.raw.get('fields', {}):\n                i.raw['fields'][v] = i.raw['fields'][k]\nreturn issues\n",
        "CUT_5": "\"\"\"Get a :class:`~jira.client.ResultList` of issue Resources matching a JQL search string.\n\n        :param jql_str: The JQL search string.\n        :type jql_str: str\n        :param startAt: Index of the first issue to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of issues to return. Total number of results\n            is available in the ``total`` attribute of the returned :class:`~jira.client.ResultList`.\n            If maxResults evaluates as False, it will try to get all issues in batches. (Default: 50)\n        :type maxResults: int\n        :param validate_query: Whether or not the query should be validated. (Default: True)\n        :type validate_query: bool\n        :param fields: comma-separated string or list of issue fields to include in the results.\n            Default is to include all fields.\n        :type fields: Optional[str or list]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :param json_result: JSON response will be returned when this parameter is set to True.\n                Otherwise, :class:`~jira.client.ResultList` will be returned.\n        :type json_result: bool\n\n        :rtype: dict or :class:`~jira.client.ResultList`\n\n        \"\"\"\nif isinstance(fields, str):\n    fields = fields.split(',')\nelse:\n    fields = list(fields or [])\nuntranslate = {}\nif self._fields:\n    for i, field in enumerate(fields):\n        if field in self._fields:\n            untranslate[self._fields[field]] = fields[i]\n            fields[i] = self._fields[field]\nsearch_params = {'jql': jql_str, 'startAt': startAt, 'validateQuery':\n    validate_query, 'fields': fields, 'expand': expand}\nif json_result:\n    search_params['maxResults'] = maxResults\n    if not maxResults:\n        warnings.warn(\n            'All issues cannot be fetched at once, when json_result parameter is set'\n            , Warning)\n    return self._get_json('search', params=search_params)\nissues = self._fetch_pages(Issue, 'issues', 'search', startAt, maxResults,\n    search_params)\nif untranslate:\n    for i in issues:\n        for k, v in untranslate.items():\n            if k in i.raw.get('fields', {}):\n                i.raw['fields'][v] = i.raw['fields'][k]\nreturn issues\n"
    },
    {
        "functionName": "test_search_issues_field_limiting",
        "className": "SearchTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issues = self.jira.search_issues('key=%s' % self.issue, fields=\n    'summary,comment')\nself.assertTrue(hasattr(issues[0].fields, 'summary'))\nself.assertTrue(hasattr(issues[0].fields, 'comment'))\nself.assertFalse(hasattr(issues[0].fields, 'reporter'))\nself.assertFalse(hasattr(issues[0].fields, 'progress'))\n",
        "CUT_1": "\"\"\"Get a :class:`~jira.client.ResultList` of issue Resources matching a JQL search string.\n\n        :param jql_str: The JQL search string.\n        :type jql_str: str\n        :param startAt: Index of the first issue to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of issues to return. Total number of results\n            is available in the ``total`` attribute of the returned :class:`~jira.client.ResultList`.\n            If maxResults evaluates as False, it will try to get all issues in batches. (Default: 50)\n        :type maxResults: int\n        :param validate_query: Whether or not the query should be validated. (Default: True)\n        :type validate_query: bool\n        :param fields: comma-separated string or list of issue fields to include in the results.\n            Default is to include all fields.\n        :type fields: Optional[str or list]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :param json_result: JSON response will be returned when this parameter is set to True.\n                Otherwise, :class:`~jira.client.ResultList` will be returned.\n        :type json_result: bool\n\n        :rtype: dict or :class:`~jira.client.ResultList`\n\n        \"\"\"\nif isinstance(fields, str):\n    fields = fields.split(',')\nelse:\n    fields = list(fields or [])\nuntranslate = {}\nif self._fields:\n    for i, field in enumerate(fields):\n        if field in self._fields:\n            untranslate[self._fields[field]] = fields[i]\n            fields[i] = self._fields[field]\nsearch_params = {'jql': jql_str, 'startAt': startAt, 'validateQuery':\n    validate_query, 'fields': fields, 'expand': expand}\nif json_result:\n    search_params['maxResults'] = maxResults\n    if not maxResults:\n        warnings.warn(\n            'All issues cannot be fetched at once, when json_result parameter is set'\n            , Warning)\n    return self._get_json('search', params=search_params)\nissues = self._fetch_pages(Issue, 'issues', 'search', startAt, maxResults,\n    search_params)\nif untranslate:\n    for i in issues:\n        for k, v in untranslate.items():\n            if k in i.raw.get('fields', {}):\n                i.raw['fields'][v] = i.raw['fields'][k]\nreturn issues\n",
        "CUT_2": "\"\"\"Get a :class:`~jira.client.ResultList` of issue Resources matching a JQL search string.\n\n        :param jql_str: The JQL search string.\n        :type jql_str: str\n        :param startAt: Index of the first issue to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of issues to return. Total number of results\n            is available in the ``total`` attribute of the returned :class:`~jira.client.ResultList`.\n            If maxResults evaluates as False, it will try to get all issues in batches. (Default: 50)\n        :type maxResults: int\n        :param validate_query: Whether or not the query should be validated. (Default: True)\n        :type validate_query: bool\n        :param fields: comma-separated string or list of issue fields to include in the results.\n            Default is to include all fields.\n        :type fields: Optional[str or list]\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[str]\n        :param json_result: JSON response will be returned when this parameter is set to True.\n                Otherwise, :class:`~jira.client.ResultList` will be returned.\n        :type json_result: bool\n\n        :rtype: dict or :class:`~jira.client.ResultList`\n\n        \"\"\"\nif isinstance(fields, str):\n    fields = fields.split(',')\nelse:\n    fields = list(fields or [])\nuntranslate = {}\nif self._fields:\n    for i, field in enumerate(fields):\n        if field in self._fields:\n            untranslate[self._fields[field]] = fields[i]\n            fields[i] = self._fields[field]\nsearch_params = {'jql': jql_str, 'startAt': startAt, 'validateQuery':\n    validate_query, 'fields': fields, 'expand': expand}\nif json_result:\n    search_params['maxResults'] = maxResults\n    if not maxResults:\n        warnings.warn(\n            'All issues cannot be fetched at once, when json_result parameter is set'\n            , Warning)\n    return self._get_json('search', params=search_params)\nissues = self._fetch_pages(Issue, 'issues', 'search', startAt, maxResults,\n    search_params)\nif untranslate:\n    for i in issues:\n        for k, v in untranslate.items():\n            if k in i.raw.get('fields', {}):\n                i.raw['fields'][v] = i.raw['fields'][k]\nreturn issues\n",
        "CUT_3": "\"\"\"\n    :type fields: Optional[Dict[str, Any]]\n    :type fieldargs: **Any\n    :return: Union[Dict[str, Dict[str, Any]], Dict[str, Dict[str, str]]]\n    \"\"\"\nif fields is not None:\n    return {'fields': fields}\nreturn {'fields': fieldargs}\n",
        "CUT_4": "\"\"\"\n    :type fields: Optional[Dict[str, Any]]\n    :type fieldargs: **Any\n    :return: Union[Dict[str, Dict[str, Any]], Dict[str, Dict[str, str]]]\n    \"\"\"\nif fields is not None:\n    return {'fields': fields}\nreturn {'fields': fieldargs}\n",
        "CUT_5": "\"\"\"Update this resource on the server.\n\n        Keyword arguments are marshalled into a dict before being sent. If this\n        resource doesn't support ``PUT``, a :py:exc:`.JIRAError` will be raised; subclasses that specialize this method\n        will only raise errors in case of user error.\n\n        :param fields: Fields which should be updated for the object.\n        :type fields: Optional[Dict[str, Any]]\n        :param async_: If true the request will be added to the queue so it can be executed later using async_run()\n        :type async_: bool\n        :param jira: Instance of Jira Client\n        :type jira: jira.JIRA\n        :param notify: Whether or not to notify users about the update. (Default: True)\n        :type notify: bool\n        :type kwargs: **Any\n        \"\"\"\nif async_ is None:\n    async_ = self._options['async']\ndata = {}\nif fields is not None:\n    data.update(fields)\ndata.update(kwargs)\ndata = json.dumps(data)\nif not notify:\n    querystring = '?notifyUsers=false'\nelse:\n    querystring = ''\nr = self._session.put(self.self + querystring, data=data)\nif 'autofix' in self._options and r.status_code == 400:\n    user = None\n    error_list = get_error_list(r)\n    logging.error(error_list)\n    if 'The reporter specified is not a user.' in error_list:\n        if 'reporter' not in data['fields']:\n            logging.warning(\n                \"autofix: setting reporter to '%s' and retrying the update.\" %\n                self._options['autofix'])\n            data['fields']['reporter'] = {'name': self._options['autofix']}\n    if 'Issues must be assigned.' in error_list:\n        if 'assignee' not in data['fields']:\n            logging.warning(\n                \"autofix: setting assignee to '%s' for %s and retrying the update.\"\n                 % (self._options['autofix'], self.key))\n            data['fields']['assignee'] = {'name': self._options['autofix']}\n    if (\n        'Issue type is a sub-task but parent issue key or id not specified.' in\n        error_list):\n        logging.warning(\n            'autofix: trying to fix sub-task without parent by converting to it to bug'\n            )\n        data['fields']['issuetype'] = {'name': 'Bug'}\n    if ('The summary is invalid because it contains newline characters.' in\n        error_list):\n        logging.warning('autofix: trying to fix newline in summary')\n        data['fields']['summary'] = self.fields.summary.replace('/n', '')\n    for error in error_list:\n        if re.search(\"^User '(.*)' was not found in the system\\\\.\", error, re.U\n            ):\n            m = re.search(\"^User '(.*)' was not found in the system\\\\.\",\n                error, re.U)\n            if m:\n                user = m.groups()[0]\n            else:\n                raise NotImplementedError()\n        if re.search(\"^User '(.*)' does not exist\\\\.\", error):\n            m = re.search(\"^User '(.*)' does not exist\\\\.\", error)\n            if m:\n                user = m.groups()[0]\n            else:\n                raise NotImplementedError()\n    if user:\n        logging.warning(\n            \"Trying to add missing orphan user '%s' in order to complete the previous failed operation.\"\n             % user)\n        jira.add_user(user, 'noreply@example.com', 10100, active=False)\n    if async_:\n        if not hasattr(self._session, '_async_jobs'):\n            self._session._async_jobs = set()\n        self._session._async_jobs.add(threaded_requests.put(self.self, data\n            =json.dumps(data)))\n    else:\n        r = self._session.put(self.self, data=json.dumps(data))\ntime.sleep(self._options['delay_reload'])\nself._load(self.self)\n"
    },
    {
        "functionName": "test_search_issues_expand",
        "className": "SearchTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "issues = self.jira.search_issues('key=%s' % self.issue, expand='changelog')\nself.assertEqual(len(issues), 1)\nself.assertFalse(hasattr(issues[0], 'editmeta'))\nself.assertTrue(hasattr(issues[0], 'changelog'))\nself.assertEqual(issues[0].key, self.issue)\n",
        "CUT_1": "\"\"\"Return the completed issues for the sprint.\"\"\"\nr_json = self._get_json(\n    'rapid/charts/sprintreport?rapidViewId=%s&sprintId=%s' % (board_id,\n    sprint_id), base=self.AGILE_BASE_URL)\nissues = [Issue(self._options, self._session, raw_issues_json) for\n    raw_issues_json in r_json['contents']['puntedIssues']]\nreturn issues\n",
        "CUT_2": "\"\"\"Return the completed issues for the sprint.\"\"\"\nr_json = self._get_json(\n    'rapid/charts/sprintreport?rapidViewId=%s&sprintId=%s' % (board_id,\n    sprint_id), base=self.AGILE_BASE_URL)\nissues = [Issue(self._options, self._session, raw_issues_json) for\n    raw_issues_json in r_json['contents']['puntedIssues']]\nreturn issues\n",
        "CUT_3": "\"\"\"Returns a minimal json object for Jira issue search results. \"\"\"\nreturn {'startAt': kwargs.get('start_at', 0), 'maxResults': kwargs.get(\n    'max_results', 50), 'total': kwargs.get('total', len(issues)), 'issues':\n    issues}\n",
        "CUT_4": "\"\"\"Get the number of unresolved issues for a version.\n\n        :param id: ID of the version to count issues for\n        \"\"\"\nreturn self._get_json('version/' + id + '/unresolvedIssueCount')[\n    'issuesUnresolvedCount']\n",
        "CUT_5": "\"\"\"Get the number of unresolved issues for a version.\n\n        :param id: ID of the version to count issues for\n        \"\"\"\nreturn self._get_json('version/' + id + '/unresolvedIssueCount')[\n    'issuesUnresolvedCount']\n"
    },
    {
        "functionName": "test_security_level",
        "className": "SecurityLevelTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "sec_level = self.jira.security_level('10000')\nself.assertEqual(sec_level.id, '10000')\n",
        "CUT_1": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_2": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_3": "self.id = id\nself.parent = parent\nself._properties = {}\nself._hashables = []\nself._SetDefaultsFromSchema()\nself.UpdateProperties(properties)\n",
        "CUT_4": "return self\n",
        "CUT_5": "\"\"\"Delete component by id.\n\n        :param id: ID of the component to use\n        :type id: str\n        :rtype: Response\n        \"\"\"\nurl = self._get_url('component/' + str(id))\nreturn self._session.delete(url)\n"
    },
    {
        "functionName": "test_server_info",
        "className": "ServerInfoTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "server_info = self.jira.server_info()\nself.assertIn('baseUrl', server_info)\nself.assertIn('version', server_info)\n",
        "CUT_1": "return self\n",
        "CUT_2": "\"\"\"Construct a Jira client instance.\n\n        Without any arguments, this client will connect anonymously to the Jira instance\n        started by the Atlassian Plugin SDK from one of the 'atlas-run', ``atlas-debug``,\n        or ``atlas-run-standalone`` commands. By default, this instance runs at\n        ``http://localhost:2990/jira``. The ``options`` argument can be used to set the Jira instance to use.\n\n        Authentication is handled with the ``basic_auth`` argument. If authentication is supplied (and is\n        accepted by Jira), the client will remember it for subsequent requests.\n\n        For quick command line access to a server, see the ``jirashell`` script included with this distribution.\n\n        The easiest way to instantiate is using j = JIRA(\"https://jira.atlasian.com\")\n        :param server: The server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n        :type server: Optional[str]\n        :param options: Specify the server and properties this client will use. Use a dict with any\n            of the following properties:\n            * server -- the server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n            * rest_path -- the root REST path to use. Defaults to ``api``, where the Jira REST resources live.\n            * rest_api_version -- the version of the REST resources under rest_path to use. Defaults to ``2``.\n            * agile_rest_path - the REST path to use for Jira Agile requests. Defaults to ``greenhopper`` (old, private\n               API). Check `GreenHopperResource` for other supported values.\n            * verify -- Verify SSL certs. Defaults to ``True``.\n            * client_cert -- a tuple of (cert,key) for the requests library for client side SSL\n            * check_update -- Check whether using the newest python-jira library version.\n        :type options: Optional[Dict[str, Any]]\n        :param basic_auth: A tuple of username and password to use when establishing a session via HTTP BASIC\n        authentication.\n        :type basic_auth: Union[Dict, None, Tuple[str, str]]\n        :param oauth: A dict of properties for OAuth authentication. The following properties are required:\n            * access_token -- OAuth access token for the user\n            * access_token_secret -- OAuth access token secret to sign with the key\n            * consumer_key -- key of the OAuth application link defined in Jira\n            * key_cert -- private key file to sign requests with (should be the pair of the public key supplied to\n            Jira in the OAuth application link)\n        :type oauth: Optional[Any]\n        :param kerberos: If true it will enable Kerberos authentication.\n        :type kerberos: bool\n        :param kerberos_options: A dict of properties for Kerberos authentication. The following properties are possible:\n            * mutual_authentication -- string DISABLED or OPTIONAL.\n            Example kerberos_options structure: ``{'mutual_authentication': 'DISABLED'}``\n        :type kerberos_options: Optional[Dict[str,str]]\n        :param jwt: A dict of properties for JWT authentication supported by Atlassian Connect. The following\n            properties are required:\n            * secret -- shared secret as delivered during 'installed' lifecycle event\n            (see https://developer.atlassian.com/static/connect/docs/latest/modules/lifecycle.html for details)\n            * payload -- dict of fields to be inserted in the JWT payload, e.g. 'iss'\n            Example jwt structure: ``{'secret': SHARED_SECRET, 'payload': {'iss': PLUGIN_KEY}}``\n        :type jwt: Optional[Any]\n        :param validate: If true it will validate your credentials first. Remember that if you are accessing Jira\n            as anonymous it will fail to instantiate.\n        :type validate: bool\n        :param get_server_info: If true it will fetch server version info first to determine if some API calls\n            are available.\n        :type get_server_info: bool\n        :param async_: To enable async requests for those actions where we implemented it, like issue update() or delete().\n        :type async_: bool\n        :param async_workers: Set the number of worker threads for async operations.\n        :type async_workers: int\n        :param timeout: Set a read/connect timeout for the underlying calls to Jira (default: None)\n        :type timeout: Optional[Any]\n        Obviously this means that you cannot rely on the return code when this is enabled.\n        :param max_retries: Sets the amount Retries for the HTTP sessions initiated by the client. (Default: 3)\n        :type max_retries: int\n        :param proxies: Sets the proxies for the HTTP session.\n        :type proxies: Optional[Any]\n        :param auth: Set a cookie auth token if this is required.\n        :type auth: Optional[Tuple[str,str]]\n        :param logging: Determine whether or not logging should be enabled. (Default: True)\n        :type logging: bool\n        \"\"\"\nself.sys_version_info = tuple([i for i in sys.version_info])\nif options is None:\n    options = {}\n    if server and hasattr(server, 'keys'):\n        warnings.warn(\n            \"Old API usage, use JIRA(url) or JIRA(options={'server': url}, when using dictionary always use named parameters.\"\n            , DeprecationWarning)\n        options = server\n        server = None\nif server:\n    options['server'] = server\nif async_:\n    options['async'] = async_\n    options['async_workers'] = async_workers\nself.logging = logging\nself._options = copy.copy(JIRA.DEFAULT_OPTIONS)\nself._options.update(options)\nself._rank = None\nif self._options['server'].endswith('/'):\n    self._options['server'] = self._options['server'][:-1]\ncontext_path = urlparse(self._options['server']).path\nif len(context_path) > 0:\n    self._options['context_path'] = context_path\nself._try_magic()\nif oauth:\n    self._create_oauth_session(oauth, timeout)\nelif basic_auth:\n    self._create_http_basic_session(*basic_auth, timeout=timeout)\n    self._session.headers.update(self._options['headers'])\nelif jwt:\n    self._create_jwt_session(jwt, timeout)\nelif kerberos:\n    self._create_kerberos_session(timeout, kerberos_options=kerberos_options)\nelif auth:\n    self._create_cookie_auth(auth, timeout)\n    validate = True\nelse:\n    verify = self._options['verify']\n    self._session = ResilientSession(timeout=timeout)\n    self._session.verify = verify\nself._session.headers.update(self._options['headers'])\nif 'cookies' in self._options:\n    self._session.cookies.update(self._options['cookies'])\nself._session.max_retries = max_retries\nif proxies:\n    self._session.proxies = proxies\nself.auth = auth\nif validate:\n    user = self.session()\n    if user.raw is None:\n        auth_method = (oauth or basic_auth or jwt or kerberos or auth or\n            'anonymous')\n        raise JIRAError('Can not log in with %s' % str(auth_method))\nself.deploymentType = None\nif get_server_info:\n    si = self.server_info()\n    try:\n        self._version = tuple(si['versionNumbers'])\n    except Exception as e:\n        logging.error('invalid server_info: %s', si)\n        raise e\n    self.deploymentType = si.get('deploymentType')\nelse:\n    self._version = 0, 0, 0\nif self._options['check_update'] and not JIRA.checked_version:\n    self._check_update_()\n    JIRA.checked_version = True\nself._fields = {}\nfor f in self.fields():\n    if 'clauseNames' in f:\n        for name in f['clauseNames']:\n            self._fields[name] = f['id']\n",
        "CUT_3": "\"\"\"Construct a Jira client instance.\n\n        Without any arguments, this client will connect anonymously to the Jira instance\n        started by the Atlassian Plugin SDK from one of the 'atlas-run', ``atlas-debug``,\n        or ``atlas-run-standalone`` commands. By default, this instance runs at\n        ``http://localhost:2990/jira``. The ``options`` argument can be used to set the Jira instance to use.\n\n        Authentication is handled with the ``basic_auth`` argument. If authentication is supplied (and is\n        accepted by Jira), the client will remember it for subsequent requests.\n\n        For quick command line access to a server, see the ``jirashell`` script included with this distribution.\n\n        The easiest way to instantiate is using j = JIRA(\"https://jira.atlasian.com\")\n        :param server: The server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n        :type server: Optional[str]\n        :param options: Specify the server and properties this client will use. Use a dict with any\n            of the following properties:\n            * server -- the server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n            * rest_path -- the root REST path to use. Defaults to ``api``, where the Jira REST resources live.\n            * rest_api_version -- the version of the REST resources under rest_path to use. Defaults to ``2``.\n            * agile_rest_path - the REST path to use for Jira Agile requests. Defaults to ``greenhopper`` (old, private\n               API). Check `GreenHopperResource` for other supported values.\n            * verify -- Verify SSL certs. Defaults to ``True``.\n            * client_cert -- a tuple of (cert,key) for the requests library for client side SSL\n            * check_update -- Check whether using the newest python-jira library version.\n        :type options: Optional[Dict[str, Any]]\n        :param basic_auth: A tuple of username and password to use when establishing a session via HTTP BASIC\n        authentication.\n        :type basic_auth: Union[Dict, None, Tuple[str, str]]\n        :param oauth: A dict of properties for OAuth authentication. The following properties are required:\n            * access_token -- OAuth access token for the user\n            * access_token_secret -- OAuth access token secret to sign with the key\n            * consumer_key -- key of the OAuth application link defined in Jira\n            * key_cert -- private key file to sign requests with (should be the pair of the public key supplied to\n            Jira in the OAuth application link)\n        :type oauth: Optional[Any]\n        :param kerberos: If true it will enable Kerberos authentication.\n        :type kerberos: bool\n        :param kerberos_options: A dict of properties for Kerberos authentication. The following properties are possible:\n            * mutual_authentication -- string DISABLED or OPTIONAL.\n            Example kerberos_options structure: ``{'mutual_authentication': 'DISABLED'}``\n        :type kerberos_options: Optional[Dict[str,str]]\n        :param jwt: A dict of properties for JWT authentication supported by Atlassian Connect. The following\n            properties are required:\n            * secret -- shared secret as delivered during 'installed' lifecycle event\n            (see https://developer.atlassian.com/static/connect/docs/latest/modules/lifecycle.html for details)\n            * payload -- dict of fields to be inserted in the JWT payload, e.g. 'iss'\n            Example jwt structure: ``{'secret': SHARED_SECRET, 'payload': {'iss': PLUGIN_KEY}}``\n        :type jwt: Optional[Any]\n        :param validate: If true it will validate your credentials first. Remember that if you are accessing Jira\n            as anonymous it will fail to instantiate.\n        :type validate: bool\n        :param get_server_info: If true it will fetch server version info first to determine if some API calls\n            are available.\n        :type get_server_info: bool\n        :param async_: To enable async requests for those actions where we implemented it, like issue update() or delete().\n        :type async_: bool\n        :param async_workers: Set the number of worker threads for async operations.\n        :type async_workers: int\n        :param timeout: Set a read/connect timeout for the underlying calls to Jira (default: None)\n        :type timeout: Optional[Any]\n        Obviously this means that you cannot rely on the return code when this is enabled.\n        :param max_retries: Sets the amount Retries for the HTTP sessions initiated by the client. (Default: 3)\n        :type max_retries: int\n        :param proxies: Sets the proxies for the HTTP session.\n        :type proxies: Optional[Any]\n        :param auth: Set a cookie auth token if this is required.\n        :type auth: Optional[Tuple[str,str]]\n        :param logging: Determine whether or not logging should be enabled. (Default: True)\n        :type logging: bool\n        \"\"\"\nself.sys_version_info = tuple([i for i in sys.version_info])\nif options is None:\n    options = {}\n    if server and hasattr(server, 'keys'):\n        warnings.warn(\n            \"Old API usage, use JIRA(url) or JIRA(options={'server': url}, when using dictionary always use named parameters.\"\n            , DeprecationWarning)\n        options = server\n        server = None\nif server:\n    options['server'] = server\nif async_:\n    options['async'] = async_\n    options['async_workers'] = async_workers\nself.logging = logging\nself._options = copy.copy(JIRA.DEFAULT_OPTIONS)\nself._options.update(options)\nself._rank = None\nif self._options['server'].endswith('/'):\n    self._options['server'] = self._options['server'][:-1]\ncontext_path = urlparse(self._options['server']).path\nif len(context_path) > 0:\n    self._options['context_path'] = context_path\nself._try_magic()\nif oauth:\n    self._create_oauth_session(oauth, timeout)\nelif basic_auth:\n    self._create_http_basic_session(*basic_auth, timeout=timeout)\n    self._session.headers.update(self._options['headers'])\nelif jwt:\n    self._create_jwt_session(jwt, timeout)\nelif kerberos:\n    self._create_kerberos_session(timeout, kerberos_options=kerberos_options)\nelif auth:\n    self._create_cookie_auth(auth, timeout)\n    validate = True\nelse:\n    verify = self._options['verify']\n    self._session = ResilientSession(timeout=timeout)\n    self._session.verify = verify\nself._session.headers.update(self._options['headers'])\nif 'cookies' in self._options:\n    self._session.cookies.update(self._options['cookies'])\nself._session.max_retries = max_retries\nif proxies:\n    self._session.proxies = proxies\nself.auth = auth\nif validate:\n    user = self.session()\n    if user.raw is None:\n        auth_method = (oauth or basic_auth or jwt or kerberos or auth or\n            'anonymous')\n        raise JIRAError('Can not log in with %s' % str(auth_method))\nself.deploymentType = None\nif get_server_info:\n    si = self.server_info()\n    try:\n        self._version = tuple(si['versionNumbers'])\n    except Exception as e:\n        logging.error('invalid server_info: %s', si)\n        raise e\n    self.deploymentType = si.get('deploymentType')\nelse:\n    self._version = 0, 0, 0\nif self._options['check_update'] and not JIRA.checked_version:\n    self._check_update_()\n    JIRA.checked_version = True\nself._fields = {}\nfor f in self.fields():\n    if 'clauseNames' in f:\n        for name in f['clauseNames']:\n            self._fields[name] = f['id']\n",
        "CUT_4": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_statuses",
        "className": "StatusTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "found = False\nstatuses = self.jira.statuses()\nfor status in statuses:\n    if status.name == 'Done':\n        found = True\n        s = self.jira.status(status.id)\n        self.assertEqual(s.id, status.id)\n        break\nself.assertTrue(found, 'Status Done not found. [%s]' % statuses)\nself.assertGreater(len(statuses), 0)\n",
        "CUT_1": "\"\"\"Get a list of status Resources from the server.\n\n        :rtype: List[Status]\n\n        \"\"\"\nr_json = self._get_json('status')\nstatuses = [Status(self._options, self._session, raw_stat_json) for\n    raw_stat_json in r_json]\nreturn statuses\n",
        "CUT_2": "\"\"\"Get a list of status Resources from the server.\n\n        :rtype: List[Status]\n\n        \"\"\"\nr_json = self._get_json('status')\nstatuses = [Status(self._options, self._session, raw_stat_json) for\n    raw_stat_json in r_json]\nreturn statuses\n",
        "CUT_3": "\"\"\"Get a status Resource from the server.\n\n        :param id: ID of the status resource to get\n        \"\"\"\nreturn self._find_for_resource(Status, id)\n",
        "CUT_4": "\"\"\"Get a status Resource from the server.\n\n        :param id: ID of the status resource to get\n        \"\"\"\nreturn self._find_for_resource(Status, id)\n",
        "CUT_5": "\"\"\"Get a status category Resource from the server.\n\n        :param id: ID of the status category resource to get\n        :type id: int\n\n        :rtype: StatusCategory\n\n        \"\"\"\nreturn self._find_for_resource(StatusCategory, id)\n"
    },
    {
        "functionName": "test_statuscategories",
        "className": "StatusCategoryTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "found = False\nstatuscategories = self.jira.statuscategories()\nfor statuscategory in statuscategories:\n    if statuscategory.id == 1 and statuscategory.name == 'No Category':\n        found = True\n        break\nself.assertTrue(found, 'StatusCategory with id=1 not found. [%s]' %\n    statuscategories)\nself.assertGreater(len(statuscategories), 0)\n",
        "CUT_1": "\"\"\"Get a list of status category Resources from the server.\n\n        :rtype: List[StatusCategory]\n        \"\"\"\nr_json = self._get_json('statuscategory')\nstatuscategories = [StatusCategory(self._options, self._session,\n    raw_stat_json) for raw_stat_json in r_json]\nreturn statuscategories\n",
        "CUT_2": "\"\"\"Get a list of status category Resources from the server.\n\n        :rtype: List[StatusCategory]\n        \"\"\"\nr_json = self._get_json('statuscategory')\nstatuscategories = [StatusCategory(self._options, self._session,\n    raw_stat_json) for raw_stat_json in r_json]\nreturn statuscategories\n",
        "CUT_3": "\"\"\"Get a status category Resource from the server.\n\n        :param id: ID of the status category resource to get\n        :type id: int\n\n        :rtype: StatusCategory\n\n        \"\"\"\nreturn self._find_for_resource(StatusCategory, id)\n",
        "CUT_4": "\"\"\"Get a status category Resource from the server.\n\n        :param id: ID of the status category resource to get\n        :type id: int\n\n        :rtype: StatusCategory\n\n        \"\"\"\nreturn self._find_for_resource(StatusCategory, id)\n",
        "CUT_5": "Resource.__init__(self, 'statuscategory/{0}', options, session)\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_statuscategory",
        "className": "StatusCategoryTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "statuscategory = self.jira.statuscategory(1)\nself.assertEqual(statuscategory.id, 1)\nself.assertEqual(statuscategory.name, 'No Category')\n",
        "CUT_1": "\"\"\"Get a list of status category Resources from the server.\n\n        :rtype: List[StatusCategory]\n        \"\"\"\nr_json = self._get_json('statuscategory')\nstatuscategories = [StatusCategory(self._options, self._session,\n    raw_stat_json) for raw_stat_json in r_json]\nreturn statuscategories\n",
        "CUT_2": "\"\"\"Get a list of status category Resources from the server.\n\n        :rtype: List[StatusCategory]\n        \"\"\"\nr_json = self._get_json('statuscategory')\nstatuscategories = [StatusCategory(self._options, self._session,\n    raw_stat_json) for raw_stat_json in r_json]\nreturn statuscategories\n",
        "CUT_3": "\"\"\"Get a status category Resource from the server.\n\n        :param id: ID of the status category resource to get\n        :type id: int\n\n        :rtype: StatusCategory\n\n        \"\"\"\nreturn self._find_for_resource(StatusCategory, id)\n",
        "CUT_4": "\"\"\"Get a status category Resource from the server.\n\n        :param id: ID of the status category resource to get\n        :type id: int\n\n        :rtype: StatusCategory\n\n        \"\"\"\nreturn self._find_for_resource(StatusCategory, id)\n",
        "CUT_5": "Resource.__init__(self, 'statuscategory/{0}', options, session)\nif raw:\n    self._parse_raw(raw)\n"
    },
    {
        "functionName": "test_user",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "user = self.jira.user(self.test_manager.user_admin.name)\nself.assertTrue(user.name)\nself.assertRegex(user.emailAddress,\n    '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$')\n",
        "CUT_1": "\"\"\"Convert a string to a value that is acceptable as a make variable name.\"\"\"\nreturn re.sub('[^a-zA-Z0-9_]', '_', string)\n",
        "CUT_2": "\"\"\"Get a dict of the current authenticated user's session information.\n\n        :rtype: User\n\n        \"\"\"\nurl = '{server}{auth_url}'.format(**self._options)\nr = self._session.get(url)\nuser = User(self._options, self._session, json_loads(r))\nreturn user\n",
        "CUT_3": "\"\"\"Get a dict of the current authenticated user's session information.\n\n        :rtype: User\n\n        \"\"\"\nurl = '{server}{auth_url}'.format(**self._options)\nr = self._session.get(url)\nuser = User(self._options, self._session, json_loads(r))\nreturn user\n",
        "CUT_4": "\"\"\"Takes a string containing variable references in the form ${FOO}, $(FOO),\n  or $FOO, and returns a string with all variable references in the form ${FOO}.\n  \"\"\"\nstr = re.sub('\\\\$([a-zA-Z_][a-zA-Z0-9_]*)', '${\\\\1}', str)\nmatches = re.findall('(\\\\$\\\\(([a-zA-Z0-9\\\\-_]+)\\\\))', str)\nfor match in matches:\n    to_replace, variable = match\n    assert '$(' not in match, '$($(FOO)) variables not supported: ' + match\n    str = str.replace(to_replace, '${' + variable + '}')\nreturn str\n",
        "CUT_5": "\"\"\"Get a user Resource from the server.\n\n        :param id: ID of the user to get\n        :param id: str\n        :param expand: Extra information to fetch inside each resource\n        :type expand: Optional[Any]\n\n        :rtype: User\n        \"\"\"\nuser = User(self._options, self._session)\nparams = {}\nif expand is not None:\n    params['expand'] = expand\nuser.find(id, params=params)\nreturn user\n"
    },
    {
        "functionName": "test_search_assignable_users_for_projects",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_assignable_users_for_projects(self.test_manager.\n    CI_JIRA_ADMIN, '%s,%s' % (self.project_a, self.project_b))\nself.assertGreaterEqual(len(users), 1)\nusernames = map(lambda user: user.name, users)\nself.assertIn(self.test_manager.CI_JIRA_ADMIN, usernames)\npytest.mark.xfail(reason='query returns empty list')",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.attachment = None\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n"
    },
    {
        "functionName": "test_search_assignable_users_for_projects_maxresults",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_assignable_users_for_projects(self.test_manager.\n    CI_JIRA_ADMIN, '%s,%s' % (self.project_a, self.project_b), maxResults=1)\nself.assertLessEqual(len(users), 1)\npytest.mark.xfail(reason='query returns empty list')",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\nself.project_a = JiraTestManager().project_a\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue3\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.attachment = None\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n"
    },
    {
        "functionName": "test_search_assignable_users_for_projects_startat",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_assignable_users_for_projects(self.test_manager.\n    CI_JIRA_ADMIN, '%s,%s' % (self.project_a, self.project_b), startAt=1)\nself.assertGreaterEqual(len(users), 0)\npytest.mark.xfail(reason='query returns empty list')",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\nself.project_a = JiraTestManager().project_a\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue3\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.attachment = None\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n"
    },
    {
        "functionName": "test_search_assignable_users_for_issues_by_project",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_assignable_users_for_issues(self.test_manager.\n    CI_JIRA_ADMIN, project=self.project_b)\nself.assertEqual(len(users), 1)\nusernames = map(lambda user: user.name, users)\nself.assertIn(self.test_manager.CI_JIRA_ADMIN, usernames)\nnot_on_custom_jira_instance",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.attachment = None\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n"
    },
    {
        "functionName": "test_search_assignable_users_for_issues_by_project_maxresults",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_assignable_users_for_issues(self.test_manager.\n    CI_JIRA_USER, project=self.project_b, maxResults=1)\nself.assertLessEqual(len(users), 1)\npytest.mark.xfail(reason='query returns empty list')",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.attachment = None\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue1\n"
    },
    {
        "functionName": "test_search_assignable_users_for_issues_by_project_startat",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_assignable_users_for_issues(self.test_manager.\n    CI_JIRA_USER, project=self.project_a, startAt=1)\nself.assertGreaterEqual(len(users), 0)\npytest.mark.xfail(reason='query returns empty list')",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\nself.test_username = 'test_%s' % self.test_manager.project_a\nself.test_email = '%s@example.com' % self.test_username\nself.test_password = rndpassword()\nself.test_groupname = 'testGroupFor_%s' % self.test_manager.project_a\n",
        "CUT_3": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_4": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n"
    },
    {
        "functionName": "test_search_assignable_users_for_issues_by_issue",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_assignable_users_for_issues(self.test_manager.\n    CI_JIRA_ADMIN, issueKey=self.issue)\nself.assertEqual(len(users), 1)\nusernames = map(lambda user: user.name, users)\nself.assertIn(self.test_manager.CI_JIRA_ADMIN, usernames)\nnot_on_custom_jira_instance",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_5": "\"\"\"Return a hash or users with their information. Requires Jira 6.0 or will raise NotImplemented.\n\n        :param group: Name of the group.\n        :type group: str\n        \"\"\"\nif self._version < (6, 0, 0):\n    raise NotImplementedError(\n        'Group members is not implemented in Jira before version 6.0, upgrade the instance, if possible.'\n        )\nparams = {'groupname': group, 'expand': 'users'}\nr = self._get_json('group', params=params)\nsize = r['users']['size']\nend_index = r['users']['end-index']\nwhile end_index < size - 1:\n    params = {'groupname': group, 'expand': 'users[%s:%s]' % (end_index + 1,\n        end_index + 50)}\n    r2 = self._get_json('group', params=params)\n    for user in r2['users']['items']:\n        r['users']['items'].append(user)\n    end_index = r2['users']['end-index']\n    size = r['users']['size']\nresult = {}\nfor user in r['users']['items']:\n    result[user['key']] = {'name': user['name'], 'fullname': user[\n        'displayName'], 'email': user.get('emailAddress', 'hidden'),\n        'active': user['active']}\nreturn OrderedDict(sorted(result.items(), key=lambda t: t[0]))\n"
    },
    {
        "functionName": "test_search_assignable_users_for_issues_by_issue_maxresults",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_assignable_users_for_issues(self.test_manager.\n    CI_JIRA_ADMIN, issueKey=self.issue, maxResults=2)\nself.assertLessEqual(len(users), 2)\npytest.mark.xfail(reason='query returns empty list')",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_3": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_4": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\nif not self.jira.supports_service_desk():\n    pytest.skip('Skipping Service Desk not enabled')\ntry:\n    self.jira.delete_project(self.test_manager.project_sd)\nexcept Exception:\n    pass\n"
    },
    {
        "functionName": "test_search_assignable_users_for_issues_by_issue_startat",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_assignable_users_for_issues(self.test_manager.\n    CI_JIRA_ADMIN, issueKey=self.issue, startAt=2)\nself.assertGreaterEqual(len(users), 0)\npytest.mark.xfail(reason='query returns empty list')",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_3": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_4": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\nif not self.jira.supports_service_desk():\n    pytest.skip('Skipping Service Desk not enabled')\ntry:\n    self.jira.delete_project(self.test_manager.project_sd)\nexcept Exception:\n    pass\n"
    },
    {
        "functionName": "test_user_avatars",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "size = os.path.getsize(TEST_ICON_PATH)\nwith open(TEST_ICON_PATH, 'rb') as icon:\n    props = self.jira.create_temp_user_avatar(JiraTestManager().\n        CI_JIRA_ADMIN, TEST_ICON_PATH, size, icon.read())\nself.assertIn('cropperOffsetX', props)\nself.assertIn('cropperOffsetY', props)\nself.assertIn('cropperWidth', props)\nself.assertTrue(props['needsCropping'])\nprops['needsCropping'] = False\navatar_props = self.jira.confirm_user_avatar(JiraTestManager().\n    CI_JIRA_ADMIN, props)\nself.assertIn('id', avatar_props)\nself.assertEqual(avatar_props['owner'], JiraTestManager().CI_JIRA_ADMIN)\nself.jira.set_user_avatar(JiraTestManager().CI_JIRA_ADMIN, avatar_props['id'])\navatars = self.jira.user_avatars(self.test_manager.CI_JIRA_ADMIN)\nself.assertGreaterEqual(len(avatars['system']), 20)\nself.assertGreaterEqual(len(avatars['custom']), 1)\npytest.mark.xfail(reason='Jira may return 500')",
        "CUT_1": "props = self._properties\nname = '%s.gyp:%s' % (props['containerPortal'].Name(), props['remoteInfo'])\nreturn '<%s %r at 0x%x>' % (self.__class__.__name__, name, id(self))\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_set_user_avatar",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "def find_selected_avatar(avatars):\n    for avatar in avatars['system']:\n        if avatar['isSelected']:\n            return avatar\navatars = self.jira.user_avatars(self.test_manager.CI_JIRA_ADMIN)\nself.jira.set_user_avatar(self.test_manager.CI_JIRA_ADMIN, avatars['system'][0]\n    )\navatars = self.jira.user_avatars(self.test_manager.CI_JIRA_ADMIN)\nself.assertEqual(find_selected_avatar(avatars)['id'], avatars['system'][0])\nself.jira.set_user_avatar(self.test_manager.CI_JIRA_ADMIN, avatars['system'][1]\n    )\navatars = self.jira.user_avatars(self.test_manager.CI_JIRA_ADMIN)\nself.assertEqual(find_selected_avatar(avatars)['id'], avatars['system'][1])\nunittest.skip('broken: set avatar returns 400')",
        "CUT_1": "for avatar in avatars['system']:\n    if avatar['isSelected']:\n        return avatar\n",
        "CUT_2": "\"\"\"Get a dict of avatars for the specified user.\n\n        :param username: the username to get avatars for\n        \"\"\"\nreturn self._get_json('user/avatars', params={'username': username})\n",
        "CUT_3": "\"\"\"Get a dict of avatars for the specified user.\n\n        :param username: the username to get avatars for\n        \"\"\"\nreturn self._get_json('user/avatars', params={'username': username})\n",
        "CUT_4": "\"\"\"Get a dict of all avatars for a project visible to the current authenticated user.\n\n        :param project: ID or key of the project to get avatars for\n        \"\"\"\nreturn self._get_json('project/' + project + '/avatars')\ntranslate_resource_args",
        "CUT_5": "\"\"\"Get a dict of all avatars for a project visible to the current authenticated user.\n\n        :param project: ID or key of the project to get avatars for\n        \"\"\"\nreturn self._get_json('project/' + project + '/avatars')\ntranslate_resource_args"
    },
    {
        "functionName": "test_delete_user_avatar",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "size = os.path.getsize(TEST_ICON_PATH)\nfilename = os.path.basename(TEST_ICON_PATH)\nwith open(TEST_ICON_PATH, 'rb') as icon:\n    props = self.jira.create_temp_user_avatar(self.test_manager.\n        CI_JIRA_ADMIN, filename, size, icon.read())\nself.jira.delete_user_avatar(self.test_manager.CI_JIRA_ADMIN, props['id'])\nunittest.skip('disable until I have permissions to write/modify')",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_3": "props = self._properties\nname = '%s.gyp:%s' % (props['containerPortal'].Name(), props['remoteInfo'])\nreturn '<%s %r at 0x%x>' % (self.__class__.__name__, name, id(self))\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n"
    },
    {
        "functionName": "test_search_users",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)\nself.assertGreaterEqual(len(users), 1)\nusernames = map(lambda user: user.name, users)\nself.assertIn(self.test_manager.user_admin.name, usernames)\n",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_3": "\"\"\"Return a hash or users with their information. Requires Jira 6.0 or will raise NotImplemented.\n\n        :param group: Name of the group.\n        :type group: str\n        \"\"\"\nif self._version < (6, 0, 0):\n    raise NotImplementedError(\n        'Group members is not implemented in Jira before version 6.0, upgrade the instance, if possible.'\n        )\nparams = {'groupname': group, 'expand': 'users'}\nr = self._get_json('group', params=params)\nsize = r['users']['size']\nend_index = r['users']['end-index']\nwhile end_index < size - 1:\n    params = {'groupname': group, 'expand': 'users[%s:%s]' % (end_index + 1,\n        end_index + 50)}\n    r2 = self._get_json('group', params=params)\n    for user in r2['users']['items']:\n        r['users']['items'].append(user)\n    end_index = r2['users']['end-index']\n    size = r['users']['size']\nresult = {}\nfor user in r['users']['items']:\n    result[user['key']] = {'name': user['name'], 'fullname': user[\n        'displayName'], 'email': user.get('emailAddress', 'hidden'),\n        'active': user['active']}\nreturn OrderedDict(sorted(result.items(), key=lambda t: t[0]))\n",
        "CUT_4": "\"\"\"Return a hash or users with their information. Requires Jira 6.0 or will raise NotImplemented.\n\n        :param group: Name of the group.\n        :type group: str\n        \"\"\"\nif self._version < (6, 0, 0):\n    raise NotImplementedError(\n        'Group members is not implemented in Jira before version 6.0, upgrade the instance, if possible.'\n        )\nparams = {'groupname': group, 'expand': 'users'}\nr = self._get_json('group', params=params)\nsize = r['users']['size']\nend_index = r['users']['end-index']\nwhile end_index < size - 1:\n    params = {'groupname': group, 'expand': 'users[%s:%s]' % (end_index + 1,\n        end_index + 50)}\n    r2 = self._get_json('group', params=params)\n    for user in r2['users']['items']:\n        r['users']['items'].append(user)\n    end_index = r2['users']['end-index']\n    size = r['users']['size']\nresult = {}\nfor user in r['users']['items']:\n    result[user['key']] = {'name': user['name'], 'fullname': user[\n        'displayName'], 'email': user.get('emailAddress', 'hidden'),\n        'active': user['active']}\nreturn OrderedDict(sorted(result.items(), key=lambda t: t[0]))\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n"
    },
    {
        "functionName": "test_search_users_maxresults",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_users(self.test_manager.CI_JIRA_USER, maxResults=1)\nself.assertGreaterEqual(1, len(users))\n",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_3": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_5": "\"\"\"Add the specified users or groups to this project role. One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'id': self.id, 'categorisedActors': {'atlassian-user-role-actor':\n    users, 'atlassian-group-role-actor': groups}}\nsuper(Role, self).update(**data)\n"
    },
    {
        "functionName": "test_search_allowed_users_for_issue_by_project",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_allowed_users_for_issue(self.test_manager.\n    CI_JIRA_USER, projectKey=self.project_a)\nself.assertGreaterEqual(len(users), 1)\n",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\nself.test_username = 'test_%s' % self.test_manager.project_a\nself.test_email = '%s@example.com' % self.test_username\nself.test_password = rndpassword()\nself.test_groupname = 'testGroupFor_%s' % self.test_manager.project_a\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_4": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_5": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n"
    },
    {
        "functionName": "test_search_allowed_users_for_issue_by_issue",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_allowed_users_for_issue('a', issueKey=self.issue)\nself.assertGreaterEqual(len(users), 1)\nnot_on_custom_jira_instance",
        "CUT_1": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_2": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_3": "\"\"\"Add the specified users or groups to this project role. One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'id': self.id, 'categorisedActors': {'atlassian-user-role-actor':\n    users, 'atlassian-group-role-actor': groups}}\nsuper(Role, self).update(**data)\n",
        "CUT_4": "\"\"\"Add the specified users or groups to this project role. One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'id': self.id, 'categorisedActors': {'atlassian-user-role-actor':\n    users, 'atlassian-group-role-actor': groups}}\nsuper(Role, self).update(**data)\n",
        "CUT_5": "\"\"\"Return a hash or users with their information. Requires Jira 6.0 or will raise NotImplemented.\n\n        :param group: Name of the group.\n        :type group: str\n        \"\"\"\nif self._version < (6, 0, 0):\n    raise NotImplementedError(\n        'Group members is not implemented in Jira before version 6.0, upgrade the instance, if possible.'\n        )\nparams = {'groupname': group, 'expand': 'users'}\nr = self._get_json('group', params=params)\nsize = r['users']['size']\nend_index = r['users']['end-index']\nwhile end_index < size - 1:\n    params = {'groupname': group, 'expand': 'users[%s:%s]' % (end_index + 1,\n        end_index + 50)}\n    r2 = self._get_json('group', params=params)\n    for user in r2['users']['items']:\n        r['users']['items'].append(user)\n    end_index = r2['users']['end-index']\n    size = r['users']['size']\nresult = {}\nfor user in r['users']['items']:\n    result[user['key']] = {'name': user['name'], 'fullname': user[\n        'displayName'], 'email': user.get('emailAddress', 'hidden'),\n        'active': user['active']}\nreturn OrderedDict(sorted(result.items(), key=lambda t: t[0]))\n"
    },
    {
        "functionName": "test_search_allowed_users_for_issue_maxresults",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_allowed_users_for_issue('a', projectKey=self.\n    project_b, maxResults=2)\nself.assertLessEqual(len(users), 2)\npytest.mark.xfail(reason='query returns empty list')",
        "CUT_1": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_2": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_3": "\"\"\"Get a list of user Resources that match a username string and have browse permission for the issue or project.\n\n        :param user: a string to match usernames against.\n        :type user: str\n        :param issueKey: find users with browse permission for this issue.\n        :type issueKey: Optional[str]\n        :param projectKey: find users with browse permission for this project.\n        :type projectKey: Optional[str]\n        :param startAt: index of the first user to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of users to return.\n                If maxResults evaluates as False, it will try to get all items in batches. (Default: 50)\n        :type maxResults: int\n        \"\"\"\nparams = {'username': user}\nif issueKey is not None:\n    params['issueKey'] = issueKey\nif projectKey is not None:\n    params['projectKey'] = projectKey\nreturn self._fetch_pages(User, None, 'user/viewissue/search', startAt,\n    maxResults, params)\n",
        "CUT_4": "\"\"\"Get a list of user Resources that match a username string and have browse permission for the issue or project.\n\n        :param user: a string to match usernames against.\n        :type user: str\n        :param issueKey: find users with browse permission for this issue.\n        :type issueKey: Optional[str]\n        :param projectKey: find users with browse permission for this project.\n        :type projectKey: Optional[str]\n        :param startAt: index of the first user to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of users to return.\n                If maxResults evaluates as False, it will try to get all items in batches. (Default: 50)\n        :type maxResults: int\n        \"\"\"\nparams = {'username': user}\nif issueKey is not None:\n    params['issueKey'] = issueKey\nif projectKey is not None:\n    params['projectKey'] = projectKey\nreturn self._fetch_pages(User, None, 'user/viewissue/search', startAt,\n    maxResults, params)\n",
        "CUT_5": "\"\"\"Add the specified users or groups to this project role. One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'id': self.id, 'categorisedActors': {'atlassian-user-role-actor':\n    users, 'atlassian-group-role-actor': groups}}\nsuper(Role, self).update(**data)\n"
    },
    {
        "functionName": "test_search_allowed_users_for_issue_startat",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users = self.jira.search_allowed_users_for_issue('c', projectKey=self.\n    project_b, startAt=1)\nself.assertGreaterEqual(len(users), 0)\npytest.mark.xfail(reason='query returns empty list')",
        "CUT_1": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_2": "\"\"\"Add the specified users or groups to this project role.\n\n        One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'user': users}\nself._session.post(self.self, data=json.dumps(data))\n",
        "CUT_3": "\"\"\"Add the specified users or groups to this project role. One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'id': self.id, 'categorisedActors': {'atlassian-user-role-actor':\n    users, 'atlassian-group-role-actor': groups}}\nsuper(Role, self).update(**data)\n",
        "CUT_4": "\"\"\"Add the specified users or groups to this project role. One of ``users`` or ``groups`` must be specified.\n\n        :param users: a user or users to add to the role\n        :type users: string, list or tuple\n        :param groups: a group or groups to add to the role\n        :type groups: string, list or tuple\n        \"\"\"\nif users is not None and isinstance(users, str):\n    users = users,\nif groups is not None and isinstance(groups, str):\n    groups = groups,\ndata = {'id': self.id, 'categorisedActors': {'atlassian-user-role-actor':\n    users, 'atlassian-group-role-actor': groups}}\nsuper(Role, self).update(**data)\n",
        "CUT_5": "\"\"\"Get a list of user Resources that match a username string and have browse permission for the issue or project.\n\n        :param user: a string to match usernames against.\n        :type user: str\n        :param issueKey: find users with browse permission for this issue.\n        :type issueKey: Optional[str]\n        :param projectKey: find users with browse permission for this project.\n        :type projectKey: Optional[str]\n        :param startAt: index of the first user to return. (Default: 0)\n        :type startAt: int\n        :param maxResults: maximum number of users to return.\n                If maxResults evaluates as False, it will try to get all items in batches. (Default: 50)\n        :type maxResults: int\n        \"\"\"\nparams = {'username': user}\nif issueKey is not None:\n    params['issueKey'] = issueKey\nif projectKey is not None:\n    params['projectKey'] = projectKey\nreturn self._fetch_pages(User, None, 'user/viewissue/search', startAt,\n    maxResults, params)\n"
    },
    {
        "functionName": "test_add_users_to_set",
        "className": "UserTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "users_set = set([self.test_manager.user_admin, self.test_manager.user_admin])\nself.assertEqual(len(users_set), 1)\n",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.attachment = None\n"
    },
    {
        "functionName": "test_create_version",
        "className": "VersionTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "name = 'new version ' + self.project_b\ndesc = 'test version of ' + self.project_b\nrelease_date = '2015-03-11'\nversion = self.jira.create_version(name, self.project_b, releaseDate=\n    release_date, description=desc)\nself.assertEqual(version.name, name)\nself.assertEqual(version.description, desc)\nself.assertEqual(version.releaseDate, release_date)\nversion.delete()\n",
        "CUT_1": "\"\"\"Create a version in a project and return a Resource for it.\n\n        :param name: name of the version to create\n        :type name: str\n        :param project: key of the project to create the version in\n        :type project: str\n        :param description: a description of the version\n        :type description: str\n        :param releaseDate: the release date assigned to the version\n        :type releaseDate: Optional[Any]\n        :param startDate: The start date for the version\n        :type startDate: Optional[Any]\n        :param archived: Denotes whether a version should be archived. (Default: False)\n        :type archived: bool\n        :param released: Denotes whether a version is released. (Default: False)\n        :type released: bool\n\n        :rtype: Version\n        \"\"\"\ndata = {'name': name, 'project': project, 'archived': archived, 'released':\n    released}\nif description is not None:\n    data['description'] = description\nif releaseDate is not None:\n    data['releaseDate'] = releaseDate\nif startDate is not None:\n    data['startDate'] = startDate\nurl = self._get_url('version')\nr = self._session.post(url, data=json.dumps(data))\ntime.sleep(1)\nversion = Version(self._options, self._session, raw=json_loads(r))\nreturn version\ntranslate_resource_args",
        "CUT_2": "\"\"\"Create a version in a project and return a Resource for it.\n\n        :param name: name of the version to create\n        :type name: str\n        :param project: key of the project to create the version in\n        :type project: str\n        :param description: a description of the version\n        :type description: str\n        :param releaseDate: the release date assigned to the version\n        :type releaseDate: Optional[Any]\n        :param startDate: The start date for the version\n        :type startDate: Optional[Any]\n        :param archived: Denotes whether a version should be archived. (Default: False)\n        :type archived: bool\n        :param released: Denotes whether a version is released. (Default: False)\n        :type released: bool\n\n        :rtype: Version\n        \"\"\"\ndata = {'name': name, 'project': project, 'archived': archived, 'released':\n    released}\nif description is not None:\n    data['description'] = description\nif releaseDate is not None:\n    data['releaseDate'] = releaseDate\nif startDate is not None:\n    data['startDate'] = startDate\nurl = self._get_url('version')\nr = self._session.post(url, data=json.dumps(data))\ntime.sleep(1)\nversion = Version(self._options, self._session, raw=json_loads(r))\nreturn version\ntranslate_resource_args",
        "CUT_3": "\"\"\"Returns a tuple of version and build version of installed Xcode.\"\"\"\nglobal XCODE_VERSION_CACHE\nif XCODE_VERSION_CACHE:\n    return XCODE_VERSION_CACHE\nversion = ''\nbuild = ''\ntry:\n    version_list = GetStdoutQuiet(['xcodebuild', '-version']).splitlines()\n    if len(version_list) < 2:\n        raise GypError('xcodebuild returned unexpected results')\n    version = version_list[0].split()[-1]\n    build = version_list[-1].split()[-1]\nexcept GypError:\n    version = CLTVersion()\n    if not version:\n        raise GypError('No Xcode or CLT version detected!')\nversion = version.split('.')[:3]\nversion[0] = version[0].zfill(2)\nversion = (''.join(version) + '00')[:4]\nXCODE_VERSION_CACHE = version, build\nreturn XCODE_VERSION_CACHE\n",
        "CUT_4": "\"\"\"Initializes the user file.\n\n    Args:\n      user_file_path: Path to the user file.\n      version: Version info.\n      name: Name of the user file.\n    \"\"\"\nself.user_file_path = user_file_path\nself.version = version\nself.name = name\nself.configurations = {}\n",
        "CUT_5": "\"\"\"Get the full description of the version.\"\"\"\nreturn self.description\n"
    },
    {
        "functionName": "test_create_version_with_project_obj",
        "className": "VersionTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "project = self.jira.project(self.project_b)\nversion = self.jira.create_version('new version 2', project, releaseDate=\n    '2015-03-11', description='test version!')\nself.assertEqual(version.name, 'new version 2')\nself.assertEqual(version.description, 'test version!')\nself.assertEqual(version.releaseDate, '2015-03-11')\nversion.delete()\n",
        "CUT_1": "\"\"\"Create a version in a project and return a Resource for it.\n\n        :param name: name of the version to create\n        :type name: str\n        :param project: key of the project to create the version in\n        :type project: str\n        :param description: a description of the version\n        :type description: str\n        :param releaseDate: the release date assigned to the version\n        :type releaseDate: Optional[Any]\n        :param startDate: The start date for the version\n        :type startDate: Optional[Any]\n        :param archived: Denotes whether a version should be archived. (Default: False)\n        :type archived: bool\n        :param released: Denotes whether a version is released. (Default: False)\n        :type released: bool\n\n        :rtype: Version\n        \"\"\"\ndata = {'name': name, 'project': project, 'archived': archived, 'released':\n    released}\nif description is not None:\n    data['description'] = description\nif releaseDate is not None:\n    data['releaseDate'] = releaseDate\nif startDate is not None:\n    data['startDate'] = startDate\nurl = self._get_url('version')\nr = self._session.post(url, data=json.dumps(data))\ntime.sleep(1)\nversion = Version(self._options, self._session, raw=json_loads(r))\nreturn version\ntranslate_resource_args",
        "CUT_2": "\"\"\"Create a version in a project and return a Resource for it.\n\n        :param name: name of the version to create\n        :type name: str\n        :param project: key of the project to create the version in\n        :type project: str\n        :param description: a description of the version\n        :type description: str\n        :param releaseDate: the release date assigned to the version\n        :type releaseDate: Optional[Any]\n        :param startDate: The start date for the version\n        :type startDate: Optional[Any]\n        :param archived: Denotes whether a version should be archived. (Default: False)\n        :type archived: bool\n        :param released: Denotes whether a version is released. (Default: False)\n        :type released: bool\n\n        :rtype: Version\n        \"\"\"\ndata = {'name': name, 'project': project, 'archived': archived, 'released':\n    released}\nif description is not None:\n    data['description'] = description\nif releaseDate is not None:\n    data['releaseDate'] = releaseDate\nif startDate is not None:\n    data['startDate'] = startDate\nurl = self._get_url('version')\nr = self._session.post(url, data=json.dumps(data))\ntime.sleep(1)\nversion = Version(self._options, self._session, raw=json_loads(r))\nreturn version\ntranslate_resource_args",
        "CUT_3": "\"\"\"Returns a tuple of version and build version of installed Xcode.\"\"\"\nglobal XCODE_VERSION_CACHE\nif XCODE_VERSION_CACHE:\n    return XCODE_VERSION_CACHE\nversion = ''\nbuild = ''\ntry:\n    version_list = GetStdoutQuiet(['xcodebuild', '-version']).splitlines()\n    if len(version_list) < 2:\n        raise GypError('xcodebuild returned unexpected results')\n    version = version_list[0].split()[-1]\n    build = version_list[-1].split()[-1]\nexcept GypError:\n    version = CLTVersion()\n    if not version:\n        raise GypError('No Xcode or CLT version detected!')\nversion = version.split('.')[:3]\nversion[0] = version[0].zfill(2)\nversion = (''.join(version) + '00')[:4]\nXCODE_VERSION_CACHE = version, build\nreturn XCODE_VERSION_CACHE\n",
        "CUT_4": "\"\"\"Get a version Resource by its name present on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :param version_name: name of the version to search for\n        :type version_name: str\n        :rtype: Optional[Version]\n        \"\"\"\nversions = self.project_versions(project)\nfor version in versions:\n    if version.name == version_name:\n        return version\ntranslate_resource_args",
        "CUT_5": "\"\"\"Get a version Resource by its name present on a project.\n\n        :param project: ID or key of the project to get versions from\n        :type project: str\n        :param version_name: name of the version to search for\n        :type version_name: str\n        :rtype: Optional[Version]\n        \"\"\"\nversions = self.project_versions(project)\nfor version in versions:\n    if version.name == version_name:\n        return version\ntranslate_resource_args"
    },
    {
        "functionName": "test_update_version",
        "className": "VersionTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "version = self.jira.create_version('new updated version 1', self.project_b,\n    releaseDate='2015-03-11', description='new to be updated!')\nversion.update(name='new updated version name 1', description='new updated!')\nself.assertEqual(version.name, 'new updated version name 1')\nself.assertEqual(version.description, 'new updated!')\nv = self.jira.version(version.id)\nself.assertEqual(v, version)\nself.assertEqual(v.id, version.id)\nversion.delete()\n",
        "CUT_1": "\"\"\"Returns a tuple of version and build version of installed Xcode.\"\"\"\nglobal XCODE_VERSION_CACHE\nif XCODE_VERSION_CACHE:\n    return XCODE_VERSION_CACHE\nversion = ''\nbuild = ''\ntry:\n    version_list = GetStdoutQuiet(['xcodebuild', '-version']).splitlines()\n    if len(version_list) < 2:\n        raise GypError('xcodebuild returned unexpected results')\n    version = version_list[0].split()[-1]\n    build = version_list[-1].split()[-1]\nexcept GypError:\n    version = CLTVersion()\n    if not version:\n        raise GypError('No Xcode or CLT version detected!')\nversion = version.split('.')[:3]\nversion[0] = version[0].zfill(2)\nversion = (''.join(version) + '00')[:4]\nXCODE_VERSION_CACHE = version, build\nreturn XCODE_VERSION_CACHE\n",
        "CUT_2": "\"\"\"Get a version Resource.\n\n        :param id: ID of the version to get\n        :type id: str\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[Any]\n\n        :rtype: Version\n        \"\"\"\nversion = Version(self._options, self._session)\nparams = {}\nif expand is not None:\n    params['expand'] = expand\nversion.find(id, params=params)\nreturn version\n",
        "CUT_3": "\"\"\"Get a version Resource.\n\n        :param id: ID of the version to get\n        :type id: str\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[Any]\n\n        :rtype: Version\n        \"\"\"\nversion = Version(self._options, self._session)\nparams = {}\nif expand is not None:\n    params['expand'] = expand\nversion.find(id, params=params)\nreturn version\n",
        "CUT_4": "\"\"\"Create a version in a project and return a Resource for it.\n\n        :param name: name of the version to create\n        :type name: str\n        :param project: key of the project to create the version in\n        :type project: str\n        :param description: a description of the version\n        :type description: str\n        :param releaseDate: the release date assigned to the version\n        :type releaseDate: Optional[Any]\n        :param startDate: The start date for the version\n        :type startDate: Optional[Any]\n        :param archived: Denotes whether a version should be archived. (Default: False)\n        :type archived: bool\n        :param released: Denotes whether a version is released. (Default: False)\n        :type released: bool\n\n        :rtype: Version\n        \"\"\"\ndata = {'name': name, 'project': project, 'archived': archived, 'released':\n    released}\nif description is not None:\n    data['description'] = description\nif releaseDate is not None:\n    data['releaseDate'] = releaseDate\nif startDate is not None:\n    data['startDate'] = startDate\nurl = self._get_url('version')\nr = self._session.post(url, data=json.dumps(data))\ntime.sleep(1)\nversion = Version(self._options, self._session, raw=json_loads(r))\nreturn version\ntranslate_resource_args",
        "CUT_5": "\"\"\"Create a version in a project and return a Resource for it.\n\n        :param name: name of the version to create\n        :type name: str\n        :param project: key of the project to create the version in\n        :type project: str\n        :param description: a description of the version\n        :type description: str\n        :param releaseDate: the release date assigned to the version\n        :type releaseDate: Optional[Any]\n        :param startDate: The start date for the version\n        :type startDate: Optional[Any]\n        :param archived: Denotes whether a version should be archived. (Default: False)\n        :type archived: bool\n        :param released: Denotes whether a version is released. (Default: False)\n        :type released: bool\n\n        :rtype: Version\n        \"\"\"\ndata = {'name': name, 'project': project, 'archived': archived, 'released':\n    released}\nif description is not None:\n    data['description'] = description\nif releaseDate is not None:\n    data['releaseDate'] = releaseDate\nif startDate is not None:\n    data['startDate'] = startDate\nurl = self._get_url('version')\nr = self._session.post(url, data=json.dumps(data))\ntime.sleep(1)\nversion = Version(self._options, self._session, raw=json_loads(r))\nreturn version\ntranslate_resource_args"
    },
    {
        "functionName": "test_delete_version",
        "className": "VersionTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "version_str = 'test_delete_version:' + self.manager.jid\nversion = self.jira.create_version(version_str, self.project_b, releaseDate\n    ='2015-03-11', description='not long for this world')\nversion.delete()\nself.assertRaises(JIRAError, self.jira.version, version.id)\n",
        "CUT_1": "\"\"\"Create a version in a project and return a Resource for it.\n\n        :param name: name of the version to create\n        :type name: str\n        :param project: key of the project to create the version in\n        :type project: str\n        :param description: a description of the version\n        :type description: str\n        :param releaseDate: the release date assigned to the version\n        :type releaseDate: Optional[Any]\n        :param startDate: The start date for the version\n        :type startDate: Optional[Any]\n        :param archived: Denotes whether a version should be archived. (Default: False)\n        :type archived: bool\n        :param released: Denotes whether a version is released. (Default: False)\n        :type released: bool\n\n        :rtype: Version\n        \"\"\"\ndata = {'name': name, 'project': project, 'archived': archived, 'released':\n    released}\nif description is not None:\n    data['description'] = description\nif releaseDate is not None:\n    data['releaseDate'] = releaseDate\nif startDate is not None:\n    data['startDate'] = startDate\nurl = self._get_url('version')\nr = self._session.post(url, data=json.dumps(data))\ntime.sleep(1)\nversion = Version(self._options, self._session, raw=json_loads(r))\nreturn version\ntranslate_resource_args",
        "CUT_2": "\"\"\"Create a version in a project and return a Resource for it.\n\n        :param name: name of the version to create\n        :type name: str\n        :param project: key of the project to create the version in\n        :type project: str\n        :param description: a description of the version\n        :type description: str\n        :param releaseDate: the release date assigned to the version\n        :type releaseDate: Optional[Any]\n        :param startDate: The start date for the version\n        :type startDate: Optional[Any]\n        :param archived: Denotes whether a version should be archived. (Default: False)\n        :type archived: bool\n        :param released: Denotes whether a version is released. (Default: False)\n        :type released: bool\n\n        :rtype: Version\n        \"\"\"\ndata = {'name': name, 'project': project, 'archived': archived, 'released':\n    released}\nif description is not None:\n    data['description'] = description\nif releaseDate is not None:\n    data['releaseDate'] = releaseDate\nif startDate is not None:\n    data['startDate'] = startDate\nurl = self._get_url('version')\nr = self._session.post(url, data=json.dumps(data))\ntime.sleep(1)\nversion = Version(self._options, self._session, raw=json_loads(r))\nreturn version\ntranslate_resource_args",
        "CUT_3": "\"\"\"Get a version Resource.\n\n        :param id: ID of the version to get\n        :type id: str\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[Any]\n\n        :rtype: Version\n        \"\"\"\nversion = Version(self._options, self._session)\nparams = {}\nif expand is not None:\n    params['expand'] = expand\nversion.find(id, params=params)\nreturn version\n",
        "CUT_4": "\"\"\"Get a version Resource.\n\n        :param id: ID of the version to get\n        :type id: str\n        :param expand: extra information to fetch inside each resource\n        :type expand: Optional[Any]\n\n        :rtype: Version\n        \"\"\"\nversion = Version(self._options, self._session)\nparams = {}\nif expand is not None:\n    params['expand'] = expand\nversion.find(id, params=params)\nreturn version\n",
        "CUT_5": "\"\"\"Returns a tuple of version and build version of installed Xcode.\"\"\"\nglobal XCODE_VERSION_CACHE\nif XCODE_VERSION_CACHE:\n    return XCODE_VERSION_CACHE\nversion = ''\nbuild = ''\ntry:\n    version_list = GetStdoutQuiet(['xcodebuild', '-version']).splitlines()\n    if len(version_list) < 2:\n        raise GypError('xcodebuild returned unexpected results')\n    version = version_list[0].split()[-1]\n    build = version_list[-1].split()[-1]\nexcept GypError:\n    version = CLTVersion()\n    if not version:\n        raise GypError('No Xcode or CLT version detected!')\nversion = version.split('.')[:3]\nversion[0] = version[0].zfill(2)\nversion = (''.join(version) + '00')[:4]\nXCODE_VERSION_CACHE = version, build\nreturn XCODE_VERSION_CACHE\n"
    },
    {
        "functionName": "test_session_invalid_login",
        "className": "OtherTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "try:\n    JIRA('https://jira.atlassian.com', basic_auth=('xxx', 'xxx'), validate=\n        True, logging=False)\nexcept Exception as e:\n    self.assertIsInstance(e, JIRAError)\n    assert e.status_code in (401, 500, 403)\n    str(JIRAError)\n    return\nassert False\n",
        "CUT_1": "self.jira = JIRA('https://jira.atlassian.com', logging=False, async_=True,\n    validate=False, get_server_info=False)\n",
        "CUT_2": "\"\"\"Returns whether or not the Jira instance supports service desk.\n\n        :rtype: bool\n        \"\"\"\nurl = self._options['server'] + '/rest/servicedeskapi/info'\nheaders = {'X-ExperimentalApi': 'opt-in'}\ntry:\n    r = self._session.get(url, headers=headers)\n    return r.status_code == 200\nexcept JIRAError:\n    return False\n",
        "CUT_3": "\"\"\"Returns whether or not the Jira instance supports service desk.\n\n        :rtype: bool\n        \"\"\"\nurl = self._options['server'] + '/rest/servicedeskapi/info'\nheaders = {'X-ExperimentalApi': 'opt-in'}\ntry:\n    r = self._session.get(url, headers=headers)\n    return r.status_code == 200\nexcept JIRAError:\n    return False\n",
        "CUT_4": "\"\"\"Construct a Jira client instance.\n\n        Without any arguments, this client will connect anonymously to the Jira instance\n        started by the Atlassian Plugin SDK from one of the 'atlas-run', ``atlas-debug``,\n        or ``atlas-run-standalone`` commands. By default, this instance runs at\n        ``http://localhost:2990/jira``. The ``options`` argument can be used to set the Jira instance to use.\n\n        Authentication is handled with the ``basic_auth`` argument. If authentication is supplied (and is\n        accepted by Jira), the client will remember it for subsequent requests.\n\n        For quick command line access to a server, see the ``jirashell`` script included with this distribution.\n\n        The easiest way to instantiate is using j = JIRA(\"https://jira.atlasian.com\")\n        :param server: The server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n        :type server: Optional[str]\n        :param options: Specify the server and properties this client will use. Use a dict with any\n            of the following properties:\n            * server -- the server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n            * rest_path -- the root REST path to use. Defaults to ``api``, where the Jira REST resources live.\n            * rest_api_version -- the version of the REST resources under rest_path to use. Defaults to ``2``.\n            * agile_rest_path - the REST path to use for Jira Agile requests. Defaults to ``greenhopper`` (old, private\n               API). Check `GreenHopperResource` for other supported values.\n            * verify -- Verify SSL certs. Defaults to ``True``.\n            * client_cert -- a tuple of (cert,key) for the requests library for client side SSL\n            * check_update -- Check whether using the newest python-jira library version.\n        :type options: Optional[Dict[str, Any]]\n        :param basic_auth: A tuple of username and password to use when establishing a session via HTTP BASIC\n        authentication.\n        :type basic_auth: Union[Dict, None, Tuple[str, str]]\n        :param oauth: A dict of properties for OAuth authentication. The following properties are required:\n            * access_token -- OAuth access token for the user\n            * access_token_secret -- OAuth access token secret to sign with the key\n            * consumer_key -- key of the OAuth application link defined in Jira\n            * key_cert -- private key file to sign requests with (should be the pair of the public key supplied to\n            Jira in the OAuth application link)\n        :type oauth: Optional[Any]\n        :param kerberos: If true it will enable Kerberos authentication.\n        :type kerberos: bool\n        :param kerberos_options: A dict of properties for Kerberos authentication. The following properties are possible:\n            * mutual_authentication -- string DISABLED or OPTIONAL.\n            Example kerberos_options structure: ``{'mutual_authentication': 'DISABLED'}``\n        :type kerberos_options: Optional[Dict[str,str]]\n        :param jwt: A dict of properties for JWT authentication supported by Atlassian Connect. The following\n            properties are required:\n            * secret -- shared secret as delivered during 'installed' lifecycle event\n            (see https://developer.atlassian.com/static/connect/docs/latest/modules/lifecycle.html for details)\n            * payload -- dict of fields to be inserted in the JWT payload, e.g. 'iss'\n            Example jwt structure: ``{'secret': SHARED_SECRET, 'payload': {'iss': PLUGIN_KEY}}``\n        :type jwt: Optional[Any]\n        :param validate: If true it will validate your credentials first. Remember that if you are accessing Jira\n            as anonymous it will fail to instantiate.\n        :type validate: bool\n        :param get_server_info: If true it will fetch server version info first to determine if some API calls\n            are available.\n        :type get_server_info: bool\n        :param async_: To enable async requests for those actions where we implemented it, like issue update() or delete().\n        :type async_: bool\n        :param async_workers: Set the number of worker threads for async operations.\n        :type async_workers: int\n        :param timeout: Set a read/connect timeout for the underlying calls to Jira (default: None)\n        :type timeout: Optional[Any]\n        Obviously this means that you cannot rely on the return code when this is enabled.\n        :param max_retries: Sets the amount Retries for the HTTP sessions initiated by the client. (Default: 3)\n        :type max_retries: int\n        :param proxies: Sets the proxies for the HTTP session.\n        :type proxies: Optional[Any]\n        :param auth: Set a cookie auth token if this is required.\n        :type auth: Optional[Tuple[str,str]]\n        :param logging: Determine whether or not logging should be enabled. (Default: True)\n        :type logging: bool\n        \"\"\"\nself.sys_version_info = tuple([i for i in sys.version_info])\nif options is None:\n    options = {}\n    if server and hasattr(server, 'keys'):\n        warnings.warn(\n            \"Old API usage, use JIRA(url) or JIRA(options={'server': url}, when using dictionary always use named parameters.\"\n            , DeprecationWarning)\n        options = server\n        server = None\nif server:\n    options['server'] = server\nif async_:\n    options['async'] = async_\n    options['async_workers'] = async_workers\nself.logging = logging\nself._options = copy.copy(JIRA.DEFAULT_OPTIONS)\nself._options.update(options)\nself._rank = None\nif self._options['server'].endswith('/'):\n    self._options['server'] = self._options['server'][:-1]\ncontext_path = urlparse(self._options['server']).path\nif len(context_path) > 0:\n    self._options['context_path'] = context_path\nself._try_magic()\nif oauth:\n    self._create_oauth_session(oauth, timeout)\nelif basic_auth:\n    self._create_http_basic_session(*basic_auth, timeout=timeout)\n    self._session.headers.update(self._options['headers'])\nelif jwt:\n    self._create_jwt_session(jwt, timeout)\nelif kerberos:\n    self._create_kerberos_session(timeout, kerberos_options=kerberos_options)\nelif auth:\n    self._create_cookie_auth(auth, timeout)\n    validate = True\nelse:\n    verify = self._options['verify']\n    self._session = ResilientSession(timeout=timeout)\n    self._session.verify = verify\nself._session.headers.update(self._options['headers'])\nif 'cookies' in self._options:\n    self._session.cookies.update(self._options['cookies'])\nself._session.max_retries = max_retries\nif proxies:\n    self._session.proxies = proxies\nself.auth = auth\nif validate:\n    user = self.session()\n    if user.raw is None:\n        auth_method = (oauth or basic_auth or jwt or kerberos or auth or\n            'anonymous')\n        raise JIRAError('Can not log in with %s' % str(auth_method))\nself.deploymentType = None\nif get_server_info:\n    si = self.server_info()\n    try:\n        self._version = tuple(si['versionNumbers'])\n    except Exception as e:\n        logging.error('invalid server_info: %s', si)\n        raise e\n    self.deploymentType = si.get('deploymentType')\nelse:\n    self._version = 0, 0, 0\nif self._options['check_update'] and not JIRA.checked_version:\n    self._check_update_()\n    JIRA.checked_version = True\nself._fields = {}\nfor f in self.fields():\n    if 'clauseNames' in f:\n        for name in f['clauseNames']:\n            self._fields[name] = f['id']\n",
        "CUT_5": "\"\"\"Construct a Jira client instance.\n\n        Without any arguments, this client will connect anonymously to the Jira instance\n        started by the Atlassian Plugin SDK from one of the 'atlas-run', ``atlas-debug``,\n        or ``atlas-run-standalone`` commands. By default, this instance runs at\n        ``http://localhost:2990/jira``. The ``options`` argument can be used to set the Jira instance to use.\n\n        Authentication is handled with the ``basic_auth`` argument. If authentication is supplied (and is\n        accepted by Jira), the client will remember it for subsequent requests.\n\n        For quick command line access to a server, see the ``jirashell`` script included with this distribution.\n\n        The easiest way to instantiate is using j = JIRA(\"https://jira.atlasian.com\")\n        :param server: The server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n        :type server: Optional[str]\n        :param options: Specify the server and properties this client will use. Use a dict with any\n            of the following properties:\n            * server -- the server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n            * rest_path -- the root REST path to use. Defaults to ``api``, where the Jira REST resources live.\n            * rest_api_version -- the version of the REST resources under rest_path to use. Defaults to ``2``.\n            * agile_rest_path - the REST path to use for Jira Agile requests. Defaults to ``greenhopper`` (old, private\n               API). Check `GreenHopperResource` for other supported values.\n            * verify -- Verify SSL certs. Defaults to ``True``.\n            * client_cert -- a tuple of (cert,key) for the requests library for client side SSL\n            * check_update -- Check whether using the newest python-jira library version.\n        :type options: Optional[Dict[str, Any]]\n        :param basic_auth: A tuple of username and password to use when establishing a session via HTTP BASIC\n        authentication.\n        :type basic_auth: Union[Dict, None, Tuple[str, str]]\n        :param oauth: A dict of properties for OAuth authentication. The following properties are required:\n            * access_token -- OAuth access token for the user\n            * access_token_secret -- OAuth access token secret to sign with the key\n            * consumer_key -- key of the OAuth application link defined in Jira\n            * key_cert -- private key file to sign requests with (should be the pair of the public key supplied to\n            Jira in the OAuth application link)\n        :type oauth: Optional[Any]\n        :param kerberos: If true it will enable Kerberos authentication.\n        :type kerberos: bool\n        :param kerberos_options: A dict of properties for Kerberos authentication. The following properties are possible:\n            * mutual_authentication -- string DISABLED or OPTIONAL.\n            Example kerberos_options structure: ``{'mutual_authentication': 'DISABLED'}``\n        :type kerberos_options: Optional[Dict[str,str]]\n        :param jwt: A dict of properties for JWT authentication supported by Atlassian Connect. The following\n            properties are required:\n            * secret -- shared secret as delivered during 'installed' lifecycle event\n            (see https://developer.atlassian.com/static/connect/docs/latest/modules/lifecycle.html for details)\n            * payload -- dict of fields to be inserted in the JWT payload, e.g. 'iss'\n            Example jwt structure: ``{'secret': SHARED_SECRET, 'payload': {'iss': PLUGIN_KEY}}``\n        :type jwt: Optional[Any]\n        :param validate: If true it will validate your credentials first. Remember that if you are accessing Jira\n            as anonymous it will fail to instantiate.\n        :type validate: bool\n        :param get_server_info: If true it will fetch server version info first to determine if some API calls\n            are available.\n        :type get_server_info: bool\n        :param async_: To enable async requests for those actions where we implemented it, like issue update() or delete().\n        :type async_: bool\n        :param async_workers: Set the number of worker threads for async operations.\n        :type async_workers: int\n        :param timeout: Set a read/connect timeout for the underlying calls to Jira (default: None)\n        :type timeout: Optional[Any]\n        Obviously this means that you cannot rely on the return code when this is enabled.\n        :param max_retries: Sets the amount Retries for the HTTP sessions initiated by the client. (Default: 3)\n        :type max_retries: int\n        :param proxies: Sets the proxies for the HTTP session.\n        :type proxies: Optional[Any]\n        :param auth: Set a cookie auth token if this is required.\n        :type auth: Optional[Tuple[str,str]]\n        :param logging: Determine whether or not logging should be enabled. (Default: True)\n        :type logging: bool\n        \"\"\"\nself.sys_version_info = tuple([i for i in sys.version_info])\nif options is None:\n    options = {}\n    if server and hasattr(server, 'keys'):\n        warnings.warn(\n            \"Old API usage, use JIRA(url) or JIRA(options={'server': url}, when using dictionary always use named parameters.\"\n            , DeprecationWarning)\n        options = server\n        server = None\nif server:\n    options['server'] = server\nif async_:\n    options['async'] = async_\n    options['async_workers'] = async_workers\nself.logging = logging\nself._options = copy.copy(JIRA.DEFAULT_OPTIONS)\nself._options.update(options)\nself._rank = None\nif self._options['server'].endswith('/'):\n    self._options['server'] = self._options['server'][:-1]\ncontext_path = urlparse(self._options['server']).path\nif len(context_path) > 0:\n    self._options['context_path'] = context_path\nself._try_magic()\nif oauth:\n    self._create_oauth_session(oauth, timeout)\nelif basic_auth:\n    self._create_http_basic_session(*basic_auth, timeout=timeout)\n    self._session.headers.update(self._options['headers'])\nelif jwt:\n    self._create_jwt_session(jwt, timeout)\nelif kerberos:\n    self._create_kerberos_session(timeout, kerberos_options=kerberos_options)\nelif auth:\n    self._create_cookie_auth(auth, timeout)\n    validate = True\nelse:\n    verify = self._options['verify']\n    self._session = ResilientSession(timeout=timeout)\n    self._session.verify = verify\nself._session.headers.update(self._options['headers'])\nif 'cookies' in self._options:\n    self._session.cookies.update(self._options['cookies'])\nself._session.max_retries = max_retries\nif proxies:\n    self._session.proxies = proxies\nself.auth = auth\nif validate:\n    user = self.session()\n    if user.raw is None:\n        auth_method = (oauth or basic_auth or jwt or kerberos or auth or\n            'anonymous')\n        raise JIRAError('Can not log in with %s' % str(auth_method))\nself.deploymentType = None\nif get_server_info:\n    si = self.server_info()\n    try:\n        self._version = tuple(si['versionNumbers'])\n    except Exception as e:\n        logging.error('invalid server_info: %s', si)\n        raise e\n    self.deploymentType = si.get('deploymentType')\nelse:\n    self._version = 0, 0, 0\nif self._options['check_update'] and not JIRA.checked_version:\n    self._check_update_()\n    JIRA.checked_version = True\nself._fields = {}\nfor f in self.fields():\n    if 'clauseNames' in f:\n        for name in f['clauseNames']:\n            self._fields[name] = f['id']\n"
    },
    {
        "functionName": "test_session",
        "className": "SessionTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "user = self.jira.session()\nself.assertIsNotNone(user.raw['self'])\nself.assertIsNotNone(user.raw['name'])\n",
        "CUT_1": "Resource.__init__(self, 'user?username={0}', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_2": "Resource.__init__(self, 'user?username={0}', options, session)\nif raw:\n    self._parse_raw(raw)\n",
        "CUT_3": "\"\"\"Get a dict of the current authenticated user's session information.\n\n        :rtype: User\n\n        \"\"\"\nurl = '{server}{auth_url}'.format(**self._options)\nr = self._session.get(url)\nuser = User(self._options, self._session, json_loads(r))\nreturn user\n",
        "CUT_4": "\"\"\"Get a dict of the current authenticated user's session information.\n\n        :rtype: User\n\n        \"\"\"\nurl = '{server}{auth_url}'.format(**self._options)\nr = self._session.get(url)\nuser = User(self._options, self._session, json_loads(r))\nreturn user\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_session_with_no_logged_in_user_raises",
        "className": "SessionTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "anon_jira = JIRA('https://jira.atlassian.com', logging=False)\nself.assertRaises(JIRAError, anon_jira.session)\n",
        "CUT_1": "self.jira = JIRA('https://jira.atlassian.com', logging=False, async_=True,\n    validate=False, get_server_info=False)\n",
        "CUT_2": "\"\"\"Get a dict of server information for this Jira instance.\n        :rtype: Dict[str, Any]\n        \"\"\"\nretry = 0\nj = self._get_json('serverInfo')\nwhile not j and retry < 3:\n    logging.warning(\n        'Bug https://jira.atlassian.com/browse/JRA-59676 trying again...')\n    retry += 1\n    j = self._get_json('serverInfo')\nreturn j\n",
        "CUT_3": "\"\"\"Get a dict of server information for this Jira instance.\n        :rtype: Dict[str, Any]\n        \"\"\"\nretry = 0\nj = self._get_json('serverInfo')\nwhile not j and retry < 3:\n    logging.warning(\n        'Bug https://jira.atlassian.com/browse/JRA-59676 trying again...')\n    retry += 1\n    j = self._get_json('serverInfo')\nreturn j\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_session_server_offline",
        "className": "SessionTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "try:\n    JIRA('https://127.0.0.1:1', logging=False, max_retries=0)\nexcept Exception as e:\n    self.assertIn(type(e), (JIRAError, requests.exceptions.ConnectionError,\n        AttributeError), e)\n    return\nself.assertTrue(False, 'Instantiation of invalid JIRA instance succeeded.')\n",
        "CUT_1": "self.jira = JIRA('https://jira.atlassian.com', logging=False, async_=True,\n    validate=False, get_server_info=False)\n",
        "CUT_2": "self.__dict__ = self.__shared_state\nif not self.__dict__:\n    self.initialized = 0\n    if 'CI_JIRA_URL' in os.environ:\n        self.CI_JIRA_URL = os.environ['CI_JIRA_URL']\n        self.max_retries = 5\n    else:\n        self.CI_JIRA_URL = 'https://pycontribs.atlassian.net'\n        self.max_retries = 5\n    if 'CI_JIRA_ADMIN' in os.environ:\n        self.CI_JIRA_ADMIN = os.environ['CI_JIRA_ADMIN']\n    else:\n        self.CI_JIRA_ADMIN = 'ci-admin'\n    if 'CI_JIRA_ADMIN_PASSWORD' in os.environ:\n        self.CI_JIRA_ADMIN_PASSWORD = os.environ['CI_JIRA_ADMIN_PASSWORD']\n    else:\n        self.CI_JIRA_ADMIN_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    if 'CI_JIRA_USER' in os.environ:\n        self.CI_JIRA_USER = os.environ['CI_JIRA_USER']\n    else:\n        self.CI_JIRA_USER = 'ci-user'\n    if 'CI_JIRA_USER_PASSWORD' in os.environ:\n        self.CI_JIRA_USER_PASSWORD = os.environ['CI_JIRA_USER_PASSWORD']\n    else:\n        self.CI_JIRA_USER_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    self.CI_JIRA_ISSUE = os.environ.get('CI_JIRA_ISSUE', 'Bug')\n    if OAUTH:\n        self.jira_admin = JIRA(oauth={'access_token':\n            'hTxcwsbUQiFuFALf7KZHDaeAJIo3tLUK', 'access_token_secret':\n            'aNCLQFP3ORNU6WY7HQISbqbhf0UudDAf', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    if not self.jira_admin.current_user():\n        self.initialized = 1\n        sys.exit(3)\n    if OAUTH:\n        self.jira_sysadmin = JIRA(oauth={'access_token':\n            '4ul1ETSFo7ybbIxAxzyRal39cTrwEGFv', 'access_token_secret':\n            'K83jBZnjnuVRcfjBflrKyThJa0KSjSs2', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA}, logging=False,\n            max_retries=self.max_retries)\n    elif self.CI_JIRA_ADMIN:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, logging=False,\n            max_retries=self.max_retries)\n    if OAUTH:\n        self.jira_normal = JIRA(oauth={'access_token':\n            'ZVDgYDyIQqJY8IFlQ446jZaURIz5ECiB', 'access_token_secret':\n            '5WbLBybPDg1lqqyFjyXSCsCtAWTwz1eD', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_USER, self.CI_JIRA_USER_PASSWORD), validate=True,\n            logging=False, max_retries=self.max_retries)\n    else:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    \"\"\" `jid` is important for avoiding concurency problems when\n            executing tests in parallel as we have only one test instance.\n\n            jid length must be less than 9 characters because we may append\n            another one and the Jira Project key length limit is 10.\n\n            Tests run in parallel:\n            * git branches master or developer, git pr or developers running\n                tests outside Travis\n            * Travis is using \"Travis\" username\n\n            https://docs.travis-ci.com/user/environment-variables/\n            \"\"\"\n    self.jid = get_unique_project_name()\n    self.project_a = self.jid + 'A'\n    self.project_a_name = 'Test user=%s key=%s A' % (getpass.getuser(),\n        self.project_a)\n    self.project_b = self.jid + 'B'\n    self.project_b_name = 'Test user=%s key=%s B' % (getpass.getuser(),\n        self.project_b)\n    self.project_sd = self.jid + 'C'\n    self.project_sd_name = 'Test user=%s key=%s C' % (getpass.getuser(),\n        self.project_b)\n    try:\n        self.jira_admin.project(self.project_a)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_a)\n        except Exception as e:\n            pass\n    try:\n        self.jira_admin.project(self.project_b)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_b)\n        except Exception as e:\n            pass\n    for i in range(1, 20):\n        try:\n            self.jira_admin.project(self.project_b)\n        except Exception:\n            break\n        print('Warning: Project not deleted yet....')\n        sleep(2)\n    for i in range(6):\n        try:\n            if self.jira_admin.create_project(self.project_a, self.\n                project_a_name):\n                break\n        except Exception as e:\n            if 'A project with that name already exists' not in e.text:\n                raise e\n    self.project_a_id = self.jira_admin.project(self.project_a).id\n    self.jira_admin.create_project(self.project_b, self.project_b_name)\n    try:\n        self.jira_admin.create_project(self.project_b, self.project_b_name)\n    except Exception:\n        pass\n    sleep(1)\n    self.project_b_issue1_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 1 from %s' % self.project_b, issuetype=\n        self.CI_JIRA_ISSUE)\n    self.project_b_issue1 = self.project_b_issue1_obj.key\n    self.project_b_issue2_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 2 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue2 = self.project_b_issue2_obj.key\n    self.project_b_issue3_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 3 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue3 = self.project_b_issue3_obj.key\nif not hasattr(self, 'jira_normal') or not hasattr(self, 'jira_admin'):\n    py.test.exit('FATAL: WTF!?')\nself.user_admin = self.jira_admin.search_users(self.CI_JIRA_ADMIN)[0]\nself.initialized = 1\n",
        "CUT_3": "self.deps = set()\nself.match_status = MATCH_STATUS_TBD\nself.back_deps = set()\nself.name = name\nself.visited = False\nself.requires_build = False\nself.added_to_compile_targets = False\nself.in_roots = False\nself.is_executable = False\nself.is_static_library = False\nself.is_or_has_linked_ancestor = False\n",
        "CUT_4": "\"\"\"Construct a Jira client instance.\n\n        Without any arguments, this client will connect anonymously to the Jira instance\n        started by the Atlassian Plugin SDK from one of the 'atlas-run', ``atlas-debug``,\n        or ``atlas-run-standalone`` commands. By default, this instance runs at\n        ``http://localhost:2990/jira``. The ``options`` argument can be used to set the Jira instance to use.\n\n        Authentication is handled with the ``basic_auth`` argument. If authentication is supplied (and is\n        accepted by Jira), the client will remember it for subsequent requests.\n\n        For quick command line access to a server, see the ``jirashell`` script included with this distribution.\n\n        The easiest way to instantiate is using j = JIRA(\"https://jira.atlasian.com\")\n        :param server: The server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n        :type server: Optional[str]\n        :param options: Specify the server and properties this client will use. Use a dict with any\n            of the following properties:\n            * server -- the server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n            * rest_path -- the root REST path to use. Defaults to ``api``, where the Jira REST resources live.\n            * rest_api_version -- the version of the REST resources under rest_path to use. Defaults to ``2``.\n            * agile_rest_path - the REST path to use for Jira Agile requests. Defaults to ``greenhopper`` (old, private\n               API). Check `GreenHopperResource` for other supported values.\n            * verify -- Verify SSL certs. Defaults to ``True``.\n            * client_cert -- a tuple of (cert,key) for the requests library for client side SSL\n            * check_update -- Check whether using the newest python-jira library version.\n        :type options: Optional[Dict[str, Any]]\n        :param basic_auth: A tuple of username and password to use when establishing a session via HTTP BASIC\n        authentication.\n        :type basic_auth: Union[Dict, None, Tuple[str, str]]\n        :param oauth: A dict of properties for OAuth authentication. The following properties are required:\n            * access_token -- OAuth access token for the user\n            * access_token_secret -- OAuth access token secret to sign with the key\n            * consumer_key -- key of the OAuth application link defined in Jira\n            * key_cert -- private key file to sign requests with (should be the pair of the public key supplied to\n            Jira in the OAuth application link)\n        :type oauth: Optional[Any]\n        :param kerberos: If true it will enable Kerberos authentication.\n        :type kerberos: bool\n        :param kerberos_options: A dict of properties for Kerberos authentication. The following properties are possible:\n            * mutual_authentication -- string DISABLED or OPTIONAL.\n            Example kerberos_options structure: ``{'mutual_authentication': 'DISABLED'}``\n        :type kerberos_options: Optional[Dict[str,str]]\n        :param jwt: A dict of properties for JWT authentication supported by Atlassian Connect. The following\n            properties are required:\n            * secret -- shared secret as delivered during 'installed' lifecycle event\n            (see https://developer.atlassian.com/static/connect/docs/latest/modules/lifecycle.html for details)\n            * payload -- dict of fields to be inserted in the JWT payload, e.g. 'iss'\n            Example jwt structure: ``{'secret': SHARED_SECRET, 'payload': {'iss': PLUGIN_KEY}}``\n        :type jwt: Optional[Any]\n        :param validate: If true it will validate your credentials first. Remember that if you are accessing Jira\n            as anonymous it will fail to instantiate.\n        :type validate: bool\n        :param get_server_info: If true it will fetch server version info first to determine if some API calls\n            are available.\n        :type get_server_info: bool\n        :param async_: To enable async requests for those actions where we implemented it, like issue update() or delete().\n        :type async_: bool\n        :param async_workers: Set the number of worker threads for async operations.\n        :type async_workers: int\n        :param timeout: Set a read/connect timeout for the underlying calls to Jira (default: None)\n        :type timeout: Optional[Any]\n        Obviously this means that you cannot rely on the return code when this is enabled.\n        :param max_retries: Sets the amount Retries for the HTTP sessions initiated by the client. (Default: 3)\n        :type max_retries: int\n        :param proxies: Sets the proxies for the HTTP session.\n        :type proxies: Optional[Any]\n        :param auth: Set a cookie auth token if this is required.\n        :type auth: Optional[Tuple[str,str]]\n        :param logging: Determine whether or not logging should be enabled. (Default: True)\n        :type logging: bool\n        \"\"\"\nself.sys_version_info = tuple([i for i in sys.version_info])\nif options is None:\n    options = {}\n    if server and hasattr(server, 'keys'):\n        warnings.warn(\n            \"Old API usage, use JIRA(url) or JIRA(options={'server': url}, when using dictionary always use named parameters.\"\n            , DeprecationWarning)\n        options = server\n        server = None\nif server:\n    options['server'] = server\nif async_:\n    options['async'] = async_\n    options['async_workers'] = async_workers\nself.logging = logging\nself._options = copy.copy(JIRA.DEFAULT_OPTIONS)\nself._options.update(options)\nself._rank = None\nif self._options['server'].endswith('/'):\n    self._options['server'] = self._options['server'][:-1]\ncontext_path = urlparse(self._options['server']).path\nif len(context_path) > 0:\n    self._options['context_path'] = context_path\nself._try_magic()\nif oauth:\n    self._create_oauth_session(oauth, timeout)\nelif basic_auth:\n    self._create_http_basic_session(*basic_auth, timeout=timeout)\n    self._session.headers.update(self._options['headers'])\nelif jwt:\n    self._create_jwt_session(jwt, timeout)\nelif kerberos:\n    self._create_kerberos_session(timeout, kerberos_options=kerberos_options)\nelif auth:\n    self._create_cookie_auth(auth, timeout)\n    validate = True\nelse:\n    verify = self._options['verify']\n    self._session = ResilientSession(timeout=timeout)\n    self._session.verify = verify\nself._session.headers.update(self._options['headers'])\nif 'cookies' in self._options:\n    self._session.cookies.update(self._options['cookies'])\nself._session.max_retries = max_retries\nif proxies:\n    self._session.proxies = proxies\nself.auth = auth\nif validate:\n    user = self.session()\n    if user.raw is None:\n        auth_method = (oauth or basic_auth or jwt or kerberos or auth or\n            'anonymous')\n        raise JIRAError('Can not log in with %s' % str(auth_method))\nself.deploymentType = None\nif get_server_info:\n    si = self.server_info()\n    try:\n        self._version = tuple(si['versionNumbers'])\n    except Exception as e:\n        logging.error('invalid server_info: %s', si)\n        raise e\n    self.deploymentType = si.get('deploymentType')\nelse:\n    self._version = 0, 0, 0\nif self._options['check_update'] and not JIRA.checked_version:\n    self._check_update_()\n    JIRA.checked_version = True\nself._fields = {}\nfor f in self.fields():\n    if 'clauseNames' in f:\n        for name in f['clauseNames']:\n            self._fields[name] = f['id']\n",
        "CUT_5": "\"\"\"Construct a Jira client instance.\n\n        Without any arguments, this client will connect anonymously to the Jira instance\n        started by the Atlassian Plugin SDK from one of the 'atlas-run', ``atlas-debug``,\n        or ``atlas-run-standalone`` commands. By default, this instance runs at\n        ``http://localhost:2990/jira``. The ``options`` argument can be used to set the Jira instance to use.\n\n        Authentication is handled with the ``basic_auth`` argument. If authentication is supplied (and is\n        accepted by Jira), the client will remember it for subsequent requests.\n\n        For quick command line access to a server, see the ``jirashell`` script included with this distribution.\n\n        The easiest way to instantiate is using j = JIRA(\"https://jira.atlasian.com\")\n        :param server: The server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n        :type server: Optional[str]\n        :param options: Specify the server and properties this client will use. Use a dict with any\n            of the following properties:\n            * server -- the server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n            * rest_path -- the root REST path to use. Defaults to ``api``, where the Jira REST resources live.\n            * rest_api_version -- the version of the REST resources under rest_path to use. Defaults to ``2``.\n            * agile_rest_path - the REST path to use for Jira Agile requests. Defaults to ``greenhopper`` (old, private\n               API). Check `GreenHopperResource` for other supported values.\n            * verify -- Verify SSL certs. Defaults to ``True``.\n            * client_cert -- a tuple of (cert,key) for the requests library for client side SSL\n            * check_update -- Check whether using the newest python-jira library version.\n        :type options: Optional[Dict[str, Any]]\n        :param basic_auth: A tuple of username and password to use when establishing a session via HTTP BASIC\n        authentication.\n        :type basic_auth: Union[Dict, None, Tuple[str, str]]\n        :param oauth: A dict of properties for OAuth authentication. The following properties are required:\n            * access_token -- OAuth access token for the user\n            * access_token_secret -- OAuth access token secret to sign with the key\n            * consumer_key -- key of the OAuth application link defined in Jira\n            * key_cert -- private key file to sign requests with (should be the pair of the public key supplied to\n            Jira in the OAuth application link)\n        :type oauth: Optional[Any]\n        :param kerberos: If true it will enable Kerberos authentication.\n        :type kerberos: bool\n        :param kerberos_options: A dict of properties for Kerberos authentication. The following properties are possible:\n            * mutual_authentication -- string DISABLED or OPTIONAL.\n            Example kerberos_options structure: ``{'mutual_authentication': 'DISABLED'}``\n        :type kerberos_options: Optional[Dict[str,str]]\n        :param jwt: A dict of properties for JWT authentication supported by Atlassian Connect. The following\n            properties are required:\n            * secret -- shared secret as delivered during 'installed' lifecycle event\n            (see https://developer.atlassian.com/static/connect/docs/latest/modules/lifecycle.html for details)\n            * payload -- dict of fields to be inserted in the JWT payload, e.g. 'iss'\n            Example jwt structure: ``{'secret': SHARED_SECRET, 'payload': {'iss': PLUGIN_KEY}}``\n        :type jwt: Optional[Any]\n        :param validate: If true it will validate your credentials first. Remember that if you are accessing Jira\n            as anonymous it will fail to instantiate.\n        :type validate: bool\n        :param get_server_info: If true it will fetch server version info first to determine if some API calls\n            are available.\n        :type get_server_info: bool\n        :param async_: To enable async requests for those actions where we implemented it, like issue update() or delete().\n        :type async_: bool\n        :param async_workers: Set the number of worker threads for async operations.\n        :type async_workers: int\n        :param timeout: Set a read/connect timeout for the underlying calls to Jira (default: None)\n        :type timeout: Optional[Any]\n        Obviously this means that you cannot rely on the return code when this is enabled.\n        :param max_retries: Sets the amount Retries for the HTTP sessions initiated by the client. (Default: 3)\n        :type max_retries: int\n        :param proxies: Sets the proxies for the HTTP session.\n        :type proxies: Optional[Any]\n        :param auth: Set a cookie auth token if this is required.\n        :type auth: Optional[Tuple[str,str]]\n        :param logging: Determine whether or not logging should be enabled. (Default: True)\n        :type logging: bool\n        \"\"\"\nself.sys_version_info = tuple([i for i in sys.version_info])\nif options is None:\n    options = {}\n    if server and hasattr(server, 'keys'):\n        warnings.warn(\n            \"Old API usage, use JIRA(url) or JIRA(options={'server': url}, when using dictionary always use named parameters.\"\n            , DeprecationWarning)\n        options = server\n        server = None\nif server:\n    options['server'] = server\nif async_:\n    options['async'] = async_\n    options['async_workers'] = async_workers\nself.logging = logging\nself._options = copy.copy(JIRA.DEFAULT_OPTIONS)\nself._options.update(options)\nself._rank = None\nif self._options['server'].endswith('/'):\n    self._options['server'] = self._options['server'][:-1]\ncontext_path = urlparse(self._options['server']).path\nif len(context_path) > 0:\n    self._options['context_path'] = context_path\nself._try_magic()\nif oauth:\n    self._create_oauth_session(oauth, timeout)\nelif basic_auth:\n    self._create_http_basic_session(*basic_auth, timeout=timeout)\n    self._session.headers.update(self._options['headers'])\nelif jwt:\n    self._create_jwt_session(jwt, timeout)\nelif kerberos:\n    self._create_kerberos_session(timeout, kerberos_options=kerberos_options)\nelif auth:\n    self._create_cookie_auth(auth, timeout)\n    validate = True\nelse:\n    verify = self._options['verify']\n    self._session = ResilientSession(timeout=timeout)\n    self._session.verify = verify\nself._session.headers.update(self._options['headers'])\nif 'cookies' in self._options:\n    self._session.cookies.update(self._options['cookies'])\nself._session.max_retries = max_retries\nif proxies:\n    self._session.proxies = proxies\nself.auth = auth\nif validate:\n    user = self.session()\n    if user.raw is None:\n        auth_method = (oauth or basic_auth or jwt or kerberos or auth or\n            'anonymous')\n        raise JIRAError('Can not log in with %s' % str(auth_method))\nself.deploymentType = None\nif get_server_info:\n    si = self.server_info()\n    try:\n        self._version = tuple(si['versionNumbers'])\n    except Exception as e:\n        logging.error('invalid server_info: %s', si)\n        raise e\n    self.deploymentType = si.get('deploymentType')\nelse:\n    self._version = 0, 0, 0\nif self._options['check_update'] and not JIRA.checked_version:\n    self._check_update_()\n    JIRA.checked_version = True\nself._fields = {}\nfor f in self.fields():\n    if 'clauseNames' in f:\n        for name in f['clauseNames']:\n            self._fields[name] = f['id']\n"
    },
    {
        "functionName": "test_fetch_pages",
        "className": "AsyncTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"Tests that the JIRA._fetch_pages method works as expected. \"\"\"\nparams = {'startAt': 0}\ntotal = 26\nexpected_results = []\nfor i in range(0, total):\n    result = _create_issue_result_json(i, 'summary %s' % i, key='KEY-%s' % i)\n    expected_results.append(result)\nresult_one = _create_issue_search_results_json(expected_results[:10],\n    max_results=10, total=total)\nresult_two = _create_issue_search_results_json(expected_results[10:20],\n    max_results=10, total=total)\nresult_three = _create_issue_search_results_json(expected_results[20:],\n    max_results=6, total=total)\nmock_session = mock.Mock(name='mock_session')\nresponses = mock.Mock(name='responses')\nresponses.content = '_filler_'\nresponses.json.side_effect = [result_one, result_two, result_three]\nresponses.status_code = 200\nmock_session.request.return_value = responses\nmock_session.get.return_value = responses\nself.jira._session.close()\nself.jira._session = mock_session\nitems = self.jira._fetch_pages(Issue, 'issues', 'search', 0, False, params)\nself.assertEqual(len(items), total)\nself.assertEqual(set(item.key for item in items), set(expected_r['key'] for\n    expected_r in expected_results))\n",
        "CUT_1": "\"\"\"Returns a minimal json object for Jira issue search results. \"\"\"\nreturn {'startAt': kwargs.get('start_at', 0), 'maxResults': kwargs.get(\n    'max_results', 50), 'total': kwargs.get('total', len(issues)), 'issues':\n    issues}\n",
        "CUT_2": "\"\"\"Fetch pages.\n\n        :param item_type: Type of single item. ResultList of such items will be returned.\n        :type item_type: type\n        :param items_key: Path to the items in JSON returned from server.\n                Set it to None, if response is an array, and not a JSON object.\n        :type items_key: Optional[str]\n        :param request_path: path in request URL\n        :type request_path: str\n        :param startAt: index of the first record to be fetched. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of items to return.\n                If maxResults evaluates as False, it will try to get all items in batches. (Default:50)\n        :type maxResults: int\n        :param params: Params to be used in all requests. Should not contain startAt and maxResults,\n                        as they will be added for each request created from this function.\n        :type params: Dict[str, Any]\n        :param base: base URL\n        :type base: str\n        :rtype: ResultList\n        \"\"\"\nasync_class = None\nif self._options['async']:\n    try:\n        from requests_futures.sessions import FuturesSession\n        async_class = FuturesSession\n    except ImportError:\n        pass\n    async_workers = self._options['async_workers']\npage_params = params.copy() if params else {}\nif startAt:\n    page_params['startAt'] = startAt\nif maxResults:\n    page_params['maxResults'] = maxResults\nresource = self._get_json(request_path, params=page_params, base=base)\nnext_items_page = self._get_items_from_page(item_type, items_key, resource)\nitems = next_items_page\nif True:\n    if isinstance(resource, dict):\n        total = resource.get('total')\n        is_last = resource.get('isLast', False)\n        start_at_from_response = resource.get('startAt', 0)\n        max_results_from_response = resource.get('maxResults', 1)\n    else:\n        total = 1\n        is_last = True\n        start_at_from_response = 0\n        max_results_from_response = 1\n    if not maxResults:\n        page_size = max_results_from_response or len(items)\n        page_start = (startAt or start_at_from_response or 0) + page_size\n        if async_class is not None and not is_last and (total is not None and\n            len(items) < total):\n            async_fetches = []\n            future_session = async_class(session=self._session, max_workers\n                =async_workers)\n            for start_index in range(page_start, total, page_size):\n                page_params = params.copy()\n                page_params['startAt'] = start_index\n                page_params['maxResults'] = page_size\n                url = self._get_url(request_path)\n                r = future_session.get(url, params=page_params)\n                async_fetches.append(r)\n            for future in async_fetches:\n                response = future.result()\n                resource = json_loads(response)\n                if resource:\n                    next_items_page = self._get_items_from_page(item_type,\n                        items_key, resource)\n                    items.extend(next_items_page)\n        while async_class is None and not is_last and (total is None or \n            page_start < total) and len(next_items_page) == page_size:\n            page_params['startAt'] = page_start\n            page_params['maxResults'] = page_size\n            resource = self._get_json(request_path, params=page_params,\n                base=base)\n            if resource:\n                next_items_page = self._get_items_from_page(item_type,\n                    items_key, resource)\n                items.extend(next_items_page)\n                page_start += page_size\n            else:\n                break\n    return ResultList(items, start_at_from_response,\n        max_results_from_response, total, is_last)\nelse:\n    return ResultList([item_type(self._options, self._session, resource)], \n        0, 1, 1, True)\n",
        "CUT_3": "\"\"\"Fetch pages.\n\n        :param item_type: Type of single item. ResultList of such items will be returned.\n        :type item_type: type\n        :param items_key: Path to the items in JSON returned from server.\n                Set it to None, if response is an array, and not a JSON object.\n        :type items_key: Optional[str]\n        :param request_path: path in request URL\n        :type request_path: str\n        :param startAt: index of the first record to be fetched. (Default: 0)\n        :type startAt: int\n        :param maxResults: Maximum number of items to return.\n                If maxResults evaluates as False, it will try to get all items in batches. (Default:50)\n        :type maxResults: int\n        :param params: Params to be used in all requests. Should not contain startAt and maxResults,\n                        as they will be added for each request created from this function.\n        :type params: Dict[str, Any]\n        :param base: base URL\n        :type base: str\n        :rtype: ResultList\n        \"\"\"\nasync_class = None\nif self._options['async']:\n    try:\n        from requests_futures.sessions import FuturesSession\n        async_class = FuturesSession\n    except ImportError:\n        pass\n    async_workers = self._options['async_workers']\npage_params = params.copy() if params else {}\nif startAt:\n    page_params['startAt'] = startAt\nif maxResults:\n    page_params['maxResults'] = maxResults\nresource = self._get_json(request_path, params=page_params, base=base)\nnext_items_page = self._get_items_from_page(item_type, items_key, resource)\nitems = next_items_page\nif True:\n    if isinstance(resource, dict):\n        total = resource.get('total')\n        is_last = resource.get('isLast', False)\n        start_at_from_response = resource.get('startAt', 0)\n        max_results_from_response = resource.get('maxResults', 1)\n    else:\n        total = 1\n        is_last = True\n        start_at_from_response = 0\n        max_results_from_response = 1\n    if not maxResults:\n        page_size = max_results_from_response or len(items)\n        page_start = (startAt or start_at_from_response or 0) + page_size\n        if async_class is not None and not is_last and (total is not None and\n            len(items) < total):\n            async_fetches = []\n            future_session = async_class(session=self._session, max_workers\n                =async_workers)\n            for start_index in range(page_start, total, page_size):\n                page_params = params.copy()\n                page_params['startAt'] = start_index\n                page_params['maxResults'] = page_size\n                url = self._get_url(request_path)\n                r = future_session.get(url, params=page_params)\n                async_fetches.append(r)\n            for future in async_fetches:\n                response = future.result()\n                resource = json_loads(response)\n                if resource:\n                    next_items_page = self._get_items_from_page(item_type,\n                        items_key, resource)\n                    items.extend(next_items_page)\n        while async_class is None and not is_last and (total is None or \n            page_start < total) and len(next_items_page) == page_size:\n            page_params['startAt'] = page_start\n            page_params['maxResults'] = page_size\n            resource = self._get_json(request_path, params=page_params,\n                base=base)\n            if resource:\n                next_items_page = self._get_items_from_page(item_type,\n                    items_key, resource)\n                items.extend(next_items_page)\n                page_start += page_size\n            else:\n                break\n    return ResultList(items, start_at_from_response,\n        max_results_from_response, total, is_last)\nelse:\n    return ResultList([item_type(self._options, self._session, resource)], \n        0, 1, 1, True)\n",
        "CUT_4": "\"\"\"\n        :return: int\n        \"\"\"\nself.current += 1\nif self.current > self.total:\n    raise StopIteration\nelse:\n    return self.iterable[self.current - 1]\n",
        "CUT_5": "\"\"\"\n        :return: int\n        \"\"\"\nself.current += 1\nif self.current > self.total:\n    raise StopIteration\nelse:\n    return self.iterable[self.current - 1]\n"
    },
    {
        "functionName": "test_kill_websudo",
        "className": "WebsudoTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "self.jira.kill_websudo()\n",
        "CUT_1": "self.jira = JIRA('https://jira.atlassian.com', logging=False, async_=True,\n    validate=False, get_server_info=False)\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\n"
    },
    {
        "functionName": "test_add_and_remove_user",
        "className": "UserAdministrationTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "if self._should_skip_for_pycontribs_instance():\n    self._skip_pycontribs_instance()\ntry:\n    self.jira.delete_user(self.test_username)\nexcept JIRAError as e:\n    print(e)\n    pass\nresult = self.jira.add_user(self.test_username, self.test_email, password=\n    self.test_password)\nassert result, True\ntry:\n    self.jira.add_user(self.test_username, self.test_email, password=self.\n        test_password)\nexcept JIRAError:\n    pass\nresult = self.jira.delete_user(self.test_username)\nassert result, True\nx = -1\nfor i in range(10):\n    x = self.jira.search_users(self.test_username)\n    if len(x) == 0:\n        break\n    sleep(1)\nself.assertEqual(len(x), 0,\n    'Found test user when it should have been deleted. Test Fails.')\nresult = self.jira.add_user(self.test_username, self.test_email, password=\n    self.test_password, application_keys=['jira-software'])\nassert result, True\nresult = self.jira.delete_user(self.test_username)\nassert result, True\n",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\nself.test_username = 'test_%s' % self.test_manager.project_a\nself.test_email = '%s@example.com' % self.test_username\nself.test_password = rndpassword()\nself.test_groupname = 'testGroupFor_%s' % self.test_manager.project_a\n",
        "CUT_2": "\"\"\"Returns the supplied test targets without 'all'.\"\"\"\nresult = self._supplied_target_names()\nresult.discard('all')\nreturn result\n",
        "CUT_3": "try:\n    return self.cache[args]\nexcept KeyError:\n    result = self.func(*args)\n    self.cache[args] = result\n    return result\n",
        "CUT_4": "self.__dict__ = self.__shared_state\nif not self.__dict__:\n    self.initialized = 0\n    if 'CI_JIRA_URL' in os.environ:\n        self.CI_JIRA_URL = os.environ['CI_JIRA_URL']\n        self.max_retries = 5\n    else:\n        self.CI_JIRA_URL = 'https://pycontribs.atlassian.net'\n        self.max_retries = 5\n    if 'CI_JIRA_ADMIN' in os.environ:\n        self.CI_JIRA_ADMIN = os.environ['CI_JIRA_ADMIN']\n    else:\n        self.CI_JIRA_ADMIN = 'ci-admin'\n    if 'CI_JIRA_ADMIN_PASSWORD' in os.environ:\n        self.CI_JIRA_ADMIN_PASSWORD = os.environ['CI_JIRA_ADMIN_PASSWORD']\n    else:\n        self.CI_JIRA_ADMIN_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    if 'CI_JIRA_USER' in os.environ:\n        self.CI_JIRA_USER = os.environ['CI_JIRA_USER']\n    else:\n        self.CI_JIRA_USER = 'ci-user'\n    if 'CI_JIRA_USER_PASSWORD' in os.environ:\n        self.CI_JIRA_USER_PASSWORD = os.environ['CI_JIRA_USER_PASSWORD']\n    else:\n        self.CI_JIRA_USER_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    self.CI_JIRA_ISSUE = os.environ.get('CI_JIRA_ISSUE', 'Bug')\n    if OAUTH:\n        self.jira_admin = JIRA(oauth={'access_token':\n            'hTxcwsbUQiFuFALf7KZHDaeAJIo3tLUK', 'access_token_secret':\n            'aNCLQFP3ORNU6WY7HQISbqbhf0UudDAf', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    if not self.jira_admin.current_user():\n        self.initialized = 1\n        sys.exit(3)\n    if OAUTH:\n        self.jira_sysadmin = JIRA(oauth={'access_token':\n            '4ul1ETSFo7ybbIxAxzyRal39cTrwEGFv', 'access_token_secret':\n            'K83jBZnjnuVRcfjBflrKyThJa0KSjSs2', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA}, logging=False,\n            max_retries=self.max_retries)\n    elif self.CI_JIRA_ADMIN:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, logging=False,\n            max_retries=self.max_retries)\n    if OAUTH:\n        self.jira_normal = JIRA(oauth={'access_token':\n            'ZVDgYDyIQqJY8IFlQ446jZaURIz5ECiB', 'access_token_secret':\n            '5WbLBybPDg1lqqyFjyXSCsCtAWTwz1eD', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_USER, self.CI_JIRA_USER_PASSWORD), validate=True,\n            logging=False, max_retries=self.max_retries)\n    else:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    \"\"\" `jid` is important for avoiding concurency problems when\n            executing tests in parallel as we have only one test instance.\n\n            jid length must be less than 9 characters because we may append\n            another one and the Jira Project key length limit is 10.\n\n            Tests run in parallel:\n            * git branches master or developer, git pr or developers running\n                tests outside Travis\n            * Travis is using \"Travis\" username\n\n            https://docs.travis-ci.com/user/environment-variables/\n            \"\"\"\n    self.jid = get_unique_project_name()\n    self.project_a = self.jid + 'A'\n    self.project_a_name = 'Test user=%s key=%s A' % (getpass.getuser(),\n        self.project_a)\n    self.project_b = self.jid + 'B'\n    self.project_b_name = 'Test user=%s key=%s B' % (getpass.getuser(),\n        self.project_b)\n    self.project_sd = self.jid + 'C'\n    self.project_sd_name = 'Test user=%s key=%s C' % (getpass.getuser(),\n        self.project_b)\n    try:\n        self.jira_admin.project(self.project_a)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_a)\n        except Exception as e:\n            pass\n    try:\n        self.jira_admin.project(self.project_b)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_b)\n        except Exception as e:\n            pass\n    for i in range(1, 20):\n        try:\n            self.jira_admin.project(self.project_b)\n        except Exception:\n            break\n        print('Warning: Project not deleted yet....')\n        sleep(2)\n    for i in range(6):\n        try:\n            if self.jira_admin.create_project(self.project_a, self.\n                project_a_name):\n                break\n        except Exception as e:\n            if 'A project with that name already exists' not in e.text:\n                raise e\n    self.project_a_id = self.jira_admin.project(self.project_a).id\n    self.jira_admin.create_project(self.project_b, self.project_b_name)\n    try:\n        self.jira_admin.create_project(self.project_b, self.project_b_name)\n    except Exception:\n        pass\n    sleep(1)\n    self.project_b_issue1_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 1 from %s' % self.project_b, issuetype=\n        self.CI_JIRA_ISSUE)\n    self.project_b_issue1 = self.project_b_issue1_obj.key\n    self.project_b_issue2_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 2 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue2 = self.project_b_issue2_obj.key\n    self.project_b_issue3_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 3 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue3 = self.project_b_issue3_obj.key\nif not hasattr(self, 'jira_normal') or not hasattr(self, 'jira_admin'):\n    py.test.exit('FATAL: WTF!?')\nself.user_admin = self.jira_admin.search_users(self.CI_JIRA_ADMIN)[0]\nself.initialized = 1\n",
        "CUT_5": "return self\n"
    },
    {
        "functionName": "test_add_group",
        "className": "UserAdministrationTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "if self._should_skip_for_pycontribs_instance():\n    self._skip_pycontribs_instance()\ntry:\n    self.jira.remove_group(self.test_groupname)\nexcept JIRAError:\n    pass\nsleep(2)\nresult = self.jira.add_group(self.test_groupname)\nassert result, True\nx = self.jira.groups(query=self.test_groupname)\nself.assertEqual(self.test_groupname, x[0],\n    'Did not find expected group after trying to add it. Test Fails.')\nself.jira.remove_group(self.test_groupname)\n",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\nself.test_username = 'test_%s' % self.test_manager.project_a\nself.test_email = '%s@example.com' % self.test_username\nself.test_password = rndpassword()\nself.test_groupname = 'testGroupFor_%s' % self.test_manager.project_a\n",
        "CUT_2": "return self\n",
        "CUT_3": "self.__dict__ = self.__shared_state\nif not self.__dict__:\n    self.initialized = 0\n    if 'CI_JIRA_URL' in os.environ:\n        self.CI_JIRA_URL = os.environ['CI_JIRA_URL']\n        self.max_retries = 5\n    else:\n        self.CI_JIRA_URL = 'https://pycontribs.atlassian.net'\n        self.max_retries = 5\n    if 'CI_JIRA_ADMIN' in os.environ:\n        self.CI_JIRA_ADMIN = os.environ['CI_JIRA_ADMIN']\n    else:\n        self.CI_JIRA_ADMIN = 'ci-admin'\n    if 'CI_JIRA_ADMIN_PASSWORD' in os.environ:\n        self.CI_JIRA_ADMIN_PASSWORD = os.environ['CI_JIRA_ADMIN_PASSWORD']\n    else:\n        self.CI_JIRA_ADMIN_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    if 'CI_JIRA_USER' in os.environ:\n        self.CI_JIRA_USER = os.environ['CI_JIRA_USER']\n    else:\n        self.CI_JIRA_USER = 'ci-user'\n    if 'CI_JIRA_USER_PASSWORD' in os.environ:\n        self.CI_JIRA_USER_PASSWORD = os.environ['CI_JIRA_USER_PASSWORD']\n    else:\n        self.CI_JIRA_USER_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    self.CI_JIRA_ISSUE = os.environ.get('CI_JIRA_ISSUE', 'Bug')\n    if OAUTH:\n        self.jira_admin = JIRA(oauth={'access_token':\n            'hTxcwsbUQiFuFALf7KZHDaeAJIo3tLUK', 'access_token_secret':\n            'aNCLQFP3ORNU6WY7HQISbqbhf0UudDAf', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    if not self.jira_admin.current_user():\n        self.initialized = 1\n        sys.exit(3)\n    if OAUTH:\n        self.jira_sysadmin = JIRA(oauth={'access_token':\n            '4ul1ETSFo7ybbIxAxzyRal39cTrwEGFv', 'access_token_secret':\n            'K83jBZnjnuVRcfjBflrKyThJa0KSjSs2', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA}, logging=False,\n            max_retries=self.max_retries)\n    elif self.CI_JIRA_ADMIN:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, logging=False,\n            max_retries=self.max_retries)\n    if OAUTH:\n        self.jira_normal = JIRA(oauth={'access_token':\n            'ZVDgYDyIQqJY8IFlQ446jZaURIz5ECiB', 'access_token_secret':\n            '5WbLBybPDg1lqqyFjyXSCsCtAWTwz1eD', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_USER, self.CI_JIRA_USER_PASSWORD), validate=True,\n            logging=False, max_retries=self.max_retries)\n    else:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    \"\"\" `jid` is important for avoiding concurency problems when\n            executing tests in parallel as we have only one test instance.\n\n            jid length must be less than 9 characters because we may append\n            another one and the Jira Project key length limit is 10.\n\n            Tests run in parallel:\n            * git branches master or developer, git pr or developers running\n                tests outside Travis\n            * Travis is using \"Travis\" username\n\n            https://docs.travis-ci.com/user/environment-variables/\n            \"\"\"\n    self.jid = get_unique_project_name()\n    self.project_a = self.jid + 'A'\n    self.project_a_name = 'Test user=%s key=%s A' % (getpass.getuser(),\n        self.project_a)\n    self.project_b = self.jid + 'B'\n    self.project_b_name = 'Test user=%s key=%s B' % (getpass.getuser(),\n        self.project_b)\n    self.project_sd = self.jid + 'C'\n    self.project_sd_name = 'Test user=%s key=%s C' % (getpass.getuser(),\n        self.project_b)\n    try:\n        self.jira_admin.project(self.project_a)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_a)\n        except Exception as e:\n            pass\n    try:\n        self.jira_admin.project(self.project_b)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_b)\n        except Exception as e:\n            pass\n    for i in range(1, 20):\n        try:\n            self.jira_admin.project(self.project_b)\n        except Exception:\n            break\n        print('Warning: Project not deleted yet....')\n        sleep(2)\n    for i in range(6):\n        try:\n            if self.jira_admin.create_project(self.project_a, self.\n                project_a_name):\n                break\n        except Exception as e:\n            if 'A project with that name already exists' not in e.text:\n                raise e\n    self.project_a_id = self.jira_admin.project(self.project_a).id\n    self.jira_admin.create_project(self.project_b, self.project_b_name)\n    try:\n        self.jira_admin.create_project(self.project_b, self.project_b_name)\n    except Exception:\n        pass\n    sleep(1)\n    self.project_b_issue1_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 1 from %s' % self.project_b, issuetype=\n        self.CI_JIRA_ISSUE)\n    self.project_b_issue1 = self.project_b_issue1_obj.key\n    self.project_b_issue2_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 2 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue2 = self.project_b_issue2_obj.key\n    self.project_b_issue3_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 3 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue3 = self.project_b_issue3_obj.key\nif not hasattr(self, 'jira_normal') or not hasattr(self, 'jira_admin'):\n    py.test.exit('FATAL: WTF!?')\nself.user_admin = self.jira_admin.search_users(self.CI_JIRA_ADMIN)[0]\nself.initialized = 1\n",
        "CUT_4": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_remove_group",
        "className": "UserAdministrationTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "if self._should_skip_for_pycontribs_instance():\n    self._skip_pycontribs_instance()\ntry:\n    self.jira.add_group(self.test_groupname)\n    sleep(1)\nexcept JIRAError:\n    pass\nresult = self.jira.remove_group(self.test_groupname)\nassert result, True\nx = -1\nfor i in range(5):\n    x = self.jira.groups(query=self.test_groupname)\n    if x == 0:\n        break\n    sleep(1)\nself.assertEqual(len(x), 0,\n    'Found group with name when it should have been deleted. Test Fails.')\n",
        "CUT_1": "self.__dict__ = self.__shared_state\nif not self.__dict__:\n    self.initialized = 0\n    if 'CI_JIRA_URL' in os.environ:\n        self.CI_JIRA_URL = os.environ['CI_JIRA_URL']\n        self.max_retries = 5\n    else:\n        self.CI_JIRA_URL = 'https://pycontribs.atlassian.net'\n        self.max_retries = 5\n    if 'CI_JIRA_ADMIN' in os.environ:\n        self.CI_JIRA_ADMIN = os.environ['CI_JIRA_ADMIN']\n    else:\n        self.CI_JIRA_ADMIN = 'ci-admin'\n    if 'CI_JIRA_ADMIN_PASSWORD' in os.environ:\n        self.CI_JIRA_ADMIN_PASSWORD = os.environ['CI_JIRA_ADMIN_PASSWORD']\n    else:\n        self.CI_JIRA_ADMIN_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    if 'CI_JIRA_USER' in os.environ:\n        self.CI_JIRA_USER = os.environ['CI_JIRA_USER']\n    else:\n        self.CI_JIRA_USER = 'ci-user'\n    if 'CI_JIRA_USER_PASSWORD' in os.environ:\n        self.CI_JIRA_USER_PASSWORD = os.environ['CI_JIRA_USER_PASSWORD']\n    else:\n        self.CI_JIRA_USER_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    self.CI_JIRA_ISSUE = os.environ.get('CI_JIRA_ISSUE', 'Bug')\n    if OAUTH:\n        self.jira_admin = JIRA(oauth={'access_token':\n            'hTxcwsbUQiFuFALf7KZHDaeAJIo3tLUK', 'access_token_secret':\n            'aNCLQFP3ORNU6WY7HQISbqbhf0UudDAf', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    if not self.jira_admin.current_user():\n        self.initialized = 1\n        sys.exit(3)\n    if OAUTH:\n        self.jira_sysadmin = JIRA(oauth={'access_token':\n            '4ul1ETSFo7ybbIxAxzyRal39cTrwEGFv', 'access_token_secret':\n            'K83jBZnjnuVRcfjBflrKyThJa0KSjSs2', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA}, logging=False,\n            max_retries=self.max_retries)\n    elif self.CI_JIRA_ADMIN:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, logging=False,\n            max_retries=self.max_retries)\n    if OAUTH:\n        self.jira_normal = JIRA(oauth={'access_token':\n            'ZVDgYDyIQqJY8IFlQ446jZaURIz5ECiB', 'access_token_secret':\n            '5WbLBybPDg1lqqyFjyXSCsCtAWTwz1eD', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_USER, self.CI_JIRA_USER_PASSWORD), validate=True,\n            logging=False, max_retries=self.max_retries)\n    else:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    \"\"\" `jid` is important for avoiding concurency problems when\n            executing tests in parallel as we have only one test instance.\n\n            jid length must be less than 9 characters because we may append\n            another one and the Jira Project key length limit is 10.\n\n            Tests run in parallel:\n            * git branches master or developer, git pr or developers running\n                tests outside Travis\n            * Travis is using \"Travis\" username\n\n            https://docs.travis-ci.com/user/environment-variables/\n            \"\"\"\n    self.jid = get_unique_project_name()\n    self.project_a = self.jid + 'A'\n    self.project_a_name = 'Test user=%s key=%s A' % (getpass.getuser(),\n        self.project_a)\n    self.project_b = self.jid + 'B'\n    self.project_b_name = 'Test user=%s key=%s B' % (getpass.getuser(),\n        self.project_b)\n    self.project_sd = self.jid + 'C'\n    self.project_sd_name = 'Test user=%s key=%s C' % (getpass.getuser(),\n        self.project_b)\n    try:\n        self.jira_admin.project(self.project_a)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_a)\n        except Exception as e:\n            pass\n    try:\n        self.jira_admin.project(self.project_b)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_b)\n        except Exception as e:\n            pass\n    for i in range(1, 20):\n        try:\n            self.jira_admin.project(self.project_b)\n        except Exception:\n            break\n        print('Warning: Project not deleted yet....')\n        sleep(2)\n    for i in range(6):\n        try:\n            if self.jira_admin.create_project(self.project_a, self.\n                project_a_name):\n                break\n        except Exception as e:\n            if 'A project with that name already exists' not in e.text:\n                raise e\n    self.project_a_id = self.jira_admin.project(self.project_a).id\n    self.jira_admin.create_project(self.project_b, self.project_b_name)\n    try:\n        self.jira_admin.create_project(self.project_b, self.project_b_name)\n    except Exception:\n        pass\n    sleep(1)\n    self.project_b_issue1_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 1 from %s' % self.project_b, issuetype=\n        self.CI_JIRA_ISSUE)\n    self.project_b_issue1 = self.project_b_issue1_obj.key\n    self.project_b_issue2_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 2 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue2 = self.project_b_issue2_obj.key\n    self.project_b_issue3_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 3 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue3 = self.project_b_issue3_obj.key\nif not hasattr(self, 'jira_normal') or not hasattr(self, 'jira_admin'):\n    py.test.exit('FATAL: WTF!?')\nself.user_admin = self.jira_admin.search_users(self.CI_JIRA_ADMIN)[0]\nself.initialized = 1\n",
        "CUT_2": "return self\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\nself.test_username = 'test_%s' % self.test_manager.project_a\nself.test_email = '%s@example.com' % self.test_username\nself.test_password = rndpassword()\nself.test_groupname = 'testGroupFor_%s' % self.test_manager.project_a\n",
        "CUT_4": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_add_user_to_group",
        "className": "UserAdministrationTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "try:\n    self.jira.add_user(self.test_username, self.test_email, password=self.\n        test_password)\n    self.jira.add_group(self.test_groupname)\n    self.jira.remove_user_from_group(self.test_username, self.test_groupname)\nexcept JIRAError:\n    pass\nresult = self.jira.add_user_to_group(self.test_username, self.test_groupname)\nassert result, True\nx = self.jira.group_members(self.test_groupname)\nself.assertIn(self.test_username, x.keys(),\n    'Username not returned in group member list. Test Fails.')\nself.assertIn('email', x[self.test_username])\nself.assertIn('fullname', x[self.test_username])\nself.assertIn('active', x[self.test_username])\nself.jira.remove_group(self.test_groupname)\nself.jira.delete_user(self.test_username)\nnot_on_custom_jira_instancepytest.mark.xfail(reason=\n    'query may return empty list: https://travis-ci.org/pycontribs/jira/jobs/191274505#L520'\n    )",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\nself.test_username = 'test_%s' % self.test_manager.project_a\nself.test_email = '%s@example.com' % self.test_username\nself.test_password = rndpassword()\nself.test_groupname = 'testGroupFor_%s' % self.test_manager.project_a\n",
        "CUT_2": "return self\n",
        "CUT_3": "self.__dict__ = self.__shared_state\nif not self.__dict__:\n    self.initialized = 0\n    if 'CI_JIRA_URL' in os.environ:\n        self.CI_JIRA_URL = os.environ['CI_JIRA_URL']\n        self.max_retries = 5\n    else:\n        self.CI_JIRA_URL = 'https://pycontribs.atlassian.net'\n        self.max_retries = 5\n    if 'CI_JIRA_ADMIN' in os.environ:\n        self.CI_JIRA_ADMIN = os.environ['CI_JIRA_ADMIN']\n    else:\n        self.CI_JIRA_ADMIN = 'ci-admin'\n    if 'CI_JIRA_ADMIN_PASSWORD' in os.environ:\n        self.CI_JIRA_ADMIN_PASSWORD = os.environ['CI_JIRA_ADMIN_PASSWORD']\n    else:\n        self.CI_JIRA_ADMIN_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    if 'CI_JIRA_USER' in os.environ:\n        self.CI_JIRA_USER = os.environ['CI_JIRA_USER']\n    else:\n        self.CI_JIRA_USER = 'ci-user'\n    if 'CI_JIRA_USER_PASSWORD' in os.environ:\n        self.CI_JIRA_USER_PASSWORD = os.environ['CI_JIRA_USER_PASSWORD']\n    else:\n        self.CI_JIRA_USER_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    self.CI_JIRA_ISSUE = os.environ.get('CI_JIRA_ISSUE', 'Bug')\n    if OAUTH:\n        self.jira_admin = JIRA(oauth={'access_token':\n            'hTxcwsbUQiFuFALf7KZHDaeAJIo3tLUK', 'access_token_secret':\n            'aNCLQFP3ORNU6WY7HQISbqbhf0UudDAf', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    if not self.jira_admin.current_user():\n        self.initialized = 1\n        sys.exit(3)\n    if OAUTH:\n        self.jira_sysadmin = JIRA(oauth={'access_token':\n            '4ul1ETSFo7ybbIxAxzyRal39cTrwEGFv', 'access_token_secret':\n            'K83jBZnjnuVRcfjBflrKyThJa0KSjSs2', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA}, logging=False,\n            max_retries=self.max_retries)\n    elif self.CI_JIRA_ADMIN:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, logging=False,\n            max_retries=self.max_retries)\n    if OAUTH:\n        self.jira_normal = JIRA(oauth={'access_token':\n            'ZVDgYDyIQqJY8IFlQ446jZaURIz5ECiB', 'access_token_secret':\n            '5WbLBybPDg1lqqyFjyXSCsCtAWTwz1eD', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_USER, self.CI_JIRA_USER_PASSWORD), validate=True,\n            logging=False, max_retries=self.max_retries)\n    else:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    \"\"\" `jid` is important for avoiding concurency problems when\n            executing tests in parallel as we have only one test instance.\n\n            jid length must be less than 9 characters because we may append\n            another one and the Jira Project key length limit is 10.\n\n            Tests run in parallel:\n            * git branches master or developer, git pr or developers running\n                tests outside Travis\n            * Travis is using \"Travis\" username\n\n            https://docs.travis-ci.com/user/environment-variables/\n            \"\"\"\n    self.jid = get_unique_project_name()\n    self.project_a = self.jid + 'A'\n    self.project_a_name = 'Test user=%s key=%s A' % (getpass.getuser(),\n        self.project_a)\n    self.project_b = self.jid + 'B'\n    self.project_b_name = 'Test user=%s key=%s B' % (getpass.getuser(),\n        self.project_b)\n    self.project_sd = self.jid + 'C'\n    self.project_sd_name = 'Test user=%s key=%s C' % (getpass.getuser(),\n        self.project_b)\n    try:\n        self.jira_admin.project(self.project_a)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_a)\n        except Exception as e:\n            pass\n    try:\n        self.jira_admin.project(self.project_b)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_b)\n        except Exception as e:\n            pass\n    for i in range(1, 20):\n        try:\n            self.jira_admin.project(self.project_b)\n        except Exception:\n            break\n        print('Warning: Project not deleted yet....')\n        sleep(2)\n    for i in range(6):\n        try:\n            if self.jira_admin.create_project(self.project_a, self.\n                project_a_name):\n                break\n        except Exception as e:\n            if 'A project with that name already exists' not in e.text:\n                raise e\n    self.project_a_id = self.jira_admin.project(self.project_a).id\n    self.jira_admin.create_project(self.project_b, self.project_b_name)\n    try:\n        self.jira_admin.create_project(self.project_b, self.project_b_name)\n    except Exception:\n        pass\n    sleep(1)\n    self.project_b_issue1_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 1 from %s' % self.project_b, issuetype=\n        self.CI_JIRA_ISSUE)\n    self.project_b_issue1 = self.project_b_issue1_obj.key\n    self.project_b_issue2_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 2 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue2 = self.project_b_issue2_obj.key\n    self.project_b_issue3_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 3 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue3 = self.project_b_issue3_obj.key\nif not hasattr(self, 'jira_normal') or not hasattr(self, 'jira_admin'):\n    py.test.exit('FATAL: WTF!?')\nself.user_admin = self.jira_admin.search_users(self.CI_JIRA_ADMIN)[0]\nself.initialized = 1\n",
        "CUT_4": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_remove_user_from_group",
        "className": "UserAdministrationTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 1,
        "isTest": true,
        "Body": "if self._should_skip_for_pycontribs_instance():\n    self._skip_pycontribs_instance()\ntry:\n    self.jira.add_user(self.test_username, self.test_email, password=self.\n        test_password)\nexcept JIRAError:\n    pass\ntry:\n    self.jira.add_group(self.test_groupname)\nexcept JIRAError:\n    pass\ntry:\n    self.jira.add_user_to_group(self.test_username, self.test_groupname)\nexcept JIRAError:\n    pass\nresult = self.jira.remove_user_from_group(self.test_username, self.\n    test_groupname)\nassert result, True\nsleep(2)\nx = self.jira.group_members(self.test_groupname)\nself.assertNotIn(self.test_username, x.keys(),\n    'Username found in group when it should have been removed. Test Fails.')\nself.jira.remove_group(self.test_groupname)\nself.jira.delete_user(self.test_username)\n",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\nself.test_username = 'test_%s' % self.test_manager.project_a\nself.test_email = '%s@example.com' % self.test_username\nself.test_password = rndpassword()\nself.test_groupname = 'testGroupFor_%s' % self.test_manager.project_a\n",
        "CUT_2": "return self\n",
        "CUT_3": "self.__dict__ = self.__shared_state\nif not self.__dict__:\n    self.initialized = 0\n    if 'CI_JIRA_URL' in os.environ:\n        self.CI_JIRA_URL = os.environ['CI_JIRA_URL']\n        self.max_retries = 5\n    else:\n        self.CI_JIRA_URL = 'https://pycontribs.atlassian.net'\n        self.max_retries = 5\n    if 'CI_JIRA_ADMIN' in os.environ:\n        self.CI_JIRA_ADMIN = os.environ['CI_JIRA_ADMIN']\n    else:\n        self.CI_JIRA_ADMIN = 'ci-admin'\n    if 'CI_JIRA_ADMIN_PASSWORD' in os.environ:\n        self.CI_JIRA_ADMIN_PASSWORD = os.environ['CI_JIRA_ADMIN_PASSWORD']\n    else:\n        self.CI_JIRA_ADMIN_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    if 'CI_JIRA_USER' in os.environ:\n        self.CI_JIRA_USER = os.environ['CI_JIRA_USER']\n    else:\n        self.CI_JIRA_USER = 'ci-user'\n    if 'CI_JIRA_USER_PASSWORD' in os.environ:\n        self.CI_JIRA_USER_PASSWORD = os.environ['CI_JIRA_USER_PASSWORD']\n    else:\n        self.CI_JIRA_USER_PASSWORD = 'sd4s3dgec5fhg4tfsds3434'\n    self.CI_JIRA_ISSUE = os.environ.get('CI_JIRA_ISSUE', 'Bug')\n    if OAUTH:\n        self.jira_admin = JIRA(oauth={'access_token':\n            'hTxcwsbUQiFuFALf7KZHDaeAJIo3tLUK', 'access_token_secret':\n            'aNCLQFP3ORNU6WY7HQISbqbhf0UudDAf', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_admin = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    if not self.jira_admin.current_user():\n        self.initialized = 1\n        sys.exit(3)\n    if OAUTH:\n        self.jira_sysadmin = JIRA(oauth={'access_token':\n            '4ul1ETSFo7ybbIxAxzyRal39cTrwEGFv', 'access_token_secret':\n            'K83jBZnjnuVRcfjBflrKyThJa0KSjSs2', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA}, logging=False,\n            max_retries=self.max_retries)\n    elif self.CI_JIRA_ADMIN:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_ADMIN, self.CI_JIRA_ADMIN_PASSWORD), logging=False,\n            validate=True, max_retries=self.max_retries)\n    else:\n        self.jira_sysadmin = JIRA(self.CI_JIRA_URL, logging=False,\n            max_retries=self.max_retries)\n    if OAUTH:\n        self.jira_normal = JIRA(oauth={'access_token':\n            'ZVDgYDyIQqJY8IFlQ446jZaURIz5ECiB', 'access_token_secret':\n            '5WbLBybPDg1lqqyFjyXSCsCtAWTwz1eD', 'consumer_key':\n            CONSUMER_KEY, 'key_cert': KEY_CERT_DATA})\n    elif self.CI_JIRA_ADMIN:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, basic_auth=(self.\n            CI_JIRA_USER, self.CI_JIRA_USER_PASSWORD), validate=True,\n            logging=False, max_retries=self.max_retries)\n    else:\n        self.jira_normal = JIRA(self.CI_JIRA_URL, validate=True, logging=\n            False, max_retries=self.max_retries)\n    \"\"\" `jid` is important for avoiding concurency problems when\n            executing tests in parallel as we have only one test instance.\n\n            jid length must be less than 9 characters because we may append\n            another one and the Jira Project key length limit is 10.\n\n            Tests run in parallel:\n            * git branches master or developer, git pr or developers running\n                tests outside Travis\n            * Travis is using \"Travis\" username\n\n            https://docs.travis-ci.com/user/environment-variables/\n            \"\"\"\n    self.jid = get_unique_project_name()\n    self.project_a = self.jid + 'A'\n    self.project_a_name = 'Test user=%s key=%s A' % (getpass.getuser(),\n        self.project_a)\n    self.project_b = self.jid + 'B'\n    self.project_b_name = 'Test user=%s key=%s B' % (getpass.getuser(),\n        self.project_b)\n    self.project_sd = self.jid + 'C'\n    self.project_sd_name = 'Test user=%s key=%s C' % (getpass.getuser(),\n        self.project_b)\n    try:\n        self.jira_admin.project(self.project_a)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_a)\n        except Exception as e:\n            pass\n    try:\n        self.jira_admin.project(self.project_b)\n    except Exception as e:\n        logging.warning(e)\n        pass\n    else:\n        try:\n            self.jira_admin.delete_project(self.project_b)\n        except Exception as e:\n            pass\n    for i in range(1, 20):\n        try:\n            self.jira_admin.project(self.project_b)\n        except Exception:\n            break\n        print('Warning: Project not deleted yet....')\n        sleep(2)\n    for i in range(6):\n        try:\n            if self.jira_admin.create_project(self.project_a, self.\n                project_a_name):\n                break\n        except Exception as e:\n            if 'A project with that name already exists' not in e.text:\n                raise e\n    self.project_a_id = self.jira_admin.project(self.project_a).id\n    self.jira_admin.create_project(self.project_b, self.project_b_name)\n    try:\n        self.jira_admin.create_project(self.project_b, self.project_b_name)\n    except Exception:\n        pass\n    sleep(1)\n    self.project_b_issue1_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 1 from %s' % self.project_b, issuetype=\n        self.CI_JIRA_ISSUE)\n    self.project_b_issue1 = self.project_b_issue1_obj.key\n    self.project_b_issue2_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 2 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue2 = self.project_b_issue2_obj.key\n    self.project_b_issue3_obj = self.jira_admin.create_issue(project=self.\n        project_b, summary='issue 3 from %s' % self.project_b, issuetype={\n        'name': self.CI_JIRA_ISSUE})\n    self.project_b_issue3 = self.project_b_issue3_obj.key\nif not hasattr(self, 'jira_normal') or not hasattr(self, 'jira_admin'):\n    py.test.exit('FATAL: WTF!?')\nself.user_admin = self.jira_admin.search_users(self.CI_JIRA_ADMIN)[0]\nself.initialized = 1\n",
        "CUT_4": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n",
        "CUT_5": "self.self = None\nResource.__init__(self, path, options, session, self.AGILE_BASE_URL)\nif raw:\n    self._parse_raw(raw)\n    if not self.self:\n        self.self = self._get_url(path.format(raw['id']))\n"
    },
    {
        "functionName": "test_jirashell_command_exists",
        "className": "JiraShellTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "result = os.system('jirashell --help')\nself.assertEqual(result, 0)\n",
        "CUT_1": "\"\"\"Returns the supplied test targets without 'all'.\"\"\"\nresult = self._supplied_target_names()\nresult.discard('all')\nreturn result\n",
        "CUT_2": "try:\n    return self.cache[args]\nexcept KeyError:\n    result = self.func(*args)\n    self.cache[args] = result\n    return result\n",
        "CUT_3": "\"\"\"Retrieve a value from |field| at |path| or return |default|. If\n    |append| is specified, and the item is found, it will be appended to that\n    object instead of returned. If |map| is specified, results will be\n    remapped through |map| before being returned or appended.\"\"\"\nresult = _GenericRetrieve(field, default, path)\nresult = _DoRemapping(result, map)\nresult = _AddPrefix(result, prefix)\nreturn _AppendOrReturn(append, result)\n",
        "CUT_4": "\"\"\"Gets a list of all the per-target settings. This will only fetch keys\n    whose values are the same across all configurations.\"\"\"\nfirst_pass = True\nresult = {}\nfor configname in sorted(self.xcode_settings.keys()):\n    if first_pass:\n        result = dict(self.xcode_settings[configname])\n        first_pass = False\n    else:\n        for key, value in self.xcode_settings[configname].items():\n            if key not in result:\n                continue\n            elif result[key] != value:\n                del result[key]\nreturn result\n",
        "CUT_5": "if result == 0:\n    raise WindowsError()\n"
    },
    {
        "functionName": "test_create_customer_request",
        "className": "JiraServiceDeskTests",
        "fileName": "/tests/tests.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "self.jira.create_project(key=self.test_manager.project_sd, name=self.\n    test_manager.project_sd_name, ptype='service_desk', template_name=\n    'IT Service Desk')\nservice_desks = []\nfor i in range(3):\n    service_desks = self.jira.service_desks()\n    if service_desks:\n        break\n    logging.warning('Service desk not reported...')\n    sleep(2)\nself.assertTrue(service_desks, 'No service desks were found!')\nservice_desk = service_desks[0]\nfor i in range(3):\n    request_types = self.jira.request_types(service_desk)\n    if request_types:\n        logging.warning('Service desk request_types not reported...')\n        break\n    sleep(2)\nself.assertTrue(request_types, 'No request_types for service desk found!')\nrequest = self.jira.create_customer_request(dict(serviceDeskId=service_desk\n    .id, requestTypeId=int(request_types[0].id), requestFieldValues=dict(\n    summary='Ticket title here', description='Ticket body here')))\nself.assertEqual(request.fields.summary, 'Ticket title here')\nself.assertEqual(request.fields.description, 'Ticket body here')\npytest.mark.xfail(reason='Broken needs fixing')",
        "CUT_1": "\"\"\" Returns request types supported by a service desk instance.\n        :param service_desk: The service desk instance.\n        :type service_desk: ServiceDesk\n        :rtype: List[RequestType]\n        \"\"\"\nif hasattr(service_desk, 'id'):\n    service_desk = service_desk.id\nurl = self._options['server'\n    ] + '/rest/servicedeskapi/servicedesk/%s/requesttype' % service_desk\nheaders = {'X-ExperimentalApi': 'opt-in'}\nr_json = json_loads(self._session.get(url, headers=headers))\nrequest_types = [RequestType(self._options, self._session, raw_type_json) for\n    raw_type_json in r_json['values']]\nreturn request_types\n",
        "CUT_2": "\"\"\" Returns request types supported by a service desk instance.\n        :param service_desk: The service desk instance.\n        :type service_desk: ServiceDesk\n        :rtype: List[RequestType]\n        \"\"\"\nif hasattr(service_desk, 'id'):\n    service_desk = service_desk.id\nurl = self._options['server'\n    ] + '/rest/servicedeskapi/servicedesk/%s/requesttype' % service_desk\nheaders = {'X-ExperimentalApi': 'opt-in'}\nr_json = json_loads(self._session.get(url, headers=headers))\nrequest_types = [RequestType(self._options, self._session, raw_type_json) for\n    raw_type_json in r_json['values']]\nreturn request_types\n",
        "CUT_3": "request_types = self.request_types(service_desk)\ntry:\n    request_type = [rt for rt in request_types if rt.name == name][0]\nexcept IndexError:\n    raise KeyError(\"Request type '%s' is unknown.\" % name)\nreturn request_type\n",
        "CUT_4": "request_types = self.request_types(service_desk)\ntry:\n    request_type = [rt for rt in request_types if rt.name == name][0]\nexcept IndexError:\n    raise KeyError(\"Request type '%s' is unknown.\" % name)\nreturn request_type\n",
        "CUT_5": "\"\"\"Get a Service Desk Resource from the server.\n\n        :param id: ID or key of the Service Desk to get\n        :type id: str\n        :rtype: ServiceDesk\n\n        \"\"\"\nreturn self._find_for_resource(ServiceDesk, id)\n"
    },
    {
        "functionName": "testargs",
        "className": null,
        "fileName": "/tests/test_shell.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "return ['jirashell', '-s', 'http://localhost']\npytest.fixture",
        "CUT_1": "pytest.skip(\n    'The current ci jira admin user for https://pycontribs.atlassian.net lacks permission to modify users.'\n    )\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\nif not self.jira.supports_service_desk():\n    pytest.skip('Skipping Service Desk not enabled')\ntry:\n    self.jira.delete_project(self.test_manager.project_sd)\nexcept Exception:\n    pass\n",
        "CUT_3": "return ''\n",
        "CUT_4": "return (x > y) - (x < y)\n",
        "CUT_5": "return x\n"
    },
    {
        "functionName": "test_unicode",
        "className": null,
        "fileName": "/tests/test_shell.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "\"\"\"This functions tests that CLI tool does not throw an UnicodeDecodeError\n    when it attempts to display some Unicode error message, which can happen\n    when printing exceptions received from the remote HTTP server.\n    \"\"\"\nrequests_mock.register_uri('GET', 'http://localhost/rest/api/2/serverInfo',\n    text='\u0394\u03b5\u03bd \u03b2\u03c1\u03ad\u03b8\u03b7\u03ba\u03b5', status_code=404)\nwith patch.object(sys, 'argv', testargs):\n    jirashell.main()\ncaptured = capsys.readouterr()\nassert captured.err.startswith('JiraError HTTP 404')\nassert captured.out == ''\n",
        "CUT_1": "return main(sys.argv[1:])\n",
        "CUT_2": "\"\"\"Construct a Jira client instance.\n\n        Without any arguments, this client will connect anonymously to the Jira instance\n        started by the Atlassian Plugin SDK from one of the 'atlas-run', ``atlas-debug``,\n        or ``atlas-run-standalone`` commands. By default, this instance runs at\n        ``http://localhost:2990/jira``. The ``options`` argument can be used to set the Jira instance to use.\n\n        Authentication is handled with the ``basic_auth`` argument. If authentication is supplied (and is\n        accepted by Jira), the client will remember it for subsequent requests.\n\n        For quick command line access to a server, see the ``jirashell`` script included with this distribution.\n\n        The easiest way to instantiate is using j = JIRA(\"https://jira.atlasian.com\")\n        :param server: The server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n        :type server: Optional[str]\n        :param options: Specify the server and properties this client will use. Use a dict with any\n            of the following properties:\n            * server -- the server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n            * rest_path -- the root REST path to use. Defaults to ``api``, where the Jira REST resources live.\n            * rest_api_version -- the version of the REST resources under rest_path to use. Defaults to ``2``.\n            * agile_rest_path - the REST path to use for Jira Agile requests. Defaults to ``greenhopper`` (old, private\n               API). Check `GreenHopperResource` for other supported values.\n            * verify -- Verify SSL certs. Defaults to ``True``.\n            * client_cert -- a tuple of (cert,key) for the requests library for client side SSL\n            * check_update -- Check whether using the newest python-jira library version.\n        :type options: Optional[Dict[str, Any]]\n        :param basic_auth: A tuple of username and password to use when establishing a session via HTTP BASIC\n        authentication.\n        :type basic_auth: Union[Dict, None, Tuple[str, str]]\n        :param oauth: A dict of properties for OAuth authentication. The following properties are required:\n            * access_token -- OAuth access token for the user\n            * access_token_secret -- OAuth access token secret to sign with the key\n            * consumer_key -- key of the OAuth application link defined in Jira\n            * key_cert -- private key file to sign requests with (should be the pair of the public key supplied to\n            Jira in the OAuth application link)\n        :type oauth: Optional[Any]\n        :param kerberos: If true it will enable Kerberos authentication.\n        :type kerberos: bool\n        :param kerberos_options: A dict of properties for Kerberos authentication. The following properties are possible:\n            * mutual_authentication -- string DISABLED or OPTIONAL.\n            Example kerberos_options structure: ``{'mutual_authentication': 'DISABLED'}``\n        :type kerberos_options: Optional[Dict[str,str]]\n        :param jwt: A dict of properties for JWT authentication supported by Atlassian Connect. The following\n            properties are required:\n            * secret -- shared secret as delivered during 'installed' lifecycle event\n            (see https://developer.atlassian.com/static/connect/docs/latest/modules/lifecycle.html for details)\n            * payload -- dict of fields to be inserted in the JWT payload, e.g. 'iss'\n            Example jwt structure: ``{'secret': SHARED_SECRET, 'payload': {'iss': PLUGIN_KEY}}``\n        :type jwt: Optional[Any]\n        :param validate: If true it will validate your credentials first. Remember that if you are accessing Jira\n            as anonymous it will fail to instantiate.\n        :type validate: bool\n        :param get_server_info: If true it will fetch server version info first to determine if some API calls\n            are available.\n        :type get_server_info: bool\n        :param async_: To enable async requests for those actions where we implemented it, like issue update() or delete().\n        :type async_: bool\n        :param async_workers: Set the number of worker threads for async operations.\n        :type async_workers: int\n        :param timeout: Set a read/connect timeout for the underlying calls to Jira (default: None)\n        :type timeout: Optional[Any]\n        Obviously this means that you cannot rely on the return code when this is enabled.\n        :param max_retries: Sets the amount Retries for the HTTP sessions initiated by the client. (Default: 3)\n        :type max_retries: int\n        :param proxies: Sets the proxies for the HTTP session.\n        :type proxies: Optional[Any]\n        :param auth: Set a cookie auth token if this is required.\n        :type auth: Optional[Tuple[str,str]]\n        :param logging: Determine whether or not logging should be enabled. (Default: True)\n        :type logging: bool\n        \"\"\"\nself.sys_version_info = tuple([i for i in sys.version_info])\nif options is None:\n    options = {}\n    if server and hasattr(server, 'keys'):\n        warnings.warn(\n            \"Old API usage, use JIRA(url) or JIRA(options={'server': url}, when using dictionary always use named parameters.\"\n            , DeprecationWarning)\n        options = server\n        server = None\nif server:\n    options['server'] = server\nif async_:\n    options['async'] = async_\n    options['async_workers'] = async_workers\nself.logging = logging\nself._options = copy.copy(JIRA.DEFAULT_OPTIONS)\nself._options.update(options)\nself._rank = None\nif self._options['server'].endswith('/'):\n    self._options['server'] = self._options['server'][:-1]\ncontext_path = urlparse(self._options['server']).path\nif len(context_path) > 0:\n    self._options['context_path'] = context_path\nself._try_magic()\nif oauth:\n    self._create_oauth_session(oauth, timeout)\nelif basic_auth:\n    self._create_http_basic_session(*basic_auth, timeout=timeout)\n    self._session.headers.update(self._options['headers'])\nelif jwt:\n    self._create_jwt_session(jwt, timeout)\nelif kerberos:\n    self._create_kerberos_session(timeout, kerberos_options=kerberos_options)\nelif auth:\n    self._create_cookie_auth(auth, timeout)\n    validate = True\nelse:\n    verify = self._options['verify']\n    self._session = ResilientSession(timeout=timeout)\n    self._session.verify = verify\nself._session.headers.update(self._options['headers'])\nif 'cookies' in self._options:\n    self._session.cookies.update(self._options['cookies'])\nself._session.max_retries = max_retries\nif proxies:\n    self._session.proxies = proxies\nself.auth = auth\nif validate:\n    user = self.session()\n    if user.raw is None:\n        auth_method = (oauth or basic_auth or jwt or kerberos or auth or\n            'anonymous')\n        raise JIRAError('Can not log in with %s' % str(auth_method))\nself.deploymentType = None\nif get_server_info:\n    si = self.server_info()\n    try:\n        self._version = tuple(si['versionNumbers'])\n    except Exception as e:\n        logging.error('invalid server_info: %s', si)\n        raise e\n    self.deploymentType = si.get('deploymentType')\nelse:\n    self._version = 0, 0, 0\nif self._options['check_update'] and not JIRA.checked_version:\n    self._check_update_()\n    JIRA.checked_version = True\nself._fields = {}\nfor f in self.fields():\n    if 'clauseNames' in f:\n        for name in f['clauseNames']:\n            self._fields[name] = f['id']\n",
        "CUT_3": "\"\"\"Construct a Jira client instance.\n\n        Without any arguments, this client will connect anonymously to the Jira instance\n        started by the Atlassian Plugin SDK from one of the 'atlas-run', ``atlas-debug``,\n        or ``atlas-run-standalone`` commands. By default, this instance runs at\n        ``http://localhost:2990/jira``. The ``options`` argument can be used to set the Jira instance to use.\n\n        Authentication is handled with the ``basic_auth`` argument. If authentication is supplied (and is\n        accepted by Jira), the client will remember it for subsequent requests.\n\n        For quick command line access to a server, see the ``jirashell`` script included with this distribution.\n\n        The easiest way to instantiate is using j = JIRA(\"https://jira.atlasian.com\")\n        :param server: The server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n        :type server: Optional[str]\n        :param options: Specify the server and properties this client will use. Use a dict with any\n            of the following properties:\n            * server -- the server address and context path to use. Defaults to ``http://localhost:2990/jira``.\n            * rest_path -- the root REST path to use. Defaults to ``api``, where the Jira REST resources live.\n            * rest_api_version -- the version of the REST resources under rest_path to use. Defaults to ``2``.\n            * agile_rest_path - the REST path to use for Jira Agile requests. Defaults to ``greenhopper`` (old, private\n               API). Check `GreenHopperResource` for other supported values.\n            * verify -- Verify SSL certs. Defaults to ``True``.\n            * client_cert -- a tuple of (cert,key) for the requests library for client side SSL\n            * check_update -- Check whether using the newest python-jira library version.\n        :type options: Optional[Dict[str, Any]]\n        :param basic_auth: A tuple of username and password to use when establishing a session via HTTP BASIC\n        authentication.\n        :type basic_auth: Union[Dict, None, Tuple[str, str]]\n        :param oauth: A dict of properties for OAuth authentication. The following properties are required:\n            * access_token -- OAuth access token for the user\n            * access_token_secret -- OAuth access token secret to sign with the key\n            * consumer_key -- key of the OAuth application link defined in Jira\n            * key_cert -- private key file to sign requests with (should be the pair of the public key supplied to\n            Jira in the OAuth application link)\n        :type oauth: Optional[Any]\n        :param kerberos: If true it will enable Kerberos authentication.\n        :type kerberos: bool\n        :param kerberos_options: A dict of properties for Kerberos authentication. The following properties are possible:\n            * mutual_authentication -- string DISABLED or OPTIONAL.\n            Example kerberos_options structure: ``{'mutual_authentication': 'DISABLED'}``\n        :type kerberos_options: Optional[Dict[str,str]]\n        :param jwt: A dict of properties for JWT authentication supported by Atlassian Connect. The following\n            properties are required:\n            * secret -- shared secret as delivered during 'installed' lifecycle event\n            (see https://developer.atlassian.com/static/connect/docs/latest/modules/lifecycle.html for details)\n            * payload -- dict of fields to be inserted in the JWT payload, e.g. 'iss'\n            Example jwt structure: ``{'secret': SHARED_SECRET, 'payload': {'iss': PLUGIN_KEY}}``\n        :type jwt: Optional[Any]\n        :param validate: If true it will validate your credentials first. Remember that if you are accessing Jira\n            as anonymous it will fail to instantiate.\n        :type validate: bool\n        :param get_server_info: If true it will fetch server version info first to determine if some API calls\n            are available.\n        :type get_server_info: bool\n        :param async_: To enable async requests for those actions where we implemented it, like issue update() or delete().\n        :type async_: bool\n        :param async_workers: Set the number of worker threads for async operations.\n        :type async_workers: int\n        :param timeout: Set a read/connect timeout for the underlying calls to Jira (default: None)\n        :type timeout: Optional[Any]\n        Obviously this means that you cannot rely on the return code when this is enabled.\n        :param max_retries: Sets the amount Retries for the HTTP sessions initiated by the client. (Default: 3)\n        :type max_retries: int\n        :param proxies: Sets the proxies for the HTTP session.\n        :type proxies: Optional[Any]\n        :param auth: Set a cookie auth token if this is required.\n        :type auth: Optional[Tuple[str,str]]\n        :param logging: Determine whether or not logging should be enabled. (Default: True)\n        :type logging: bool\n        \"\"\"\nself.sys_version_info = tuple([i for i in sys.version_info])\nif options is None:\n    options = {}\n    if server and hasattr(server, 'keys'):\n        warnings.warn(\n            \"Old API usage, use JIRA(url) or JIRA(options={'server': url}, when using dictionary always use named parameters.\"\n            , DeprecationWarning)\n        options = server\n        server = None\nif server:\n    options['server'] = server\nif async_:\n    options['async'] = async_\n    options['async_workers'] = async_workers\nself.logging = logging\nself._options = copy.copy(JIRA.DEFAULT_OPTIONS)\nself._options.update(options)\nself._rank = None\nif self._options['server'].endswith('/'):\n    self._options['server'] = self._options['server'][:-1]\ncontext_path = urlparse(self._options['server']).path\nif len(context_path) > 0:\n    self._options['context_path'] = context_path\nself._try_magic()\nif oauth:\n    self._create_oauth_session(oauth, timeout)\nelif basic_auth:\n    self._create_http_basic_session(*basic_auth, timeout=timeout)\n    self._session.headers.update(self._options['headers'])\nelif jwt:\n    self._create_jwt_session(jwt, timeout)\nelif kerberos:\n    self._create_kerberos_session(timeout, kerberos_options=kerberos_options)\nelif auth:\n    self._create_cookie_auth(auth, timeout)\n    validate = True\nelse:\n    verify = self._options['verify']\n    self._session = ResilientSession(timeout=timeout)\n    self._session.verify = verify\nself._session.headers.update(self._options['headers'])\nif 'cookies' in self._options:\n    self._session.cookies.update(self._options['cookies'])\nself._session.max_retries = max_retries\nif proxies:\n    self._session.proxies = proxies\nself.auth = auth\nif validate:\n    user = self.session()\n    if user.raw is None:\n        auth_method = (oauth or basic_auth or jwt or kerberos or auth or\n            'anonymous')\n        raise JIRAError('Can not log in with %s' % str(auth_method))\nself.deploymentType = None\nif get_server_info:\n    si = self.server_info()\n    try:\n        self._version = tuple(si['versionNumbers'])\n    except Exception as e:\n        logging.error('invalid server_info: %s', si)\n        raise e\n    self.deploymentType = si.get('deploymentType')\nelse:\n    self._version = 0, 0, 0\nif self._options['check_update'] and not JIRA.checked_version:\n    self._check_update_()\n    JIRA.checked_version = True\nself._fields = {}\nfor f in self.fields():\n    if 'clauseNames' in f:\n        for name in f['clauseNames']:\n            self._fields[name] = f['id']\n",
        "CUT_4": "\"\"\"Add a simple remote link from an issue to web resource.\n\n        This avoids the admin access problems from add_remote_link by just\n            using a simple object and presuming all fields are correct and not\n            requiring more complex ``application`` data.\n\n        ``object`` should be a dict containing at least ``url`` to the\n            linked external URL and ``title`` to display for the link inside Jira.\n\n        For definitions of the allowable fields for ``object`` , see https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+for+Remote+Issue+Links.\n\n        :param issue: the issue to add the remote link to\n        :param object: the dictionary used to create remotelink data\n        \"\"\"\ndata = {'object': object}\nurl = self._get_url('issue/' + str(issue) + '/remotelink')\nr = self._session.post(url, data=json.dumps(data))\nsimple_link = RemoteLink(self._options, self._session, raw=json_loads(r))\nreturn simple_link\n",
        "CUT_5": "\"\"\"Add a simple remote link from an issue to web resource.\n\n        This avoids the admin access problems from add_remote_link by just\n            using a simple object and presuming all fields are correct and not\n            requiring more complex ``application`` data.\n\n        ``object`` should be a dict containing at least ``url`` to the\n            linked external URL and ``title`` to display for the link inside Jira.\n\n        For definitions of the allowable fields for ``object`` , see https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+for+Remote+Issue+Links.\n\n        :param issue: the issue to add the remote link to\n        :param object: the dictionary used to create remotelink data\n        \"\"\"\ndata = {'object': object}\nurl = self._get_url('issue/' + str(issue) + '/remotelink')\nr = self._session.post(url, data=json.dumps(data))\nsimple_link = RemoteLink(self._options, self._session, raw=json_loads(r))\nreturn simple_link\n"
    },
    {
        "functionName": "mock_keyring",
        "className": null,
        "fileName": "/tests/test_shell.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "_keyring = {}\ndef mock_set_password(server, username, password):\n    _keyring[server, username] = password\ndef mock_get_password(server, username):\n    return _keyring.get((server, username), '')\nmock_kr = MagicMock(set_password=MagicMock(side_effect=mock_set_password),\n    get_password=MagicMock(side_effect=mock_get_password), _keyring=_keyring)\nmocked_module = patch.object(jirashell, 'keyring', new=mock_kr)\nyield mocked_module.start()\nmocked_module.stop()\npytest.fixture",
        "CUT_1": "if auth.get('password'):\n    password = auth['password']\n    if input('Would you like to remember password in OS keyring? (y/n)'\n        ) == 'y':\n        keyring.set_password(server, auth['username'], password)\nelse:\n    print('Getting password from keyring...')\n    password = keyring.get_password(server, auth['username'])\n    assert password, 'No password provided!'\nreturn auth['username'], password\n",
        "CUT_2": "if auth.get('password'):\n    password = auth['password']\n    if input('Would you like to remember password in OS keyring? (y/n)'\n        ) == 'y':\n        keyring.set_password(server, auth['username'], password)\nelse:\n    print('Getting password from keyring...')\n    password = keyring.get_password(server, auth['username'])\n    assert password, 'No password provided!'\nreturn auth['username'], password\n",
        "CUT_3": "\"\"\"Deletes a Jira User.\n\n        :param username: Username to delete\n        :type username: str\n\n        :return: Success of user deletion\n        :rtype: bool\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/user/?username=%s' % username\nr = self._session.delete(url)\nif 200 <= r.status_code <= 299:\n    return True\nelse:\n    logging.error(r.status_code)\n    return False\n",
        "CUT_4": "\"\"\"Deletes a Jira User.\n\n        :param username: Username to delete\n        :type username: str\n\n        :return: Success of user deletion\n        :rtype: bool\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/user/?username=%s' % username\nr = self._session.delete(url)\nif 200 <= r.status_code <= 299:\n    return True\nelse:\n    logging.error(r.status_code)\n    return False\n",
        "CUT_5": "\"\"\" Creates a basic http session.\n\n        :param username: Username for the session\n        :type username: str\n        :param password: Password for the username\n        :type password: str\n        :param timeout: If set determines the timeout period for the Session.\n        :type timeout: Optional[int]\n\n        :rtype: NoReturn\n        \"\"\"\nverify = self._options['verify']\nself._session = ResilientSession(timeout=timeout)\nself._session.verify = verify\nself._session.auth = username, password\nself._session.cert = self._options['client_cert']\n"
    },
    {
        "functionName": "mock_set_password",
        "className": null,
        "fileName": "/tests/test_shell.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "_keyring[server, username] = password\n",
        "CUT_1": "if auth.get('password'):\n    password = auth['password']\n    if input('Would you like to remember password in OS keyring? (y/n)'\n        ) == 'y':\n        keyring.set_password(server, auth['username'], password)\nelse:\n    print('Getting password from keyring...')\n    password = keyring.get_password(server, auth['username'])\n    assert password, 'No password provided!'\nreturn auth['username'], password\n",
        "CUT_2": "if auth.get('password'):\n    password = auth['password']\n    if input('Would you like to remember password in OS keyring? (y/n)'\n        ) == 'y':\n        keyring.set_password(server, auth['username'], password)\nelse:\n    print('Getting password from keyring...')\n    password = keyring.get_password(server, auth['username'])\n    assert password, 'No password provided!'\nreturn auth['username'], password\n",
        "CUT_3": "\"\"\" Creates a basic http session.\n\n        :param username: Username for the session\n        :type username: str\n        :param password: Password for the username\n        :type password: str\n        :param timeout: If set determines the timeout period for the Session.\n        :type timeout: Optional[int]\n\n        :rtype: NoReturn\n        \"\"\"\nverify = self._options['verify']\nself._session = ResilientSession(timeout=timeout)\nself._session.verify = verify\nself._session.auth = username, password\nself._session.cert = self._options['client_cert']\n",
        "CUT_4": "\"\"\" Creates a basic http session.\n\n        :param username: Username for the session\n        :type username: str\n        :param password: Password for the username\n        :type password: str\n        :param timeout: If set determines the timeout period for the Session.\n        :type timeout: Optional[int]\n\n        :rtype: NoReturn\n        \"\"\"\nverify = self._options['verify']\nself._session = ResilientSession(timeout=timeout)\nself._session.verify = verify\nself._session.auth = username, password\nself._session.cert = self._options['client_cert']\n",
        "CUT_5": "\"\"\"Deletes a Jira User.\n\n        :param username: Username to delete\n        :type username: str\n\n        :return: Success of user deletion\n        :rtype: bool\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/user/?username=%s' % username\nr = self._session.delete(url)\nif 200 <= r.status_code <= 299:\n    return True\nelse:\n    logging.error(r.status_code)\n    return False\n"
    },
    {
        "functionName": "mock_get_password",
        "className": null,
        "fileName": "/tests/test_shell.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "return _keyring.get((server, username), '')\n",
        "CUT_1": "\"\"\"Deletes a Jira User.\n\n        :param username: Username to delete\n        :type username: str\n\n        :return: Success of user deletion\n        :rtype: bool\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/user/?username=%s' % username\nr = self._session.delete(url)\nif 200 <= r.status_code <= 299:\n    return True\nelse:\n    logging.error(r.status_code)\n    return False\n",
        "CUT_2": "\"\"\"Deletes a Jira User.\n\n        :param username: Username to delete\n        :type username: str\n\n        :return: Success of user deletion\n        :rtype: bool\n\n        \"\"\"\nurl = self._options['server'] + '/rest/api/latest/user/?username=%s' % username\nr = self._session.delete(url)\nif 200 <= r.status_code <= 299:\n    return True\nelse:\n    logging.error(r.status_code)\n    return False\n",
        "CUT_3": "\"\"\"Get a dict of avatars for the specified user.\n\n        :param username: the username to get avatars for\n        \"\"\"\nreturn self._get_json('user/avatars', params={'username': username})\n",
        "CUT_4": "\"\"\"Get a dict of avatars for the specified user.\n\n        :param username: the username to get avatars for\n        \"\"\"\nreturn self._get_json('user/avatars', params={'username': username})\n",
        "CUT_5": "\"\"\"Disable/deactivate the user.\n\n        :param username: User to be deactivated.\n        :type username: str\n\n        :rtype: Union[str, int]\n        \"\"\"\nif self.deploymentType == 'Cloud':\n    if 'authCookie' not in vars(self):\n        user = self.session()\n        if user.raw is None:\n            raise JIRAError('Can not log in!')\n        self.authCookie = '%s=%s' % (user.raw['session']['name'], user.raw[\n            'session']['value'])\n    url = self._options['server'\n        ] + '/admin/rest/um/1/user/deactivate?username=%s' % username\n    try:\n        r = requests.post(url, headers={'Cookie': self.authCookie,\n            'Content-Type': 'application/json'}, proxies=self._session.\n            proxies, data={})\n        if r.status_code == 200:\n            return True\n        else:\n            logging.warning('Got response from deactivating %s: %s' % (\n                username, r.status_code))\n            return r.status_code\n    except Exception as e:\n        logging.error('Error Deactivating %s: %s' % (username, e))\n        raise JIRAError('Error Deactivating %s: %s' % (username, e))\nelse:\n    url = self._options['server'] + '/secure/admin/user/EditUser.jspa'\n    self._options['headers']['Content-Type'\n        ] = 'application/x-www-form-urlencoded; charset=UTF-8'\n    user = self.user(username)\n    userInfo = {'inline': 'true', 'decorator': 'dialog', 'username': user.\n        name, 'fullName': user.displayName, 'email': user.emailAddress,\n        'editName': user.name}\n    try:\n        r = self._session.post(url, headers=self._options['headers'], data=\n            userInfo)\n        if r.status_code == 200:\n            return True\n        else:\n            logging.warning('Got response from deactivating %s: %s' % (\n                username, r.status_code))\n            return r.status_code\n    except Exception as e:\n        logging.error('Error Deactivating %s: %s' % (username, e))\n        raise JIRAError('Error Deactivating %s: %s' % (username, e))\n"
    },
    {
        "functionName": "test_no_password_try_keyring",
        "className": null,
        "fileName": "/tests/test_shell.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "requests_mock.register_uri('GET', 'http://localhost/rest/api/2/serverInfo',\n    status_code=200)\nargs = testargs + ['-u', 'test@user']\nwith patch.object(sys, 'argv', args):\n    jirashell.main()\n    assert len(requests_mock.request_history) == 0\n    captured = capsys.readouterr()\n    assert captured.err == \"No password provided!\\nassert ''\\n\"\n    assert 'Getting password from keyring...' == captured.out.strip()\n    assert mock_keyring._keyring == {}\nmonkeypatch.setattr('sys.stdin', io.StringIO('n'))\nargs = args + ['-p', 'pass123']\nwith patch.object(sys, 'argv', args):\n    jirashell.main()\n    assert len(requests_mock.request_history) == 4\n    captured = capsys.readouterr()\n    assert captured.out.strip().startswith(\n        'Would you like to remember password in OS keyring? (y/n)')\n    assert mock_keyring._keyring == {}\nmonkeypatch.setattr('sys.stdin', io.StringIO('y'))\nargs = args + ['-p', 'pass123']\nwith patch.object(sys, 'argv', args):\n    jirashell.main()\n    assert len(requests_mock.request_history) == 8\n    captured = capsys.readouterr()\n    assert captured.out.strip().startswith(\n        'Would you like to remember password in OS keyring? (y/n)')\n    assert mock_keyring._keyring == {('http://localhost', 'test@user'):\n        'pass123'}\nargs = testargs + ['-u', 'test@user']\nwith patch.object(sys, 'argv', args):\n    jirashell.main()\n    assert len(requests_mock.request_history) == 12\n    captured = capsys.readouterr()\n    assert 'Getting password from keyring...' == captured.out.strip()\n    assert mock_keyring._keyring == {('http://localhost', 'test@user'):\n        'pass123'}\npytest.mark.timeout(4)",
        "CUT_1": "if auth.get('password'):\n    password = auth['password']\n    if input('Would you like to remember password in OS keyring? (y/n)'\n        ) == 'y':\n        keyring.set_password(server, auth['username'], password)\nelse:\n    print('Getting password from keyring...')\n    password = keyring.get_password(server, auth['username'])\n    assert password, 'No password provided!'\nreturn auth['username'], password\n",
        "CUT_2": "if auth.get('password'):\n    password = auth['password']\n    if input('Would you like to remember password in OS keyring? (y/n)'\n        ) == 'y':\n        keyring.set_password(server, auth['username'], password)\nelse:\n    print('Getting password from keyring...')\n    password = keyring.get_password(server, auth['username'])\n    assert password, 'No password provided!'\nreturn auth['username'], password\n",
        "CUT_3": "return main(sys.argv[1:])\n",
        "CUT_4": "\"\"\"Append a message to the given exception's message.\"\"\"\nif not e.args:\n    e.args = msg,\nelif len(e.args) == 1:\n    e.args = str(e.args[0]) + ' ' + msg,\nelse:\n    e.args = (str(e.args[0]) + ' ' + msg,) + e.args[1:]\n",
        "CUT_5": "if len(sys.argv) < 2:\n    print(__doc__, file=sys.stderr)\n    print(file=sys.stderr)\n    print('usage: %s target1 target2...' % sys.argv[0], file=sys.stderr)\n    return 1\nedges = LoadEdges('dump.json', sys.argv[1:])\nWriteGraph(edges)\nreturn 0\n"
    },
    {
        "functionName": "prep",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "pass\npytest.fixture()",
        "CUT_1": "pass\n",
        "CUT_2": "pass\n",
        "CUT_3": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\nif not self.jira.supports_service_desk():\n    pytest.skip('Skipping Service Desk not enabled')\ntry:\n    self.jira.delete_project(self.test_manager.project_sd)\nexcept Exception:\n    pass\n",
        "CUT_4": "pytest.skip(\n    'The current ci jira admin user for https://pycontribs.atlassian.net lacks permission to modify users.'\n    )\n",
        "CUT_5": "\"\"\"Make sure the directory for |path| exists.\"\"\"\ntry:\n    os.makedirs(os.path.dirname(path))\nexcept OSError:\n    pass\n"
    },
    {
        "functionName": "test_manager",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "return JiraTestManager()\npytest.fixture(scope='module')",
        "CUT_1": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\n",
        "CUT_2": "self.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\n",
        "CUT_3": "self.manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = JiraTestManager().project_b\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\nif not self.jira.supports_service_desk():\n    pytest.skip('Skipping Service Desk not enabled')\ntry:\n    self.jira.delete_project(self.test_manager.project_sd)\nexcept Exception:\n    pass\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\nself.project_a = JiraTestManager().project_a\nself.project_b = JiraTestManager().project_b\nself.test_manager = JiraTestManager()\nself.issue = self.test_manager.project_b_issue3\n"
    },
    {
        "functionName": "cl_admin",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "return test_manager.jira_admin\npytest.fixture()",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_4": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\nif not self.jira.supports_service_desk():\n    pytest.skip('Skipping Service Desk not enabled')\ntry:\n    self.jira.delete_project(self.test_manager.project_sd)\nexcept Exception:\n    pass\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n"
    },
    {
        "functionName": "cl_normal",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "return test_manager.jira_normal\npytest.fixture()",
        "CUT_1": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_normal\nself.issue_1 = self.test_manager.project_b_issue1\n",
        "CUT_2": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.jira_normal = JiraTestManager().jira_normal\nself.user_admin = self.jira.search_users(self.test_manager.CI_JIRA_ADMIN)[0]\nself.project_b = self.test_manager.project_b\nself.project_a = self.test_manager.project_a\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\nself.issue_3 = self.test_manager.project_b_issue3\n",
        "CUT_3": "self.test_manager = JiraTestManager()\nself.jira = self.test_manager.jira_admin\n",
        "CUT_4": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n",
        "CUT_5": "self.test_manager = JiraTestManager()\nself.jira = JiraTestManager().jira_admin\nself.project_b = self.test_manager.project_b\nself.issue_1 = self.test_manager.project_b_issue1\nself.issue_2 = self.test_manager.project_b_issue2\n"
    },
    {
        "functionName": "slug",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "def remove_by_slug():\n    try:\n        cl_admin.delete_project(slug)\n    except (ValueError, JIRAError):\n        pass\nslug = get_unique_project_name()\nproject_name = 'Test user=%s key=%s A' % (getpass.getuser(), slug)\ntry:\n    proj = cl_admin.project(slug)\nexcept JIRAError:\n    proj = cl_admin.create_project(slug, project_name)\nassert proj\nrequest.addfinalizer(remove_by_slug)\nreturn slug\npytest.fixture(scope='function')",
        "CUT_1": "\"\"\"Delete project from Jira.\n\n        :param pid: Jira projectID or Project or slug\n        :type pid: str\n        :return: True if project was deleted\n        :rtype: bool\n        :raises JIRAError:  If project not found or not enough permissions\n        :raises ValueError: If pid parameter is not Project, slug or ProjectID\n        \"\"\"\nif hasattr(pid, 'id'):\n    pid = pid.id\nurl = self._options['server'] + '/rest/api/2/project/%s' % pid\nr = self._session.delete(url)\nif r.status_code == 403:\n    raise JIRAError('Not enough permissions to delete project')\nif r.status_code == 404:\n    raise JIRAError('Project not found in Jira')\nreturn r.ok\n",
        "CUT_2": "\"\"\"Delete project from Jira.\n\n        :param pid: Jira projectID or Project or slug\n        :type pid: str\n        :return: True if project was deleted\n        :rtype: bool\n        :raises JIRAError:  If project not found or not enough permissions\n        :raises ValueError: If pid parameter is not Project, slug or ProjectID\n        \"\"\"\nif hasattr(pid, 'id'):\n    pid = pid.id\nurl = self._options['server'] + '/rest/api/2/project/%s' % pid\nr = self._session.delete(url)\nif r.status_code == 403:\n    raise JIRAError('Not enough permissions to delete project')\nif r.status_code == 404:\n    raise JIRAError('Project not found in Jira')\nreturn r.ok\n",
        "CUT_3": "raise_on_error(r)\ntry:\n    return r.json()\nexcept ValueError:\n    if not r.text:\n        return {}\n    raise\n",
        "CUT_4": "raise_on_error(r)\ntry:\n    return r.json()\nexcept ValueError:\n    if not r.text:\n        return {}\n    raise\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\nif not self.jira.supports_service_desk():\n    pytest.skip('Skipping Service Desk not enabled')\ntry:\n    self.jira.delete_project(self.test_manager.project_sd)\nexcept Exception:\n    pass\n"
    },
    {
        "functionName": "remove_by_slug",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "try:\n    cl_admin.delete_project(slug)\nexcept (ValueError, JIRAError):\n    pass\n",
        "CUT_1": "pass\n",
        "CUT_2": "pass\n",
        "CUT_3": "raise_on_error(r)\ntry:\n    return r.json()\nexcept ValueError:\n    if not r.text:\n        return {}\n    raise\n",
        "CUT_4": "raise_on_error(r)\ntry:\n    return r.json()\nexcept ValueError:\n    if not r.text:\n        return {}\n    raise\n",
        "CUT_5": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\nif not self.jira.supports_service_desk():\n    pytest.skip('Skipping Service Desk not enabled')\ntry:\n    self.jira.delete_project(self.test_manager.project_sd)\nexcept Exception:\n    pass\n"
    },
    {
        "functionName": "test_delete_project",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "assert cl_admin.delete_project(slug)\n",
        "CUT_1": "self.jira = JiraTestManager().jira_admin\nself.test_manager = JiraTestManager()\nif not self.jira.supports_service_desk():\n    pytest.skip('Skipping Service Desk not enabled')\ntry:\n    self.jira.delete_project(self.test_manager.project_sd)\nexcept Exception:\n    pass\n",
        "CUT_2": "\"\"\"Delete project from Jira.\n\n        :param pid: Jira projectID or Project or slug\n        :type pid: str\n        :return: True if project was deleted\n        :rtype: bool\n        :raises JIRAError:  If project not found or not enough permissions\n        :raises ValueError: If pid parameter is not Project, slug or ProjectID\n        \"\"\"\nif hasattr(pid, 'id'):\n    pid = pid.id\nurl = self._options['server'] + '/rest/api/2/project/%s' % pid\nr = self._session.delete(url)\nif r.status_code == 403:\n    raise JIRAError('Not enough permissions to delete project')\nif r.status_code == 404:\n    raise JIRAError('Project not found in Jira')\nreturn r.ok\n",
        "CUT_3": "\"\"\"Delete project from Jira.\n\n        :param pid: Jira projectID or Project or slug\n        :type pid: str\n        :return: True if project was deleted\n        :rtype: bool\n        :raises JIRAError:  If project not found or not enough permissions\n        :raises ValueError: If pid parameter is not Project, slug or ProjectID\n        \"\"\"\nif hasattr(pid, 'id'):\n    pid = pid.id\nurl = self._options['server'] + '/rest/api/2/project/%s' % pid\nr = self._session.delete(url)\nif r.status_code == 403:\n    raise JIRAError('Not enough permissions to delete project')\nif r.status_code == 404:\n    raise JIRAError('Project not found in Jira')\nreturn r.ok\n",
        "CUT_4": "assert self.configname\nreturn self.xcode_settings[self.configname]\n",
        "CUT_5": "assert self.compile_headers\nh = self.compiled_headers[lang]\nif arch:\n    h += '.' + arch\nreturn h\n"
    },
    {
        "functionName": "test_delete_inexistent_project",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "slug = 'abogus123'\nwith pytest.raises(JIRAError) as ex:\n    assert cl_admin.delete_project(slug)\nassert 'No project could be found with key' in str(ex.value\n    ) or 'Parameter pid=\"%s\" is not a Project, projectID or slug' % slug in str(\n    ex.value)\n",
        "CUT_1": "\"\"\"Delete project from Jira.\n\n        :param pid: Jira projectID or Project or slug\n        :type pid: str\n        :return: True if project was deleted\n        :rtype: bool\n        :raises JIRAError:  If project not found or not enough permissions\n        :raises ValueError: If pid parameter is not Project, slug or ProjectID\n        \"\"\"\nif hasattr(pid, 'id'):\n    pid = pid.id\nurl = self._options['server'] + '/rest/api/2/project/%s' % pid\nr = self._session.delete(url)\nif r.status_code == 403:\n    raise JIRAError('Not enough permissions to delete project')\nif r.status_code == 404:\n    raise JIRAError('Project not found in Jira')\nreturn r.ok\n",
        "CUT_2": "\"\"\"Delete project from Jira.\n\n        :param pid: Jira projectID or Project or slug\n        :type pid: str\n        :return: True if project was deleted\n        :rtype: bool\n        :raises JIRAError:  If project not found or not enough permissions\n        :raises ValueError: If pid parameter is not Project, slug or ProjectID\n        \"\"\"\nif hasattr(pid, 'id'):\n    pid = pid.id\nurl = self._options['server'] + '/rest/api/2/project/%s' % pid\nr = self._session.delete(url)\nif r.status_code == 403:\n    raise JIRAError('Not enough permissions to delete project')\nif r.status_code == 404:\n    raise JIRAError('Project not found in Jira')\nreturn r.ok\n",
        "CUT_3": "for key, value in the_dict.items():\n    if type(value) in (str, int, list):\n        variables['_' + key] = value\n",
        "CUT_4": "return value\n",
        "CUT_5": "\"\"\"Get a project Resource from the server.\n\n        :param id: ID or key of the project to get\n        :rtype: Project\n        \"\"\"\nreturn self._find_for_resource(Project, id)\n"
    },
    {
        "functionName": "test_templates",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "templates = cl_admin.templates()\nexpected_templates = set(filter(None,\n    \"\"\"\nAgility\nBasic\nBug tracking\nContent Management\nCustomer service\nDocument Approval\nIT Service Desk\nKanban software development\nLead Tracking\nProcess management\nProcurement\nProject management\nRecruitment\nScrum software development\nTask management\n\"\"\"\n    .split('\\n')))\nfor t in expected_templates:\n    assert t in templates\n",
        "CUT_1": "url = self._options['server'] + '/rest/project-templates/latest/templates'\nr = self._session.get(url)\ndata = json_loads(r)\ntemplates = {}\nif 'projectTemplatesGroupedByType' in data:\n    for group in data['projectTemplatesGroupedByType']:\n        for t in group['projectTemplates']:\n            templates[t['name']] = t\nreturn templates\nlru_cache(maxsize=None)",
        "CUT_2": "url = self._options['server'] + '/rest/project-templates/latest/templates'\nr = self._session.get(url)\ndata = json_loads(r)\ntemplates = {}\nif 'projectTemplatesGroupedByType' in data:\n    for group in data['projectTemplatesGroupedByType']:\n        for t in group['projectTemplates']:\n            templates[t['name']] = t\nreturn templates\nlru_cache(maxsize=None)",
        "CUT_3": "\"\"\"Get a Service Desk Resource from the server.\n\n        :param id: ID or key of the Service Desk to get\n        :type id: str\n        :rtype: ServiceDesk\n\n        \"\"\"\nreturn self._find_for_resource(ServiceDesk, id)\n",
        "CUT_4": "\"\"\"Get a Service Desk Resource from the server.\n\n        :param id: ID or key of the Service Desk to get\n        :type id: str\n        :rtype: ServiceDesk\n\n        \"\"\"\nreturn self._find_for_resource(ServiceDesk, id)\n",
        "CUT_5": "\"\"\"Returns whether or not the Jira instance supports service desk.\n\n        :rtype: bool\n        \"\"\"\nurl = self._options['server'] + '/rest/servicedeskapi/info'\nheaders = {'X-ExperimentalApi': 'opt-in'}\ntry:\n    r = self._session.get(url, headers=headers)\n    return r.status_code == 200\nexcept JIRAError:\n    return False\n"
    },
    {
        "functionName": "test_result_list",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "iterable = [2, 3]\nstartAt = 0\nmaxResults = 50\ntotal = 2\nresults = jira.client.ResultList(iterable, startAt, maxResults, total)\nfor idx, result in enumerate(results):\n    assert results[idx] == iterable[idx]\nassert next(results) == iterable[0]\nassert next(results) == iterable[1]\nwith pytest.raises(StopIteration):\n    next(results)\n",
        "CUT_1": "\"\"\"\n        :type iterable: Any\n        :type _startAt: int\n        :type _maxResults: int\n        :type _total: int\n        :type isLast: Optional[bool]\n        \"\"\"\nif iterable is not None:\n    list.__init__(self, iterable)\nelse:\n    list.__init__(self)\nself.startAt = _startAt\nself.maxResults = _maxResults\nself.isLast = _isLast\nself.total = _total\nself.iterable = iterable or []\nself.current = self.startAt\n",
        "CUT_2": "\"\"\"\n        :type iterable: Any\n        :type _startAt: int\n        :type _maxResults: int\n        :type _total: int\n        :type isLast: Optional[bool]\n        \"\"\"\nif iterable is not None:\n    list.__init__(self, iterable)\nelse:\n    list.__init__(self)\nself.startAt = _startAt\nself.maxResults = _maxResults\nself.isLast = _isLast\nself.total = _total\nself.iterable = iterable or []\nself.current = self.startAt\n",
        "CUT_3": "for i in iterable:\n    if i not in self:\n        self.add(i)\n",
        "CUT_4": "projects = dict()\ndependencies = dict()\nbegin_project = re.compile(\n    '^Project\\\\(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\"\\\\) = \"(.*)\", \"(.*)\", \"(.*)\"$'\n    )\nend_project = re.compile('^EndProject$')\nbegin_dep = re.compile('ProjectSection\\\\(ProjectDependencies\\\\) = postProject$'\n    )\nend_dep = re.compile('EndProjectSection$')\ndep_line = re.compile(' *({.*}) = ({.*})$')\nin_deps = False\nsolution = open(solution_file)\nfor line in solution:\n    results = begin_project.search(line)\n    if results:\n        if results.group(1).find('icu') != -1:\n            continue\n        current_project = results.group(1).replace('_gyp', '')\n        projects[current_project] = [results.group(2).replace('_gyp', ''),\n            results.group(3), results.group(2)]\n        dependencies[current_project] = []\n        continue\n    results = end_project.search(line)\n    if results:\n        current_project = None\n        continue\n    results = begin_dep.search(line)\n    if results:\n        in_deps = True\n        continue\n    results = end_dep.search(line)\n    if results:\n        in_deps = False\n        continue\n    results = dep_line.search(line)\n    if results and in_deps and current_project:\n        dependencies[current_project].append(results.group(1))\n        continue\nfor project in dependencies:\n    new_dep_array = []\n    for dep in dependencies[project]:\n        for project_info in projects:\n            if projects[project_info][1] == dep:\n                new_dep_array.append(project_info)\n    dependencies[project] = sorted(new_dep_array)\nreturn projects, dependencies\n",
        "CUT_5": "\"\"\"Returns a minimal json object for Jira issue search results. \"\"\"\nreturn {'startAt': kwargs.get('start_at', 0), 'maxResults': kwargs.get(\n    'max_results', 50), 'total': kwargs.get('total', len(issues)), 'issues':\n    issues}\n"
    },
    {
        "functionName": "test_result_list_if_empty",
        "className": null,
        "fileName": "/tests/test_client.py",
        "projectName": "jira",
        "Label": 0,
        "isTest": true,
        "Body": "results = jira.client.ResultList()\nfor r in results:\n    raise AssertionError('`results` should be empty')\nwith pytest.raises(StopIteration):\n    next(results)\n",
        "CUT_1": "projects = dict()\ndependencies = dict()\nbegin_project = re.compile(\n    '^Project\\\\(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\"\\\\) = \"(.*)\", \"(.*)\", \"(.*)\"$'\n    )\nend_project = re.compile('^EndProject$')\nbegin_dep = re.compile('ProjectSection\\\\(ProjectDependencies\\\\) = postProject$'\n    )\nend_dep = re.compile('EndProjectSection$')\ndep_line = re.compile(' *({.*}) = ({.*})$')\nin_deps = False\nsolution = open(solution_file)\nfor line in solution:\n    results = begin_project.search(line)\n    if results:\n        if results.group(1).find('icu') != -1:\n            continue\n        current_project = results.group(1).replace('_gyp', '')\n        projects[current_project] = [results.group(2).replace('_gyp', ''),\n            results.group(3), results.group(2)]\n        dependencies[current_project] = []\n        continue\n    results = end_project.search(line)\n    if results:\n        current_project = None\n        continue\n    results = begin_dep.search(line)\n    if results:\n        in_deps = True\n        continue\n    results = end_dep.search(line)\n    if results:\n        in_deps = False\n        continue\n    results = dep_line.search(line)\n    if results and in_deps and current_project:\n        dependencies[current_project].append(results.group(1))\n        continue\nfor project in dependencies:\n    new_dep_array = []\n    for dep in dependencies[project]:\n        for project_info in projects:\n            if projects[project_info][1] == dep:\n                new_dep_array.append(project_info)\n    dependencies[project] = sorted(new_dep_array)\nreturn projects, dependencies\n",
        "CUT_2": "base_path = posixpath.dirname(_ToLocalPath(toplevel_dir, _ToGypPath(target)))\nbase_path_components = base_path.split('/')\nif len(base_path):\n    base_path += '/'\nif debug:\n    print('ExtractSources', target, base_path)\nresults = []\nif 'sources' in target_dict:\n    _AddSources(target_dict['sources'], base_path, base_path_components,\n        results)\nif 'actions' in target_dict:\n    for action in target_dict['actions']:\n        _ExtractSourcesFromAction(action, base_path, base_path_components,\n            results)\nif 'rules' in target_dict:\n    for rule in target_dict['rules']:\n        _ExtractSourcesFromAction(rule, base_path, base_path_components,\n            results)\nreturn results\n",
        "CUT_3": "if 'inputs' in action:\n    _AddSources(action['inputs'], base_path, base_path_components, results)\n",
        "CUT_4": "\"\"\"\n    Returns a list of cycles in the graph, where each cycle is its own list.\n    \"\"\"\nresults = []\nvisited = set()\ndef Visit(node, path):\n    for child in node.dependents:\n        if child in path:\n            results.append([child] + path[:path.index(child) + 1])\n        elif not child in visited:\n            visited.add(child)\n            Visit(child, [child] + path)\nvisited.add(self)\nVisit(self, [self])\nreturn results\n",
        "CUT_5": "\"\"\"Get the metadata required to create issues, optionally filtered by projects and issue types.\n\n        :param projectKeys: keys of the projects to filter the results with.\n            Can be a single value or a comma-delimited string. May be combined\n            with projectIds.\n        :type projectKeys: Union[None, Tuple[str, str], str]\n        :param projectIds: IDs of the projects to filter the results with. Can\n            be a single value or a comma-delimited string. May be combined with\n            projectKeys.\n        :type projectIds: Union[List, Tuple[str, str]]\n        :param issuetypeIds: IDs of the issue types to filter the results with.\n            Can be a single value or a comma-delimited string. May be combined\n            with issuetypeNames.\n        :type issuetypeIds: Optional[List[str]]\n        :param issuetypeNames: Names of the issue types to filter the results\n            with. Can be a single value or a comma-delimited string. May be\n            combined with issuetypeIds.\n        :type issuetypeNames: Optional[str]\n        :param expand: extra information to fetch inside each resource.\n        :type expand: Optional[str]\n        :rtype: Dict[str, Any]\n\n        \"\"\"\nparams = {}\nif projectKeys is not None:\n    params['projectKeys'] = projectKeys\nif projectIds is not None:\n    if isinstance(projectIds, str):\n        projectIds = projectIds.split(',')\n    params['projectIds'] = projectIds\nif issuetypeIds is not None:\n    params['issuetypeIds'] = issuetypeIds\nif issuetypeNames is not None:\n    params['issuetypeNames'] = issuetypeNames\nif expand is not None:\n    params['expand'] = expand\nreturn self._get_json('issue/createmeta', params)\n"
    }
]